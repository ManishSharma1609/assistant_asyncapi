[
  {
    "id": "163e8aa3",
    "title": "About | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/about.html",
    "content": "About | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets AsyncAPI AsyncAPI is an Apache License 2.0 library under the Linux Foundation that seeks to improve the current state of event-driven architecture (EDA). The AsyncAPI Initiative is a specification and growing set of open-source tools to help developers define, build, and maintain asynchronous APIs and EDAs. Developers familiar with OpenAPI (aka Swagger) for RESTful APIs will see strong similarities when using AsyncAPI. One common use case is generating asynchronous API documentation (HTML or Markdown). The specification is both platform and language agnostic. The current tooling includes support for common message brokers such as Apache Kafka and RabbitMQ and languages including Python, Java, and Nodejs. Our long-term goal is to make working with EDAs as easy as working with REST APIs. That goes from documentation to code generation, discovery to event management, and beyond. Our 150+ Open-Source (OSS) contributors are EDA enthusiasts from all around the world. The AsyncAPI project started at Hitch (a.k.a. API Changelog). Hitch needed a machine-readable format to describe internal message-driven microservices architecture. The goal was to benefit from it in the same way they had used OpenAPI for their HTTP APIs. Inspired by OpenAPI, Fran M\u00e9ndez , who worked at Hitch at the time, created the AsyncAPI specification. After publishing the first version, he noticed that he solved not only his problems but the problems of the wider community. Eventually, the AsyncAPI specification and community evolved into the AsyncAPI Initiative, a project now under the umbrella of the Linux Foundation. Open governance model Free software allows users to apply, modify, and continue in the chain by distributing copies to help others and, in this case, disseminating modified versions of the specification. Transferring AsyncAPI to the Linux Foundation and forming an open governance model assures the community that a single company does not control AsyncAPI Initiative. This move takes the project to a higher level of transparency. In doing so, we achieve: Ensuring an open governance model where no single company dominates the specification and its tools. Making the project as democratic as possible. Relying on an asynchronous decision-making process that empowers the people who \"work,\" not the companies who \"pay.\" In other words, it gives equal power to individual and corporate contributors . Maintainers Committers (also known as Maintainers ) are the decision-makers at the repository/project level. They regularly contribute to the project and are invited by other maintainers to manage the repository, have more privileges, and approve pull requests. The committers run the repository, but for issues that go beyond that, there is a Technical Steering Committee (TSC) . This committee comprises all the maintainers who voluntarily want to be part of this committee, thus taking responsibility for overseeing the initiative. You can see the list of maintainers who also form part of the AsyncAPI TSC here . Contributors We do our best to recognize every contribution to the project. We do it individually in every repository from AsyncAPI GitHub organization . There should always be a Contributors section in the readme, like this one . We use All Contributors specification to handle recognitions. We apologize in advance if we failed to recognize your work. Feel free to contact us on Slack , and we will fix it immediately, or just talk to our All Contributors bot . AsyncAPI, in numbers Interested to know more about our growth? Feel free to check our annual summary report: Summary report 2022 Summary report 2021 Summary report 2020 Companies support This is the list of companies that either provide a significant financial support or delegate their employees to support AsyncAPI with maintainance: \n![Solace: powering event-driven architectures, integrations and AI](/img/sponsors/solace.png)\n \n![Postman](/img/sponsors/postman.png)\n Want to become a sponsor? Support us! Would you like to get on the list and support us financially? Check out all AsyncAPI sponsoring options . Would you like to help us with the maintenance? Contact us on AsyncAPI Slack . Brands and companies using AsyncAPI The total number of companies and projects using AsyncAPI as well as their identity is impossible to know. So far, we are aware that the following ones operate with it. Slack : Business Communication Platform that permits to operate with multiple channels (public and private). It currently has more than 10 million daily active users worldwide. It was recently acquired by Salesforce. Adidas : Company dedicated to manufacturing sports equipment and fashion products. It is the largest sportswear manufacturer in Europe, and the second largest in the world. This company has more than 150.000 sales outlets around the world. Salesforce : Business consultancy company. It provides (CRM) services and more. It manages from small businesses to FORTUNE 500 companies, and it has more than 150,000 customers. IBM : Company that manufactures and markets hardware and software. It has operations in over 170 countries and provides hosting and consulting services in many areas. SAP : Company dedicated to the design of computer products for business management. Develops business software to manage operations and business-to-customer relationships. It\u2019s a large company with 100,330 employees. IQVIA : Company providing services for the combined health information technology and clinical research industries. It employs more than 58.000 people in over 100 countries. Values of AsyncAPI Innovative . There is no other specification that covers the messaging needs in event-driven architecture that AsyncAPI is covering. What it tries to do is to integrate with the existing tools and remove walls for communication. Free . It\u2019s a free software project: it seeks the user's liberty by offering a tool that can be used and enhanced without restrictions. Open . As it's an open-source project, not a company or a product. It works in a change of paradigm because it does not sell anything; it moves away from fierce competition and bets for cooperation. Multicultural and inclusive . It\u2019s an initiative with an international and multicultural vision. It\u2019s organic, always in constant mutation and change. It also actively demands compliance with human rights, respect for racial, sexual, and cultural diversity equality. And, of course, the equality between women and men. Transparent . The initiative is built on transparency, being one of the main values of AsyncAPI, internally and externally, including its financing. All the relevant data of the project is public. All tasks are public, with participation and communication handled through Slack and GitHub. Horizontal and participative . Its structure is based on horizontality; most of the decisions are defined as a group, including the Community. Anyone can submit improvements, lines of action, or elements to be taken into account to strengthen AsyncAPI. User-friendly . AsyncAPI bets for a seamless API development experience. Users should be able to create their first API even without prior knowledge of AsyncAPI. It has to be natural, simple, and intuitive. Funding AsyncAPI is an open-source project funded by both talent and voluntary contributions. It relies on the expertise and dedication of the Community developers who believe in the project and contribute to its evolution. Financially, there are individual donations and contributions made by users of the project, and others from different companies and initiatives that trust and support AsyncAPI through sponsorship. The main sponsors that contribute to sustaining this initiative are Postman, IBM, IQVIA Technology, and Solace. AsyncAPI also receives different levels of contributions from other companies such as Red Hat, Slack, etc. All the information about the project's economy, the amount of the donations, the identity of the donors, the sponsors supporting the project, and the use of this money is public via the AsyncAPI Open Collective . Contact details Press & communications info: press@asyncapi.io . Twitter : It's used for disseminating all news and information regarding the project, resolving user queries, and sharing the latest updates within AsyncAPI. Slack workspace : The main place of encounter for the whole community of AsyncAPI. Newsletter : To learn about the status of the project, news, actualizations, recorded events, and meetings. Blog : It\u2019s used to disseminate information related to the project. It's also open to collaborations. LinkedIn : It's used to publish news related to the project or its environment. It\u2019s also used as a source of information. YouTube Channel : Where you can find conferences, AsyncAPI Open Meetings, and much more. GitHub : Issues (bugs, feature requests, etc.) and pull requests (PRs) for fixes or new features already discussed, as per the contributing guidelines. AsyncAPI Open Meetings : AsyncAPI hosts different meetings every week. They are focused on different topics, sometimes purely technical and sometimes about community building. Pick one and join us! Learn more about our meetings FAQs",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/sponsors/solace.png",
        "alt": "Solace: powering event-driven architectures, integrations and AI"
      },
      {
        "src": "/img/sponsors/postman.png",
        "alt": "Postman"
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "8764afed",
    "title": "Blog | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/blog.html",
    "content": "Blog | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets Welcome to our blog! Find the latest and greatest stories from our community Want to publish a blog post? We love community stories. Submit yours! We have an RSS Feed , too! Filter by type... Filter by authors... Filter by tags... \n![Loading...](asyncapi-docs/www.asyncapi.com/img/loaders/loader.png)\n Loading Blogs",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "asyncapi-docs/www.asyncapi.com/img/loaders/loader.png",
        "alt": "Loading..."
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "48e4d55f",
    "title": "Blog | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/blog?tags=Project+Status.html",
    "content": "Blog | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets Welcome to our blog! Find the latest and greatest stories from our community Want to publish a blog post? We love community stories. Submit yours! We have an RSS Feed , too! Filter by type... Filter by authors... Filter by tags... \n![Loading...](asyncapi-docs/www.asyncapi.com/img/loaders/loader.png)\n Loading Blogs",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "asyncapi-docs/www.asyncapi.com/img/loaders/loader.png",
        "alt": "Loading..."
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "9b93ff4e",
    "title": "Blog | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/blog?tags=Release+Notes.html",
    "content": "Blog | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets Welcome to our blog! Find the latest and greatest stories from our community Want to publish a blog post? We love community stories. Submit yours! We have an RSS Feed , too! Filter by type... Filter by authors... Filter by tags... \n![Loading...](asyncapi-docs/www.asyncapi.com/img/loaders/loader.png)\n Loading Blogs",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "asyncapi-docs/www.asyncapi.com/img/loaders/loader.png",
        "alt": "Loading..."
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "c7ba9024",
    "title": "Case Studies | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/casestudies.html",
    "content": "Case Studies | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets Case Studies The best way to learn how to use AsyncAPI is not only through documentation that usually is focused on recommendations and best practices. It is also good to confront with real-life case studies that explain how people really use AsyncAPI and what are their flows. Feel free to submit your case study. We have a template for you. For more details read our FAQ . Adeo owns different brands in retail industry focused on home improvement and DIY markets, like Leroy Merlin. The HDI brand operates in Germany and internationally, offering life and property/casualty insurance services. They cater to both private individuals and corporate clients, and have been providing industrial insurance since 2016. Adopters Check out how different companies use AsyncAPI and what problems they solve. Feel free to submit a pull request with information about how your company uses AsyncAPI. We know that writing an official case study might be time consuming and requires too much internal paper work. Let's make sure we can at least capture a use case that is already a great learning information for the community. Company name Use Case Resources Reiffeisen Bank Implementing a Continuous Integration and Continuous Delivery (CI/CD) pipeline utilizing GitOps principles to deploy a topology constructed on AsyncAPI definitions using a Kubernetes operator to an Apache Pulsar cluster. Video: From an AsyncAPI Definition to a Deployed Pulsar Topology Via GitOps LEGO Group Managing brokers, where developers abstain from direct access to the management console and instead upload AsyncAPI documents to a self-service API, which provisions access and topics specified in the documents. Video: Documentation as Configuration for Management of Apache Pulsar LEGO Group Defining, documenting, and distributing event-driven APIs while ensuring consistency and governance. Video: Cross-Domain Events with AsyncAPI and AWS Bank of New Zealand Establishing a decentralized company-wide governance strategy for APIs, providing a self-service platform for publishing APIs and documentation. Video: Self-service Events & Decentralised Governance with AsyncAPI: A Real World Example Zora Robotics Documenting public MQTT APIs for IoT products and constructing a developer portal. Video: Building and managing an extensive API for Robotics and IoT Docs: Building and managing an extensive API for Robotics and IoT Walmart Managing a centralized API Hub for internal teams, enhancing event discoverability and visibility using AsyncAPI. AsyncAPI facilitates company-wide governance on asynchronous APIs. Video: Time For AsyncAPI Specification eBay Facilitating partner integration with eBay through asynchronous communication, leveraging public AsyncAPI documents for code generation and rapid integration, while ensuring governance and standardization. Video: AsyncAPI 2.0: Enabling the Event-Driven World Article: AsyncAPI 2.0: Enabling the Event-Driven World Docs: Overview of Notification API with public AsyncAPI documents Postman Enhancing discoverability of information about system events by building a tool called Synapse for provisioning entire event-based infrastructure, with AsyncAPI documents as the source of truth. Video: Turbocharging your Developer Ecosystem with Events Powered by SNS/SQS, Serverless, and AsyncAPI Adobe Providing event documentation to expedite development by generating classes based on message payload information from AsyncAPI documents. Slides: AsyncAPI and Modelina Open University of Catalonia and Prodevelop Enabling monitoring of ports through a design-first approach, utilizing UML class diagrams to design the entire infrastructure. UML diagrams are source of truth for generated AsyncAPI documents that later are used for models and clients generation. These documents are extended with additional SLA properties to specify runtime quality of service requirements, facilitating real-time monitoring. Video: Leveraging AsyncAPI To Detect Anomalies in Smart Ports Platforms Oracle Documenting data streaming APIs with AsyncAPI documents for client library generation in various programming languages, reducing development time for applications consuming data. Video: Productizing AsyncAPI for Data Replication TransferGo Enhancing discoverability of information about event-driven systems by documenting services with AsyncAPI, rendering documentation, and creating catalogs of events. Legacy services utilize a special library to generate AsyncAPI documents, while new services require AsyncAPI documents for generating PHP classes. Slides: How TransferGo Uses AsyncAPI To Improve Developer Experience Kuehne+Nagel Implementing a GitOps-based pipeline to enable self-service management of Kafka infrastructure, including access control management. Automation of AsyncAPI document governance ensures consistency in the infrastructure at the pull request level. Slides: AsyncAPI For Platform Self-Service: A GitOps Tale Adidas AsyncAPI is a standard for defining asynchronous APIs using Apache Kafka. AsyncAPI governed under official guidelines. AsyncAPI is promoted to be used for documentation and code generation. Docs: AsyncAPI and Kafka Guidelines Morgan Stanley AsyncAPI is promoted not only inside the company but also as a standard for FinOS Foundation for managing architecture as code. Slides: Deploying WebSockets with AsyncAPI and Architecture as Code",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "fa0c9af6",
    "title": "AsyncAPI Community Meetings | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/community.html",
    "content": "AsyncAPI Community Meetings | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets AsyncAPI Community Welcome to the AsyncAPI Community We're an OSS community that's passionate about AsyncAPI. Join us in building the future of Event Driven APIs by asking questions, sharing ideas, and building connections. AsyncAPI Discussions \n![reaction](/img/homepage/reaction.webp)\n \n![que](/img/homepage/que.webp)\n \n![idea](/img/homepage/idea.webp)\n \n![lukasz](/img/homepage/lukasz-homepage-slack.webp)\n \n![comment](/img/homepage/comment.webp)\n \n![fran](/img/homepage/fran.webp)\n AsyncAPI Community Welcome to the AsyncAPI Community We're an OSS community that's passionate about AsyncAPI. Join us in building the future of Event Driven APIs by asking questions, sharing ideas, and building connections. AsyncAPI Discussions \n![jonas](/img/homepage/jonas.webp)\n \n![slack](/img/homepage/slack.webp)\n \n![missy](/img/homepage/missy.webp)\n \n![check](/img/homepage/check.webp)\n \n![eve-chan](/img/homepage/eve-and-chan.webp)\n \n![maciej](/img/homepage/maciej.webp)\n \n![git](/img/homepage/git.webp)\n \n![ace](/img/homepage/ace.webp)\n \n![star](/img/homepage/star.webp)\n \n![barbano](/img/homepage/barbano.webp)\n \n![dale](/img/homepage/dale.webp)\n \n![kuda](/img/homepage/kuda.webp)\n \n![yash](/img/homepage/yash.webp)\n \n![sergio](/img/homepage/sergio.webp)\n \n![github-discussion](/img/homepage/discuss-page.webp)\n Home of #CommunityOps Join the conversation with over 10k+ developers from literally everywhere. Thanking our AsyncAPI Ambassadors Ambassador Programs Launch OSS community programs that your community is proud to participate in. Let's build thriving OSS communities together! Become an ambassador \ud83d\udd25 Issues Explore and Contribute to Hot Issues Discover over 100s of interesting issues, suitable for new and existing contributors. Explore issues \ud83d\udce3 Newsroom Never Get Left Behind Do you want to get the latest news with recent activities happening in the community? \ud83e\uddf0 Toolings Check out our collection of Toolings Discover various AsyncAPI tools to optimize your journey! These tools are made by the community, for the community. Community heartbeat AsyncAPI Community Meetings & Events Join an AsyncAPI meeting from anywhere in the world! We host both live and recorded community events. You can also sign up for our community newsletter to stay up-to-date on all meetings and events. Explore more events 3 Design WG Meeting Thursday, April 3, 2025 4:00 PM UTC +00:00 8 AsyncAPI Community Working Group Meeting Tuesday, April 8, 2025 3:00 PM UTC +00:00 10 Preventing API Drift: Ensuring Your APIs Stay True to Their Spec Thursday, April 10, 2025 6:00 PM UTC +00:00 \ud83c\udfaf Goals 2024 AsyncAPI Community Goals Help us improve our 2024 AsyncAPI community building and maintenance goals. \ud83d\ude80 TSC Meet Folks Redefining the Initiative Learn how to become a Technical Steering Committee (TSC) member and see our current members. All community info, tracked AsyncAPI Slack AsyncAPI's incredible community of developers, designers, technical writers, and more hail from over 83 countries. We actively contribute, collaborate, and mentor others on how to build with AsyncAPI. Join AsyncAPI slack \ud83d\udcb0 Finance Track Initiative Spending with Budget Analysis Explore our transparent finance section for a detailed analysis of our project's budget. See how we track expenses and gain insights into funds allocation. Subscribe to our newsletter to receive news about AsyncAPI. We respect your inbox. No spam, promise \u270c\ufe0f",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/homepage/reaction.webp",
        "alt": "reaction"
      },
      {
        "src": "/img/homepage/que.webp",
        "alt": "que"
      },
      {
        "src": "/img/homepage/idea.webp",
        "alt": "idea"
      },
      {
        "src": "/img/homepage/lukasz-homepage-slack.webp",
        "alt": "lukasz"
      },
      {
        "src": "/img/homepage/comment.webp",
        "alt": "comment"
      },
      {
        "src": "/img/homepage/fran.webp",
        "alt": "fran"
      },
      {
        "src": "/img/homepage/jonas.webp",
        "alt": "jonas"
      },
      {
        "src": "/img/homepage/slack.webp",
        "alt": "slack"
      },
      {
        "src": "/img/homepage/missy.webp",
        "alt": "missy"
      },
      {
        "src": "/img/homepage/check.webp",
        "alt": "check"
      },
      {
        "src": "/img/homepage/eve-and-chan.webp",
        "alt": "eve-chan"
      },
      {
        "src": "/img/homepage/maciej.webp",
        "alt": "maciej"
      },
      {
        "src": "/img/homepage/git.webp",
        "alt": "git"
      },
      {
        "src": "/img/homepage/ace.webp",
        "alt": "ace"
      },
      {
        "src": "/img/homepage/star.webp",
        "alt": "star"
      },
      {
        "src": "/img/homepage/barbano.webp",
        "alt": "barbano"
      },
      {
        "src": "/img/homepage/dale.webp",
        "alt": "dale"
      },
      {
        "src": "/img/homepage/kuda.webp",
        "alt": "kuda"
      },
      {
        "src": "/img/homepage/yash.webp",
        "alt": "yash"
      },
      {
        "src": "/img/homepage/sergio.webp",
        "alt": "sergio"
      },
      {
        "src": "/img/homepage/discuss-page.webp",
        "alt": "github-discussion"
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "f57796b0",
    "title": "Welcome | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs.html",
    "content": "Welcome | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Welcome to AsyncAPI Docs! Explore the Docs Welcome Found an error? Have a suggestion? Edit this page on GitHub Welcome to AsyncAPI Docs! AsyncAPI is an open source initiative that seeks to improve the current state of Event-Driven Architectures (EDA). Our long-term goal is to make working with EDAs as easy as working with REST APIs. That goes from documentation to code generation, from discovery to event management, and beyond. Explore the Docs Concepts Our Concepts section defines the concepts of AsyncAPI features and capabilities. Tutorials Our Tutorials section teaches beginner processes with AsyncAPI, guiding you from Point A to Point B. Guides Our Guides section teaches AsyncAPI's capabilities at a high level. Tools Our Tools section documents the AsyncAPI tools ecosystem. Reference Our Reference section documents the AsyncAPI specification. Migration Our migration guides on how to upgrade to newer AsyncAPI versions. Community Our Community section documents the community guidelines and resources. Specification Explorer Simplifying our Specification JSON Schema like a pro. Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "9b77a57c",
    "title": "AsyncAPI Finance Summary",
    "path": "asyncapi-docs/www.asyncapi.com/finance.html",
    "content": "AsyncAPI Finance Summary AsyncAPI Logo AsyncAPI Financial Summary To help improve the current state of Event-Driven Architectures and their tooling, you can show your support for the AsyncAPI Initiative by making a financial contribution. We offer three donation options: Open Collective, GitHub Sponsors, and Linux Foundation Crowdfunding . Our expenses are managed through Open Collective and GitHub Sponsors, while Linux Foundation Crowdfunding operates separately. Become a Sponsor Ways to Support Us? The easiest way to support AsyncAPI is by becoming a financial sponsor. While there are alternative options, they may involve greater effort. Contribute monetarily using the following channels. Sponsorship Tiers AsyncAPI offers various sponsorship tiers, each with its own set of benefits and privileges. These tiers include Bronze, Silver, Gold, and Platinum. Tiers Amounts Benefits Bronze $100/month Company logo in README on GitHub Silver $500/month Company logo in README on GitHub and asyncapi.com Gold $1000/month Company logo in README on GitHub and asyncapi.com Platinum $2000/month Company logo in README on GitHub and asyncapi.com. Up to 2 hours of support per month. Support will be remote with the option of a shared screen or via private chat. Support hours do not accumulate. Other Forms Of Financial Support You can also support AsyncAPI initiative by getting involved through employment, providing services and organizing events \n![Employee involvement](/img/illustrations/EmployeeInvolvement.webp)\n Employee involvement Assign your employees to contribute to projects under the AsyncAPI Initiative on a regular basis, and we'll welcome them as new maintainers. \n![Service provision](/img/illustrations/ServiceProvision.webp)\n Service provision AsyncAPI Initiative relies on numerous tools, many of which incur costs. Your organization can provide services such as hosting or storage to support our efforts. \n![Event organization](/img/illustrations/EventOrganization.webp)\n Event organization Host AsyncAPI conferences by sponsoring and organizing events under the AsyncAPI brand at your provided venue. Expense Breakdown Funds from GitHub Sponsors are directly transferred to our AsyncAPI Open Collective account. We maintain transparency in all expenses, and the TSC approves anticipated expenses. \n![Mentorship Program](/img/illustrations/MentorshipProgram.webp)\n Mentorship Program Our AsyncAPI Mentorship program offers paid guidance to develop valuable features, investing in tools and motivated individuals for community benefit. \n![Bounty Program](/img/illustrations/BountyProgram.webp)\n Bounty Program Rewarding contributors regardless of affiliation or volunteer status. Free mentoring and support for newcomers to build portfolios and unlock tech prospects. \n![Events](/img/illustrations/Events.webp)\n Events Supporting AsyncAPI conferences incurs costs for services and travel arrangements. Your contributions facilitate event hosting and community growth. \n![Swag Store](/img/illustrations/SwagStore.webp)\n Swag Store Creating a swag store for seamless distribution to contributors, mentees, ambassadors, and community members. Store profits can fund complimentary swag expenses. \n![Hiring](/img/illustrations/Hiring.webp)\n Hiring To support our community, we require full-time commitment. Open Collective helps us hire for AsyncAPI. Thulie joined us as a community manager, with plans to expand our team. \n![Services](/img/illustrations/Services.webp)\n Services Occasionally, we must pay for services such as Zoom or Descript, as they are not available through specific Open Source support programs. Budget Analysis Gain insights into the allocation of funds across different categories through our Budget Analysis Expenses $ 83482.62 All Categories JSON Schema Sponsorship Swag Store Bounty Program Community Manager AsyncAPI Conf on Tour 2023 Mentorship Program 2023 Community Marketing Specialist AsyncAPI Conf on Tour 2024 3rd Party Services All Months January February March April May June July August September October November December $0 $6000 $12000 $18000 $24000 Amount Success Stories Thanks to financial support we can already see many success stories in the project. Community Manager With the addition of a dedicated Community Manager, we now have a monthly newsletter, regular status updates, an active social media presence, and the ability to drive initiatives such as event organization. Dedicated focus enables us to also focus on a year to year vision . AsyncAPI Mentorship The 2022 mentorship program yielded significant achievements: Kafka support in Glee, a centralized platform for sharing AsyncAPI tools, and a versatile error handling library for multiple projects. AsyncAPI Conference Every year we organize a conference that attracts many participants. In 2022 the online conference generated 3k views . In 2023 we organized four different in person events , some that was also live streamed. Interested in getting in touch? Feel free to contact us if you need more explanation. We are happy to hop on a call and help with onboarding to the project as a sponsor. Write email to info@asyncapi.io Contact Us",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/illustrations/EmployeeInvolvement.webp",
        "alt": "Employee involvement"
      },
      {
        "src": "/img/illustrations/ServiceProvision.webp",
        "alt": "Service provision"
      },
      {
        "src": "/img/illustrations/EventOrganization.webp",
        "alt": "Event organization"
      },
      {
        "src": "/img/illustrations/MentorshipProgram.webp",
        "alt": "Mentorship Program"
      },
      {
        "src": "/img/illustrations/BountyProgram.webp",
        "alt": "Bounty Program"
      },
      {
        "src": "/img/illustrations/Events.webp",
        "alt": "Events"
      },
      {
        "src": "/img/illustrations/SwagStore.webp",
        "alt": "Swag Store"
      },
      {
        "src": "/img/illustrations/Hiring.webp",
        "alt": "Hiring"
      },
      {
        "src": "/img/illustrations/Services.webp",
        "alt": "Services"
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "cecbabe8",
    "title": "AsyncAPI Initiative for event-driven APIs | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/index.html",
    "content": "AsyncAPI Initiative for event-driven APIs | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo \n![Loading...](asyncapi-docs/www.asyncapi.com/img/loaders/loader.png)\n Loading...",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "asyncapi-docs/www.asyncapi.com/img/loaders/loader.png",
        "alt": "Loading..."
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "d0e9bda5",
    "title": "Newsletter | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/newsletter.html",
    "content": "Newsletter | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo Subscribe to our newsletter to receive news about AsyncAPI. We respect your inbox. No spam, promise \u270c\ufe0f",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "a7b6e00f",
    "title": "Vision & Roadmap | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/roadmap.html",
    "content": "Vision & Roadmap | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets Vision AsyncAPI becomes the #1 API specification for defining and developing APIs. Any kind of APIs. It all starts with a vision. This is where we want to see AsyncAPI by 2026. To make this vision a reality, we've set some goals below that will help us to get there. These goals are not necessarily everything we'll have to do to get to that vision but instead, they are manageable objectives we can already anticipate. Together, vision and goals set the direction of the project. Goal AsyncAPI unifies all the API specifications Nobody does only event-driven architectures. Most people complement them with REST (OpenAPI), GraphQL, and/or RPC APIs. We want people to use the AsyncAPI specification and tooling together with their existing OpenAPI, GraphQL, and gRPC definitions. For that purpose, our specification and tools will need to understand and leverage many other specifications and tools. This is not about reinventing the wheel or creating yet another spec to solve the same problems but to integrate with the existing tools and specs instead. Goal API development experience is seamless We want to make the development experience super seamless, from idea to production. Users should be able to create their first API within minutes without prior knowledge of AsyncAPI, the communication protocol, or anything else that's not business logic. Furthermore, making sure production behavior and documentation are always aligned, independently of the programming language or framework of choice. Goal The AsyncAPI community grows 400% We are aware that our goals are ambitious. None of the other goals are possible if we don't have a huge community supporting us. AsyncAPI is and must continue being a community-driven initiative. Now more than ever. We need people to contribute code, ideas, docs, articles, presentations, and more. The sponsors base should also grow along with the community size and the donated money should serve to give back to the community. We'll be regularly setting outcomes or key results that will allow us to accomplish the goals above. You can find a categorization of the outcomes in the roadmap below. They are split by priority and some of them show the related features. Please bear in mind this is an outcome-based roadmap . We don't maintain a long-term release plan. If you want to find more specific and actionable items, head to the related repository issues or start an issue/discussion at github.com/asyncapi/community . Roadmap The outcomes we want to achieve Outcome Solution Implementation Now Our top priority. We're probably working on it right now or starting pretty soon. Specification and parsers are ready to accommodate future features Design a new Parser API resilient to breaking changes Solve the publish/subscribe perspective problem Solve the channel reusability problem User is able to create an API in under 20 minutes with no prior knowledge of AsyncAPI Create an AsyncAPI CLI Create a framework Create outstanding documentation and tutorials User is able to focus only on business logic Make Generator support React Make Generator provide a way to generate types/models in any language It's impossible to unsync documentation from code Create a framework Create AsyncAPI plugins for most common frameworks The vision and roadmap are clear Create a landing page in the website with vision and roadmap Later Our next priority. We'll work on this soon if everything goes as planned. Time to first contribution goes down to a day Create an outstanding contributing guide User is able to render AsyncAPI documentation inside their existing docs Create a UI library Future Not a priority. We're considering working on this but it's too early to know when. OpenAPI, RAML, Avro, GraphQL, Protobuf, and XSD users reuse their schema/type definitions within AsyncAPI. User can modify their existing APIs to work with AsyncAPI in under an hour with no prior knowledge of AsyncAPI and without leaving their framework of choice Create AsyncAPI plugins for most common frameworks User can make sure only well-formed messages reach the broker without having to touch a single line of code Create an event gateway Number of contributors go above 100 in top repos Create an outstanding contributing guide Create a support program to give back to the community The number of community and community-donated projects go above 100 Create a support program to give back to the community The yearly number of community members presenting and/or writing about AsyncAPI goes above 50 Create a support program to give back to the community If you want to know more about the format of this roadmap, watch this recording from one of our SIG meetings: Warning for Contributors This roadmap reflects the priorities of the AsyncAPI Initiative. If you want to contribute a feature from the roadmap, feel free to let us know on the corresponding GitHub issue so we can discuss what's the best way to proceed and implement it yourself.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "c44ce0e5",
    "title": "Slack",
    "path": "asyncapi-docs/www.asyncapi.com/slack-invite.html",
    "content": "Slack We're very sorry, but your browser is not supported! Please upgrade to a supported browser , or try one of our apps. Desktop Apps Mac See system requirements \n![Download on the Mac App Store](https://a.slack-edge.com/80588/marketing/img/downloads/app_stores/ios_mac_app_store_badge.IN.png)\n v4.43.51 Windows See system requirements \n![Download on the Microsoft Store](https://a.slack-edge.com/80588/marketing/img/downloads/app_stores/windows_store_btn.IN.png)\n v4.43.51 Linux See system requirements \n![Download from the Snap Store](https://a.slack-edge.com/80588/marketing/img/downloads/app_stores/snap_store_btn.IN.png)\n v4.41.105 Mobile Apps iOS \n![Download on the App Store](https://a.slack-edge.com/80588/marketing/img/downloads/app_stores/ios_app_store_btn.IN.png)\n Android \n![Get it on Google Play](https://a.slack-edge.com/80588/marketing/img/downloads/app_stores/google_play_store_btn.IN.png)\n Don't see the platform you're looking for? Let us know.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "https://a.slack-edge.com/80588/marketing/img/downloads/app_stores/ios_mac_app_store_badge.IN.png",
        "alt": "Download on the Mac App Store"
      },
      {
        "src": "https://a.slack-edge.com/80588/marketing/img/downloads/app_stores/windows_store_btn.IN.png",
        "alt": "Download on the Microsoft Store"
      },
      {
        "src": "https://a.slack-edge.com/80588/marketing/img/downloads/app_stores/snap_store_btn.IN.png",
        "alt": "Download from the Snap Store"
      },
      {
        "src": "https://a.slack-edge.com/80588/marketing/img/downloads/app_stores/ios_app_store_btn.IN.png",
        "alt": "Download on the App Store"
      },
      {
        "src": "https://a.slack-edge.com/80588/marketing/img/downloads/app_stores/google_play_store_btn.IN.png",
        "alt": "Get it on Google Play"
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "94e00532",
    "title": "Tools | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/tools.html",
    "content": "Tools | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets AsyncAPI Tools Dashboard Discover various AsyncAPI tools to optimize your journey! These tools are made by the community, for the community. Have an AsyncAPI tool you want to be featured on this list? Then follow the procedure given in the Tool Documentation file, and show up your AsyncAPI Tool card in the website. Filter Jump to Category APIs The following is a list of APIs that expose functionality related to AsyncAPI. API Tracker - AsyncAPI specs Open Source Explore APIs and companies with public AsyncAPI specifications. LANGUAGE Visit Website AsyncAPI Server API Open Source Server API providing official AsyncAPI tools LANGUAGE TECHNOLOGIES Node.js TypeScript View Github Visit Website Visit Docs AsyncAPI Server API Open Source Server API providing official AsyncAPI tools LANGUAGE TECHNOLOGIES Node.js TypeScript View Github Visit Website Visit Docs AsyncAPI-Directory by APIs.guru Open Source Directory of asynchronous API specifications in AsyncAPI format. LANGUAGE JavaScript TECHNOLOGIES Node.js Liquid View Github Visit Website SIO-AsyncAPI Open Source This is code-first approach to generate AsyncAPI specification from Socket.IO server. LANGUAGE Python TECHNOLOGIES Socket.IO Flask View Github Visit Website Visit Docs SIO-AsyncAPI Open Source This is code-first approach to generate AsyncAPI specification from Socket.IO server. LANGUAGE Python TECHNOLOGIES Socket.IO Flask View Github Visit Website Visit Docs Code-first tools The following is a list of tools that generate AsyncAPI documents from your code. AsyncAPI.Net Open Source The AsyncAPI.NET SDK contains a useful object model for AsyncAPI documents in .NET along with common serializers to extract raw OpenAPI JSON and YAML documents from the model. LANGUAGE C# TECHNOLOGIES .NET ASP.NET View Github Visit Website AsyncAPI.Net Open Source The AsyncAPI.NET SDK contains a useful object model for AsyncAPI documents in .NET along with common serializers to extract raw OpenAPI JSON and YAML documents from the model. LANGUAGE C# TECHNOLOGIES .NET ASP.NET View Github Visit Website AsyncApi.Net.Generator Open Source Code-first AsyncAPI documentation generator and ui LANGUAGE C# TECHNOLOGIES .NET ASP.NET View Github EventBridge Atlas Open Source Tool that translates your AWS EventBridge Schemas into an AsyncAPI document and a web UI. LANGUAGE TECHNOLOGIES Node.js View Github Visit Website FastStream Open Source A powerful and easy-to-use Python framework for building asynchronous services interacting with event streams such as Apache Kafka, RabbitMQ and NATS. LANGUAGE Python View Github Visit Website Go AsyncAPI Open Source This library helps to create AsyncAPI spec from your Go message structures. It uses reflection to translate Go structures in JSON Schema definitions and arrange them in AsyncAPI schema. LANGUAGE Go/Golang View Github Java AsyncAPI Open Source This tool stores modules, which simplifies interacting with AsyncAPI in jvm ecosystem. LANGUAGE Java TECHNOLOGIES Kotlin Maven View Github KnstEventBus Open Source AsyncApi code-first tools for c#. Generates document and view. LANGUAGE C# TECHNOLOGIES ASP.NET .NET View Github Kotlin AsyncAPI Open Source The Kotlin AsyncAPI project aims to provide convenience tools for generating and serving AsyncAPI documentation. The core of this project is a Kotlin DSL for building the specification in a typesafe way. LANGUAGE Kotlin TECHNOLOGIES Springboot Maven View Github nestjs-asyncapi Open Source Utilize decorators to generate AsyncAPI document utilizing DTOs (similar to @nestjs/swagger) and a web UI. LANGUAGE TypeScript TECHNOLOGIES Node.js Nest Js View Github nestjs-asyncapi Open Source Utilize decorators to generate AsyncAPI document utilizing DTOs (similar to @nestjs/swagger) and a web UI. LANGUAGE TypeScript TECHNOLOGIES Node.js Nest Js View Github Neuroglia AsyncAPI Open Source A .NET SDK for the Async API specification. Automatically generates and serves AsyncAPI documents based on your code. Includes fluent-builders to create AsyncAPI documents from scratch, and provides a web-based GUI to browse generated documents. LANGUAGE C# TECHNOLOGIES .NET View Github Saunter Open Source Saunter is an AsyncAPI documentation generator for dotnet. Generates (and hosts) an AsyncAPI schema document from your code. LANGUAGE C# TECHNOLOGIES .NET ASP.NET View Github SIO-AsyncAPI Open Source This is code-first approach to generate AsyncAPI specification from Socket.IO server. LANGUAGE Python TECHNOLOGIES Socket.IO Flask View Github Visit Website Visit Docs SIO-AsyncAPI Open Source This is code-first approach to generate AsyncAPI specification from Socket.IO server. LANGUAGE Python TECHNOLOGIES Socket.IO Flask View Github Visit Website Visit Docs Springwolf Open Source Automated documentation for async APIs built with Spring Boot. Like Springfox for AsyncAPI. Auto-generates an AsyncAPI document and a web UI. LANGUAGE Java TECHNOLOGIES Springboot Gradle View Github Visit Website sttp tapir Open Source Library for describing HTTP endpoints, and then interpreting them as a server, client, or documentation LANGUAGE Scala View Github Visit Website Zod Sockets Open Source Socket.IO solution with I/O validation and the ability to generate AsyncAPI specification and a contract for consumers. LANGUAGE TypeScript TECHNOLOGIES Node.js TypeScript View Github Visit Website Zod Sockets Open Source Socket.IO solution with I/O validation and the ability to generate AsyncAPI specification and a contract for consumers. LANGUAGE TypeScript TECHNOLOGIES Node.js TypeScript View Github Visit Website Code Generators The following is a list of tools that generate code from an AsyncAPI document; not the other way around. AsyncAPI Generator Open Source Generator is a tool that you can use to generate whatever you want basing on the AsyncAPI specification file as an input. LANGUAGE JavaScript TECHNOLOGIES Node.js View Github Visit Docs AsyncAPI Modelina Open Source Generate payload models into Java, TypeScript, Go, etc, you name it, from AsyncAPI documents. This tool gives you full control over the models through high customization LANGUAGE TypeScript TECHNOLOGIES React JS Docker View Github Visit Website Visit Docs AsyncAPI Modelina Open Source Generate payload models into Java, TypeScript, Go, etc, you name it, from AsyncAPI documents. This tool gives you full control over the models through high customization LANGUAGE TypeScript TECHNOLOGIES React JS Docker View Github Visit Website Visit Docs asyncapi-python Open Source Easily generate type-safe and async Python applications from AsyncAPI 3 specifications. LANGUAGE Python TECHNOLOGIES amqp View Github Visit Website asyncapi-python Open Source Easily generate type-safe and async Python applications from AsyncAPI 3 specifications. LANGUAGE Python TECHNOLOGIES amqp View Github Visit Website Golang AsyncAPI Code Generator Open Source Generate Go user and application boilerplate from AsyncAPI specifications. Can be called from `go generate` without requirements. LANGUAGE Go/Golang View Github Golang AsyncAPI Code Generator Open Source Generate Go user and application boilerplate from AsyncAPI specifications. Can be called from `go generate` without requirements. LANGUAGE Go/Golang View Github MultiAPI Generator Open Source This is a plugin designed to help developers automatizing the creation of code classes from YML files based on AsyncApi and OpenAPI. It is presented in 2 flavours Maven and Gradle LANGUAGE Java TECHNOLOGIES Groovy Maven View Github Node-RED AsyncAPI plugin Open Source A plugin for generating and configuring nodes for Kafka, MQTT, AMQP, etc. automatically from an AsyncAPI specification. LANGUAGE TECHNOLOGIES Node-RED View Github ZenWave SDK Open Source DDD and API-First for Event-Driven Microservices LANGUAGE Java TECHNOLOGIES Maven Liquid Spring Cloud Streams JHipster JDL View Github Visit Website Visit Docs ZenWave SDK Open Source DDD and API-First for Event-Driven Microservices LANGUAGE Java TECHNOLOGIES Maven Liquid Spring Cloud Streams JHipster JDL View Github Visit Website Visit Docs Converters The following is a list of tools that do not yet belong to any specific category but are also useful for the community. AsyncAPI-format Open Source Format an AsyncAPI document by ordering, casing, formatting, and filtering fields. LANGUAGE JavaScript TECHNOLOGIES Node.js View Github AsyncAPI.Net Open Source The AsyncAPI.NET SDK contains a useful object model for AsyncAPI documents in .NET along with common serializers to extract raw OpenAPI JSON and YAML documents from the model. LANGUAGE C# TECHNOLOGIES .NET ASP.NET View Github Visit Website AsyncAPI.Net Open Source The AsyncAPI.NET SDK contains a useful object model for AsyncAPI documents in .NET along with common serializers to extract raw OpenAPI JSON and YAML documents from the model. LANGUAGE C# TECHNOLOGIES .NET ASP.NET View Github Visit Website Converter Open Source Converts old versions of AsyncAPI files into the latest version. LANGUAGE TypeScript TECHNOLOGIES Node.js View Github Converter-Go Open Source The AsyncAPI Converter converts AsyncAPI documents from versions 1.0.0, 1.1.0 and 1.2.0 to version 2.0.0. It supports both json and yaml formats on input and output. By default, the AsyncAPI Converter converts a document into the json format. LANGUAGE Go/Golang View Github Directories The following is a list of directories that index public AsyncAPI documents. API Tracker - AsyncAPI specs Open Source Explore APIs and companies with public AsyncAPI specifications. LANGUAGE Visit Website AsyncAPI-Directory by APIs.guru Open Source Directory of asynchronous API specifications in AsyncAPI format. LANGUAGE JavaScript TECHNOLOGIES Node.js Liquid View Github Visit Website Documentation Generators The following is a list of tools that generate human-readable documentation from an AsyncAPI document. AsyncAPI Generator Open Source Generator is a tool that you can use to generate whatever you want basing on the AsyncAPI specification file as an input. LANGUAGE JavaScript TECHNOLOGIES Node.js Markdown View Github Visit Docs asyncapi-asciidoc-template Open Source Asciidoc template for the asyncapi generator LANGUAGE JavaScript TECHNOLOGIES React JS View Source Code Bump.sh Commercial OpenAPI 2 & 3 / AsyncAPI 2 documentation generator, with automatic changelog and visual diff. LANGUAGE Visit Website Visit Docs Cupid Open Source A library that focuses on finding and analyzing the relationships between AsyncAPI documents. It outputs a map of the system architecture. LANGUAGE JavaScript TECHNOLOGIES Node.js View Github KnstEventBus Open Source AsyncApi code-first tools for c#. Generates document and view. LANGUAGE C# TECHNOLOGIES ASP.NET .NET View Github Springwolf Open Source Automated documentation for async APIs built with Spring Boot. Like Springfox for AsyncAPI. Auto-generates an AsyncAPI document and a web UI. LANGUAGE Java TECHNOLOGIES Springboot Gradle View Github Visit Website Widdershins Open Source OpenAPI 3.0 / Swagger 2.0 / AsyncAPI 1.0 definition to Slate / Shins compatible markdown. LANGUAGE JavaScript TECHNOLOGIES Node.js Shell View Github Visit Website Editors The following is a list of editors or related tools that allow editing of AsyncAPI document. AsyncAPI Studio Open Source Visually design your AsyncAPI files and event-driven architecture. LANGUAGE TECHNOLOGIES React JS TypeScript View Github Visit Website AsyncAPI Studio Open Source Visually design your AsyncAPI files and event-driven architecture. LANGUAGE TECHNOLOGIES React JS TypeScript View Github Visit Website UI components The following is a list of UI components to view AsyncAPI documents. Api-Diff-Viewer Open Source React component to view the difference between two Json based API documents. Supported specifications: JsonSchema, OpenAPI 3.x, AsyncAPI 2.x. LANGUAGE TypeScript TECHNOLOGIES React JS Babel Storybook View Github Visit Website AsyncAPI React component Open Source React component for rendering documentation from your specification in real-time in the browser. It also provides a WebComponent and bundle for Angular and Vue LANGUAGE TypeScript TECHNOLOGIES React JS WebComponents View Github AsyncAPI React component Open Source React component for rendering documentation from your specification in real-time in the browser. It also provides a WebComponent and bundle for Angular and Vue LANGUAGE TypeScript TECHNOLOGIES React JS WebComponents View Github DSL Writing YAML by hand is no fun, and maybe you don't want a GUI, so use a Domain Specific Language to write AsyncAPI in your language of choice. BOATS Open Source Compile your single AsyncAPI file from multiple YAML files with BOATS and with the help of the template engine Nunjucks, plus a many extra helpers to automate much of the donkey work. LANGUAGE TypeScript TECHNOLOGIES Node.js View Github ZenWave SDK Open Source DDD and API-First for Event-Driven Microservices LANGUAGE Java TECHNOLOGIES Maven Liquid Spring Cloud Streams JHipster JDL View Github Visit Website Visit Docs ZenWave SDK Open Source DDD and API-First for Event-Driven Microservices LANGUAGE Java TECHNOLOGIES Maven Liquid Spring Cloud Streams JHipster JDL View Github Visit Website Visit Docs Zod Sockets Open Source Socket.IO solution with I/O validation and the ability to generate AsyncAPI specification and a contract for consumers. LANGUAGE TypeScript TECHNOLOGIES Node.js TypeScript View Github Visit Website Zod Sockets Open Source Socket.IO solution with I/O validation and the ability to generate AsyncAPI specification and a contract for consumers. LANGUAGE TypeScript TECHNOLOGIES Node.js TypeScript View Github Visit Website Frameworks The following is a list of API/application frameworks that make use of AsyncAPI. Asynction Open Source SocketIO server framework driven by the AsyncAPI specification. Asynction guarantees that your API will work in accordance with its AsyncAPI documentation. Built on top of Flask-SocketIO. LANGUAGE Python TECHNOLOGIES Flask View Github Visit Website FastStream Open Source A powerful and easy-to-use Python framework for building asynchronous services interacting with event streams such as Apache Kafka, RabbitMQ and NATS. LANGUAGE Python View Github Visit Website Glee Open Source Glee \u2014 The AsyncAPI framework that will make you smile again :) LANGUAGE TECHNOLOGIES TypeScript View Github Glee Open Source Glee \u2014 The AsyncAPI framework that will make you smile again :) LANGUAGE TECHNOLOGIES TypeScript View Github Zod Sockets Open Source Socket.IO solution with I/O validation and the ability to generate AsyncAPI specification and a contract for consumers. LANGUAGE TypeScript TECHNOLOGIES Node.js TypeScript View Github Visit Website Zod Sockets Open Source Socket.IO solution with I/O validation and the ability to generate AsyncAPI specification and a contract for consumers. LANGUAGE TypeScript TECHNOLOGIES Node.js TypeScript View Github Visit Website GitHub Actions The following is a list of GitHub Actions that you can use in your workflows API documentation generation on Bump.sh Open Source With this GitHub Action you can automatically generate your API reference (with the changelog and diff) on Bump.sh from any AsyncAPI file. LANGUAGE TypeScript View Github Visit Website AsyncAPI GitHub Action Open Source This action validates if the AsyncAPI schema file is valid or not. LANGUAGE JavaScript TECHNOLOGIES Node.js View Github Visit Website Automated version bump for AsyncAPI documents Open Source With this GitHub Action, you can automatically bump the version based on commit messages, which is similar to what semantic-release is for NPM. LANGUAGE JavaScript TECHNOLOGIES Node.js View Github Visit Website GitHub Action for Generator Open Source CLI to work with your AsyncAPI files. You can validate them and in the future use a generator and even bootstrap a new file. Contributions are welcomed! LANGUAGE TECHNOLOGIES AsyncAPI Generator View Github GitHub Action for Generator Open Source CLI to work with your AsyncAPI files. You can validate them and in the future use a generator and even bootstrap a new file. Contributions are welcomed! LANGUAGE TECHNOLOGIES AsyncAPI Generator View Github GitHub Action for Generator Open Source LANGUAGE TECHNOLOGIES AsyncAPI Generator View Github GitHub Action for Generator Open Source LANGUAGE TECHNOLOGIES AsyncAPI Generator View Github Mocking and Testing The tools below take specification documents as input, then publish fake messages to broker destinations for simulation purposes. They may also check that publisher messages are compliant with schemas. Microcks Open Source Mocking and testing platform for API and microservices. Turn your AsyncAPI, OpenAPI contract examples, or Postman collections into ready-to-use mocks. Use examples to simulate and validate received messages according to schema elements. LANGUAGE Java TECHNOLOGIES TypeScript Kubernetes-native Saas View Github Visit Website MultiAPI Converter Open Source Use AsyncAPI definition, to generate Spring Cloud Contract producer validation or consumer stubs, using maven. LANGUAGE Java TECHNOLOGIES Springboot View Github Specmatic Open Source An API contract testing tool that helps ensure the correctness APIs by automatically generating test cases and verifying them against the API spec. It simplifies the process of testing APIs and reduces the likelihood of bugs and compatibility issues. LANGUAGE Kotlin TECHNOLOGIES Maven View Github Visit Website Visit Docs Specmatic Open Source An API contract testing tool that helps ensure the correctness APIs by automatically generating test cases and verifying them against the API spec. It simplifies the process of testing APIs and reduces the likelihood of bugs and compatibility issues. LANGUAGE Kotlin TECHNOLOGIES Maven View Github Visit Website Visit Docs Virtualan Open Source Mocking and testing platform for API and microservices. Allows you to create and setup mocks for OpenAPI and AsyncAPI contracts. Shows how to setup and create AsyncAPI GitHub Reference Examples and OpenAPI GitHub Reference Examples. LANGUAGE TECHNOLOGIES Kubernetes-native View Github Visit Website ZenWave SDK Open Source DDD and API-First for Event-Driven Microservices LANGUAGE Java TECHNOLOGIES Maven Liquid Spring Cloud Streams JHipster JDL View Github Visit Website Visit Docs ZenWave SDK Open Source DDD and API-First for Event-Driven Microservices LANGUAGE Java TECHNOLOGIES Maven Liquid Spring Cloud Streams JHipster JDL View Github Visit Website Visit Docs Validators The following is a list of tools that validate AsyncAPI documents. AMF Open Source AMF (AML Modeling Framework) is an open-source library capable of parsing and validating AML metadata documents. LANGUAGE Scala View Github Visit Docs AsyncAPI GitHub Action Open Source This action validates if the AsyncAPI schema file is valid or not. LANGUAGE JavaScript TECHNOLOGIES Node.js View Github Visit Website AsyncAPI Parser Open Source Use this package to parse and validate AsyncAPI documents \u2014either YAML or JSON\u2014 in your Node.js or browser application. Updated bundle for the browser is always attached to the GitHub Release. LANGUAGE JavaScript TECHNOLOGIES Node.js View Github AsyncAPI Parser Open Source The AsyncAPI Parser validates AsyncAPI documents according to dedicated schemas. LANGUAGE Go/Golang View Github AsyncAPI Parser Wrapper Open Source Use this library to parse and validate AsyncAPI documents \u2014 either YAML or JSON \u2014 in your Java application. It is a Java wrapper over JavaScript Parser implemented using J2V8. LANGUAGE Java View Github AsyncAPI Validation Open Source Message validation package for YAML and JSON AsyncAPI documents. LANGUAGE TypeScript TECHNOLOGIES Node.js View Github AsyncAPI Validation Open Source Message validation package for YAML and JSON AsyncAPI documents. LANGUAGE TypeScript TECHNOLOGIES Node.js View Github asyncapi-validator Open Source It allows you to validate the schema of your messages against your AsyncAPI schema definition. You can use it with Kafka, RabbitMQ or any other messaging/queue. LANGUAGE JavaScript TECHNOLOGIES Node.js View Github AsyncAPI.Net Open Source The AsyncAPI.NET SDK contains a useful object model for AsyncAPI documents in .NET along with common serializers to extract raw OpenAPI JSON and YAML documents from the model. LANGUAGE C# TECHNOLOGIES .NET ASP.NET View Github Visit Website AsyncAPI.Net Open Source The AsyncAPI.NET SDK contains a useful object model for AsyncAPI documents in .NET along with common serializers to extract raw OpenAPI JSON and YAML documents from the model. LANGUAGE C# TECHNOLOGIES .NET ASP.NET View Github Visit Website Spectral Open Source A flexible JSON/YAML linter for creating automated style guides, with baked in support for OpenAPI v3.1, v3.0, and v2.0 as well as AsyncAPI v2.x. LANGUAGE TypeScript TECHNOLOGIES Node.js View Github Compare tools The following is a list of tools that compare AsyncAPI documents. Api-Smart-Diff Open Source It allows you to compare two API documents and classify changes. Supported API specifications: OpenAPI, AsyncAPI, JsonSchema. LANGUAGE TypeScript View Github AsyncAPI Diff Open Source Diff is a library that compares two AsyncAPI Documents and provides information about the differences by pointing out explicitly information like breaking changes. LANGUAGE TypeScript TECHNOLOGIES TypeScript View Github AsyncAPI Diff Open Source Diff is a library that compares two AsyncAPI Documents and provides information about the differences by pointing out explicitly information like breaking changes. LANGUAGE TypeScript TECHNOLOGIES TypeScript View Github jasyncapicmp Open Source Tool for comparing two AsyncAPI versions and evaluating compatibility. LANGUAGE Java TECHNOLOGIES Maven View Github Visit Website Visit Docs jasyncapicmp Open Source Tool for comparing two AsyncAPI versions and evaluating compatibility. LANGUAGE Java TECHNOLOGIES Maven View Github Visit Website Visit Docs jasyncapicmp Open Source Tool/library/maven-plugin for comparing two AsyncAPI versions and evaluating compatibility. LANGUAGE Java TECHNOLOGIES Maven View Github Visit Website CLIs The following is a list of tools that you can work with in terminal or do some CI/CD automation. AsyncAPI CLI Open Source One CLI to rule them all. This is a CLI that aims to integrate all AsyncAPI tools that you need while AsyncAPI document development and maintainance. You can use it to generate docs or code, validate AsyncAPI document and event create new documents. LANGUAGE TECHNOLOGIES TypeScript View Github Visit Website AsyncAPI CLI Open Source One CLI to rule them all. This is a CLI that aims to integrate all AsyncAPI tools that you need while AsyncAPI document development and maintainance. You can use it to generate docs or code, validate AsyncAPI document and event create new documents. LANGUAGE TECHNOLOGIES TypeScript View Github Visit Website AsyncAPI CLI Open Source One CLI to rule them all. This is a CLI that aims to integrate all AsyncAPI tools that you need while AsyncAPI document development and maintainance. You can use it to generate docs or code, validate AsyncAPI document and event create new documents. LANGUAGE TECHNOLOGIES TypeScript View Github Visit Website AsyncAPI CLI Open Source One CLI to rule them all. This is a CLI that aims to integrate all AsyncAPI tools that you need while AsyncAPI document development and maintainance. You can use it to generate docs or code, validate AsyncAPI document and event create new documents. LANGUAGE TECHNOLOGIES TypeScript View Github Visit Website AsyncAPI-format Open Source Format an AsyncAPI document by ordering, casing, formatting, and filtering fields. LANGUAGE JavaScript TECHNOLOGIES Node.js View Github ZenWave SDK Open Source DDD and API-First for Event-Driven Microservices LANGUAGE Java TECHNOLOGIES Maven Liquid Spring Cloud Streams JHipster JDL View Github Visit Website Visit Docs ZenWave SDK Open Source DDD and API-First for Event-Driven Microservices LANGUAGE Java TECHNOLOGIES Maven Liquid Spring Cloud Streams JHipster JDL View Github Visit Website Visit Docs Bundlers The following is a list of tools that you can work with to bundle AsyncAPI documents. Api-ref-bundler Open Source It allows you bundle/dereference external/internal $refs in Json based API document. Supported specifications: OpenAPI, AsyncAPI, JsonSchema. LANGUAGE TypeScript TECHNOLOGIES TypeScript View Github AsyncAPI Bundler Open Source Combine multiple AsyncAPI specification files into one. LANGUAGE TypeScript TECHNOLOGIES TypeScript View Github AsyncAPI Bundler Open Source Combine multiple AsyncAPI specification files into one. LANGUAGE TypeScript TECHNOLOGIES TypeScript View Github IDE Extensions The following is a list of extensions for different IDEs like VSCode, IntelliJ IDEA and others asyncapi-preview Open Source VSCode extension that enables you to: - Preview documentation generated using you AsyncAPI document. It uses AsyncAPI React component under the hood, - Create AsyncAPI documents faster using SmartPaste functionality LANGUAGE TECHNOLOGIES VSCode SmartPaste View Github asyncapi-preview Open Source VSCode extension that enables you to: - Preview documentation generated using you AsyncAPI document. It uses AsyncAPI React component under the hood, - Create AsyncAPI documents faster using SmartPaste functionality LANGUAGE TECHNOLOGIES VSCode SmartPaste View Github asyncapi-preview Open Source VSCode extension that enables you to: - Preview documentation generated using you AsyncAPI document. It uses AsyncAPI React component under the hood, - Create AsyncAPI documents faster using SmartPaste functionality LANGUAGE TECHNOLOGIES VSCode SmartPaste View Github asyncapi-preview Open Source VSCode extension that enables you to: - Preview documentation generated using you AsyncAPI document. It uses AsyncAPI React component under the hood, - Create AsyncAPI documents faster using SmartPaste functionality LANGUAGE TECHNOLOGIES VSCode SmartPaste View Github jAsyncAPI - IDEA plugin Open Source Idea plugin for the java-asyncapi - Helps to edit and validate AsyncAPI schemas. LANGUAGE Kotlin TECHNOLOGIES JetBrains IntelliJ IDEA View Github Visit Website Visit Docs jAsyncAPI - IDEA plugin Open Source Idea plugin for the java-asyncapi - Helps to edit and validate AsyncAPI schemas. LANGUAGE Kotlin TECHNOLOGIES JetBrains IntelliJ IDEA View Github Visit Website Visit Docs AsyncAPI Generator Templates The following is a list of templates compatible with AsyncAPI Generator. You can use them to generate apps, clients or documentation from your AsyncAPI documents. HTML Template Open Source HTML template for AsyncAPI Generator. Use it to generate a static docs. It is using AsyncAPI React component under the hood. LANGUAGE JavaScript TECHNOLOGIES HTML View Github HTML Template Open Source HTML template for AsyncAPI Generator. Use it to generate a static docs. It is using AsyncAPI React component under the hood. LANGUAGE JavaScript TECHNOLOGIES HTML View Github Java Spring Cloud Stream Template Open Source Java Spring Cloud Stream template for the AsyncAPI Generator LANGUAGE JavaScript TECHNOLOGIES Spring Cloud Streams Maven View Github Java Spring Cloud Stream Template Open Source Java Spring Cloud Stream template for the AsyncAPI Generator LANGUAGE JavaScript TECHNOLOGIES Spring Cloud Streams Maven View Github Java Spring Template Open Source Java Spring template for the AsyncAPI Generator LANGUAGE JavaScript TECHNOLOGIES Springboot Maven Gradle View Github Java Spring Template Open Source Java Spring template for the AsyncAPI Generator LANGUAGE JavaScript TECHNOLOGIES Springboot Maven Gradle View Github Java Template Open Source Java template for the AsyncAPI Generator LANGUAGE JavaScript TECHNOLOGIES Java View Github Java Template Open Source Java template for the AsyncAPI Generator LANGUAGE JavaScript TECHNOLOGIES Java View Github Node.js Multiprotocol Template Open Source This template generates a server using your AsyncAPI document. It supports multiple different protocols, like Kafka or MQTT. It is designed in the way that generated code is a library and with it's API you can start the server, send messages or register a middleware for listening incoming messages. Runtime message validation included. LANGUAGE JavaScript TECHNOLOGIES Node.js View Github Node.js Multiprotocol Template Open Source This template generates a server using your AsyncAPI document. It supports multiple different protocols, like Kafka or MQTT. It is designed in the way that generated code is a library and with it's API you can start the server, send messages or register a middleware for listening incoming messages. Runtime message validation included. LANGUAGE JavaScript TECHNOLOGIES Node.js View Github Node.js Websockets Template Open Source Node.js WebSockets template for the AsyncAPI Generator. It showcases how from a single AsyncAPI document you can generate a server and a client at the same time. LANGUAGE JavaScript TECHNOLOGIES Node.js View Github Node.js Websockets Template Open Source Node.js WebSockets template for the AsyncAPI Generator. It showcases how from a single AsyncAPI document you can generate a server and a client at the same time. LANGUAGE JavaScript TECHNOLOGIES Node.js View Github Others The following is a list of tools that comes under Other category. AsyncAPI CLI Open Source One CLI to rule them all. This is a CLI that aims to integrate all AsyncAPI tools that you need while AsyncAPI document development and maintainance. You can use it to generate docs or code, validate AsyncAPI document and event create new documents. LANGUAGE TECHNOLOGIES TypeScript View Github Visit Website AsyncAPI CLI Open Source One CLI to rule them all. This is a CLI that aims to integrate all AsyncAPI tools that you need while AsyncAPI document development and maintainance. You can use it to generate docs or code, validate AsyncAPI document and event create new documents. LANGUAGE TECHNOLOGIES TypeScript View Github Visit Website AsyncAPI CLI Open Source One CLI to rule them all. This is a CLI that aims to integrate all AsyncAPI tools that you need while AsyncAPI document development and maintainance. You can use it to generate docs or code, validate AsyncAPI document and event create new documents. LANGUAGE TECHNOLOGIES TypeScript View Github Visit Website AsyncAPI CLI Open Source One CLI to rule them all. This is a CLI that aims to integrate all AsyncAPI tools that you need while AsyncAPI document development and maintainance. You can use it to generate docs or code, validate AsyncAPI document and event create new documents. LANGUAGE TECHNOLOGIES TypeScript View Github Visit Website",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "c5a40385",
    "title": "Awesome 2020 and What Can Get Better In 2021 | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/blog/2020-summary.html",
    "content": "Awesome 2020 and What Can Get Better In 2021 | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Important moments Slack Numbers getting high Most present companies What's next with Slack LinkedIn Followers and impressions Sponsored marketing What's next with LinkedIn Google Analytics Traffic got much higher Top referring channels Top blog posts What's next with the website Twitter Paid marketing Top tweets What's next with Twitter GitHub Most popular repositories Traffic growth What's next with GitHub npm Top packages What's next with npm YouTube Watch time goes crazy Most popular videos What's next with YouTube Open Collective Ultimate questions - how many people use the spec? Final words \n![](/img/posts/2020-summary/cover.webp)\n \ud83d\udd95 COVID-19 AsyncAPI Community is stronger than you think. See the growth of AsyncAPI in 2020 in hard numbers. How do we compare to 2019? This post is based on quantitative data using metrics from different platforms where AsyncAPI is present. I collected this data between 15-17.12, so they are already a bit larger by now. I'll try to confront our qualitative knowledge, what we know from discussions with others, and our observations. This post is not 100% just in numbers and analytics. It is also a summary of all the important things that happened to the project this year. Important moments Our first ever AsyncAPI Online Conference . This pandemic edition turned out to be a very successful event that powered us up for the rest of the year We took active part in Hacktoberfest as maintainers and increased the number of contributions to the project AsyncAPI was featured in InfoQ's Software Architecture and Design InfoQ Trends Report\u2014April 2020 that directly brought 1963 new users to the AsyncAPI website AsyncAPI showed up on Technology Radar that took 1051 users directly to the AsyncAPI website Our two core tools reached their first major release JavaScript Parser Generator All those moments lead us to the most important one: the partnership with Postman . Slack tl;dr AsyncAPI community activity on our Slack workspace doubled! \n![Figure 1: Slack active members weekly](/img/posts/2020-summary/active-members.webp)\n Figure 1: Slack active members weekly Numbers getting high I don't think the below tables require any introduction. January 2019 January 2020 December 2020 Messages posted 2788 25388 (+22600) 76609 (+51221) Number of members 159 432 (+273) 888 (+456) More members means higher activity \ud83d\ude05 2019 2020 Weekly members activity 45 average 42 median 81 average 76 median Most present companies I was also super curious to check out where our members are coming from. The only way to do it was by checking the domain of their emails used during registration. Yes, this is not 100% accurate. Not all people use company emails in open source. It is visible in data; half of the users have the gmail.com domain. Nevertheless, the result of my investigation is pretty accurate with our knowledge. The ones that have more than three representants: mulesoft.com postman.com redhat.com sap.com smartbear.com solace.com tibco.com worldpay.com Some of these companies sponsored our work in 2020. The ones that didn't... don't worry, we'll contact you \ud83d\ude09 In 2021, we want to go into a neutral ground (i.e., joining a foundation). There'll be no more excuses. What's next with Slack Slack hard numbers confirm what we see in Slack every day. Luckily, even though the activity doubled, the number of active users that help out in the workspace also grew \ud83d\ude4f With the recently announced Postman partnership, I do not worry about how we'll handle 2021. Next year we need to address two critical topics: our community grows but the knowledge that we all share in Slack is lost. We use a free version of Slack, and therefore, only the last 10k messages are available. In 2021, we need to make a strong decision on what's next. Should we spend some budget on Slack commercial subscriptions, or maybe we should find a better tool? we need to reorganize our channels, be a bit more granular, and target suitable community groups. We'll bother you to get your feedback once we start this reorganization. LinkedIn LinkedIn grew a lot this year. We won't be able to compare this year with the previous one because... this is not a place where I want to discuss the experience you get with LinkedIn. Followers and impressions At the moment, we have 757 followers. Followers Likes Impressions 611 57 from payed marketing 1253 80095 People that like our updates are most likely the ones that click on links. 75% (947) of likes converted into visits to our website . We took this data from Google Analytics, and we know that in 2019 we had only 137 visits from LinkedIn. The most performing update was the one about the partnership with Postman . It is LinkedIn, and it is all about business. The chart below shows that data match reality. The highest peak in late March is related to our first AsyncAPI Online Conference . The rise of sponsored traffic is connected to our post-conference activities using the money we got from conference sponsors. \n![Figure 2: Impressions to updates in 2020](/img/posts/2020-summary/linkedin-impressions.webp)\n Figure 2: Impressions to updates in 2020 Sponsored marketing This year we explored paid adverts on LinkedIn. We had some money left from sponsors of our AsyncAPI conference but zero experience with LinkedIn. Luckily, we have a fantastic community. One of the community members, Dan Weese , helped us here. He did not only put us in contact with marketing expert, Charles Serdou but also covered his wages. Thank you, Dan \ud83d\ude4f This way, we covered only LinkedIn costs paying $1 074,08 \n![Figure 3: Followers growth in 2020](/img/posts/2020-summary/linkedin-folowers.webp)\n Figure 3: Followers growth in 2020 Marketing was focused on increasing the number of followers. Comparing the results of sponsored marketing with followers' organic growth, one could say LinkedIn marketing was not so good. It was very good though. LinkedIn is just super expensive and charged a lot for every new follower. We should give it a second chance in 2021, but this time with sponsored updates. What's next with LinkedIn The numbers show it is worth investing in the channel. We can reach a lot of people that are not reachable on other channels. So we will for sure continue what we do now, especially that this work doesn't require too much extra effort from us. I feel that probably some traffic coming from LinkedIn to our website is not adequately tracked in Google Analytics. Data from LinkedIn say we should notice 2x947 traffic. It might be related to people blocking tracking tools, and we will have to make sure to use other tracking methods, like putting identifiers in the links. Google Analytics We use Google Analytics on AsyncAPI website because we want to understand what content is most valuable for you, and we want to learn how the interest is growing. Traffic got much higher The interest is growing by a lot! Our website handles it well with the support of Netlify , which is free for open-source projects. 2019 2020 Unique users visits 27 090 80 399 (+53 309) Number of sessions 50 405 142 229 (+91 824) Unique pageviews 143 059 348 131 (+205 172) Top referring channels If we look closer to the statistics to check out how people learn about AsyncAPI, referral channels keep pretty much the same share of the pie, just numbers grow. \n![Figure 4: Top channels in 2019](/img/posts/2020-summary/top-channel-2019.webp)\n Figure 4: Top channels in 2019 \n![Figure 5: Top channels in 2020](/img/posts/2020-summary/top-channel-2020.webp)\n Figure 5: Top channels in 2020 In 2019, the most viral was the information about AsyncAPI 2.0 release, while in 2020, the blog post about how we automated releases on AsyncAPI packages to speed up work. Top blog posts AsyncAPI blog is not just for Fran and me. It is for the AsyncAPI Community. Anyone can share knowledge, experience, and showcase their work there. Just let us know what you want to write about. What is the benefit of writing/republishing on the AsyncAPI blog? Visibility among the AsyncAPI community plus our activities to make your work go viral. Just look at the below table to see our top 3 viral posts. Post Unique pageviews Author Full automation of release to NPM and Docker Hub with GitHub Actions and Conventional Commits (March 2020) 9 318 Lukasz Gornicki AsyncAPI Code Generation: Microservices Using Spring Cloud Stream (June 2020) 8 508 Marc DiPasquale An API Strategist Explores Event-Driven APIs (May 2019) 3 451 Emmelyn Wang What's next with the website We need to enable Google Search Console and connect with our Google Analytics account. It will increase our knowledge about how people google before they get into the AsyncAPI website. Knowing how people find us, we can focus on more content related to search queries. We need more posts on our blog. 2020 shows this is something that increases traffic. We already welcomed many guest bloggers, and you can become one of our writers too. Twitter By the time I gathered data for this blog post, we had 1433 followers on Twitter. 876 followers joined us in 2020. It is a large increase since the account creation back in March 2019. Paid marketing We used money from our AsyncAPI conference sponsors to advertise the conference on Twitter. We spent $924,14 on this activity and when we compare it to organic impressions over this year, result is just great: Organic (549 tweets) Promoted (3! tweets) Impressions 570 466 525 329 Retweets 1 429 77 Likes 2 507 567 URLs clicks 2 759 2 283 Follows 4 35 Nothing is black and white, even Twitter performance. One could say: leave organic growth and invest in paid marketing We do not treat Twitter as just a marketing channel. It is our window to the community. We use it to share updates, short information and engage directly with our community members. We should continue to work on organic growth. It converted only into 2 160 sessions to the AsyncAPI website, which is not much if we compare it with 2 283 sessions opened with the AsyncAPI Conference website using promoted content. We do not want to close the window, though. It's all about keeping the balance \u2696\ufe0f Top tweets We did some research on the most impressive and engaging tweets. Tweet Impressions 15k 14k 9k There is only one tweet that shows up in the top 3 for each category. Tweet Engagements 428 259 253 (not all those memes were lame after all) It is pretty clear that what you liked the most this year is that we are hiring \ud83d\udcaa We are still hiring! What's next with Twitter We should get more insights into how Twitter activity converts into visits to our website. Twitter offers something called conversion tracking which seems like a perfect fit, and this is something we will enable for next year. Paid marketing on Twitter is useful, so we will continue using it for important events. GitHub We notice growing traffic in our GitHub organization like on other channels. Most popular repositories Our most popular repositories contain the AsyncAPI specification and the AsyncAPI Generator that the community can use to generate documentation and code. The asyncapi repository that had 245 stars in 2019 jumped to 1361. The peak you see on the diagram was caused by us putting the link to the asyncapi repository on Hacker News . \n![Figure 6: GitHub stars growth in asyncapi repository](/img/posts/2020-summary/star-history-asyncapi.webp)\n Figure 6: GitHub stars growth in asyncapi repository The generator repository grew from 62 to 198. The path got steeper this year. This popularity is covered with our recent development activities in the project. \n![Figure 7: GitHub stars growth in generator repository](/img/posts/2020-summary/star-history-generator.webp)\n Figure 7: GitHub stars growth in generator repository Traffic growth All numbers went up \ud83d\ude05 The growth of contributors was not organic but driven by our activities in the Hacktoberfest event. 2019 2020 Contributors 76 119 Commits 1.5k 3.5k Pull requests (opened/closed) 399/397 99% closed 1200/1175 97% closed Issues (opened/closed) 322/287 89% closed 587/401 68% closed We're closing fewer issues. This number got worse than last year because we freeze progress on the asyncapi repository, and the last few months did not continue any efforts towards specification 2.1 and 3.0 releases. The reason was pretty simple; we were involved in discussions with many players and planning the next step forward to scale up in 2021. It would not be fair with the AsyncAPI community to work on the next specification versions, with the current government process, knowing we prepare partnership with Postman . What's next with GitHub We are doing well on GitHub, and so far, I don't see any improvements other than the further automation that we have in plans to handle even more traffic next year. npm The majority of our tools are written in JavaScript/TypeScript, and we host them on Node Package Manager(npm) Top packages Our most important packages are the Generator and the Parser . Below you can see how downloads of these packages increased. 2019 2020 Generator 21 536 134 224 Parser (published May 2019) 18 591 173 286 The change in numbers is so huge that I checked them twice to make sure I'm not wrong. \n![Figure 8: Popularity of all packages on npm](/img/posts/2020-summary/npm.webp)\n Figure 8: Popularity of all packages on npm If you know the package from the above list had some different names over the year, you can check it with npm stat project. For example, late in the year, we moved the React component under @asyncapi , and under the old name, it had 56 520 downloads. Next year won't be so messy. What's next with npm This year we introduced @asyncapi scope on npm and switched all packages to it. You could see some differences in numbers in previous sections because for the generator and parser I manually counted the sum of downloads of a package under different names. There are still many downloads of the parser and generator using old names. It means we still have many people that do not migrate to new releases. Next year we could write a blog post that summarizes the differences between old tools and their latest versions. It could be linked to the deprecation notice. YouTube The AsyncAPI YouTube channel had a massive increase in the traffic. Watch time goes crazy We felt it might be significant because of the AsyncAPI conference, but we never expected a 6000% growth of the watch time! 2019 2020 Views 527 8 678 Watch time 29.9h 1 850.1h Subscribers 35 390 Most popular videos Undeniably the most popular this year was our first AsyncAPI online conference. Views Author AsyncAPI Online Conference 4 123 AsyncAPI Community AsyncAPI SIG meeting 37 (December 8, 2020) - SPECIAL EDITION! 542 AsyncAPI Community Event-Based API Patterns and Practices 354 James Higginbotham In case you missed our conference, watch the recording and stay tuned for the next conference in 2021. What's next with YouTube I think it is the right moment to work on the channels' landing page. We could use it to promote the most valuable content. Open Collective We earned and spent lots of money this year \ud83e\udd11 Huge applause \ud83d\udc4f to all our sponsors ! We enabled the GitHub sponsoring this year, but still, 99% of funds go through the Open Collective . Source Amount Balance AsyncAPI Online Conference $983 Swags for participants $359,10 WWC donation $1 074,08 LinkedIn marketing $924,14 Twitter marketing $66,54 Zoom account $0 AsyncAPI Initiative $52 371 Maintanance $3 750 JSON Schema $1 493,64 In 2021 we continue using Open Collective. Even though we started partnership with Postman to cover many maintenance costs, there are other costs. Even once we join some foundation next year, we still need to collect money to run the project. Ultimate questions - how many people use the spec? We don't know. It is the area where we have no specific metrics. We see the growth in tools' adoption, but not everybody uses open source tools. Many companies prefer to develop those in-house. From observations, we know that number of users that use specification grows: More and more companies seek integration with the specification. From unofficial discussions, we know their customers ask them about AsyncAPI support The metrics from this blog post clearly show adoption and interest growth It is a specification we are talking about here. There is no way to measure how many AsyncAPI files were created worldwide. At least there was no way to do it in 2020. We'll try one idea of ours in 2021. It looks like in the 2021 summary, we could provide some hard numbers on the subject \ud83e\udd1e Final words Most important conclusion: If the AsyncAPI conference brought so much activity, it is evident that in 2021 we must organize another great AsyncAPI event. Thanks for being with us in 2020, and stay with us for 2021 as it will be epic! I planned to include a list of all the AsyncAPI Heroes for 2020, but I was afraid I could miss someone very important and that the list would be very subjective. I hope it is clear, though, that this project is where it is, thanks to many guardian angels out there that help us out. Photo by Immo Wegmann on Unsplash",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/posts/2020-summary/cover.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/2020-summary/active-members.webp",
        "alt": "Figure 1: Slack active members weekly"
      },
      {
        "src": "/img/posts/2020-summary/linkedin-impressions.webp",
        "alt": "Figure 2: Impressions to updates in 2020"
      },
      {
        "src": "/img/posts/2020-summary/linkedin-folowers.webp",
        "alt": "Figure 3: Followers growth in 2020"
      },
      {
        "src": "/img/posts/2020-summary/top-channel-2019.webp",
        "alt": "Figure 4: Top channels in 2019"
      },
      {
        "src": "/img/posts/2020-summary/top-channel-2020.webp",
        "alt": "Figure 5: Top channels in 2020"
      },
      {
        "src": "/img/posts/2020-summary/star-history-asyncapi.webp",
        "alt": "Figure 6: GitHub stars growth in asyncapi repository"
      },
      {
        "src": "/img/posts/2020-summary/star-history-generator.webp",
        "alt": "Figure 7: GitHub stars growth in generator repository"
      },
      {
        "src": "/img/posts/2020-summary/npm.webp",
        "alt": "Figure 8: Popularity of all packages on npm"
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "46ee05a7",
    "title": "AsyncAPI Initiative 2021 in Numbers | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/blog/2021-summary.html",
    "content": "AsyncAPI Initiative 2021 in Numbers | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Slack Weekly active members LinkedIn Followers and impressions Sponsored marketing Google Analytics Traffic got much higher Top blog posts Google Search Console Twitter GitHub Most popular repositories npm Top packages YouTube Watch time Open Collective Final words \n![](/img/posts/2021-summary/cover.webp)\n This article is a continuation of a tradition where once a year, we summarize all the metrics that we can collect from our different tools to see how we are growing as a community. It is good to see how we are doing, how are we growing \ud83d\ude80 If you are interested in previous years, look at this 2020 summary article . Slack We noted 1846 members at the end of 2021: 2020 2021 New members 490 877 (79% increase) In 2021 we also went through reorganization of the channels setup, created etiquette, and most importantly, got a standard subscription from Slack. We definitely are not going away from Slack. Weekly active members Slack is our primary community channel, a kind of direct connection between community members. In my opinion, it indicates the community's growth that is more active in the initiative. For this year, I removed the stats about the number of posted messages. We have many messages posted by bots (about GitHub activity, for example) affecting the numbers. They are big but do not indicate only Slack activity. Data is shown weekly and not daily, so the numbers are not affected by usually silent weekends. 2020 2021 Active members weekly 81 average 77 median 174 average (114% increase) 173 median (125% increase) Active members posting messages weekly 20 average 19 median 40 average (100% increase) 41 median (116% increase) I think the median is accurate not only because it shows higher numbers. It basically eliminates super high weeks (like when we organized conferences) and weeks when we have lots of holidays simultaneously, like Christmas break. LinkedIn LinkedIn grows like other channels. We mostly attract folks with job functions related to engineering (51%). Other are also tech but related to business development or product management. I personally wish we actually reach more product managers (PM) than 2%. As a person that was a PM in the past, I remember how much specs and APIs were important for products and hope other PMs go that path too. Followers and impressions At the moment, we have 1534 followers. Unfortunately, LinkedIn memory is short and remembers only numbers one year back. I do not have access to January 2021 data. In the case of a percentage increase, I take only numbers related to organic growth. 2020 2021 Followers 611 57 from payed marketing 745 (34% increase) Impressions 80 095 248 571 146 252 from payed marketing (28% increase) We published 265 posts on LinkedIn, and with a growing number of followers, it converted into many users visiting our website . 2020 2021 Users 715 1 857 (160% increase) New Users 656 1 699 (159% increase) Sessions 1 042 2 511 (141% increase) Sponsored marketing We spent $1200 on paid marketing on LinkedIn to increase awareness about AsyncAPI Hackathon and Conference. We noticed a large increase in impressions on our sponsored posts. These sponsored posts did not link to our AsyncAPI website but to the conference registration site. To summarize, $1200 converted into 763 visits to the registration website and ... wait for it ... wait for it ... 15 registrations. I have to tell you that 2021 taught me that there is nothing better than organic marketing. Better pay $1200 to contributors for their work rather than give it out to LinkedIn. I recommend everyone to maintain a relationship with the community also on LinkedIn. This social media is changing. Many folks that are not active on Twitter are active on LinkedIn, and you should target them. In the end, reposting stuff you have for Twitter to LinkedIn is not very time-consuming. In Q4 of 2021, we also started streaming different meetings to LinkedIn. In three months, we noted 1180 views of our streaming content. So we basically enabled over 1k users to watch the content they would probably not watch if LinkedIn was their only social media channel. Think about it, omnichannel is the only way to build the community, Google Analytics We use Google Analytics on AsyncAPI website because we want to understand what content is most valuable for you, and we want to learn how the interest is growing. Traffic got much higher The interest is growing by a lot! Our website handles it well with the support of Netlify , which is free for open-source projects. 2019 2020 2021 Users visits 27 090 83 655 (208% increase) 131 802 (57% increase) Sessions 50 405 147 409 (192% increase) 235 321 (60% increase) Pageviews 143 059 362 686 (153% increase) 590 501 (63% increase) Top blog posts AsyncAPI blog is a place where the AsyncAPI Community can publish articles. Anyone can share knowledge, experience, and showcase their work there. Just let us know what you want to write about . What is the benefit of writing/republishing on the AsyncAPI blog? Visibility among the AsyncAPI community plus our activities to make your work go viral. Just look at the below table to see our top 3 viral posts. Post Unique pageviews Author AsyncAPI vs OpenAPI: Answers to Your Burning Questions About Two Leading API Specs (September 2021) 8 107 Jesse Menning Understanding AsyncAPIs with a Practical Example (March 2021) 6 161 Dunith Dhanushka Creating AsyncAPI for WebSocket API - Step by Step (April 2021) 5 049 Lukasz Gornicki Google Search Console In 2021 we integrated our Google Analytics with Google Search Console (GSC). I believe that numbers from GSC can show how many more people hear about AsyncAPI and gain interest in the topic. In other words, the assumption is that the more people google, the more people are aware of AsyncAPI. The last data we have access to is from the 20th of September 2020. So we cannot fully compare 2020 and 2021. We know we had 1 230 000 (OVER ONE MILLION) impressions and 104 000 clicks in 2021 in total, but in the table below we only compare data between the 20th of September and the 31st of December. 2020 2021 Total clicks 19 200 34 400 (79% increase) Total impressions 300 000 350 000 (17% increase) Impressions conversion into clicks 6.4% average 9.8% average Position in search results 31.3 average 29.7 average We can compare only three months, so numbers for 2022 will definitely be better than 2021. We did some super basic SEO improvements in mid 2021, which sure took effect on increased click rate. We also published a few articles with topics that people google for together with asyncapi , WebSocket, and OpenAPI. I think we have proof that all additional activities planned for 2022, such as rework of existing documentation, should improve numbers even more. If you have more ideas on improving, just open up an issue in the website repository , and let's discuss how we can get better. Twitter By the time I gathered data for this blog post, we had 2997 followers on Twitter. 1 564 increase since the last time we had published such metrics in mid-December 2020. It is 78% more followers in a year compared to 2020 . I'm not gonna hide, I'm not a Twitter fan, really. \ud83d\ude03 Who cares about my preferences, though, our community is present there, and we must too. In the end, Twitter led 2 478 new users to AsyncAPI website. What I can tell you for sure. Do not spend your money on Twitter marketing. We tried it for AsyncAPI Conference. Of course, I might configure something in a bad way, but does it change anything? We spent $560.21 on sponsored tweets that converted into 16 471 visits to the conference registration page. Guess what, 0 folks registered . Now yes, of course, might be that tweets were not targetted properly, might be that registration page was not attractive. But I challenge you with a question: is it worth spending many extra hours and money on this classical marketing instead of the community? GitHub We notice growing traffic in our GitHub organization like on other channels. Most popular repositories Our most popular repositories contain the AsyncAPI specification and the AsyncAPI Generator that the community can use to generate documentation and code. The AsyncAPI Specification repository that had 1 357 stars in 2020 jumped to 1 870. The AsyncAPI Generator repository grew from 198 to 417. So the number of fans doubled. The number of contributors also increased, but the problem is I no longer have access to tools that can help me get exact numbers, like the ones I got last year. The good news is that we should get access to Linux Foundation Insights tool around April. It will enable us to look deep into not only GitHub stats in one place. We will definitely get more accurate numbers for 2022. npm The majority of our tools are written in JavaScript/TypeScript, and we host them on Node Package Manager (npm). Top packages Our most important packages are the project that provides AsyncAPI JSON Schema files , the Generator and the Parser . Below you can see how downloads of these packages increased. 2019 2020 2021 Generator 21 536 136 994 396 766 Parser 18 591 187 475 1 460 275 Module with JSON Schema files for specification (new @asyncapi/specs & old asyncapi ) 79 527 215 016 1 483 839! The increase in numbers is insanely huge. People automatically say that it is because of build systems, local development, or some single corporation started using it at scale. In other words, the increase could result from just one project that uses these tools as a dependency. Let me challenge you: Corporations always use mirrored versions in npm. When you work on a project in a corporate network, you will always hit internal proxy. Not included in downloads. Most build systems cache packages that are downloaded already to improve performance. Not included in downloads. When you work with npm locally, you also have a local cache that is used if you want to install something that you already installed. Not included in downloads. An interesting observation is that Generator uses Parser and Parser uses the package with AsyncAPI specs. So you can read from this data that packages with specs are primarily used in the AsyncAPI Parser. You can also see that Parser is a backbone for many more projects than just the AsyncAPI Generator. Do you see it? Last year Generator and Parser download numbers were super close to each other, now the difference is much higher, 1 MILLION! YouTube The AsyncAPI YouTube channel had a massive increase in traffic. Watch time YouTube is the only channel where numbers were not higher than in previous years. The main reason is that in 2020, our conference took place in March, while in 2021, it was November. We only released like 1/5 of all presentations. Let's see if I'm right. Numbers in 2022 should get up. 2019 2020 2021 Views 527 8 830 10 444 Watch time 29.9h 1 900h 1 672.9h Subscribers 35 396 292 Open Collective We earned and spent lots of money this year. \ud83e\udd11 Huge applause \ud83d\udc4f to all our sponsors ! Source Expenses Balance AsyncAPI Hackathon & Conference $1,200.51 LinkedIn marketing $563.00 Twitter marketing $2,200.53 Daily.dev marketing (converted into 22 registrations out of 369 visits) $11,023.92 Hackathon prizes $1,972.31 Swags for Hackathon participants and Conference presenters $8,146.63 AsyncAPI Initiative $15,093.31 Marketing and Maintainance $3,000.00 Donation to JSON Schema $56 252.68 We also have a good amount of money thanks to the new Platinum sponsor that joined last year, IBM. Also, RedHat joined as a Gold sponsor. We also had other donations. Final words We grow. Numbers just confirm our observation. We grow not only because people love to build a community around the specification. We grow because AsyncAPI Initiative is attractive for contributors because we also host tools related to AsyncAPI. If you want to look at more data, some of it is available in this spreadsheet and for others you just need to contact me directly. In 2022, we need to establish a stronger bond with the community. We have many folks that give back a lot of time into the project, and it is time to give back. The main goals we have: Meet in person for AsyncAPI Conference Setup Ambassador program to give back to most active community members Get involved in more events like Google Summer of Code Join us so we can work on these together! Photo by Alternate Skate on Unsplash",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/posts/2021-summary/cover.webp",
        "alt": ""
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "945f9494",
    "title": "State of AsyncAPI Initiative 2022 in Numbers | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/blog/2022-summary.html",
    "content": "State of AsyncAPI Initiative 2022 in Numbers | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Slack Workspace size Weekly active members Channels popularity New members' activity Social media LinkedIn Twitter Google Analytics Confusing data The more docs we get, the more traffic increase we will see Google Search Console GitHub Total contributions Negative aspect of growth npm Top packages YouTube Watch time Final words \n![](/img/posts/2022-summary/cover.webp)\n It is a good practice to sometimes stop and turn back. Sometimes you need to see what you left behind, what successes made you go that far, and what things you missed and never had time to enjoy or explore. The more often you do it, the better your decisions may be in the future. It is essential to do it at least once a year in open source. Omg, I don't recall when I last wrote something so clever. At least, I think it sounds clever. \ud83d\ude03 This article will take you on a journey to the past to see what happened in 2022 at AsyncAPI Initiative. If you are interested in previous project updates check other Project Status posts . Slack At the end of 2022, we had 3114 members in the AsyncAPI workspace. But what does that really mean? Don't get me wrong; I like when the numbers are high, especially if I see them in my bank account. The thing is that some accounts might belong to people that joined three years ago but don't even remember that they had an account in the AsyncAPI workspace. It would be good to check how this number relates to people's activity. Another important item to understand is how come we have 3114 members. Did all of them join in 2016? Have we had no new people join since then? That would be a disaster and a clear indication we are doing something wrong. \ud83d\ude05 Workspace size Below you can see how many members have joined AsyncAPI Slack in past years. The numbers are pretty neat! People join AsyncAPI Slack because they know: someone will answer their call for help it is a welcoming place for first-time contributors we participate in many mentorship programs this is the best place to get closer together with the community \n![](/img/posts/2022-summary/slack-people-joining.webp)\n My prediction is that it will be growing and growing cause existing members will tell others what place it is and why it is worth joining. Weekly active members Below I'm showing the average and median activity throughout the years. I think the median is more accurate as it eliminates super-high weeks (like typical conference-related noise) and weeks when we have lots of holidays simultaneously, like Christmas break. \n![](/img/posts/2022-summary/slack-weekly.webp)\n Last year was the first time the median value was much lower than the average. It is higher than the previous year, but not something we got used to so far. We noticed a significant increase in Slack members, but I think we can say that this number doesn't correlate well with median activity. We should look into the data more deeply and understand what happened between April 23 and June 21 when numbers got much higher than usual. For example, what the heck happened on April 29 when we had 583 active members? Was AsyncAPI Mentorship the reason? Anyway, I definitely predict that data for 2023 will show an increase in activity as we plan to do a series of meetups around the world that will bring more and more people into Slack. Channels popularity Below you can see all-time data that show the number of messages posted on each channel in Slack. The General channel is the oldest, and yeah, it is generally for general stuff... what a joker. Anyway, the most important is the discussion size in the Tooling channel. Specifications are boring, and people are interested more in how it works. On the other hand, tooling is most attractive to tech folks; coding and talking about it is more fun. \n![](/img/posts/2022-summary/slack-channel-usage.webp)\n Remember that AsyncAPI Initiative cares about both the specification and the tooling ecosystem. New members' activity As I wrote in the intro, each community must be welcoming to new people and give them space inside so they feel comfortable interacting with others and feeling safe. Below you can see the top three members that joined the community in 2022 and were most active among other new-joiners. Their activity was clearly reflected in their contributions. In the end, all the people you can see below are now members of the AsyncAPI Technical Steering Committee . \n![](/img/posts/2022-summary/slack-most-active-new-2022.webp)\n Social media Social media is not a silver bullet. I think social media should only be a news interface with the community, not a marketing tool. Below data will show you that these channels should not be treated as promotion channels that convert to new users. You will see that LinkedIn and Twitter brought together 2,082 users to the AsyncAPI website. Now, compare it to this single Mozilla documentation article that referred to our website 5,542 users. Social media is suitable for communication with the community. Promotion should target people in a location where they look for help. In other words, mentioning AsyncAPI on a WebSocket-related website performs much better than hundreds of social media posts. So we should also try to make sure AsyncAPI is mentioned in other locations. Why not mention AsyncAPI in official docs for Kafka, MQTT, and other protocols? LinkedIn I'm so damn tired of LinkedIn. Seriously, a platform that drains so much data from others and earns money from job marketing cannot afford to give users access to historical data and see more than one-year-old stats. Like seriously... We had 2,139 followers at the end of 2022. Every year's data since account creation looks like below. \n![](/img/posts/2022-summary/linkedin-followers.webp)\n We are not active on LinkedIn. We only republish whatever we publish on Twitter. No engagement is created. We treat it as a news feed, although LinkedIn != Twitter. Numbers went down a lot compared to last year, but when you look two years back, numbers are very similar. Why? In 2021, we spent $1,200 on LinkedIn marketing; thus, the number spike for one year. \n![](/img/posts/2022-summary/linkedin-referrals.webp)\n My statement doesn't change. LinkedIn is an important presence, and even without dedicated moderation, simple reposting brings people to the project. We should continue our work there. Twitter Twitter? Seriously, the most unreliable tool ever. \ud83d\ude03 But of course, I'm biased; I do not like it. So let's look at the data. Are people really leaving Twitter because of Elon Musk? Forget about the number of followers. We have over 3.5k followers, over 500 more than last year. For me, followers number are as reliable as GitHub stars on a repository. Not much... Let's see how Twitter's presence converts to visits to the AsyncAPI website. \n![](/img/posts/2022-summary/twitter-referrals.webp)\n Exactly the same situation as with LinkedIn. Numbers drop between 2021 and 2022, but again because 2021 was a special year. We experimented that year with paid marketing on Twitter too. So the numbers we should compare are for the years 2020 and 2022. As we can see no change, and it is pretty stable. It looks like Twitter was not really abandoned, at least not for now \ud83d\ude03 . My take on it. This is acceptable. I do not think we have to do more there. My observation is that tweets that perform there are not technical tweets that could bring more people to the project, but \"thank you\" tweets and \"appreciation\" tweets. And do not get me wrong, we should still create such tweets, no question about it. It proves it is a social media, not a \"technical geeks knowledge exchange center.\" I do not think any additional investment in the platform makes sense. Google Analytics We use Google Analytics on AsyncAPI website to understand the most valuable content for you and learn how the interest is growing. The data we get doesn't 100% reflect reality because AsyncAPI is for technical people, and many technical people use plugins in browsers to block Google Analytics or browsers that block it natively. We also have numbers that confirm that. I checked the last seven days of data from Google Analytics and compared it with the raw traffic data we get from Netlify servers. The dates I checked were February 13-20: Google Analytics noted over 24k page views. Netlify noted over 26k page views. This means we are losing around 7% of the data if I calculated it right. \ud83d\ude03 Unfortunately, with Netlify we do not have access to data older than seven days. We can dump this data for future analytics, but we need New Relic or some other service to sponsor the storage for us \ud83d\ude03 Confusing data The \"quality\" of the user visiting the website is much better. In 2022, we had no paid marketing nor any viral blog posts, and finally, data is more reliable and natural. \n![](/img/posts/2022-summary/ga-views.webp)\n There is a much larger increase in the amount of Pageviews and Sessions but no significant increase in User visits . My theory: In 2022, we didn't have a single super viral blog post like in previous years that would bring a few thousand people in just a few days (like September 9, 2021 - over 5k readers), people that are interested in an article, and not AsyncAPI in general. I think we can say that it is the first time we have had a regular increase in users and that this increase is valuable as these users generate a lot of sessions and navigate through the website a lot. In other words, the bigger difference between User visits and Pageviews , the better. It would make sense to retake the above table and check it against Google Analytics, but not base it on the total number of visits and sessions, but the median for each year. In theory, this way, we would remove the traffic that is hard to predict from the equation, as it is not up to us to decide if something will be viral. The more docs we get, the more traffic increase we will see One of the top goals for the AsyncAPI website should be to increase the content and benefit from the SEO. This happened in 2022, thanks to participation in Google Season of Docs. We had six dedicated docs contributors. We gained new Concepts and Generator documentation in the website. In the case of Generator documentation, Florence and Pratik refactored all the documentation from the Generator repository and made sure it was published in an automated way on the website. It was published on the website on the 20th of December, almost the end of the year during Christmas break, a dead season for the website. Yet the new content managed to generate an additional 1,053 Pageviews to the website! Concepts were published to the website on different dates, some in September and some in early December. This new content generated more than 17,646 Pageviews in over three months. \n![](/img/posts/2022-summary/google-concepts.webp)\n As you can see, more technical content, which was not even released at the beginning of the year, converted into many additional pageviews. In 2023, this content will perform even better. I know it for sure, as only in the case of Generator docs, in January 2023, Google Analytics noted 4,668 views! Well, you must admit that 48k Pageviews for 2023 would be huge! Google Search Console I believe that numbers from GSC can show how many more people hear about AsyncAPI and gain interest in the topic. In other words, the assumption is that the more people google, the more people are aware of AsyncAPI. And yes, the below numbers of impressions indicate a number higher than a million. \ud83d\ude09 \n![](/img/posts/2022-summary/google-search.webp)\n In 2022 we didn't perform any specific modifications on the website to improve SEO. So the only explanation for the increase in impressions and clicks is the increased volume of documentation I wrote about in the previous section. More useful content, better ranking in search. GitHub Like on other channels, we notice growing traffic in our GitHub organization . Total contributions In the last three years, we increased from 301 contributors in Q1 2020 to 1,520 in Q4 2022. From 301 to 1,520 contributors for things like commits, pull requests authoring and review, or issues participation. In just three years!!! \n![](/img/posts/2022-summary/github-contrib.webp)\n This huge difference also has a negative aspect. More contributions mean more maintenance work. Negative aspect of growth Unfortunately, the number of maintainers does not grow as much as the number of contributors. This means that the difference between the number of submitted and resolved issues will get larger and larger. \n![](/img/posts/2022-summary/github-issues.webp)\n Three years ago, we dreamed about having thousands of contributions. We forgot to balance that number with the proper number of maintainers. Now we need to react and make sure we also get a large number of active maintainers. npm Most of our tools are written in JavaScript/TypeScript; we host them on Node Package Manager (npm). Top packages Our most essential packages are the project that provides AsyncAPI JSON Schema files , the Generator , the React component and the Parser . Below you can see how downloads of these packages increased. \n![](/img/posts/2022-summary/npm-stats.webp)\n You do not believe in this data? Lemme repeat what I wrote last year: The increase in numbers is insanely huge. People automatically say that it is because of build systems, local development, or that some single corporation started using it at scale. In other words, the increase could result from just one project that uses these tools as a dependency. Let me challenge you: Corporations always use mirrored versions in npm. When you work on a project in a corporate network, you will always hit the internal proxy. Not included in downloads. Most build systems cache packages downloaded are ready to improve performance. Not included in downloads. When you work with npm locally, you also have a local cache that is used if you want to install something that you already installed. Not included in downloads. An interesting observation is that in 2021 AsyncAPI Parser was the only user of the AsyncAPI spec JSON schemas project ( @asyncapi/specs ), as the number of downloads was almost the same. In 2022, the AsyncAPI spec JSON schemas project was downloaded five million times, three times more than the parser. This means many more tools are dependent on the project. In 2021 we could see that the AsyncAPI Parser is not only a Generator dependency; today we see the AsyncAPI spec JSON schemas project is not only a Parser dependency. This means that the increase in traffic in different channels and the growing user base also reflect the number of tools built on top of AsyncAPI tools. One of the big users of @asyncapi/specs is now Spectral. Also, GitHub tells us that @asyncapi/specs is used in 1,329 public repositories YouTube The AsyncAPI YouTube channel had a massive increase in traffic. Watch time YouTube is just another channel where we can see the audience is growing. The conference and other regular live streams bring a lot of watchers. In 2023, numbers might drop because we do not want to do the online conference, but yeah, let's see. \n![](/img/posts/2022-summary/yt.webp)\n Final words We grow. Numbers just confirm our observation. If you plan to invest in AsyncAPI Initiative, don't worry. It is still an on-top project. It was the right call if you already invested in AsyncAPI Initiative. The community is growing. We do not see any negative trends indicating that the interest in the project got stale and that the community is not growing anymore. I also recommend below conference recording to learn more about AsyncAPI Community. Photo by Hannah Busing on Unsplash",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/posts/2022-summary/cover.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/2022-summary/slack-people-joining.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/2022-summary/slack-weekly.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/2022-summary/slack-channel-usage.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/2022-summary/slack-most-active-new-2022.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/2022-summary/linkedin-followers.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/2022-summary/linkedin-referrals.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/2022-summary/twitter-referrals.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/2022-summary/ga-views.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/2022-summary/google-concepts.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/2022-summary/google-search.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/2022-summary/github-contrib.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/2022-summary/github-issues.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/2022-summary/npm-stats.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/2022-summary/yt.webp",
        "alt": ""
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "9090b911",
    "title": "November and December Community Update And AsyncAPI Conf in Paris 2024 | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/blog/2024-december-and-paris.html",
    "content": "November and December Community Update And AsyncAPI Conf in Paris 2024 | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page AsyncAPI Community Building and Maintenance Goals Proposal 2025 AsyncAPI Conf in Paris 2024 Technical Steering Committee Final Remarks \n![](/img/posts/2024-blog-banner/blog-banner-december.webp)\n I can't believe we are in the final weeks of the year, and it has been an eventful one. As a community, we have experienced both proud and painful moments, celebrated our victories, and faced challenges and losses. However, in the end, we overcame those difficulties and emerged stronger and better. Although this summary is a bit later than usual, I am excited to share the details of what happened in November and December and the highlights from the last conference of the year, which took place in Paris. AsyncAPI Community Building and Maintenance Goals Proposal 2025 The 2025 community building and maintenance goals proposal is currently open for discussion and will soon be put to a vote for TSC members. We would love your thoughts and suggestions, particularly when solving our community's challenges. Please take a moment to review the open PR related to the AsyncAPI Community Building Goals for 2025 to participate in the discussion and share your ideas and solutions. AsyncAPI Conf in Paris 2024 The AsyncAPI Conf was back again in Paris this December, thanks to Mehdi Medjaoui and the amazing team at APIdays for hosting and sponsoring the venue. We participated in the three-day event, celebrating a year of the API Standards booth alongside friends from OpenAPI, JSON Schema, and GraphQL. Special thanks to all the members of the AsyncAPI community who could join the conference and help at the booth: Hugo Guerrero , Fran M\u00e9ndez , Richard Coppen , Hari Krishnan , and Lukasz Gornicki . The AsyncAPI Conf track took place on the 3rd day of the conference, featuring an impressive lineup of sessions that attracted a diverse audience. The event was consistently packed, with attendees engaged throughout the day. \n![Attendees engaged through the sessions.](/img/posts/paris-conf-2024/full-room.webp)\n Attendees engaged through the sessions. Fran M\u00e9ndez and Lukasz Gornicki started the track with a welcome speech and mentioned that AsyncAPI recently celebrated its 8th anniversary in November. \n![Fran and Lukasz during the welcome speech.](/img/posts/paris-conf-2024/lukasz-and-fran.webp)\n Fran and Lukasz during the welcome speech. Naresh Jain and Pierre Gauthier presented their keynote on TMForum's AsyncAPI for a New Era of Event-Driven Architecture . During the session, Pierre announced TMForum adopts AsyncAPI as a standard, with over 120 telco APIs already in production. TMForum has around 800 telco companies, and they will implement all APIs in an async manner, extensively utilizing the request-reply pattern. \n![Naresh and Pierre presenting their keynote.](/img/posts/paris-conf-2024/naresh-and-pierre.webp)\n Naresh and Pierre presenting their keynote. Frank Kilcommins demonstrated how treating API governance as an enabler unlocks the ability to deliver compelling developer experiences for producers and consumers in event-driven architecture (EDA). \n![Frank presenting on API Governance for EDA: Unlocking Developer Experience with AsyncAPI.](/img/posts/paris-conf-2024/frank.webp)\n Frank presenting on API Governance for EDA: Unlocking Developer Experience with AsyncAPI. Leonid Lukyanov shared how EDAs introduce new data models, protocols, and APIs not found in the traditional REST/CRUD application stack. And how one can abstract these elements to make them feel familiar to application developers, allowing them to create streaming applications seamlessly. \n![Leonid presenting on Reimagining Streaming Apps with AsyncAPI and Postgres.](/img/posts/paris-conf-2024/leonid.webp)\n Leonid presenting on Reimagining Streaming Apps with AsyncAPI and Postgres. Hugo Guerrero then shared how the AsyncAPI Initiative is not only in charge of the specification but has created open-source projects to make it easier for developers to work with the specification documents. \n![Hugo presenting on Using the AsyncAPI Ecosystem for Your Event-Driven Architecture.](/img/posts/paris-conf-2024/hugo.webp)\n Hugo presenting on Using the AsyncAPI Ecosystem for Your Event-Driven Architecture. Julien Testut and Alessandro Cagnetti shared how organizations can harness the full potential of event-driven integration by leveraging GoldenGate Data Streams, AsyncAPI, and Solace PubSub+ Event Mesh. They shared a great use case for AI and how it can be trained real-time and standardized with AsyncAPI. \n![Julien and Alessandro presenting on Streaming Data Events Into An AI Cognitive Event Mesh Using AsyncAPI.](/img/posts/paris-conf-2024/julien-and-alessandro.webp)\n Julien and Alessandro presenting on Streaming Data Events Into An AI Cognitive Event Mesh Using AsyncAPI. Annegret Junker explained how to design effective asynchronous APIs by using an API-first approach. The importance of defining Kafka topics and structuring your definitions. \n![Annegret presenting on AsyncAPI for Kafka.](/img/posts/paris-conf-2024/annegret.webp)\n Annegret presenting on AsyncAPI for Kafka. Jonathan Michaux spoke on how leveraging AI agents with AsyncAPI can create conversational interfaces that dynamically interact with event streams and asynchronous messaging systems. \n![Jonathan presenting on AI Agents Meet AsyncAPI: Conversational Interfaces for Event Streams.](/img/posts/paris-conf-2024/jonathan.webp)\n Jonathan presenting on AI Agents Meet AsyncAPI: Conversational Interfaces for Event Streams. Hari Krishnan and Joel Rosario touched on leveraging the AsyncAPI specification as an executable contract and how to isolate and test each component within an EDA. \n![Hari and Joel presenting on Contract-Driven Development for Event-Driven Architectures.](/img/posts/paris-conf-2024/hari-and-joel.webp)\n Hari and Joel presenting on Contract-Driven Development for Event-Driven Architectures. Laurent Broudoux and Hugo Guerrero ended the day by explaining how to use Microcks to provide a solution for mocking and contract-testing your async APIs without extensive coding and empowering you to build extensive and reliable integration tests. \n![Laurent and Hugo presenting From Nightmares to Sweet Dreams: Conquering AsyncAPI Testing!.](/img/posts/paris-conf-2024/laurent-and-hugo.webp)\n Laurent and Hugo presenting From Nightmares to Sweet Dreams: Conquering AsyncAPI Testing!. Technical Steering Committee Part of doing mentorships is witnessing the growth within the community, and we are excited to welcome Ashmit Jagtap as our newest addition to the maintainers list and TSC member. We are proud of the work you have done so far. Ashmit Jagtap Final Remarks It's been a privilege to write the AsyncAPI monthly summary blog consistently. As this is the final blog for the year, I am genuinely grateful for the opportunity to serve and continue supporting the community. As we approach the holidays, I wish everyone happy holidays and a fantastic 2025. I'll be back next year with an overall review summary of 2024. Until then, stay safe, and happy holidays!",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/posts/2024-blog-banner/blog-banner-december.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/paris-conf-2024/full-room.webp",
        "alt": "Attendees engaged through the sessions."
      },
      {
        "src": "/img/posts/paris-conf-2024/lukasz-and-fran.webp",
        "alt": "Fran and Lukasz during the welcome speech."
      },
      {
        "src": "/img/posts/paris-conf-2024/naresh-and-pierre.webp",
        "alt": "Naresh and Pierre presenting their keynote."
      },
      {
        "src": "/img/posts/paris-conf-2024/frank.webp",
        "alt": "Frank presenting on API Governance for EDA: Unlocking Developer Experience with AsyncAPI."
      },
      {
        "src": "/img/posts/paris-conf-2024/leonid.webp",
        "alt": "Leonid presenting on Reimagining Streaming Apps with AsyncAPI and Postgres."
      },
      {
        "src": "/img/posts/paris-conf-2024/hugo.webp",
        "alt": "Hugo presenting on Using the AsyncAPI Ecosystem for Your Event-Driven Architecture."
      },
      {
        "src": "/img/posts/paris-conf-2024/julien-and-alessandro.webp",
        "alt": "Julien and Alessandro presenting on Streaming Data Events Into An AI Cognitive Event Mesh Using AsyncAPI."
      },
      {
        "src": "/img/posts/paris-conf-2024/annegret.webp",
        "alt": "Annegret presenting on AsyncAPI for Kafka."
      },
      {
        "src": "/img/posts/paris-conf-2024/jonathan.webp",
        "alt": "Jonathan presenting on AI Agents Meet AsyncAPI: Conversational Interfaces for Event Streams."
      },
      {
        "src": "/img/posts/paris-conf-2024/hari-and-joel.webp",
        "alt": "Hari and Joel presenting on Contract-Driven Development for Event-Driven Architectures."
      },
      {
        "src": "/img/posts/paris-conf-2024/laurent-and-hugo.webp",
        "alt": "Laurent and Hugo presenting From Nightmares to Sweet Dreams: Conquering AsyncAPI Testing!."
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "36dc4a74",
    "title": "October Community Update And AsyncAPI Online Conference 2024 | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/blog/2024-october-summary.html",
    "content": "October Community Update And AsyncAPI Online Conference 2024 | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page AsyncAPI Community Building and Maintenance Goals Proposal 2025 AsyncAPI Conferences AsyncAPI Conf in Paris 2024 AsyncAPI Conf 2025 Venues AsyncAPI Conference Rebranding AsyncAPI at FOSDEM 2025 Should AsyncAPI Initiative Endorse The United Nations Global Digital Compact? Spec x Tooling AsyncAPI Mascot Brand Refresh AsyncAPI Conference Hall of Fame Coming in November \n![](/img/posts/2024-blog-banner/blog-banner-october.webp)\n October marked the third AsyncAPI Conference, this time an online edition. As someone fortunate enough to be extensively involved in organizing the conferences, I saw the challenges that came with in-person events. It gave me the idea to propose bringing back the online edition as part of the AsyncAPI Conference brand. We're glad and excited that we received positive results, with over 360 views from attendees who watched and engaged with us. I want to express my gratitude to our financial sponsors, Gravitee.io and Postman , as well as to the speakers for their engaging talks and the conference volunteers ( be sure to check out the Hall of Fame section ). I encourage you to watch the recorded sessions if you missed the event . A playlist of the individual talks and slides will also be available on the conference website . AsyncAPI Community Building and Maintenance Goals Proposal 2025 As we approach the end of 2024, we have a proposal outlining the community building and maintenance goals we should prioritize in 2025. Please note that the AsyncAPI community manager will manage and oversee these goals. The goals are poised to address some of the challenges our community is facing, such as the limited number of maintainers and the lack of onboarding materials, and pave the way for a more vibrant and thriving community. I encourage everyone to participate in the open discussion and share your thoughts and solutions. Please take a moment to review the open PR related to the AsyncAPI Community Building Goals for 2025 . AsyncAPI Conferences AsyncAPI Conf in Paris 2024 We are excited to announce that the final AsyncAPI Conference will be held on December 5th in Paris, thanks to the amazing team at APIdays. The draft agenda is now available on our conference website , and the lineup of speakers looks fantastic. Additionally, we have a limited number of free community tickets available. To register, please visit the AsyncAPI Conference website . Note : When getting your tickets, please choose quantity one (1) of the Regular ticket and click the blue continue button to get your free ticket. AsyncAPI Conf 2025 Venues The discussion for potential venues for the AsyncAPI Conference 2025 is underway, and we invite everyone to participate. Please share your thoughts and suggestions for locations for the upcoming year in the AsyncAPI Conference 2025 open discussion . Your input is valuable to us! AsyncAPI Conference Rebranding In 2023, we successfully launched the AsyncAPI Conf on Tour (AACoT). We followed our vision to host events in various locations, allowing us to connect with the community in multiple cities. As we expand our reach and grow as a brand, we believe it is necessary to drop \"on Tour\" and simply refer to our events as the AsyncAPI Conf/Conference moving forward. Although we are simplifying the name, we remain committed to hosting conferences worldwide and enhancing our conference brand's visibility. We welcome your thoughts on this rebranding in the AsyncAPI Conf rebranding discussion . AsyncAPI at FOSDEM 2025 Are you attending FOSDEM and interested in speaking? AsyncAPI will participate in the FOSDEM conference as part of the APIs: GraphQL, OpenAPI, AsyncAPI, and Friends track. The Call for Participation is now open , and we encourage everyone in the community to apply. Deadline for talk submissions is December 15, 2024. This is another great opportunity to meet fellow community members! Should AsyncAPI Initiative Endorse The United Nations Global Digital Compact? The United Nations General Assembly has approved the Global Digital Compact, a commitment to ensure digital technologies support sustainable development and human rights. AsyncAPI is one of the key standards for event-driven architectures, and our Executive Director, Lukasz Gornicki , has called for a vote to determine whether we, as the AsyncAPI Initiative, should endorse the Compact which aligns with our values of open-source software and collaboration. We encourage all community members to participate in the vote and share their thoughts on this important decision . Spec x Tooling We're thrilled to announce that Glee has been migrated to a monorepo structure and is moving its core functionality to a new package called Gleequore, inspired by the Italian word \"cuore,\" which means \"heart.\" This change will allow developers to leverage Glee's features without using the full framework, facilitating integration with platforms like Remix and Next.js. We're also working on creating a \"Glee for the browser\" by extracting protocol adapters to support HTTP and WebSocket clients, overcoming current limitations. Kudos to Fran Mendez and all the Glee maintainers for their amazing work! The packages are now available on the Glee repo ; be sure to try it out. AsyncAPI Mascot Brand Refresh As part of the AsyncAPI Bounty Program, we have a task to rebrand the Eve and Chan mascots. The designs look amazing so far! \n![Eve and Chan - AsyncAPI Mascots](/img/posts/2024-blog-banner/mascots.webp)\n Eve and Chan - AsyncAPI Mascots Please join the discussion and share your thoughts on the progress made on the brand refresh mascot issue . AsyncAPI Conference Hall of Fame I want to extend a heartfelt thank you to the incredible volunteers who generously dedicated their skills and time to ensure the success of the Online Conference. From developers and designers to those working both on-stage and off-stage, their efforts made the planning and execution of the event seamless. Victoria Nduka Miracle Aishat Muibudeen Ashmit Jagtap Tenzin Delek Azeez Elegbede Oluwabamikemi Sarvesh Patil Roland Awoda Hridyesh bisht Komolafe Joshua Anushka Saxena Manul Patel Fuad ALIPHATIC Adegoke Olumide Coming in November AsyncAPI Community Updates Newsletter - The November Edition issue will arrive in your inbox on the 8th. Ensure you subscribe to the AsyncAPI Newsletter ; you don't want to miss out.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/posts/2024-blog-banner/blog-banner-october.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/2024-blog-banner/mascots.webp",
        "alt": "Eve and Chan - AsyncAPI Mascots"
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "df94eac5",
    "title": "September Community Update And AsyncAPI Conference London 2024 | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/blog/2024-september-summary-and-london.html",
    "content": "September Community Update And AsyncAPI Conference London 2024 | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page AsyncAPI Conference London Edition 2024 API Specs And Standards Booth AsyncAPI Conf in Paris AsyncAPI Bounty Program AsyncAPI Mantainership Program AsyncAPI Ambassador Coming in October \n![](/img/posts/2024-blog-banner/blog-banner-september.webp)\n In September, we had our second in-person AsyncAPI conference after Helsinki; read all about it in the AsyncAPI Helsinki Conference update . This time, I had the privilege of being present in person. First and foremost, I would like to thank Gravitee.io and to Georgie Burrows for sponsoring the AsyncAPI Conference. Their sponsorship enabled me to cover the visa expenses and travel costs. I also want to express my gratitude to Lukasz Gornicki for his support and assistance throughout the process. It wasn't easy, but in the end, it was an incredible achievement for all of us, especially for me. AsyncAPI Conference London Edition 2024 This year's London Edition was made possible by the amazing folks at APIdays , and we were part of the 2-day APIdays London Conference. The AsyncAPI track took place on the first day, and we had an incredible lineup of speakers and talks that attracted an entire room of attendees. \n![Full room of attendees.](/img/posts/london-conf-2024/full-room.webp)\n Full room of attendees. Lorna started things off with a session on Better AsyncAPI Governance and how to devise sensible standards that support usability, security, and reliability. \n![Lorna presenting Better AsyncAPI Governance.](/img/posts/london-conf-2024/lorna.webp)\n Lorna presenting Better AsyncAPI Governance. Artur followed with a demonstration on harmonizing NATS, CloudEvents, and AsyncAPI to build scalable, robust, and maintainable systems. \n![Artur presenting Harmonizing Asynchronous Systems: NATS, CloudEvents and AsyncAPI.](/img/posts/london-conf-2024/artur.webp)\n Artur presenting Harmonizing Asynchronous Systems: NATS, CloudEvents and AsyncAPI. Eduardo then shared a success story on how using AsyncAPI helps build API management platforms that enable event-driven architectures across domains by decoupling producers and consumers without compromising data contracts between parties. \n![Eduardo presenting Event-Driven Architectures Through API Management and AsyncAPI.](/img/posts/london-conf-2024/eduardo.webp)\n Eduardo presenting Event-Driven Architectures Through API Management and AsyncAPI. Later, Swen spoke on lessons we can learn from synchronous API design and architecture. \n![Swen presenting Lessons from Sync API Design: What Makes A Good AsyncAPI?.](/img/posts/london-conf-2024/swen.webp)\n Swen presenting Lessons from Sync API Design: What Makes A Good AsyncAPI?. During the break, the API Specs and Standards Booth was busy with people interested in what the AsyncAPI Initiative is all about and the work we do. \n![Specs booth during the break.](/img/posts/london-conf-2024/booth-1.webp)\n Specs booth during the break. Dale gave a session on how much information you need to know to design a solution around Kafka topics and illustrated the critical additional information a provider of an asynchronous API needs to provide. \n![Dale presenting Topic Characteristics: What Do You Need To Know In Advance.](/img/posts/london-conf-2024/dale.webp)\n Dale presenting Topic Characteristics: What Do You Need To Know In Advance. Laurent shared how to use Microcks ready to work with Testcontainers to provide solutions for mocking and testing APIs without extensive coding. \n![Laurent presenting Using Test Containers for AsyncAPI Unit Testing and Mocking.](/img/posts/london-conf-2024/laurent.webp)\n Laurent presenting Using Test Containers for AsyncAPI Unit Testing and Mocking. Will then demonstrated how Architecture as Code and AsyncAPI work together to create deployable environments for production and the deployment of WebSocket-based APIs in a financial organization. \n![Will presenting Deploying WebSockets with AsyncAPI and Architecture as Code.](/img/posts/london-conf-2024/will.webp)\n Will presenting Deploying WebSockets with AsyncAPI and Architecture as Code. Sho ended the day by taking us on a journey on how to build a cross-exchange trading bot and how AsyncAPI has the proper tooling to tackle pain points such as document inconsistency and missing language support. \n![Sho presenting Building Cross-Exchange Trading Library With AsyncAPI.](/img/posts/london-conf-2024/sho.webp)\n Sho presenting Building Cross-Exchange Trading Library With AsyncAPI. All the talks were incredible, and even the questions asked during the sessions were very insightful. Some of the slide presentations and recordings will soon be available under the Resources Hub at the AsyncAPI Conference website . API Specs And Standards Booth We teamed up with the OpenAPI Initiative team at the booth and had many insightful conversations. The first day was bustling with activity, and it was interesting to see how many people were not familiar with AsyncAPI and the community. They were very intrigued by how a bunch of folks with diverse expertise and skills from different continents and companies came together to represent AsyncAPI despite having never met. Our maintainers and ambassadors did a fantastic job educating and answering questions about the community, specification, and tooling. \n![AsyncAPI Maintainers and Ambassadors Answering Some Questions.](/img/posts/london-conf-2024/booth-day-1.webp)\n AsyncAPI Maintainers and Ambassadors Answering Some Questions. Day 2 at the conference was calmer and less busy than the first day, but we had the opportunity to visit other booths and get some contacts for the future. \n![Day 2 at the booth with AsyncAPI experts. From left: Artur, Ian, Thulie, Khuda](/img/posts/london-conf-2024/booth-cover.webp)\n Day 2 at the booth with AsyncAPI experts. From left: Artur, Ian, Thulie, Khuda I would like to thank the experts for taking their time at the conference and volunteering at the API Specs and Standards Booth . Khuda Dad Nomani Artur Ciocanu Daniel Kocot Frank Kilcommins Dale Lane Laurent Broudoux Ian Cooper Richard Coppen Richa Sharma AsyncAPI Conf in Paris As you can tell, London was a success, and now there's an opportunity to be part of another fantastic AsyncAPI conference in Paris. The Call for Proposals for Paris will soon close on the 12th of October, and we encourage anyone to apply. AsyncAPI Bounty Program This month, we celebrate a significant milestone: the first anniversary of the official launch of the AsyncAPI Bounty Program. Our goal has been and continues to recognize and reward the efforts of our maintainers and contributors and to challenge the notion that contributing to Open Source is always free. You can learn about the history of the AsyncAPI Program from the redistribution of Open Collective funds discussion . As a community, we have greatly benefited from the program. For example, we have used the AsyncAPI Cheat Sheet at conferences, saved costs on Digital Ocean, and implemented an automated TSC voting process. For more details, please read the AsyncAPI Bounty Program Summary . Kudos to Viacheslav Turovskyi (Ash) for his outstanding work in leading and managing the initiative smoothly. AsyncAPI Mantainership Program The Maintainership Program is progressing well; we have received some excellent project ideas. Once the project ranking is complete, we will announce the call for applications soon. Keep an eye on the #09_mentorships Slack channel for the exact dates. For details on the submitted projects, please take a look at the Mentor/Maintainership discussion . AsyncAPI Ambassador We are excited to welcome Lorna Mitchell , VP of Developer Experience at Redocly, to the AsyncAPI Ambassador Program . Lorna Mitchell Coming in October AsyncAPI Community Updates Newsletter - The October Edition issue will arrive in your inbox on the 9th. Ensure you subscribe to the AsyncAPI Newsletter ; you don't want to miss out. AsyncAPI Online Conference - The Online Conference will take place on the 30th of October . Be sure to check the website for the Agenda and Speakers.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/posts/2024-blog-banner/blog-banner-september.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/london-conf-2024/full-room.webp",
        "alt": "Full room of attendees."
      },
      {
        "src": "/img/posts/london-conf-2024/lorna.webp",
        "alt": "Lorna presenting Better AsyncAPI Governance."
      },
      {
        "src": "/img/posts/london-conf-2024/artur.webp",
        "alt": "Artur presenting Harmonizing Asynchronous Systems: NATS, CloudEvents and AsyncAPI."
      },
      {
        "src": "/img/posts/london-conf-2024/eduardo.webp",
        "alt": "Eduardo presenting Event-Driven Architectures Through API Management and AsyncAPI."
      },
      {
        "src": "/img/posts/london-conf-2024/swen.webp",
        "alt": "Swen presenting Lessons from Sync API Design: What Makes A Good AsyncAPI?."
      },
      {
        "src": "/img/posts/london-conf-2024/booth-1.webp",
        "alt": "Specs booth during the break."
      },
      {
        "src": "/img/posts/london-conf-2024/dale.webp",
        "alt": "Dale presenting Topic Characteristics: What Do You Need To Know In Advance."
      },
      {
        "src": "/img/posts/london-conf-2024/laurent.webp",
        "alt": "Laurent presenting Using Test Containers for AsyncAPI Unit Testing and Mocking."
      },
      {
        "src": "/img/posts/london-conf-2024/will.webp",
        "alt": "Will presenting Deploying WebSockets with AsyncAPI and Architecture as Code."
      },
      {
        "src": "/img/posts/london-conf-2024/sho.webp",
        "alt": "Sho presenting Building Cross-Exchange Trading Library With AsyncAPI."
      },
      {
        "src": "/img/posts/london-conf-2024/booth-day-1.webp",
        "alt": "AsyncAPI Maintainers and Ambassadors Answering Some Questions."
      },
      {
        "src": "/img/posts/london-conf-2024/booth-cover.webp",
        "alt": "Day 2 at the booth with AsyncAPI experts. From left: Artur, Ian, Thulie, Khuda"
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "54f818ba",
    "title": "Monthly Community Update: February 2025 | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/blog/2025-february-summary.html",
    "content": "Monthly Community Update: February 2025 | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page New AsyncAPI Mascots AsyncAPI Budget 2025 AsyncAPI Bounty Program AsyncAPI Conference 2025 Community Discussions TSC Members Coming in March \n![](/img/posts/2025-blog-banner/banner-february.webp)\n It's been a busy few weeks in the community, and we are establishing an organizational structure as we continue to grow. We now have the Community Working Group , which serves as an umbrella for the initiatives and programs under AsyncAPI while increasing visibility for our community builder's efforts to sustain the community. In light of that, we are also discussing the introduction of a Governance Board to replace the Executive Director position with a board of 3 to 5 members. The board aims to share community responsibilities, reduce the risk of key-person dependency (bus factor), and work towards sustaining the community in the long term. Please participate in this discussion and share your thoughts and ideas on establishing our first AsyncAPI Governance Board . New AsyncAPI Mascots The redesign of Eve and Chan, the official mascots of AsyncAPI, is now complete, thanks to the incredible work of Victoria Nduka . The redesign work was part of the AsyncAPI Bounty Program, and you can find the illustrations in the AsyncAPI Mascot Redesign Documentation . Many have been wondering who Eve and Chan are. Stay tuned for an upcoming blog post explaining the concept behind the mascots. Be sure to subscribe to our newsletter to read all about it ! AsyncAPI Budget 2025 The 2025 budget voting for the initiative was approved. We also improved TSC voting by sending message reminders to members who haven't voted yet to increase participation. Thanks to Ashish Padhy for working on the implementation. \n![Message reminder sent to TSC for voting](/img/posts/2025-blog-banner/voting-example.webp)\n Message reminder sent to TSC for voting AsyncAPI Bounty Program AsyncAPI maintainers, please start preparing to submit issues for the AsyncAPI Bounty Program for Q2 from March 3rd to March 16th . The program is designed for you, so submit any issues requiring attention under the Bounty Program 2025 issue submission discussion . AsyncAPI Conference 2025 We are still seeking Financial Sponsors for the AsyncAPI Conf 2025 to assist community members with travel expenses. Please help us by sharing the conference prospectus within your networks to enhance the experience. Our first stop will be in Singapore on April 15th and 16th , and we have an incredible lineup of speakers. The agenda and ticket details will be shared soon, so check the Conference Website regularly for updates . Community Discussions We have an open discussion on the idea of having an AsyncAPI AI Hackathon, and we are looking for ideas and use cases that can impact the community. Please share your suggestions or thoughts on the AsyncAPI AI hackathon discussion . TSC Members We are excited to welcome new Technical Steering Committee (TSC) members. Aayush Saini Hari Krishnan Rohit T Coming in March AsyncAPI Community Updates Newsletter - The March Edition issue will arrive in your inbox on the 6th. Ensure you subscribe to the AsyncAPI Newsletter ; we have some amazing content you don't want to miss.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/posts/2025-blog-banner/banner-february.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/2025-blog-banner/voting-example.webp",
        "alt": "Message reminder sent to TSC for voting"
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "83b0f4c8",
    "title": "An API Strategist Explores Event-Driven APIs | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/blog/an-api-strategist-explores-event-driven-apis.html",
    "content": "An API Strategist Explores Event-Driven APIs | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page An API Strategist Explores Event-Driven APIs For the greater API Community Question 1: What do you think is the most important value proposition of event-driven architecture? Question 2: What is the consumption experience of event-driven APIs? How much does it differ from RESTful APIs? Question 3: Today, how can I test drive event-driven APIs out in the wild? Question 4: How do you measure event-driven APIs? Value Proposition of Event-Driven Architecture Question: How and when should companies actively choose event-driven architecture? In general, I\u2019m studying API Design Patterns and how various kinds of APIs expedite R&D adoption. What business results are accelerated from these kinds of patterns? \n![](/img/posts/an-api-strategist-explores-event-driven-apis.webp)\n An API Strategist Explores Event-Driven APIs If you\u2019re like me and have experience with web services and the paradigm of RESTful, web services, and SOAP APIs, but curious about event-driven, message based, or streaming APIs, this article is for you. I virtually sat down with these experts: Fran Mendez , Founder of AsyncAPI Jonathan Schabowsky , Chief Architect, Solace David McKenna , SVP, Research & Development, Axway Eric Horesnyi , General Manager, APIs & Integration, Axway (CEO of Streamdata.io acquired by Axway ) Question 1: What do you think is the most important value proposition of event-driven architecture and event-driven/messaging APIs? Question 2: What is the consumption experience of messaging APIs and how much does it differ from RESTful APIs? For example, at the time of writing can\u2019t just mock up the API and run it in a Postman collection and transform it (convert the technical specification to the version I want such as YAML to RAML or JSON, for example) and consume it. Try http://editor.asyncapi.org to understand the sister spec to OpenAPI (OAS). Question 3: Today, how can I test drive event-driven APIs out in the wild? My frame of reference with REST APIs: I can inspect HTTP calls in a browser and mock up the API. I can run the API calls in API Builder or Stoplight or Postman and get an InVision conceptual app to consume the API, for example. I can use Stoplight to lint or APIMatic to create starter SDKs to test drive. Question 4: How do you measure event-driven APIs? I was thinking about how you measure the effects of event-driven APIs. For example, how can various types of calls live within dashboards for the sake of analytics and measurement? Future Trend: Is there a way to get wholistic data from webhooks, RESTful/JSON, SOAP/WSDL/WADL/XML, GraphQL, gRPC, etc.? POV: The future of APIs is the unified catalog having a matching data-driven view. lifewingmate For the greater API Community Recommendations are the most important piece of the event-driven architecture value proposition. Business leaders only care about event-driven architecture as much as the end result produces the business-driving experience that specifically this type of architecture can produce. Technology and consulting organizations need to know when and how to recommend event-driven architecture, APIs and microservices, and corresponding methods of implementation. How they impact my current product engine? What business results justify the spend? \u2014 lifewingmate Here we go! Question 1: What do you think is the most important value proposition of event-driven architecture? Fran: I\u2019d say most interesting for me are: loose coupling between services (if a downstream service breaks the others just work fine), they\u2019re fault-tolerant since events are queued or stored somewhere, and processed once the service is up and running again, and they allow you to build real-time products easily. Jonathan: 1) Loose Coupling \u2014 As Fran states, apps do not have to know how many different apps they are consuming data from. Rather they just care about what data they are consuming. This [scenario] is extremely powerful. Also, data today is RARELY consumed only once, rather, it goes into big data and analytics platforms. The loose coupling described allows you to have this for free. Reactive to Change \u2014 Instead of polling, consumers can register their their interest (subscribe) and react to changes in real-time. The producer just sends events, and does not care if anyone is interested\u2026 fire and forget\u2026 Meanwhile clients that are subscribed get the data in realtime and can react. This is useful where you want to service customers in real-time. Scale \u2014 Want to be able to consume events, in order, across millions of devices? How about do 500k messages per second guaranteed of capital market trades? Asynchronous interactions enable enterprises to do things which are nearly impossible to do synchronously. \u2014 JSchabowsky David, Eric: Event-driven architecture brings comfort to end users and efficiency to the web at individual component level and at system level: UX in Frontends Network APIs Backends Behind the API: Application languages, data plane, and DevOps Entire System UX in Frontends The most popular reactive frameworks (AngularJS, ReactJS, VueJS) react to streams of events presented to their observables , a data plane presenting events to the UI. Why is that? Because, we -mobile and desktop human users- want to be presented data in real-time: Where is my cab? What is the price of my favorite share, now? At what time will my train arrive at destination ? Yes, our life is real-time: we do not want to waste any time and we do not want to miss anything that happens in the world ( FOMO \u2014 Fear Of Missing Out). Good news: Events improve latency of the UI by factor x20 according to our benchmark , and avoids for users to have to refresh their UI to get the latest from their newsfeed, stocks or favorite transportation, as our reptilian brain is naturally used to [understanding]. Network Since 2011, with the advent of social networks and to support reactive UI, the web has RFCed protocols for low-volume bidirectional/peer-to-peer traffic ( Websockets ) and server to client push over HTTP ( SSE ). For lower volume of events, typically for alerts, webhooks have become popular. APIs Most API calls are useless: up to 98.5% according to Zapier who created the concept of Polling Madness. That is because the API client does not know when data will change, so would keep polling an API to make sure it does not miss any update. Event-Driven Architecture in APIs reverses the paradigm: why don\u2019t we have the component who know when data change to take charge, instead of answering to useless calls? This [situation] leads to the API server pushing streams of events to the API client who have subscribed to a topic. Traffic hence goes north-south only when necessary, rather than south-north-south to hit updates randomly. Augmenting a REST API with a streaming API typically brings 90% efficiency in CPU and network use for most demanding traffic. Backends In some industries, backends have been using evented architecture for a while. Behind the API: Application Languages, data plane, and DevOps Backend architectures have relied on events for a while, before REST was created. In my Flashboy days in High Frequency Trading , we were pushing events from exchanges to hedge funds to allow them to stay in front of the market (making big money at low risk, I\u2019m repentant), using IP-based tweaks (IP multicast and their famous storms), and proprietary middleware. Since then, message buses have evolved to open standards adopted outside finance (thanks Linkedin for Kafka ), and -as already noted- the web has made it possible to transport events over HTTP. Additionally, and almost at the same time, people -like myself - having advocated microservices for years without seeing convergence of best practices are now contented: Kubernetes is here, and has instantly been adopted by all architects and DevOps to prepare their ideal microservices architecture. And when you dig into Kubernetes and associated frameworks Istio and Envoy, what do you find? REST APIs of course, but that was expected by definition of microservices. What you also find is Async APIs for each microservice. Kaboom! Backends now have a blueprint for quite a few years: Kafka and Kubernetes to orchestrate data flows, control and scale them. And this blueprint is entirely event-driven. To top it all and not surprisingly, languages traditionally used to create application layers linked to databases have also gone through their event revolution with reactive extensions such as RxJava widely adopted by the Java community. Now the entire backend dev, DevOps, and IT community can focus on what will make them able to compete with agility over the web. Entire System If we take a helicopter view to look at the entire system, what does the event-driven revolution? The entire chain from data plane, app, API, network down to the frontends are event-driven: Event flow between IoT devices (eg GPS), mobile apps, and ML without any barrier, people can all align thinking in terms of data streams of events rather than databases, considering intensity and relevance of feeds rather than states and calls. As all components have embraced the EDA revolution (I prefer evolution -revolution is always violent- as this is happening with live clients to be supported at the same time, hence slowly, but based on a Darwinian selection of design). This new end-to-end chain of events brings simplicity and efficiency to components individually and collectively. Question 2: What is the consumption experience of event-driven APIs? How much does it differ from RESTful APIs? Fran: You usually connect to a broker to start sending and/or receiving messages. Examples of brokers are RabbitMQ, Kafka, Solace, etc. The difference with synchronous patterns like REST, gRPC, and GraphQL is that you don\u2019t ask for information. You don\u2019t make requests. Just connect to the broker and subscribe to a channel of your interest. Eventually (no pun intended), you\u2019ll get this information, such as when the events occur. Similarly, you\u2019ll send events to the broker whenever they occur to you. (replace you with your service) Jonathan: Today, the consumption experience generally sucks! This is a gap in the market AsyncAPI is solving and Solace [and several other companies, organizations, and individuals] is looking to help solve too\u2026 help make the experience as pleasant as with RESTful APIs. David, Eric: There are many different technologies for providing event driven APIs Server-Sent Events (SSE) for pushing data to the client to provide reactive user experience Webhooks for making HTTP callbacks on state change HTML5 Websockets providing full-duplex communication channels over a single TCP connection between client and server. MQTT and AMQP for IoT use cases Question 3: Today, how can I test drive event-driven APIs out in the wild? Fran: You can\u2019t or is not easy. Part of the reason for the existence of AsyncAPI is precisely to enable that. Jonathan: Check out cloud.solace.com \u2026 Sign up for an account (free) and play around. Create an event broker (think of that like an API gateway) and look at our runnable code pen examples. This is all more infrastructure based\u2026. Now imagine AsyncAPI and you layer that on top, it becomes more like API management. Also, check out this blog https://solace.com/blog/api-management-event-management/ (Emmelyn) I can inspect HTTP calls in a browser and mock up the API and run it in Postman and get an InVision conceptual app to consume the API, for example. You can kind of do this at cloud.solace.com \u2026 Again its more how do you send/receive messages\u2026 with no app context, but its a start and the most useful I have ever found. (Emmelyn) I can use Stoplight to lint or APIMatic to create starter SDKs to \u201ctry it\u201d See previous comment and try it out and give me feedback! David, Eric: Many of the traditional testing tools do not natively support event- driven protocols and are built for standard HTTP request/response found in REST based services. In order to help support the testing of SSE a client SDK is provided to help build automated clients to test both functional and non-functional aspects of SSE services. Question 4: How do you measure event-driven APIs? Fran: You don\u2019t have \u201ccalls\u201d because you don\u2019t ask for anything. You just show your interest in certain types of events and wait for them to happen. That\u2019s a subscriber/consumer. If you\u2019re building a publisher/producer then you\u2019ll send events to the broker when certain events occur. The consumers interested in your type of event will receive them. Jonathan: I think effectiveness is a direct correlation between consumption. An event that is consumed 0 times was actually worth 0\u2026 an event consumed 100 times is valuable. Yes, you do this via dashboards. Today, nobody deals with BOTH events and synchronous apis in one platform. David, Eric: The enhanced user experience in the client can be tracked by NPS of the service. Traditional monitoring tools are optimized for request-response scenario, asynchronous scenarios bring in additional complexity where by a single request could result in N number of responses been relayed to the client. Adoption of OpenTracing can help to see the spans of distributed transactions. Value Proposition of Event-Driven Architecture Business leaders only care about event-driven architecture as much as the end result produces the business-driving experience that specifically this type of architecture can produce. What would you explain to this type of audience? Fran\u2019s take Real-time experiences are built with event-driven architectures. You can\u2019t build something real-time with REST APIs or any of the aforementioned styles. Solace has an interesting concept called \u201cevent mesh\u201d and Jonathan Schabowsky can explain better and point to existing documentation. And then you have the cool thing about event-driven microservices, which allows you to build products faster. It allows you to spend less time worrying about the systems and more about your business logic. Eric\u2019s take As a CEO myself, I do not invest in any feature of any technology until I can see proven track records and numbers. Well, EDA actually brings sizeable benefits in terms of topline, customer satisfaction, cost base, competitive differentiation and even HR attractiveness and retention: Topline Customer Satisfaction Outsmart your Competitors with Machine Learning ML IT Cost Base Reduction HR Topline The main benefits of the EDA mindset is to optimize the time it takes between the occurrence of an event in the universe, and the reaction by the company to that event. Each industry has its own metrics for assessing such benefit. In capital markets, 1 millisecond is worth $8m (!) In marketplace/ecommerce/retail/logistics business where players make as much money as they can reduce the time between an order is placed to them, and such order is shipped to the end user, each second count. I did a quick calculation of how much a second is worth for Amazon, by dividing revenue by the number of seconds in a year: $50m (!) Customer Satisfaction As already noted, reactive interfaces are not only the coolest but also the most natural for our human brain. Well, we can put a number on this: 100 ms is worth 1% additional revenue on any mobile or desktop app, from mobile banking to eCommerce. For developers using your API, when you can provide your most important customer the ability to consume your API without limit, they are happy to pay a premium for it as it means they have more data to make decision upon, and it helps streamlining their data ingestion chain. Outsmart your Competitors with ML A major way for technology to bring value to customer interactions (chatbots), optimize processes and make best-possible decisions in an ever-changing world is Machine Learning. And Machine Learning thrives on data. In the past, data architectures were based on tables and data lakes. Well, for practitioners, data lakes actually became data swamps. With some experience, the key is to master data ingestion so that data sources are consumed upstream, as close as possible to the source, and turned into value as soon as possible by Machine Learning. Machine Learning consumes streams of data conveyed by Kafka from third party streaming APIs, such as Xignite Cloudstreaming , learn from them as they come and learns from its errors against what it had predicted. And the closer you are from data sources (acting as senses for the ML brain), the smarter your ML brain will be, faster than your competition. There is even a family of ML updating their model for each, called Massive Online Analysis or Streaming Algorithms. EDA has even invaded ML. IT Cost Base Reduction With the 90%+ gains in efficiency that we have mentioned earlier, an API vendor servicing clients with events can not only make them happier, but also reduce its cloud bill on CPU and network by 90% on these use cases. As cloud bills have become so high and critical to become visible to executive desks, they should understand the impact. HR I believe we would agree that developers and DevOps like new and efficient [tools]. And events are fun while bringing efficiency. Working with events makes your organization more attractive to new developers, and help keeping them happy while working on cutting-edge technology. As developers cannot meet the demand while \u201csoftware is eating the world\u201d this [circumstance] alone could be a driver for considering and EDA and API and Microservices first approach in your organization. Question: How and when should companies actively choose event-driven architecture? For example, how is discovery performed? Which APIM catalogs can showcase event-driven APIs so that companies can decide to consume rather than build it themselves? What kind of guidance and best practices can we provide? David and Eric advise IoT \u2014 Many companies are looking to leverage IoT in their offering such as car insurance (pay as you drive), healthcare (health monitoring). A vast variety of low-price devices (sensors, thermostats, robots, etc.) with internet connectivity is flooding the market. Their value does not lie in the hardware but in the services that are/will be attached to it. The infrastructure that support these services must have a real-time processing capability to provide real value back to the consumer. MQTT is becoming the de-facto standard to exchange data with IoT devices because it is simple and efficient on low memory devices. It is also based on a Publish/Subscribe model that will force the companies to adopt an EDA in order to process all the generated events. Cloud \u2014 Adaption of cloud-based services in Enterprise adds more integration patterns (Cloud-to-cloud, Cloud-to-ground, Ground-to-Cloud, ..) thus more complexity. The different systems needs to exchange data to keep a coherent state across the applications. Using a point-to-point integration strategy can quickly become a trap because of the exponential complexity and tight coupling between the different systems. EDA enables a loose coupling between the components/apps in order regain agility, increases innovation pace and reduces time-to-market for new features/services. In general, I\u2019m studying API Design Patterns and how various kinds of APIs expedite R&D adoption. What business results are accelerated from these kinds of patterns? Thanks for suggesting topics and connecting with feedback. You can also reach me via Twitter @lifewingmate DM or via the AsyncAPI community via our GitHub or Slack channel . Disclaimer: The professional opinions of those interviewed do not necessarily reflect the organizations they represent. These interviewees volunteered their time and contributions to support the AsyncAPI initiative and community.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/posts/an-api-strategist-explores-event-driven-apis.webp",
        "alt": ""
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "52929c96",
    "title": "AsyncAPI Ambasador Program | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/blog/asyncapi-ambassador-program.html",
    "content": "AsyncAPI Ambasador Program | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Why create an ambassador program? How does the program work? More about AsyncAPI Ambassador Program \n![](/img/posts/ambassador-program/cover.webp)\n AsyncAPI and its community have grown exponentially during the last few months. As a feedback exercise, both the project and the community are getting stronger with one another. The community is the driving force that leads the initiative and the bigger it gets, the greater the consistency and potential it has. It\u2019s amazing to see a vast number of people who invest their time in disseminating and promoting the initiative through talks, articles, workshops, and program direction... To follow that line, the AsyncAPI Ambassador Program is one of the latest additions to the initiative to keep the community going. The program is, after all, a reaction to the natural impulse of the community. Thus, in this case, the ambassadors came before the Ambassadors Program itself. This proposal was born based on the recognition of the work of community members who invest their time in bringing AsyncAPI to the community and new potential users. AsyncAPI Ambassadors are passionate about open source. They are committed to making AsyncAPI an inclusive place for everyone and participate in leading and mentoring the community. Below are guidelines to be followed by anyone who wishes to become an ambassador: Promote user cooperation and disseminate the tools needed for any specific user. Engage with the project in some way, whether as a contributor, blogger, speaker, etc. Speak at community events or write technical content (e.g., blog posts) that solves community needs. Foster community growth and a welcoming environment to spread knowledge about the project. Why create an ambassador program? As we know, everyone has a unique way of looking at things and a person's abilities differ. Following that line, each ambassador can offer a different approach. They bring part of their essence into the content or the program where they are involved and disseminate. This is what brings human value to the project, enriching the conception and possibilities. \n![heart&brain](https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExOTgzODZhZDM1MWZhMDJiODNkODFhZTI3MWRjZDExZGQyYzBlNzMwYiZjdD1z/NfBApd81ooX87Od5hk/giphy.gif)\n The community is experiencing rapid growth. Over the past year, we started the Ambassadors Program and the AsyncAPI Mentorship program and participated in GSoD for the first time. As the community evolves, the initiative remains dynamic and open, driving new ideas and proposals. How does the program work? The Ambassador Program is a transparent system, just like any other management issue related to the initiative. Its success relies on diversity, inclusiveness, and integration. The goal is to materialize these concepts within the program. \n![heart&brain](https://media.giphy.com/media/eEh1lwAYtnmwDWSirZ/giphy.gif)\n The process of recruiting ambassadors is completely open. If anyone meets the requirements, they only need to add themselves to this document , attaching their personal information along with their contributions. The TSC members will then approve the proposal. Subsequently, all ambassador information will be displayed on the AsyncAPI website once the PR has been merged. The process tries to be simple, collaborative, and transparent as possible. More about AsyncAPI Ambassador Program The minimum enrollment period for ambassadors is one year with the option to renew annually. At the end of each period, the number of participants will be assessed and confirmed on a yearly basis. To qualify as an ambassador, individuals must make at least four contributions per year, which may include articles, talks, videos, podcasts, presentations, or driving initiatives, etc. Ambassadors are entrusted with some amount of responsibilities. As a token of appreciation for their work, we try to compensate them with certain perks, including exclusive swags and conference passes. Learn more about the Ambassador Program here . We are waiting for you on board! \ud83d\ude80 Photo by Ian Schneider on Unsplash",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/posts/ambassador-program/cover.webp",
        "alt": ""
      },
      {
        "src": "https://media.giphy.com/media/v1.Y2lkPTc5MGI3NjExOTgzODZhZDM1MWZhMDJiODNkODFhZTI3MWRjZDExZGQyYzBlNzMwYiZjdD1z/NfBApd81ooX87Od5hk/giphy.gif",
        "alt": "heart&brain"
      },
      {
        "src": "https://media.giphy.com/media/eEh1lwAYtnmwDWSirZ/giphy.gif",
        "alt": "heart&brain"
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "d0d6f480",
    "title": "AsyncAPI Bounty Program Summary - 2024 | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/blog/asyncapi-bounty-program-2024.html",
    "content": "AsyncAPI Bounty Program Summary - 2024 | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page AsyncAPI Bounty Program Benefits for FOSS Community Benefits for AsyncAPI GitHub Organization Benefits for AsyncAPI Maintainers Benefits for Bounty Program Participants \n![](/img/posts/bounty-program/photo-from-starship-cockpit.jpeg)\n AsyncAPI Bounty Program Since ancient times, sponsors furiously wanted to support Open Source. AsyncAPI addressed that need by starting to quarterly publish for Middle and Senior engineers a set of tasks that are currently in demand among AsyncAPI Maintainers and rewarding their completion using accumulated donated funds. During one year of existence of the AsyncAPI Bounty Program : 32 GitHub issues were resolved, 16 of which had complexity level Advanced ; 50+ PRs were merged in total; 8000+ USD were paid out as rewards. Benefits for FOSS Community At least one issue was closed in a third-party project due to a fixed bug in AsyncAPI's software. Benefits for AsyncAPI GitHub Organization Thanks to the Bounty Program Participants, AsyncAPI got: Automation in Technical Steering Committee voting process ( Aayush Saini ): New automation and the process around voting have been introduced, as well as transparent summaries of each voting activity. New monorepo setup in generator and parser-js ( Ayush Nautiyal ): Consolidation of smaller repositories into these two larger projects helped unify the dispersed community within the organization, fostering collaboration in a single location and accelerating development. Saving of costs on DigitalOcean ( Ashish Padhy ): AsyncAPI was running out of credits too fast, and with proper deployment changes , it's not the case anymore. GitHub Action refactored from scratch to use CLI ( Ashish Padhy ): Simplification is always a driver for innovation. Now official GitHub Action from AsyncAPI supports not only AsyncAPI Generator but also 1:1 all features from the CLI. Not just any but AMAZING cheat sheet poster ( Aishat Muibudeen ): It is not only available for download , but is also used at AsyncAPI conferences. \n![](/img/posts/bounty-program/362263381-acc75432-0f58-4c96-a65f-f172d34ee4ec.jpg)\n Benefits for AsyncAPI Maintainers The Bounty Program gives AsyncAPI Maintainers the possibility: To announce a financial reward for GitHub issues that are currently in demand by the maintained project or the AsyncAPI Initiative as a whole, on which AsyncAPI Maintainers can either work and get rewarded themselves or delegate those issues to regular contributors who have more time and/or the necessary expertise. Benefits for Bounty Program Participants Typical benefits of the Bounty Program for its Participants who are in the early stages of their career are: Development of a better approach to the evaluation of issues (it's fun reading messages from two months ago saying, '1-2 weeks left'.) First/differing working experience (fully asynchronous distributed teams are still rare, unlike partially asynchronous distributed ones.) Development of the possibility to showcase to the potential employer real-world work not obscured by an NDA. With all that said, join a finally sure way to directly sponsor (and get rewarded for) FOSS development. Giggly thing as a finishing touch: PR for a bug due to which several lines were output incorrectly to the front end. Co-authored-by: Lukasz Gornicki",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/posts/bounty-program/photo-from-starship-cockpit.jpeg",
        "alt": ""
      },
      {
        "src": "/img/posts/bounty-program/362263381-acc75432-0f58-4c96-a65f-f172d34ee4ec.jpg",
        "alt": ""
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "9328427a",
    "title": "AsyncAPI Online Conference scheduled for 22.04 11 AM UTC | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/blog/asyncapi-conference-kick-off.html",
    "content": "AsyncAPI Online Conference scheduled for 22.04 11 AM UTC | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page How do you organize an event like this in such a short time First baby steps to kick off the event Talks selection Sponsoring Logistics aka connectivity issues can kill your event Conclusion \n![](/img/posts/asyncapi-conf-banner.webp)\n It is happening, a first-ever AsyncAPI Online conference. We start on 22 of April, at 11 AM UTC . The event is going to take 7 hours with 12 talks from all over the world. We start in sunny Sydney and finish in cloudy Vancouver. The event is for free, online, in your favorite quarantine room. How do you organize an event like this in such a short time There are two requirements you should fulfill behind you start organizing a conference: Gather a few people that like to walk off the beaten tracks. Best would be to involve your whole core team, as we did in AsyncAPI. All three of us got involved \n![](https://emojipedia-us.s3.amazonaws.com:443/content/2020/04/05/trollface-github-emojipedia.png)\n Fran M\u00e9ndez - Project Director. Eva Morcillo Rodr\u00edguez - Marketing and Video Content Manager. \u0141ukasz G\u00f3rnicki - Maintainer and Dev Community Keeper. Make sure you have a fantastic community behind your back that supports your efforts First baby steps to kick off the event Consult your community if what you plan to do makes sense \n![slack asyncapi conference](/img/posts/slack-conference.webp)\n Set a conference date and call for proposals deadline Get your community involved We decided on a tight schedule. Our community had only three days to submit proposals. Oh boy, they exceeded our expectations. In total, we got 18! proposals. We were happy and proud but also afraid that we can't accept all talks. Talks selection We wanted to establish as many fair rules as possible in such a short timeframe. We decided to form a committee of people that could join Fran and vote for talks that they found most interesting: They could give 1-10 points per talk. They had no idea who is behind the talk. They knew only a title and an abstract of every proposal. After voting, we applied the following additional rules: We did not accept more than one talk from the same company. We choose the one that was most popular among voters. We did not accept talks that were either not related to the theme or other talks accepted for the conference. In other words, we did not want to favor any company and wanted to have a schedule with talks around a similar area. As a result, we accepted 11 talks from the community. We did it thanks to the support of this amazing group of people: Waleed Ashraf Mike Ralphson Jonas Lagoni Andrzej Jarzyna Sponsoring We decided to enable companies and individuals to support the event financially. How to collect money? Do it transparently with tools that you already know. We decided to use Open Collective because we use it already to collect money for AsyncAPI We created a dedicated event using Open Collective events . This approach allows us to collect money and share expenses explicitly for the event only. The sponsors in exchange get much more than just being listed in our conference sponsors list , and it is clearly described under our event page. What is the money for? We want to spend it mainly on: Prizes for the community involved in the event. Paid event marketing. We are doing our best to promote event on our own , but we know that we could do much better using paid channels too. More people know about the event and indirectly about AsyncAPI, better profits for the community, and the sponsors. Logistics aka connectivity issues can kill your event These are coronavirus times. ISPs are having stress tests. Netflix is probably hitting view records. Kids are running around the house all the time. We took it all into account, and this is how we want to solve those challenges: First of all, we asked our presenters to record their sessions upfront and send them to us. We want to stream them live to YouTube, and we are exploring platforms that might make it easy to stream not only to YouTube but also Twitter and others. Presenters still join their sessions, and they are going to engage with the audience in conference chat in real-time during the whole presentation. What is so great about it? The audience doesn't have to wait until the end of the presentation with questions as it works in traditional conferences Presenters have much more time to engage with their audience, to exchange thoughts, and get more questions. They can also ask their teammates, organization members, or experts in their field to provide support during the talk. Conclusion Don't be afraid to organize your event; just find some freaks that follow you to organize it. I'm a proud freak that bought the idea immediately. It is worth it, even if you do not know the outcome yet, the experience you always gain profits in the future. In the name of the whole AsyncAPI community and the core team, I'd like to invite you to join our event on 22 of April, at 11 AM UTC . The conference line-up suggests that the AsyncAPI Online conference is going to be epic! #stayhome #staysafe #staycurious",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/posts/asyncapi-conf-banner.webp",
        "alt": ""
      },
      {
        "src": "https://emojipedia-us.s3.amazonaws.com:443/content/2020/04/05/trollface-github-emojipedia.png",
        "alt": ""
      },
      {
        "src": "/img/posts/slack-conference.webp",
        "alt": "slack asyncapi conference"
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "0079461e",
    "title": "AsyncAPI Mascot Redesign - The Biography of Eve and Chan | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/blog/asyncapi-mascot-redesign.html",
    "content": "AsyncAPI Mascot Redesign - The Biography of Eve and Chan | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page AsyncAPI Mascot Redesign: The Biography of Eve and Chan The Birth of Eve and Chan Why the Redesign? Meet Eve and Chan What's Next for Eve and Chan? \n![](/img/posts/mascot-banner.webp)\n AsyncAPI Mascot Redesign: The Biography of Eve and Chan The Birth of Eve and Chan Why the Redesign? Meet Eve and Chan What\u2019s Next for Eve and Chan? AsyncAPI\u2019s mascots, Eve and Chan, have had a brand refresh, and I\u2019m proud to say that I helped redesign them. Seeing the community use them in different ways warms my heart. Any designer will tell you that nothing beats seeing your work come to life beyond the Figma canvas, and that\u2019s exactly how I feel about the new mascots. Throughout the redesign process, I kept asking myself questions to ensure the new look stayed true to its original purpose. Whose idea was it to have the mascots? Why the names Eve and Chan? Who designed them originally? Who are Eve and Chan? As it turns out, I\u2019m not the only one with these questions. Within and outside the AsyncAPI community, folks have often wondered about the origins of these characters. So, I recently sat down with Fran Mendez, the founder of AsyncAPI, to get their backstory. This is the story of Eve and Chan\u2014their biography. The Birth of Eve and Chan Fran M\u00e9ndez\u2019s idea was to have a mascot that people could easily associate with the AsyncAPI brand. Most open-source projects and companies use mascots to reinforce their brand identity, so why not AsyncAPI? Since Linux has Tux, the Penguin, and GitHub has Octocat, Fran wanted something like that for AsyncAPI. Initially, he envisioned just one eye-catching character that could work well on merch. The goal was to create swag people would want to buy. Not everyone would wear a hoodie with just a logo slapped on it. But a mascot? That\u2019s stylish, versatile, and could be worn anywhere. Ultimately, the mascot served two purposes: strengthening AsyncAPI\u2019s brand identity and helping raise funds for the project through merch sales. An illustrator from a studio in Colombia designed the first version of the mascots. He created two characters: a bold female lead and a quirky extraterrestrial. Now the mascots were ready\u2014but what\u2019s a mascot without a name? Fran took to his socials and asked the community for suggestions. Someone came up with Eve and Chan\u2014Eve for \"events\" and Chan for \"channels.\" Not only were they catchy, but they also tied back to what AsyncAPI does. Real names with real meaning. It was brilliant. \n![Poll for mascot name suggestions](/img/posts/mascot-poll.webp)\n If you\u2019re wondering, like I was, why there are two mascots instead of just one, it\u2019s because they were designed to tell a story. Eve is the skilled, knowledgeable one who always does things correctly, while Chan is slightly clumsy and represents the mistakes people often make in event-driven architecture. Why the Redesign? About two years after their debut in 2019, the mascots were due for a visual refresh. While the original designs were charming, they were too detailed for AsyncAPI\u2019s needs. The goal was to simplify their look\u2014using basic shapes, fewer curves, and minimal shading\u2014to make them more versatile and easier to use across different formats. This redesign aimed to create a cleaner, more adaptable style while preserving the essence of the original concept. In 2021, a GitHub issue was created to kick off discussions and track progress on the redesign. However, for a couple of years, not much was done. Then, in September last year, I expressed interest in working on the project and was assigned the task. And the rest, as they say, is history. For more details about the redesign, you can check out the mascot documentation here . Meet Eve and Chan After four months of multiple design iterations, community voting, plenty of back-and-forth, and a few unavoidable breaks, I\u2019m excited to introduce the redesigned AsyncAPI mascots. \n![AsyncAPI Mascots](/img/posts/mascots.webp)\n What's Next for Eve and Chan? Designing Eve and Chan was both a challenge and an honor, and I can\u2019t wait to see all the fun and creative ways the community brings them to life. You\u2019ve probably already seen them in some of our social media posts, and they\u2019re now the face of AsyncAPI\u2019s GitHub bots. We\u2019re looking to feature them on swag, in documentation, at community events, and more. So, if you\u2019ve ever wondered about the story behind these little characters, now you know, and if you\u2019re part of the AsyncAPI community, get ready. You\u2019ll be seeing a lot more of them.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/posts/mascot-banner.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/mascot-poll.webp",
        "alt": "Poll for mascot name suggestions"
      },
      {
        "src": "/img/posts/mascots.webp",
        "alt": "AsyncAPI Mascots"
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "acac7eb3",
    "title": "AsyncAPI partners with Postman to boost development of Asynchronous APIs | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/blog/asyncapi-partners-with-postman.html",
    "content": "AsyncAPI partners with Postman to boost development of Asynchronous APIs | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Next steps \n![](/img/posts/asyncapi-partners-with-postman.webp)\n I'm proud and honored to let you know that we're partnering with Postman to boost the development of Asynchronous APIs to a new level \ud83d\ude80 Since the very beginning, I knew the duty we had at hand was challenging. And still is! The specification was just the trigger of a snowball effect. What's the spec for if you can't do anything with it? Tooling is as important as the specification. However, tooling is a number of times more complex than the specification. We engineers don't want to abandon our favorite programming language and framework, therefore, it's AsyncAPI's responsibility to integrate with the existing tools in the market. The specification (and tools) should work for the user, not the other way around. Partnering with Postman allows us to boost the development of more and better tools to help engineers create and maintain Asynchronous APIs while using their favorite programming languages and frameworks. Our goal is to make Asynchronous APIs as successful and mature as REST APIs. We are aware this is a long journey but, with Postman's help, we'll be able to grow the team and continue working on the AsyncAPI specification and all the necessary tools to create a delightful developer experience. The AsyncAPI Initiative team is fully committed to open source software (OSS), and the partnership with Postman will help us keep doing our job with freedom and independence. Next steps We want to make the AsyncAPI Initiative a neutral and independent place for collaborating on defining the future of Asynchronous APIs. Next step for us is to host the project in a neutral foundation to guarantee the long-term success of the initiative. We're currently in conversations with different actors of the OSS world to make sure the initiative remains independent. Also, we want you to work with us. We are hiring at Postman to work full-time on AsyncAPI. In the first half of 2021, we'll open a bunch of positions, including Software Engineers, Graphic Designers, Technical Writers, and more. Make sure you don't miss them! Before I finish, I would love to thank Kin Lane and Abhinav Asthana for being so supportive. And of course, a huge shout out to \u0141ukasz Gornicki and Eva Morcillo for their tireless support. None of these would be possible without their help. There's a bright future ahead for Asynchronous APIs. 2021 will be the year of AsyncAPI, the year of you, our beloved open-source community. Cheers! \ud83c\udf7b",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/posts/asyncapi-partners-with-postman.webp",
        "alt": ""
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "f283cb64",
    "title": "AsyncAPI Code Generation: Microservices Using Spring Cloud Stream | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/blog/asyncapi_codegen_scst.html",
    "content": "AsyncAPI Code Generation: Microservices Using Spring Cloud Stream | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page AsyncAPI: What Is It? Defining the Application That You Want to Develop: The AsyncAPI Document Create Event-Driven Microservices Using Spring Cloud Stream Without Learning Messaging APIs Download and Run the AsyncAPI Generator Add Your Business Logic Helpful Parameters and Specification Extensions for Creating Microservices Using the AsyncAPI Spring Cloud Stream Template Tips For Using The Code Generator To Create Event-Driven Microservices Using Spring Cloud Stream Conclusion \n![](/img/posts/asyncapi-codegen_pic-00.webp)\n Code generation is no simple feat. There are a lot of complexities when it comes to generating useful application code. In this post, I am going to walk you through generating your own microservices using Spring Cloud Stream and the AsyncAPI Code Generator. These tools should help to simplify things when defining and implementing your asynchronous applications. I explained the same idea in a video you can watch here , and all of the artifacts are available in GitHub . This post AsyncAPI Code Generation: Microservices Using Spring Cloud Stream appeared first on Solace . AsyncAPI: What Is It? Before we dive into code generation let\u2019s start with the basics \u2013 what is AsyncAPI? Over the past few years, AsyncAPI has emerged as the industry standard for defining asynchronous, event-driven APIs; you can think of it as OpenAPI for the asynchronous world. It is an open source initiative that provides both a specification to describe and document your asynchronous applications in a machine-readable format, and tooling (such as code generators) to make life easier for developers tasked with implementing them. I\u2019m not going to go into great detail about the specification, but for context you should know that it defines metadata about your asynchronous API, the channels available for sending/receiving messages, and components \u2013 such as schemas \u2013 that define the messages that are being exchanged. For more information about the specification you can read about it here . Defining the Application That You Want to Develop: The AsyncAPI Document The first step in doing code generation with AsyncAPI is obtaining an AsyncAPI document that defines the application that you want to develop. Per the specification, this document is represented as JSON objects and must conform to the JSON standards. YAML, being a superset of JSON, can also be used. There are two main ways of going about obtaining this document: manually create the document or use an event portal. If you decide to manually create the document after familiarizing yourself with the specification, don\u2019t worry \u2013 you won\u2019t be starting with a blank slate. The AsyncAPI initiative has provided a handy, interactive tool called the AsyncAPI Studio to make this easier. On the left side of the Studio you can familiarize yourself with the specification and make changes to a real AsyncAPI document, and as you do so the right side of the screen updates to show how the document is parsed into a more human-readable format. \n![asyncapi playground for creating microservices using spring cloud stream](/img/posts/asyncapi-codegen_pic-01.webp)\n The second way is to use an event portal. Solace PubSub+ Event Portal, for example, allows for architects and developers to collaborate using a GUI to design your event-driven architecture. The team would define the applications that exist in the system, as well as the events that are exchanged and the schemas which define them. Having a catalog of well-organized channels and events for reuse will also save you both time and headaches while collaborating, instead of having to comb through a bunch of files in various locations. Once the design is in place, PubSub+ Event Portal allows the developer to choose the application they are responsible for developing and download the AsyncAPI document in JSON or YAML. \n![pic2](/img/posts/asyncapi-codegen_pic-02.webp)\n Create Event-Driven Microservices Using Spring Cloud Stream Without Learning Messaging APIs Now that we have our AsyncAPI document that describes our application it\u2019s time to develop the application. The AsyncAPI Code Generator supports templates to generate code for a variety of different languages and protocols, but for this example we\u2019re going to use the Spring Cloud Stream template . One should note that the template generates a Maven project. The Spring Cloud Stream framework provides an easy way to get started with event-driven microservices by providing binders that allow the developer to create their microservices without having to learn messaging APIs. Download and Run the AsyncAPI Generator The first step is of course to install the AsyncAPI generator itself. If you have NodeJS installed this takes just one easy npm command as seen below. You can find the required versions in the Code Generator on github. npm install -g @asyncapi/generator Once you have the generator installed you can run it using the ag command. At a minimum you must specify the AsyncAPI document to run it against and the template to use as shown below. \n```javascript\nag https://raw.githubusercontent.com/asyncapi/asyncapi/2.0.0/examples/2.0.0/streetlights.yml @asyncapi/java-spring-cloud-stream-template\n```\n In most cases you\u2019ll want to take advantage of the parameters and specification extensions that are specified by the template being used. For example, the Spring Cloud Stream template that I\u2019m using in this example allows me to configure many options , including the Spring Cloud Stream binder I want to use \u2013 for example, the Solace binder. Other parameters include: Maven information: artifactId and groupId Java package: javaPackage Broker connection Info: host , username , password and msgVpn Using these options, my ag command might look something like this, where -o specifies the output directory: \n```javascript\nag -o ExpenseIntegration -p binder=solace -p view=provider -p actuator=true -p artifactId=ExpenseIntegration -p groupId=acme.rideshare -p javaPackage=acme.rideshare.expense -p host=localhost:55555 -p username=default -p password=default -p msgVpn=default ~/Downloads/ExpenseIntegration.yaml @asyncapi/java-spring-cloud-stream-template\n```\n After running, the output will look something like this: \n![pic3](/img/posts/asyncapi-codegen_pic-03.webp)\n Add Your Business Logic At this point the generator has created an ExpenseIntegration directory that contains the Maven project. We can use the IDE of choice and import the Maven project to add business logic. As seen in the image below, once imported, the project looks like a regular Spring Boot Java project with generated classes under the javaPackage that was defined earlier and an application.yml file for configuration. Generated classes under javaPackage include Plain Old Java Objects (POJOs) defined from the schemas in the AsyncAPI document and Application.java which contains the actual Spring Cloud Functions where we\u2019ll add our business logic. \n![pic4](/img/posts/asyncapi-codegen_pic-04.webp)\n The generated POJOs, like RideReceipt in the image above, define your data model per the schemas included in the AsyncAPI document. These POJOs contains variables with getters and setters for each attribute defined to allow both for developers to get coding quickly without having to manually create the objects themselves, but also for Spring Cloud Stream to automatically convert messages directly to POJOs. Then we have the Application.java class, which can be renamed using the javaClass parameter. The generator will add functions to handle messages delivered on the channels defined in the AsyncAPI document as described in the template . In the example below we can see a single java.util.function.Consumer bean since our AsyncAPI document describes our application as a subscriber to messages whose payload is defined by the RideReceipt schema. Note the comment that states // Add business logic here; this is where the developer can add their business logic. \n```javascript\n1@SpringBootApplication\n2public class Application {\n3   private static final Logger logger = LoggerFactory.getLogger(Application.class);\n4   public static void main(String[] args) {\n5      SpringApplication.run(Application.class);\n6   }\n7\n8   @Bean\n9   public Consumer<RideReceipt> acmeRideshareBillingReceiptCreated001Consumer() {\n10      // Add business logic here.\n11      return null;\n12   }\n13}\n```\n You might say: \u201cMarc, that\u2019s great, but how the heck is that function actually binding to the messaging channels!?\u201d This is where the application.yml file comes into play. The generated application.yml file defines several things as specified in the AsyncAPI document or from the parameters passed into the generator. First, it defines the list of functions it wants Spring Cloud Stream aware of under spring.cloud.stream.function.definition . Second, it tells Spring Cloud Stream which channels to bind those functions to under spring.cloud.streams.bindings . Lastly, it contains connection information to the messaging system. The connection info is specified by different parameters depending on the binder you choose but, in this case, it\u2019s defined under solace.java . \n```javascript\n1spring: \n2  cloud: \n3    stream: \n4      function: \n5        definition: acmeRideshareBillingReceiptCreated001Consumer \n6    bindings: \n7      acmeRideshareBillingReceiptCreated001Consumer-in-0:\n8        destination: acme/rideshare/billing/receipt/created/0.0.1\n9\n10solace: \n11  java: \n12    host: 'localhost:55555' \n13    msgVpn: default \n14    clientUsername: default \n15    clientPassword: default\n16\n17logging: \n18  level: \n19    root: info \n20    org: \n21      springframework: info\n```\n Note that all of this was done for the developer so they didn\u2019t have to track down which SCSt parameters needed to be set, map the functions to the bindings, etc. They just have to add their business logic in place of the project and hit run! In this case since it\u2019s a Spring Boot project you can \u201crun as a Spring Boot app\u201d in your IDE or even run from the command line using mvn spring-boot:run . Helpful Parameters and Specification Extensions for Creating Microservices Using the AsyncAPI Spring Cloud Stream Template As I mentioned, there are a lot of complexities when it comes to generating useful application code from a microservice. Because of these complexities, I thought I\u2019d call out some tips, tricks, and painpoints of using the AsyncAPI Spring Cloud Stream template. There are a bunch of different parameters and specification extensions that you should consider when generating your code. All of them can be found here , but I\u2019ll go over a few of the parameters that I use quite often: The binder parameter allows you to specify the Spring Cloud Stream binder that you\u2019d like to use. Currently the generator supports kafka , rabbit and solace . The info.x-view specification extension can be set at the info level in your AsyncAPI document. This extension allows for you to define how the document should be viewed from an application perspective. By default an AsyncAPI specification takes a client view where operations (publish/subscribe) defined in a document represent what an application accepts (or how you would communicate with that application). However, for code generation you may want to generate what an application actually does. This is where setting the view parameter comes in. If you set view to a value of provider the operations defined in the document will be treated as what an application actually does. Note that this extension can also be set using the view parameter on some generator templates, such as the Java Spring Cloud Stream one. The operation.x-scs-function-name specification extension can be set on your publish or subscribe operations in the AsyncAPI document, allowing you not only to name the generated function, but also tie two operations together to form a function that subscribes to one channel and publishes to another when the same name is used. For example, if your AsyncAPI document looked like the image below a java.util.function.Function bean called \u201ccalculatePercentage\u201d would be generated which subscribes to the input channel and publishes to the output channel. \n```javascript\n1channels:\n2  'input':\n3    subscribe:\n4      x-scs-function-name: calculatePercentage\n5      message:\n6        $ref: '#/components/messages/CovidTracking_SingleStateCurrentDataUpdate'\n7  'output':\n8    publish:\n9      x-scs-function-name: calculatePercentage\n10      message:\n11        $ref: '#/components/messages/CovidTracking_SingleStateTestPercentagesUpdate'\n```\n The x-scs-destination specification extension can be specified on a subscribe operation, allowing you to override the default destination value which usually matches the channel. This is useful when you are using the Solace binder and you are following the Solace pattern of publishing to topics and consuming from queues. In this case the x-scs-destination value would be treated as the name of the queue which your microservice will consume from and the channel name in the AsyncAPI document will be added as a topic subscription to that queue. The x-scs-group specification extension can also be specified on a subscribe operation, allowing for the addition of a group to the generated Spring Cloud Stream binding . This allows for the use of consumer groups and will end up in a durable queue being created when using the Solace binder. Tips For Using The Code Generator To Create Event-Driven Microservices Using Spring Cloud Stream Besides configuration options there are a few more things to keep in mind when using the generator to create event-driven microservices using Spring Cloud Stream. Make sure generated POJOs have the Java types you would expect for generated variables! For example, if your JSON schema defines an attribute type as a number or integer those are being mapped to a Double or Integer in Java respectively. If you would like another type, such as a float or long, you\u2019ll want to make that change. It is also important to make sure you pay close attention to data that represents dates and/or times as those will likely end up just being represented by a String by default. Dynamic topics are not yet supported by the AsyncAPI SCSt Code Generator. We\u2019ll be looking to enhance them both to support dynamic topics in the future but for now you\u2019ll want to remove dynamic pieces of the topic from your channels in the AsyncAPI document and add them into the code afterwards. When creating a Spring Cloud Stream microservice that does not contain a java.util.function.Supplier include a web server so the microservice continues running and listening for messages to process. This can be done by including the -p actuator=true parameter to include Spring Actuator functionality which itself requires a web server, and also provides some cool management and monitoring capabilities. Alternatively, you can just add the spring-boot-starter-web starter to your pom after it\u2019s been generated. Note this is not an issue with the AsyncAPI generator template, but just a bug with the Solace Spring Cloud Stream binder which will be relevant to people using the generator. I hope those tips are helpful and save you some troubleshooting time! Conclusion I hope this post was useful and you\u2019re able to quickly dive in to generating your own event-driven microservices using Spring Cloud Stream and the AsyncAPI Code Generator after exploring the example described above. You can get started right away and use the Solace PubSub+ Event Portal to generate your AsyncAPI document for FREE by signing up for a new cloud account ! If you have more questions or want to share your experience with the tools, you can let us know in the Solace Community Forum or consider joining us in contributing directly to the AsyncAPI initiative.",
    "code_blocks": [
      "ag https://raw.githubusercontent.com/asyncapi/asyncapi/2.0.0/examples/2.0.0/streetlights.yml @asyncapi/java-spring-cloud-stream-template",
      "ag -o ExpenseIntegration -p binder=solace -p view=provider -p actuator=true -p artifactId=ExpenseIntegration -p groupId=acme.rideshare -p javaPackage=acme.rideshare.expense -p host=localhost:55555 -p username=default -p password=default -p msgVpn=default ~/Downloads/ExpenseIntegration.yaml @asyncapi/java-spring-cloud-stream-template",
      "1@SpringBootApplication\n2public class Application {\n3   private static final Logger logger = LoggerFactory.getLogger(Application.class);\n4   public static void main(String[] args) {\n5      SpringApplication.run(Application.class);\n6   }\n7\n8   @Bean\n9   public Consumer<RideReceipt> acmeRideshareBillingReceiptCreated001Consumer() {\n10      // Add business logic here.\n11      return null;\n12   }\n13}",
      "1spring: \n2  cloud: \n3    stream: \n4      function: \n5        definition: acmeRideshareBillingReceiptCreated001Consumer \n6    bindings: \n7      acmeRideshareBillingReceiptCreated001Consumer-in-0:\n8        destination: acme/rideshare/billing/receipt/created/0.0.1\n9\n10solace: \n11  java: \n12    host: 'localhost:55555' \n13    msgVpn: default \n14    clientUsername: default \n15    clientPassword: default\n16\n17logging: \n18  level: \n19    root: info \n20    org: \n21      springframework: info",
      "1channels:\n2  'input':\n3    subscribe:\n4      x-scs-function-name: calculatePercentage\n5      message:\n6        $ref: '#/components/messages/CovidTracking_SingleStateCurrentDataUpdate'\n7  'output':\n8    publish:\n9      x-scs-function-name: calculatePercentage\n10      message:\n11        $ref: '#/components/messages/CovidTracking_SingleStateTestPercentagesUpdate'"
    ],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/posts/asyncapi-codegen_pic-00.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/asyncapi-codegen_pic-01.webp",
        "alt": "asyncapi playground for creating microservices using spring cloud stream"
      },
      {
        "src": "/img/posts/asyncapi-codegen_pic-02.webp",
        "alt": "pic2"
      },
      {
        "src": "/img/posts/asyncapi-codegen_pic-03.webp",
        "alt": "pic3"
      },
      {
        "src": "/img/posts/asyncapi-codegen_pic-04.webp",
        "alt": "pic4"
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "e846e2c6",
    "title": "Full automation of release to NPM and Docker Hub with GitHub Actions and Conventional Commits | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/blog/automated-releases.html",
    "content": "Full automation of release to NPM and Docker Hub with GitHub Actions and Conventional Commits | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page What full automation means Conventional Commits Workflow design GitHub Actions Release workflow GitHub and NPM Docker Bump version in package.json Conditions and sharing outputs Full workflow Automated merging workflow Conclusions \n![](/img/posts/robot.webp)\n tl;dr from now on, we release generator in an automated way. We roll-out this setup to the rest when we see it is needed. Repetitive tasks are tedious. If what you do manually can be automated, then what are you waiting for! But these tasks take only a couple of minutes from time to time, gimme a break A couple of minutes here, a couple of minutes there and all of a sudden you do not have time on more important things, on innovation. Automation makes it easier to scale and eliminates errors. Distractions consume time and make you less productive. We kick ass at AsyncAPI Initiative at the moment. We started to improve our tooling regularly. We are now periodically sharing project status in our newsletter , and host bi-weekly open meetings , but most important is that we just recently updated our roadmap. Am I just showing off? It sounds like, but that is not my intention. I wish to point out we are productive, and we want to continue this trend and automation helps here a lot. If you have libraries that you want to release regularly and you plan additional ones to come, you need to focus on release automation. What full automation means Full automation means that the release process if fully automated with no manual steps. What else did you think? Your responsibility is just to merge a pull request. The automation handles the rest. You might say: but I do not want to release on every merge, sometimes I merge changes that are not related to the functionality of the library . This is a valid point. You need a way to recognize if the given commit should trigger the release and what kind of version, PATCH, or MINOR. The way to do it is to introduce in your project Conventional Commits specification. Conventional Commits At AsyncAPI Initiative we use Semantic Versioning . This is why choosing Conventional Commits specification was a natural decision. Purpose of Conventional Commits is to make commits not only human-readable but also machine-readable. It defines a set of commit prefixes that can be easily parsed and analyzed by tooling. This is how the version of the library looks like when it follows semantic versioning: MAJOR.MINOR.PATCH . How does the machine know what release you want to bump because of a given commit? Simplest mapping looks like in the following list: Commit message prefix fix: indicates PATCH release, Commit message prefix feat: indicates MINOR release, Commit message prefix {ANY_PREFIX}!: so for example feat!: or even refactor!: indicate MAJOR release. It other words, assume your version was 1.0.0, and you made a commit like feat: add a new parameter to test endpoint . You can have a script that picks up feat: and triggers release that eventually bumps to version 1.1.0. Workflow design At AsyncAPI Initiative where we introduced the release pipeline for the very first time, we had to do the following automatically: Tag Git repository with a new version Create GitHub Release Push new version of the package to NPM Push new version of Docker image to Docker Hub Bump the version of the package in package.json file and commit the change to the repository This is how the design looks like: \n![npm docker release workflow](/img/posts/release-workflow.webp)\n There are two workflows designed here. The first workflow reacts to changes in the release branch ( master in this case), decides if release should be triggered, and triggers it. The last step of the workflow is a pull request creation with changes in package.json and package-lock.json . Why are changes not committed directly to the release branch? Because we use branch protection rules and do not allow direct commits to release branches. You can extend this workflow with additional steps, like: Integration testing Deployment Notifications The second workflow is just for handling changes in package.json . To fulfill branch protection settings, we had to auto-approve the pull request so we can automatically merge it. GitHub Actions Even though I have my opinion about GitHub Actions , I still think it is worth investing in it, especially for the release workflows. We used the GitHub-provided actions and the following awesome actions built by the community: Create Pull Request Auto Approve Merge Pull Request Release workflow Release workflow triggers every time there is something new happening in the release branch. In our case, it is the master branch: \n```javascript\n1on:\n2  push:\n3    branches:\n4      - master\n```\n GitHub and NPM For releases to GitHub and NPM, the most convenient solution is to integrate semantic release package and related plugins that support Conventional Commits. You can configure plugins in your package.json in the order they should be invoked: \n```javascript\n1\"plugins\": [\n2  [\n3    \"@semantic-release/commit-analyzer\",\n4    {\n5      \"preset\": \"conventionalcommits\"\n6    }\n7  ],\n8  [\n9    \"@semantic-release/release-notes-generator\",\n10    {\n11      \"preset\": \"conventionalcommits\"\n12    }\n13  ],\n14  \"@semantic-release/npm\",\n15  \"@semantic-release/github\"\n16]\n```\n Conveniently, functional automation uses a technical bot rather than a real user . GitHub actions allow you to encrypt the credentials of different systems at the repository level. Referring to them in actions looks as follows: \n```javascript\n1- name: Release to NPM and GitHub\n2  id: release\n3  env:\n4    GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}\n5    NPM_TOKEN: ${{ secrets.NPM_TOKEN }}\n6    GIT_AUTHOR_NAME: asyncapi-bot\n7    GIT_AUTHOR_EMAIL: info@asyncapi.io\n8    GIT_COMMITTER_NAME: asyncapi-bot\n9    GIT_COMMITTER_EMAIL: info@asyncapi.io\n10  run: npm run release\n```\n Aside from automation, the bot also comments on every pull request and issue included in the release notifying subscribed participants that the given topic is part of the release. Isn't it awesome? \n![pr info about release](/img/posts/pr-indicator.webp)\n Docker For handling Docker, you can use some community-provided GitHub action that abstracts Docker CLI. I don't think it is needed if you know Docker. You might also want to reuse some commands during local development, like image building, and have them behind an npm script like npm run docker-build . \n```javascript\n1- name: Release to Docker\n2  if: steps.initversion.outputs.version != steps.extractver.outputs.version\n3  run: |\n4    echo ${{secrets.DOCKER_PASSWORD}} | docker login -u ${{secrets.DOCKER_USERNAME}} --password-stdin\n5    npm run docker-build\n6    docker tag asyncapi/generator:latest asyncapi/generator:${{ steps.extractver.outputs.version }}\n7    docker push asyncapi/generator:${{ steps.extractver.outputs.version }}\n8    docker push asyncapi/generator:latest\n```\n Bump version in package.json A common practice is to bump the package version in package.json on every release. You should also push the modified file to the release branch. Be aware though that good practices in the project are: Do not commit directly to the release branch. All changes should go through pull requests with proper peer review. Branches should have basic protection enabled. There should be simple rules that block pull requests before the merge. Release workflow, instead of pushing directly to the release branch, should commit to a new branch and create a pull request. Seems like an overhead? No, you can also automate it. Just keep on reading. \n```javascript\n1- name: Create Pull Request with updated package files\n2  if: steps.initversion.outputs.version != steps.extractver.outputs.version\n3  uses: peter-evans/create-pull-request@v2.4.4\n4  with:\n5    token: ${{ secrets.GH_TOKEN }}\n6    commit-message: 'chore(release): ${{ steps.extractver.outputs.version }}'\n7    committer: asyncapi-bot <info@asyncapi.io>\n8    author: asyncapi-bot <info@asyncapi.io>\n9    title: 'chore(release): ${{ steps.extractver.outputs.version }}'\n10    body: 'Version bump in package.json and package-lock.json for release [${{ steps.extractver.outputs.version }}](https://github.com/${{github.repository}}/releases/tag/v${{ steps.extractver.outputs.version }})'\n11    branch: version-bump/${{ steps.extractver.outputs.version }}\n```\n Conditions and sharing outputs GitHub Actions has two excellent features: You can set conditions for specific steps You can share the output of one step with another These features are used in the release workflow to check the version of the package, before and after the GitHub/NPM release step. To share the output, you must assign an id to the step and declare a variable and assign any value to it. \n```javascript\n1- name: Get version from package.json after release step\n2  id: extractver\n3  run: |\n4    version=$(npm run get-version --silent)\n5    echo \"version=$version\" >> $GITHUB_OUTPUT\n```\n You can access the shared value by the id and a variable name like steps.extractver.outputs.version . We use it, for example, in the condition that specifies if further steps of the workflow should be triggered or not. If the version in package.json changed after GitHub and NPM step, this means we should proceed with Docker publishing and pull request creation: \n```yaml\nif: steps.initversion.outputs.version != steps.extractver.outputs.version\n```\n Full workflow Below you can find the entire workflow file: \n```javascript\n1name: Release\n2\n3on:\n4  push:\n5    branches:\n6      - master\n7\n8jobs:\n9  release:\n10    name: 'Release NPM, GitHub, Docker'\n11    runs-on: ubuntu-latest\n12    steps:\n13      - name: Checkout repo\n14        uses: actions/checkout@v2\n15      - name: Setup Node.js\n16        uses: actions/setup-node@v1\n17        with:\n18          node-version: 13\n19      - name: Install dependencies\n20        run: npm ci\n21        \n22      - name: Get version from package.json before release step\n23        id: initversion\n24        run: npm run get-version --silent\n25\n26      - name: Set output\n27        run: echo \"version=$(npm run get-version --silent)\" >> $GITHUB_OUTPUT\n28\n29      - name: Release to NPM and GitHub\n30        id: release\n31        env:\n32          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}\n33          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}\n34          GIT_AUTHOR_NAME: asyncapi-bot\n35          GIT_AUTHOR_EMAIL: info@asyncapi.io\n36          GIT_COMMITTER_NAME: asyncapi-bot\n37          GIT_COMMITTER_EMAIL: info@asyncapi.io\n38        run: npm run release\n39      - name: Get version from package.json after release step\n40        id: extractver\n41        run: echo \"::set-output name=version::$(npm run get-version --silent)\"\n42      - name: Release to Docker\n43        if: steps.initversion.outputs.version != steps.extractver.outputs.version\n44        run: |\n45          echo ${{secrets.DOCKER_PASSWORD}} | docker login -u ${{secrets.DOCKER_USERNAME}} --password-stdin\n46          npm run docker-build\n47          docker tag asyncapi/generator:latest asyncapi/generator:${{ steps.extractver.outputs.version }}\n48          docker push asyncapi/generator:${{ steps.extractver.outputs.version }}\n49          docker push asyncapi/generator:latest\n50      - name: Create Pull Request with updated package files\n51        if: steps.initversion.outputs.version != steps.extractver.outputs.version\n52        uses: peter-evans/create-pull-request@v2.4.4\n53        with:\n54          token: ${{ secrets.GH_TOKEN }}\n55          commit-message: 'chore(release): ${{ steps.extractver.outputs.version }}'\n56          committer: asyncapi-bot <info@asyncapi.io>\n57          author: asyncapi-bot <info@asyncapi.io>\n58          title: 'chore(release): ${{ steps.extractver.outputs.version }}'\n59          body: 'Version bump in package.json and package-lock.json for release [${{ steps.extractver.outputs.version }}](https://github.com/${{github.repository}}/releases/tag/v${{ steps.extractver.outputs.version }})'\n60          branch: version-bump/${{ steps.extractver.outputs.version }}\n```\n Automated merging workflow You may be asking yourself: Why automated approving and merging is handled in a separate workflow and not as part of release workflow One reason is that the time between pull request creation and its readiness to be merged is hard to define. Pull requests always include some automated checks, like testing, linting, and others. These are long-running checks. You should not make such an asynchronous step a part of your synchronous release workflow. Another reason is that you can also extend such an automated merging flow to handle not only pull requests coming from the release-handling bot but also other bots, that, for example, update your dependencies for security reasons. You should divide automation into separate jobs that enable you to define their dependencies. There is no point to run the automerge job until the autoapprove one ends. GitHub Actions allows you to express this with needs: [autoapprove] Below you can find the entire workflow file: \n```javascript\n1name: Automerge release bump PR\n2\n3on:\n4  pull_request:\n5    types:\n6      - labeled\n7      - unlabeled\n8      - synchronize\n9      - opened\n10      - edited\n11      - ready_for_review\n12      - reopened\n13      - unlocked\n14  pull_request_review:\n15    types:\n16      - submitted\n17  check_suite:\n18    types:\n19      - completed\n20  status: {}\n21\n22jobs:\n23  autoapprove:\n24    runs-on: ubuntu-latest\n25    steps:\n26      - name: Autoapproving\n27        uses: hmarr/auto-approve-action@v2.0.0\n28        if: github.actor == 'asyncapi-bot'\n29        with:\n30          github-token: '${{ secrets.GITHUB_TOKEN }}'\n31\n32  automerge:\n33    needs: [autoapprove]\n34    runs-on: ubuntu-latest\n35    steps:\n36      - name: Automerging\n37        uses: pascalgn/automerge-action@v0.7.5\n38        if: github.actor == 'asyncapi-bot'\n39        env:\n40          GITHUB_TOKEN: '${{ secrets.GH_TOKEN }}'\n41          GITHUB_LOGIN: asyncapi-bot\n42          MERGE_LABELS: ''\n43          MERGE_METHOD: 'squash'\n44          MERGE_COMMIT_MESSAGE: 'pull-request-title'\n45          MERGE_RETRIES: '10'\n46          MERGE_RETRY_SLEEP: '10000'\n```\n For a detailed reference, you can look into this pull request that introduces the above-described workflow in the generator . Conclusions Automate all the things, don't waste time. Automate releases, even if you are a purist that for years followed a rule of using imperative mood in commit subject and now, after looking on prefixes from Conventional Commits you feel pure disgust. In the end, you can always use something different, custom approach, like reacting to merges from pull requests with the specific label only. If you have time to reinvent the wheel, go for it. Cover photo by Franck V. taken from Unsplash.",
    "code_blocks": [
      "1on:\n2  push:\n3    branches:\n4      - master",
      "1\"plugins\": [\n2  [\n3    \"@semantic-release/commit-analyzer\",\n4    {\n5      \"preset\": \"conventionalcommits\"\n6    }\n7  ],\n8  [\n9    \"@semantic-release/release-notes-generator\",\n10    {\n11      \"preset\": \"conventionalcommits\"\n12    }\n13  ],\n14  \"@semantic-release/npm\",\n15  \"@semantic-release/github\"\n16]",
      "1- name: Release to NPM and GitHub\n2  id: release\n3  env:\n4    GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}\n5    NPM_TOKEN: ${{ secrets.NPM_TOKEN }}\n6    GIT_AUTHOR_NAME: asyncapi-bot\n7    GIT_AUTHOR_EMAIL: info@asyncapi.io\n8    GIT_COMMITTER_NAME: asyncapi-bot\n9    GIT_COMMITTER_EMAIL: info@asyncapi.io\n10  run: npm run release",
      "1- name: Release to Docker\n2  if: steps.initversion.outputs.version != steps.extractver.outputs.version\n3  run: |\n4    echo ${{secrets.DOCKER_PASSWORD}} | docker login -u ${{secrets.DOCKER_USERNAME}} --password-stdin\n5    npm run docker-build\n6    docker tag asyncapi/generator:latest asyncapi/generator:${{ steps.extractver.outputs.version }}\n7    docker push asyncapi/generator:${{ steps.extractver.outputs.version }}\n8    docker push asyncapi/generator:latest",
      "1- name: Create Pull Request with updated package files\n2  if: steps.initversion.outputs.version != steps.extractver.outputs.version\n3  uses: peter-evans/create-pull-request@v2.4.4\n4  with:\n5    token: ${{ secrets.GH_TOKEN }}\n6    commit-message: 'chore(release): ${{ steps.extractver.outputs.version }}'\n7    committer: asyncapi-bot <info@asyncapi.io>\n8    author: asyncapi-bot <info@asyncapi.io>\n9    title: 'chore(release): ${{ steps.extractver.outputs.version }}'\n10    body: 'Version bump in package.json and package-lock.json for release [${{ steps.extractver.outputs.version }}](https://github.com/${{github.repository}}/releases/tag/v${{ steps.extractver.outputs.version }})'\n11    branch: version-bump/${{ steps.extractver.outputs.version }}",
      "1- name: Get version from package.json after release step\n2  id: extractver\n3  run: |\n4    version=$(npm run get-version --silent)\n5    echo \"version=$version\" >> $GITHUB_OUTPUT",
      "1name: Release\n2\n3on:\n4  push:\n5    branches:\n6      - master\n7\n8jobs:\n9  release:\n10    name: 'Release NPM, GitHub, Docker'\n11    runs-on: ubuntu-latest\n12    steps:\n13      - name: Checkout repo\n14        uses: actions/checkout@v2\n15      - name: Setup Node.js\n16        uses: actions/setup-node@v1\n17        with:\n18          node-version: 13\n19      - name: Install dependencies\n20        run: npm ci\n21        \n22      - name: Get version from package.json before release step\n23        id: initversion\n24        run: npm run get-version --silent\n25\n26      - name: Set output\n27        run: echo \"version=$(npm run get-version --silent)\" >> $GITHUB_OUTPUT\n28\n29      - name: Release to NPM and GitHub\n30        id: release\n31        env:\n32          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}\n33          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}\n34          GIT_AUTHOR_NAME: asyncapi-bot\n35          GIT_AUTHOR_EMAIL: info@asyncapi.io\n36          GIT_COMMITTER_NAME: asyncapi-bot\n37          GIT_COMMITTER_EMAIL: info@asyncapi.io\n38        run: npm run release\n39      - name: Get version from package.json after release step\n40        id: extractver\n41        run: echo \"::set-output name=version::$(npm run get-version --silent)\"\n42      - name: Release to Docker\n43        if: steps.initversion.outputs.version != steps.extractver.outputs.version\n44        run: |\n45          echo ${{secrets.DOCKER_PASSWORD}} | docker login -u ${{secrets.DOCKER_USERNAME}} --password-stdin\n46          npm run docker-build\n47          docker tag asyncapi/generator:latest asyncapi/generator:${{ steps.extractver.outputs.version }}\n48          docker push asyncapi/generator:${{ steps.extractver.outputs.version }}\n49          docker push asyncapi/generator:latest\n50      - name: Create Pull Request with updated package files\n51        if: steps.initversion.outputs.version != steps.extractver.outputs.version\n52        uses: peter-evans/create-pull-request@v2.4.4\n53        with:\n54          token: ${{ secrets.GH_TOKEN }}\n55          commit-message: 'chore(release): ${{ steps.extractver.outputs.version }}'\n56          committer: asyncapi-bot <info@asyncapi.io>\n57          author: asyncapi-bot <info@asyncapi.io>\n58          title: 'chore(release): ${{ steps.extractver.outputs.version }}'\n59          body: 'Version bump in package.json and package-lock.json for release [${{ steps.extractver.outputs.version }}](https://github.com/${{github.repository}}/releases/tag/v${{ steps.extractver.outputs.version }})'\n60          branch: version-bump/${{ steps.extractver.outputs.version }}",
      "1name: Automerge release bump PR\n2\n3on:\n4  pull_request:\n5    types:\n6      - labeled\n7      - unlabeled\n8      - synchronize\n9      - opened\n10      - edited\n11      - ready_for_review\n12      - reopened\n13      - unlocked\n14  pull_request_review:\n15    types:\n16      - submitted\n17  check_suite:\n18    types:\n19      - completed\n20  status: {}\n21\n22jobs:\n23  autoapprove:\n24    runs-on: ubuntu-latest\n25    steps:\n26      - name: Autoapproving\n27        uses: hmarr/auto-approve-action@v2.0.0\n28        if: github.actor == 'asyncapi-bot'\n29        with:\n30          github-token: '${{ secrets.GITHUB_TOKEN }}'\n31\n32  automerge:\n33    needs: [autoapprove]\n34    runs-on: ubuntu-latest\n35    steps:\n36      - name: Automerging\n37        uses: pascalgn/automerge-action@v0.7.5\n38        if: github.actor == 'asyncapi-bot'\n39        env:\n40          GITHUB_TOKEN: '${{ secrets.GH_TOKEN }}'\n41          GITHUB_LOGIN: asyncapi-bot\n42          MERGE_LABELS: ''\n43          MERGE_METHOD: 'squash'\n44          MERGE_COMMIT_MESSAGE: 'pull-request-title'\n45          MERGE_RETRIES: '10'\n46          MERGE_RETRY_SLEEP: '10000'"
    ],
    "yaml_blocks": [
      "if: steps.initversion.outputs.version != steps.extractver.outputs.version"
    ],
    "images": [
      {
        "src": "/img/posts/robot.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/release-workflow.webp",
        "alt": "npm docker release workflow"
      },
      {
        "src": "/img/posts/pr-indicator.webp",
        "alt": "pr info about release"
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "c83961ff",
    "title": "Beyond Boundaries - Empowering Through OSS Mentorship | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/blog/beyond-boundaries.html",
    "content": "Beyond Boundaries - Empowering Through OSS Mentorship | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Our Backstory Why Start Our Own OSS Mentorship Program? The Journey Proved To Be More Challenging Than Anticipated How We Are Approaching These Challenges For The Next Cohorts Our Relationship With Potential Mentors How We Engage Contributors In The Community During The Mentorship Program Where Are We? Current Cohort Projects Who Is This Program For? Would you be interested in sponsoring our program? How To Connect With Us \n![](/img/posts/beyond.webp)\n In 2022 we piloted our innovative mentorship program that focuses on open-source software(OSS). We envisioned a platform where aspiring developers could learn, grow, and contribute to exciting projects while receiving guidance from experienced mentors. Our Backstory At AsyncAPI, we value giving back to the community, giving us a sense of purpose as a community-first organization. We are always looking for ways to participate in open-source mentorship programs like Google Summer of Code(GSoC), Google Season of Docs(GSoD), and more because the fulfilling feeling of contributing to society gotten from these programs is unparalleled. As an open-source organization, we participate to collaborate with a broader reach of enthusiasts and help bring more folks into this world(which we are already doing). Furthermore, our reason for participating in these programs comes from our passion for open source and the care to support and encourage contributors by building and participating in mentorships. Why Start Our Own OSS Mentorship Program? In 2021, AsyncAPI participated in its first paid mentorship program alongside Postman under Google Summer Of Code(GSoC). After applying to participate as an organization for GSoC in 2021, we got rejected and were opportune to participate alongside Postman. Postman is an established software development company committed to open-source initiatives. We received a lot of engagement from folks interested in our projects despite having just a few slots allocated to us by Postman. Fast forward to 2022, we applied for GSoC and got rejected again. This time, Postman also got rejected, leaving us in shock because many folks were already looking forward to joining us. The shock and disappointment permeated the team's spirits, but they refused to let this setback deter them from their mission. Determined to overcome this unexpected obstacle, we regrouped and brainstormed alternative strategies to keep the program afloat. What had initially seemed like a devastating rejection transformed into an opportunity for growth and resilience. The team's unwavering passion and refusal to accept defeat turned their setback into a stepping stone toward even greater success. The Journey Proved To Be More Challenging Than Anticipated We knew piloting an in-house mentorship program would be challenging, so we made the initial program a way to collect feedback. We approached the program flexibly, avoiding rigid decisions or commitments. During the project ideas phase, we received 19 project ideas , and ten of these projects made it to the final phase but out of the ten selected candidates for the program only six were able to complete their project. This program addresses the real needs of the open-source community. It ensures the program leaders forge meaningful relationships with the participants to ensure their diverse voices are heard and provide them with resources, advice, and networking opportunities. How We Are Approaching These Challenges For The Next Cohorts At AsyncAPI, mentorship programs are practical tools for teaching and upskilling professionals. When managed well, they can create significant benefits for mentees and lasting benefits and impact for mentors. However, we know it takes some strategy and finesse to operate a mentorship program that lasts and reaches its potential. That's why we've organized a way to keep our Mentees on schedule to complete their projects using the following method: Reduce the level of stress in the program. Encourage them to ask when they need help. Ask them what they want. Connect often. Share stories and struggles. Agree on expectations. Emphasize good self-care. Our Relationship With Potential Mentors All of AsyncAPI's mentors are core community members and prominent advocates for open-source projects with a strong belief in FOSS, which means keeping them engaged will require just a little effort. But we still keep them engaged by staying connected and ensuring communication channels go both ways, showing how they made a difference and valuing the opinions of every mentor. How We Engage Contributors In The Community During The Mentorship Program We value every single contribution at AsyncAPI, and there is a nearly immediate value to people using and contributing to AsyncAPI. If and when they contribute code, the quicker it gets integrated into the main codebase, the happier the contributor will be. We also know contributors like to be challenged and to learn new things, and they like to work on code that's known to be of high quality and work with projects that positively impact the industry. This quality makes AsyncAPI stand out and will encourage contributors to be involved in the community during the program. Furthermore, we ensure contributors are heard and respected and give them public credit for their work to encourage them to contribute. We ensure contributors have direct access to the main maintainer(s) and can have meaningful discussions with them. Where Are We? With the next cohort kicking off, we put things such as the [program guidline] in place, including the Evaluation Period . And we received a significant surge in this current cohort(2023) application phase! We received 29 project ideas, 10 of which were selected for the program, over 90+ proposals were received across all of these ten projects, and 13 candidates made it to the final selection phase. Unlike the previous year(2022), we were not only accepting code-related projects but also design and technical writing, which means anyone can be a part of the program this year. Comparing this to the previous year, we are proud of this current trajectory and can't wait to see the numbers for the coming years, how much growth awaits us as a community, and how fantastic the projects under this great initiative will become with all of these contributions. Current Cohort Projects No Project Idea Mentor/s Category Mentee/s 1 Add help/{command} endpoint David Pereira Engineering Prince Rajpoot 2 Website UI Kit design/dev project AceTheCreator Design AISHAT MUIBUDEEN 3 MVP integration of extensions catalog with AsyncAPI tools Lukasz Gornicki Engineering Sambhav Gupta 4 Documenting how different protocols work with AsyncAPI Quetzalli Writes Documentation Cynthia Peter , Arya Gupta , Joy Almeida , Vaishnavi Nandakumar 5 Rewrite this template and NodeJS WS template Lukasz Gornicki Engineering Kaushik Rishi 6 Simulator Desktop Application Nektarios Fifes Engineering Sumant Tirkey 7 Tutorial document or separate guides for glee Souvik & Khuda Dad Nomani Documentation Afzal Ansari 8 Add support for translations Maciej Urba\u0144czyk Engineering Ansh Goyal 9 Prepare CLI for v1.0.0 release Souvik Engineering Ashish Padhy 10 DocsUI: Messages Object output Missy Turco & Fran M\u00e9ndez Design Asmit Malakannawar Who Is This Program For? If you're new to the world of open-source or you'd love to get paid for doing open-source for some time, then this program is definitely for you. Would you be interested in sponsoring our program? By sponsoring us, we can use your sponsorship funds to provide more slots in future mentorship programs for candidates interested in elevating their careers via open-source contributions. How To Connect With Us Join our Slack workspace . Just make sure to follow our Slack etiquette and the code of conduct . Join the dedicated Mentorship channel #mentorships that we use for all mentorships discussion. All mentees and mentors are there. Photo by Rachel on Unsplash",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/posts/beyond.webp",
        "alt": ""
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "4928959f",
    "title": "Change is coming to our AsyncAPI Developer Documentation | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/blog/changes-coming-docs.html",
    "content": "Change is coming to our AsyncAPI Developer Documentation | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page \ud83e\udd84 Hola, soy Quetzalli Writes \ud83d\udc69\ud83c\udffb\u200d\ud83d\udcbb What I do for AsyncAPI Docs \ud83d\udc84 AsyncAPI Docs are getting a makeover! \ud83d\ude2d Why do we need to make so many changes? \ud83e\udea3 Agnostic Content Buckets, coming right up The Di\u00e1taxis 4-Part Classification System: \ud83d\udc81\ud83c\udffb\u200d\u2640\ufe0f How does the Di\u00e1taxis system apply to an actual technology? \ud83d\udc49\ud83c\udffd How to contribute to AsyncAPI Docs \ud83d\ude42 Talk to me \n![](/img/posts/changes-coming-docs/mind-map.webp)\n \ud83e\udd84 Hola, soy Quetzalli Writes \u00a1Hola! \ud83d\ude04 AsyncAPI community, it's an absolute pleasure to meet you. My name is Quetzalli. I was born and raised in M\u00e9xico \ud83c\uddf2\ud83c\uddfd , so my first language is Spanish. I\u2019m a Senior Technical Writer \ud83d\udc69\ud83c\udffb\u200d\ud83d\udcbb recently hired by Postman to focus solely on the Open-Source (OSS) AsyncAPI initiative as primary owner for our AsyncAPI Dev Docs \ud83d\udcc4 . I also recently joined our initiative's Technical Steering Committee (TSC) ! The TSC is responsible for the oversight of the AsyncAPI Initiative, helping make decisions on a higher level, or when maintainers cannot find a consensus. By the second day, I was already working on community Pull Requests (PRs) and getting to know more of our community members. This direct engagement with community feels amazing, because I really do want to help as much as I can. I'm excited to listen what our OSS community thinks needs to be documented first. Before I tell you more details about upcoming changes to the Docs and how you can contribute to them, I also want to share more granular details about my work here within our OSS community. \ud83d\udc69\ud83c\udffb\u200d\ud83d\udcbb What I do for AsyncAPI Docs Own the docs for the AsyncAPI feature set \u2014 documenting this specific area of our Open Technologies function and driving all docs efforts around it. Plan documentation in conjunction with OSS community feedback \u2014 working with open-source communities to learn about a feature from specifications and user research. Collaborate closely with Developer Relations to ensure docs, educational, and learning materials align with community needs: this includes assisting with documentation, tutorials, and all education efforts within AsyncAPI. Conduct editorial reviews on community doc drafts \u2014 providing constructive and kind feedback that helps colleagues to grow. Liaise with stakeholders across the AsyncAPI Initiative to establish and address docs needs. Maintain AsyncAPI Docs GitHub Discussions . \ud83d\udc84 AsyncAPI Docs are getting a makeover! Now that I've introduced myself, my role, and high-level goals, I wanted to tell you more about some of the cool stuff coming up for AsyncAPI Docs. Pretty big changes are coming to our Dev Docs; in fact, our first \"big\" item to tackle will be giving the Information Architecture (IA) a makeover! \ud83d\ude2d Why do we need to make so many changes? The current docs and repo READMEs were(are) made with much care and love, but with growth comes change, and with change comes improvements! In our case, we need to add... Conceptual docs that explain our spec terminology in more detail that include engineering diagrams : people often learn visually! Many more tutorials . (i.e. Websocket tutorial) CLI docs under a Reference content bucket. A tools section ! Currently we have documentation for our tools in individual tools' GitHub repos, under a /docs directory. Those should still remain there and continue to be maintained, but they also need to be documented in our Docs in a less informal way than what you see in a README . Usecases and Troubleshooting Guides , under a new How-To section. \ud83e\udea3 Agnostic Content Buckets, coming right up Engineering Documentation can and should be divided into agnostic content buckets. Currently, our documentation has the following content buckets: Getting Started Tutorials Specification Community In upcoming months, the plan is to change it to the following content buckets instead: Concepts Tutorials Reference How-To Tools Why, you wonder? It was important (and exciting!) to me to introduce best practices from the Di\u00e1taxis Framework for our new content buckets. \n![Di\u00e1taxis framework](/img/posts/changes-coming-docs/diataxis.webp)\n Photo from Di\u00e1taxis on Di\u00e1taxis framework The Di\u00e1taxis engineering documentation system classifies content under 4 main agnostic buckets. This approach for Information Architecture (IA) and User Flows in dev docs is currently upheld widely within the tech industry. (i.e. One current live example is GatsbyJS, which also uses the Di\u00e1taxis system for their Dev Docs. If you want to see a longer list of companies using it, go over here .) The Di\u00e1taxis 4-Part Classification System: concepts: Defining concepts within a technology's features and capabilities. how-to: Solve a problem or advanced use case by doing. tutorial: Learn a beginner process or concept by doing. reference: Learn how to set up your development environment, CLI, APIs, etc. \ud83d\udc81\ud83c\udffb\u200d\u2640\ufe0f How does the Di\u00e1taxis system apply to an actual technology? Let\u2019s take a look at the following Mind Map. \n![Mind Map, displaying Di\u00e1taxis system applied to documenting AsyncAPI capabilities](/img/posts/changes-coming-docs/mind-map.webp)\n Here we see that the AsyncAPI CLI and Spec fall under the Reference bucket. The Concepts bucket details AsyncAPI's specification concepts and terms that deserve to be covered in more detail. But when it comes to understanding the difference between what fits under a Tutorial vs. a How-To bucket, it feels harder to understand. Let\u2019s make the subtle difference between the audiences for Tutorial and How-To buckets clearer. The Tutorial bucket Think of a Tutorial as something that you need to teach a user that is new to your technology. A first-time AsyncAPI user. A user who is new to APIs AND AsyncAPI. The How-To bucket Think of a How-To as the bucket to address problems and advanced scenarios that you already know your users will encounter. These problems tend to fall under unique usecases or advanced troubleshooting guides that a more active user would encounter. How to generate documentation from an AsyncAPI file How to generate a standalone static website with documentation How to generate documentation in a component that you can embed in an existing website How to generate markdown How to generate PDFs How to reuse schema definitions from an OpenAPI file with an AsyncAPI file Organising your AsyncAPI files Generating documentation from your AsyncAPI files Describing WebSocket APIs with AsyncAPI \ud83d\udc49\ud83c\udffd How to contribute to AsyncAPI Docs Did you know that you can contribute Docs to AsyncAPI as well? Code isn't the only way to contribute to OSS; Dev Docs are a huge help that benefit the entire OSS ecosystem. At AsyncAPI, we value Doc contributions as much as every other type of contribution. \u2764\ufe0f To get started as a Docs contributor: Familiarize yourself with our project's Contribution Guide and our Code of Conduct . Head over to our AsyncAPI Docs Board . Pick an issue you would like to contribute to and leave a comment introducing yourself. This is also the perfect place to leave any questions you may have on how to get started. If there is no work done in that Docs issue yet, feel free to open a PR and get started! Docs contributor questions Do you have a documentation contributor question and you're wondering how to tag me into a GitHub discussion or PR? Never fear! Tag me in your AsyncAPI Doc PRs or GitHub Discussions via my GitHub handle, quetzalliwrites \ud83d\udc19 . \ud83d\ude42 Talk to me I want and need to listen \ud83d\udc42\ud83c\udffd to all of your perspectives and ideas. Please don't be shy to express to me what you think needs to be documented first or what is missing. \ud83d\udcdd There's a lot of good work ahead, but you determine our content roadmap because the OSS community needs should always come first. \u2728",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/posts/changes-coming-docs/mind-map.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/changes-coming-docs/diataxis.webp",
        "alt": "Di\u00e1taxis framework"
      },
      {
        "src": "/img/posts/changes-coming-docs/mind-map.webp",
        "alt": "Mind Map, displaying Di\u00e1taxis system applied to documenting AsyncAPI capabilities"
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "abb84368",
    "title": "From Mentee to Maintainer: The Ashmit GSoC Story! | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/blog/community-spotlight-ashmit.html",
    "content": "From Mentee to Maintainer: The Ashmit GSoC Story! | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page The GSoC Experience: A Transformative Phase Getting Started with Google Summer of Code and AsyncAPI The Project: Revamping the AsyncAPI Conference Website Challenges and Learning Experiences Community Experience and Mentorship Key Takeaways and Advice for Future GSoC Mentees Looking Ahead: What\u2019s Next for Ashmit? \n![](/img/posts/marketing-images/ashmit-story.webp)\n Open-source contributions have long been a gateway for developers to refine their skills, build meaningful projects, and connect with a global community. For many, the journey starts with small contributions, but for some, it evolves into a leadership role that impacts the project\u2019s future. One such inspiring story is that of Ashmit Jagtap , whose path from a Google Summer of Code (GSoC) mentee to a maintainer within AsyncAPI showcases dedication, learning, and a deep commitment to open-source development. In this blog post, we explore his journey, challenges, and the lessons he learned. The GSoC Experience: A Transformative Phase Ashmit\u2019s open-source journey began with his participation in GSoC, an esteemed program that connects aspiring developers with organizations working on impactful projects. His interest in API documentation and event-driven architectures fueled his decision to contribute to the AsyncAPI Initiative. As a mentee, he worked on refining the AsyncAPI Conference website, and he was mentored by experienced contributors who provided guidance, code reviews, and architectural insights. Reflecting on his GSoC experience, Ashmit emphasizes the steep learning curve and the importance of proactive engagement. He recalls, \u201cInitially, I was overwhelmed by the scale of the project, but the community was incredibly supportive. I learned how to navigate large codebases, enhance my problem-solving skills, and contribute in a structured manner.\u201d This phase allowed him to grasp not only the technical aspects of the project but also the collaborative spirit of open-source communities. We then asked Ashmit about his GSoC experience with the AsyncAPI Initiative. Below, I've included an outline of our conversation. Getting Started with Google Summer of Code and AsyncAPI Bami: What inspired you to apply for Google Summer of Code with AsyncAPI? Ashmit: Google Summer of Code had been a goal of mine since my first year of college when I first learned about it. However, I knew it was a competitive program, so I focused on building my skills. I was ready to contribute by my second year and began working towards it in January. Initially, I aimed to contribute to Postman, but my contributions to both projects led to my selection for AsyncAPI. Bami: How did you first learn about AsyncAPI, and what motivated you to contribute to the community? Ashmit: I discovered AsyncAPI while exploring Postman\u2019s GSoC issues. The event-driven architecture and the mission of promoting open-source software intrigued me. My first significant interaction was with the VS Code extension for AsyncAPI, which allows users to preview YAML files. Later, I explored AsyncAPI React and the CLI tool. However, my primary project was the conference website, the most active repository due to an upcoming event. The Project: Revamping the AsyncAPI Conference Website Bami: Can you tell us about your project, the problem it solved, and why was it important? Ashmit: The primary goal of my project was to make maintaining the conference website easier. Previously, the website had to be rebuilt or heavily refactored yearly due to a lack of a consistent theme or streamlined process, creating a significant workload for maintainers. My project aimed to standardize the codebase, making it easier to update and maintain. Additionally, I introduced automated testing to simplify reviewing contributions, ensuring that new changes wouldn\u2019t break existing functionality. Challenges and Learning Experiences Bami: What was the most challenging part of your project, and how did you overcome it? Ashmit: The most unexpected challenge occurred towards the end of the program when my project wouldn\u2019t build successfully just before the final submission deadline. After deliberation, we merged the pull request and troubleshot the issue later. Unfortunately, this action caused the website to crash temporarily. My mentors and I worked intensively for a few hours to restore the website's functionality. It was stressful, but it reinforced the importance of testing and careful deployment. Bami: What technologies and skills did you use for your project? Did you have to learn anything new? Ashmit: My project primarily used JavaScript, focusing on Next.js for the front end. For testing, I used Cypress for end-to-end testing. While I didn\u2019t learn a completely new programming language during GSoC, I did have to learn TypeScript during the proposal phase and improve my understanding of testing methodologies. Community Experience and Mentorship Bami: How was your experience with the AsyncAPI community and your mentors? Ashmit: My mentors, Aishat Muibudeen , Thulisile Sibanda , and Elegbede Azeez , were incredibly supportive. I\u2019ve been involved with AsyncAPI for nearly a year and have been a maintainer for about five months. The community is hardworking, collaborative, and always looking to improve the project. The mentorship aspect was especially valuable in helping me balance my college studies with my GSoC responsibilities. My mentors were understanding and even took on tasks when I was unavailable. Bami: Did you face any unexpected challenges or surprises during the program? Ashmit: Everything went smoothly apart from the final submission issue. However, the most unexpected challenge was adapting to remote collaboration. Before GSoC, I wasn\u2019t very experienced with remote work. The program helped me develop asynchronous communication and project management skills, which are crucial in open-source and professional environments. Key Takeaways and Advice for Future GSoC Mentees Bami: What were your key takeaways from the GSoC experience? Ashmit: One of my biggest takeaways was that anything is achievable with hard work and patience. Initially, I doubted my chances of being selected, but I put in the effort and succeeded. Another key lesson was the importance of structured workflows in open-source projects, which significantly improves maintainability. Bami: Has this experience changed your perception of open-source? Was this your first time contributing? Ashmit: No, this wasn\u2019t my first open-source experience. I previously participated in Hacktoberfest 2021 when they still gave out T-shirts! However, being a GSoC mentee and later a maintainer was a different experience. As a mentee, you focus on individual contributions, whereas as a maintainer, you oversee multiple contributions and ensure the stability of the project. It gave me a deeper appreciation of the responsibilities maintainers handle. Bami: Any advice for future GSoC mentees or newcomers to AsyncAPI? Ashmit: I have two main pieces of advice: be patient and work hard. Open-source is community-driven, and maintainers often have full-time jobs, so responses to contributions can take time. Patience is essential. Hard work is equally important\u2014keep learning, refining your skills, and making meaningful contributions. Looking Ahead: What\u2019s Next for Ashmit? Bami: What are your plans after GSoC? Will you continue contributing to AsyncAPI or explore other open-source projects? Ashmit: I am currently focusing on completing my degree and securing a position in a good software company. However, I will continue contributing to open-source because it has given me so much, and I feel a responsibility to give back. While AsyncAPI remains my primary focus, I am also interested in projects like Chromium, though I know it\u2019s quite a challenging one to take on. Bami: Are there any new features or improvements you\u2019d like to see in AsyncAPI? Ashmit: Specifically for the conference website, I have some ideas for future improvements. However, AsyncAPI is constantly evolving, and I look forward to contributing to its growth and helping the community in any way I can. To add a bit of fun to our spotlight interview, we played a This or That game with Ashmit. Bami: Okay, so I have a fun activity to do with you. It is called this for that. So GitHub or GitLab. Ashmit: GitHub Bami: Slack or Discord. Ashmit: Discord Bami: LinkedIn or Twitter? Ashmit: Neither. I deleted both of them just this week. Yeah, both are toxic in their own ways, to be honest. Bami: Google Docs or Microsoft Word. Ashmit: Google Docs. Bami VS Code or Xcode Ashmit: Vs Code Bami: Window or Linux Ashmit: Linux. Not hardcore Linux, like Fedora though. Bami: Apple or Samsung. Ashmit: Samsung Bami: How do you like to spend your time outside coding? Do you have any hobbies or interests? Ashmit: I might say cooking is one of them for hobbies. Yeah, I do enjoy cooking sometimes because when I have some spare time, that's where I go, towards the kitchen. Bami: Is there anyone or a lot of people you would like to thank or give a shout-out to from the community or the GSoC program, either your other mentees, your mentors, or other community members. Ashmit: The mentors I would like to shout out are Aishat Muibudeen , Thulisile Sibanda , and Elegbede Azeez . And on top of that, I would like to thank Lukasz Gornicki for being quite helpful. Some issues in my project required his assistance, and he was there for them. That's nice of him because he didn't have to do it. For those considering GSoC or open-source contributions, Ashmit advises, \u201cStart with issues labeled \u2018good first issue,\u2019 ask questions, and don\u2019t be afraid to make mistakes. Open-source communities thrive on collaboration and learning together.\u201d Ashmit Jagtap\u2019s story is a testament to the power of open-source in shaping careers and fostering innovation. His transition from a GSoC mentee to an AsyncAPI maintainer underscores the importance of dedication, community engagement, and continuous learning. Whether you are a beginner exploring open-source or an experienced developer looking to give back, Ashmit\u2019s journey inspires you to take that first step, contribute meaningfully, and grow within the community. At AsyncAPI, we welcome new contributors and encourage them to embark on their open-source journeys. Who knows\u2014your story might be the next one we celebrate!",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/posts/marketing-images/ashmit-story.webp",
        "alt": ""
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "0e63ebe4",
    "title": "AsyncAPI Conference 2024 Report | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/blog/conference-2024-summary.html",
    "content": "AsyncAPI Conference 2024 Report | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Planning Process Challenges Attendance Conference Sponsors Special Shout Out Where To In 2025? Call for Speakers, Singapore \n![](/img/posts/2024-conference/banner-2024.webp)\n As the saying goes, \"The second time is a charm.\" AsyncAPI Conf on Tour returned in 2024 for a set of events across different locations. Not only did we run in-person conferences, but we also brought back our beloved online conference this time around, making the whole experience complete. In the AsyncAPI Conf on Tour 2023, I mentioned a few things I would love to improve; let's see what we changed, the challenges we faced, and what we are changing as we advance. Planning Process After a successful partnership with the APIdays Paris event, they offered to sponsor a track at other events they were hosting. Given the positive outcome in Paris, we were eager to explore the options. We decided to hold three in-person events with APIdays as our venue and host sponsor. Later in the year, I thought it would be a great idea to bring back the online conference to provide an opportunity for those who can't travel but still want to speak and share their expertise. This idea completed the entire experience, bringing the total number of events to four. \n![](/img/posts/2024-conference/venues.webp)\n For a detailed summary of what happened at each event, please read the following summaries: AsyncAPI Conference Helsinki AsyncAPI Conference London AsyncAPI Online Conference AsyncAPI Conf in Paris Challenges The first challenge we faced was that most of the conferences were held in Europe this time, and for many, obtaining a Schengen visa isn't an easy process. Secondly, although we have a venue and host sponsor, we still need financial support to cover costs such as shipping swags and providing travel funding for speakers. Attendance We had an incredible turnout for all our in-person events. The highlight was networking with community members, ambassadors, and friends at the APIs Standards booth. This booth became a hub for discussions with various companies and experts while maintaining vendor neutrality. Over 580 people attended our in-person conference, and we had more than 450 views during our AsyncAPI Online Conference livestream. Additionally, the recorded sessions received over 446 views after the conference. You can also catch up on the recordings from the AsyncAPI Online Conference . Conference Sponsors AACoT'24 was possible thanks to APIdays , our Event Host and Sponsor. They not only provided a venue to host the conferences and sponsored us for lunch, breakfast, and refreshments, but we also had an API Standards booth. I want to thank our financial sponsors, Gravitee.io and Postman , for supporting the conference. Thanks to their sponsorship, I traveled to London to support the event in person. Additionally, we were able to provide partial assistance to speakers at the Paris conference and covered the logistics of swag shipment. \n![postman](/img/sponsors/postman.png)\n Special Shout Out Firstly, my gratitude goes out to all the speakers for dedicating their time to share their expertise and provide valuable insights to the community. Secondly, I want to thank all the community members who volunteered at the API Standards booth during the conference. Your commitment to sharing knowledge with attendees is greatly appreciated and does not go unnoticed. Lastly, I am genuinely thankful for their hard work and commitment to assisting me behind the scenes. They led and contributed to the aspects that made the conference successful and even being a courier so that we could have materials and set up the booth tables. Lukasz Gornicki Azeez Elegbede Barbara Czy\u017c Khuda Dad Nomani Aishat Muibudeen Oluwabamikemi Kayode Ashmit Jagtap Where To In 2025? For AsyncAPI Conference 2025, we are excited to announce that APIdays will be hosting us in: Singapore on the 15th - 16th of April . Munich on the 2nd - 3rd of July . London on the 22nd - 24th of September . Paris on the 9th -11th of December . APIConf Lagos will be hosting us in Lagos, Nigeria, on the 18th - 19th of July . We will also have our annual AsyncAPI Online Conference on the 29th of October . We are looking for financial sponsors, and if you know any company that will be interested, please download and share our conference sponsorship prospectus . You can also check out our Open Collective Page to explore sponsorship tiers. Alternatively, for more details on partnerships, please email us at info@asyncapi.io . Call for Speakers, Singapore The call for speakers for AsyncAPI Conf Singapore is now open ! Send those proposals and share your knowledge and expertise with the community. The submission deadline is on the 23rd of February, so don't miss out. When submitting your proposal, please follow these simple steps to ensure you choose the correct track: Click on the link and select \"Start.\" Choose option A, \"apidays Singapore 2025,\" and click \"OK.\" In the conference track selection, choose option I, \"AsyncAPI.\" After that, you can submit your details! Looking forward to receiving your submissions!",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/posts/2024-conference/banner-2024.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/2024-conference/venues.webp",
        "alt": ""
      },
      {
        "src": "/img/sponsors/postman.png",
        "alt": "postman"
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "86eb4deb",
    "title": "\ud83d\udcd1 Google Season of Docs 2022 at AsyncAPI | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/blog/google-season-of-docs-2022.html",
    "content": "\ud83d\udcd1 Google Season of Docs 2022 at AsyncAPI | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page \u00a1Hola, AsyncAPI community! Update Docs Information Architecture - AsyncAPI Initiative About AsyncAPI About our Docs project Our current Docs problem Our Docs project\u2019s scope Measuring our Docs project\u2019s success Timeline Project budget Get started contributing to AsyncAPI Docs Today \u00a1Hola, AsyncAPI community! For today's blog post about AsyncAPI Docs \ud83d\udcd1 , I wanted to share with all technical writers about our organization\u2019s plan for participation in Google Season of Docs 2022 (GSoD) . Any and all technical writers are welcome to come participate with us for GSoD 2022 season, regardless of tech background or years of experience! At AsyncAPI, we love mentoring folks who want to get involved in OSS, tech, and Docs. \u2764\ufe0f As some of you may remember from my Gist Docs update for 31 Jan - 11 Feb 2022 , I noted that GSoD 2022 was coming up and that AsyncAPI wanted to participate in the application process once it opened on February 23, 2022. In anticipation of this, I also created a new AsyncAPI Slack channel named #temp-gsod-2022 that anyone can join! First, join our Slack workspace \u260e\ufe0f and please respect our slack etiquette .\ud83d\ude42 Then join the temp-gsod-2022 channel, our temporary channel to coordinate GSoC 2022 setup. I'll publish regular updates on where we are in the application process, so stay tuned as the process continues. \ud83d\ude04 Join the #temp-gsod-2022 slack channel for: mentees identification mentors identification ideas identification mentees and ideas and mentors matching Below is the project proposal we're submitting to GSoD 2022 and then we close with a reminder of how to get started as an AsyncAPI Docs contributor: Update Docs Information Architecture - AsyncAPI Initiative About AsyncAPI AsyncAPI (currently version 2.3.0, first released in 2016) is an Apache License 2.0 library under the Linux Foundation that seeks to improve the current state of Event-Driven Architectures (EDA). The AsyncAPI Initiative is a specification and growing set of open-source tools to help developers define asynchronous APIs, and build and maintain event-driven architectures. Developers familiar with OpenAPI (aka Swagger) for RESTful APIs will see strong similarities when using AsyncAPI. One common use case is generating documentation (HTML or Markdown) of an asynchronous API. The specification is both platform and language agnostic. Current tooling includes support for common message brokers such as Apache Kafka and RabbitMQ, and languages including Python, Java, and Nodejs. Our long-term goal is to make working with EDAs as easy as working with REST APIs. That goes from documentation to code generation, from discovery to event management, and beyond. Our 150+ Open-Source (OSS) contributors are EDA enthusiasts from all around the world. About our Docs project Our current Docs problem Our current Docs and their Information Architecture (IA) needs a major makeover. The current content buckets are far from ideal and much basic content is missing to help onboard new contributors. Users new to our API spec need /Conceptual docs that explain our spec terminology in more detail with engineering diagrams: people often learn visually! We also have to move our CLI docs under the Docs upcoming new Reference content bucket; currently, we have a README version of CLI docs only. Similarly, we're adding a new and broader /Tools section of documentation for our tools in individual tools' GitHub repositories, under a /docs directory. Those should still remain there and continue to be maintained, but they also need to be documented in our Docs in a less informal way than what you see in a README. In time, we also need to add many more tutorials (i.e. Websocket, Kafka, etc) and Use Cases and Troubleshooting Guides, under a new How-To section. We also need to re-structure the Generator tool docs. Because this is one of our main tools, it's big enough to be it's own independent project for 2022 GSoD. Currently, our Generator docs need a major update, to better explain every single functionality of the Generator. Our Docs project\u2019s scope We're already invested in utilizing the Di\u00e1taxis methodology for determining our content buckets (Concepts, Tutorials, Tools, How-To Guides, Reference) . Along with this change, it makes sense to add new landing pages that introduce each content bucket. Each content bucket landing page could include cards featuring requested content from the community that still needs contributions. Then each card will read, \"Contributors Needed.\" AsyncAPI has several CLI and Tools markdown README documentation in miscellaneous GitHub repositories that we plan to migrate over to the main Docs site. This task is part of our goal for finalizing our 2022 AsyncAPI Docs Information Architecture makeover. We explain this in more detail in our previous OSS blog post titled \"Change is coming to our AsyncAPI Developer Documentation\" . It's also extensively documented in our AsyncAPI Docs GitHub Project Board . In addition, we want to also target improving the Generator tool docs that are only READMEs in a repo right now. The Docs for this one tool are a big enough job to merit being our 2nd proposed project for 2022 GSoD. We're also writing voluntary OSS bi-weekly updates via GitHub Gists to speak about the latest updates made in the AsyncAPI Docs Ecosystem. Due to our commitment to investing time in gaining interest in our community and getting Google excited about us, we've made sure to maintain updates about our Google Season of Docs 2022 application too! In fact, you can take a look at the latest three where we made said mentions here in AsyncAPI Docs update (31 Jan - 11 Feb 2022) , AsyncAPI Docs update (14 Feb - 25 Feb 2022) , and AsyncAPI Docs update (28 Feb - 11 March 2022) . Measuring our Docs project\u2019s success We will partially measure success in the Docs project by capturing specific feedback about the IA changes via our soon-to-come new Docs Feedback card . We need this specific and granular feedback to make sure we listen and make changes according to what the community requests from Docs. In previous AsyncAPI Docs Gist updates, we've mentioned that Design contributors were teaming with Docs on /website issue #453 for the ideation and development of our new feedback card that will be added at the bottom of each Docs page. What the community decided over the last 2 weeks was that the Submit feedback button in the card will publish the feedback anonymously via the AsyncAPI bot and create a new GitHub Discussion with said feedback: \n![A screenshot displaying the design of our new feedback card for receiving feedback on AsyncAPI Docs](/img/posts/gsod-2022/feedback-card.webp)\n \n![A screenshot of AsyncAPI GitHub Discussions for the Docs category](/img/posts/gsod-2022/docs-community-discussions.webp)\n The other way we would consider the project successful is the number of our contributors and Docs PRs increased from 3 to 6 community members. Currently, a majority of our OSS contributor community focuses only on contributing code, but we would like to instill a greater interest in contributing to documentation that provides value for everyone. Timeline The project itself will take approximately 4-6 months to complete, depending on the different levels of knowledge from diverse technical writers (TW) that might get involved. (At AsyncAPI, we want to work with any TW, regardless of their years of experience. We have a passion for mentorship, and we do not wish to have a bar that would prevent any TW from contributing to our OSS Initiative. In fact, we look forward to potentially mentoring TW(s) who are completely new to tech and making them feel welcome!) For our 2 projects, we would like to request a minimum of 2 TWs, so that we can work on both the CLI/Tools and Generator Docs. The timeline would look as follows: May: Orientation on how to contribute to AsyncAPI Inititiave, how Docs issues are organized, detail how we're migrating our CLI and Tools Docs, and assign good first-time-tickets to get each new TW contributor started. June - August: Each TW goes through designated issues marked for both first time contributors and work set aside for GSoD 2022 . Each TW starts creating documentation for their individual issues assigned/selected. September - October: We determine if we're going to be able to complete both CLI and Tools Docs plus the Generator Docs, depending on how many TWs are in our group and how much they've been able to complete so far. We re-align priorities as needed and asses what is missing to reach our 2022 IA change goals for AsyncAPI Docs. November: Project completion and all contributors receive some swag! Project budget We have set aside 2 mentors for now, for our 2 projects: improving our IA and re-structuring our Generator Docs. Should we be selected, AsyncAPI would like to request from Google a US $5000 budget for each project. For both projects, the request then totals for a $10,000 budget. Budget item Total Amount Technical writer updates, reviews, edits, and publishing new documentation for the IA improvements. $5000 Technical writer updates, reviews, migration, and publishing improved Generator tool documentation. $5000 Get started contributing to AsyncAPI Docs Today Last but not least, don't forget that Code isn't the only way to contribute to OSS; Dev Docs are a huge help that benefit the entire OSS ecosystem. At AsyncAPI, we value Doc contributions as much as every other type of contribution. \u2764\ufe0f To get started as a Docs contributor: Familiarize yourself with our project's Contribution Guide and our Code of Conduct . Head over to our AsyncAPI Docs Board . Pick an issue you would like to contribute to and leave a comment introducing yourself. This is also the perfect place to leave any questions you may have on how to get started. If there is no work done in that Docs issue yet, feel free to open a PR and get started! Docs contributor questions Do you have a documentation contributor question and you're wondering how to tag me into a GitHub discussion or PR? Never fear! Tag me in your AsyncAPI Doc PRs or GitHub Discussions via my GitHub handle, quetzalliwrites \ud83d\udc19 . -Q.W. \ud83d\udc69\ud83c\udffb\u200d\ud83d\udcbb and Canela \ud83d\udc15\u200d\ud83e\uddba",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/posts/gsod-2022/feedback-card.webp",
        "alt": "A screenshot displaying the design of our new feedback card for receiving feedback on AsyncAPI Docs"
      },
      {
        "src": "/img/posts/gsod-2022/docs-community-discussions.webp",
        "alt": "A screenshot of AsyncAPI GitHub Discussions for the Docs category"
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "a15f8a1d",
    "title": "Finding a Good Open Governance Model for AsyncAPI | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/blog/governance-motivation.html",
    "content": "Finding a Good Open Governance Model for AsyncAPI | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page The vision Vocabulary Single TSC for spec and tools Value work more than money Respecting committers and the right to vote Work on all the tools under the AsyncAPI umbrella No meetings - async all the things Wishful thinking \n![](/img/posts/governance-motivation-cover.webp)\n tl;dr charter for the AsyncAPI Initiative open governance is ready for review. Leave your comments there in this pull request. We will wait two weeks for your feedback. December 2020 brought to AsyncAPI an important announcement, a partnership with Postman . This huge milestone secured the AsyncAPI Initiative development efforts as few active community members moved to Postman. This move speeded up our work on transferring AsyncAPI to a foundation and forming an open governance model to assure the community that a single company does not control AsyncAPI Initiative. It took us a lot of time to write down the initial charter for the initiative. Pro Tip : Charter is not a person that creates charts \ud83d\ude03 Nobody's trying to be a smart ass here. We actually had to google that \ud83d\ude03 The vision We started with a basic vision in our heads and studied governance models of many diverse communities, like NodeJS Foundation, OpenJS Foundation, GraphQL Foundation, Cloud Events, OpenAPI Initiative, and CNCF. We also got a charter template from Linux Foundation. That was a lot to handle. \n![](https://media.giphy.com/media/5QMPpCzH6yxEqhev5A/giphy.gif)\n In the end, we just wanted to make sure the initiative is community-driven and leaves no one behind. We tried to figure out a governance model that: is as democratic as possible supports the asynchronous decision-making process gives power to people that \"work\", not companies that \"pay\". In other words, it gives equal power to both individual and corporate contributors. Vocabulary In the AsyncAPI governance model, you can find two essential roles: contributor and committer. A contributor is a person that contributes to the project code, docs, or other artifacts. A committer is a person that contributes regularly and is invited by other committers to manage the repository, to have more privileges, and to approve pull requests. Committer rules in the repository, but for topics that go beyond, there is a Technical Steering Committee (TSC). TSC consists of all committers. Yes, not a dedicated group of people for now. Are you a committer? If yes, then it means you are a voting member of TSC (unless you do not want to). But more on that further in the blog post. Single TSC for spec and tools Spec and tools will have different licenses, but there will not be two TSCs though. One TSC to handle both the specification and the tools. Why? start small, they say. don't design processes and then work accordingly but better build a process that facilitates the way you work already. we are a large community, but not large enough to handle two different charters, not now. The other good reason for not splitting is that we believe the initiative should work on spec and tools to provide essential open-source tools that consistently support the latest version of the specification. In other words, when we release the newest version of the specification, you can already use it with official tools and do not have to wait for other tooling providers to catch up. We know big companies do not care much about basic tooling as they most probably write their own because it is much easier for them to work without unnecessary noise. Nevertheless, we need to think about the small ones too. Two TSCs sound like having two silos that work separately, and it is not good for the start. Nobody says, though, that the TSC can't organically grow into two separate groups in the future. Value work more than money We want to have a TSC consisting of all the active committers in the project, not people who are there because their company is a sponsor of the project. You are a TSC member because you work on the project, you code, write docs, maintain CI. You work, and therefore, you are a part of the initiative. Why? Don't you like money? We like money, don't get us wrong here \ud83d\ude03 Money helps the project a lot, we can sponsor many good things with the money we obtain from you. Nevertheless, we believe that it isn't good to run a project alone with lots of bucks in the pocket. What? We need a doctor here! \ud83e\udd37\u200d\u2642 We just prefer to work with a large group of people, from different cultures, from other parts of the world, with diverse experience and use cases in heads. That is just how you build great products by having many people around you to help and validate the ideas actively. Respecting committers and the right to vote The rule we want to follow is that the committer automatically gets a right to vote. Why? Voting is always about essential things, essential for the entire initiative. Who else should have a right to vote if not people that are directly affected by the decisions of the ToC? The tricky situation here is that this approach can lead to a problem where one company hires most committers and, therefore, takes over project steering. This is something we actually have at the moment. The majority of folks working actively on the project are from Postman. Nothing terrible happened to the project for now, but this doesn't mean the whole community feels comfortable. We had a tough brainstorming here about finding the right balance between respecting all contributors equally and still making sure that there is no risk that a company has most voters. That is why we have a rule that only 1/4 of voters can be affiliated with the same company. Or 1/3 in case we need to look for more maintainers to bring balance back to the force. Work on all the tools under the AsyncAPI umbrella We want AsyncAPI Initiative to be a place where AsyncAPI open source tools are developed, together, so we do not duplicate each other in the community with different variations of the same tool. So far, seven AsyncAPI tools resulted from different companies or individuals' work and moved to the AsyncAPI GitHub organization. We want this to become a standard in the community. The governance model embraces this direction. How? If you own a project, you created it. It means you are its committer. Do you see where We're getting? Yes, it means that once you donate the project to the AsyncAPI Initiative, you do not only stay there as a committer but also become a voting member. No meetings - async all the things We hate to have too many meetings. Meetings suck out your blood. Meetings = schedule and schedule = leash. Zero meetings? No, we will have something on the schedule, but it will not be mandatory. We will not make decisions during the meetings, so you do not have to rush to be there. You just need to watch the recording to learn if there is something relevant for you if there is a topic that needs voting. Decision-making should be asynchronous, and people should have time to make wise decisions. The async decision-making process also assures that the number of voters can scale up easily, and we should be able to handle as many committers in the group as we have. We can automate many things here. Wishful thinking We hope that a side effect of such an open governance model will be that companies will have a better motivation to sponsor the initiative financially and assign employees to work on the spec and tooling regularly to become committers and become voting members of the TSC. Hopefully, these companies will take shortcuts here that will open up new job opportunities for individual contributors. That was not our initial goal, though. We just figured that this might happen, and we look forward to it. I hope this rough explanation makes it easier to digest the charter. Please share what you think. Use Twitter , Slack , email. Write publicly or privately. We just care about the feedback and not how you pass it on. You can also comment on this pull request with the charter. You can leave generic comments that we could reuse in official communication after we join the foundation. Cheers \ud83c\udf7b Photo by United Nations COVID-19 Response on Unsplash",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/posts/governance-motivation-cover.webp",
        "alt": ""
      },
      {
        "src": "https://media.giphy.com/media/5QMPpCzH6yxEqhev5A/giphy.gif",
        "alt": ""
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "0fb022de",
    "title": "AsyncAPI @Hacktoberfest | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/blog/hacktoberfest-2020.html",
    "content": "AsyncAPI @Hacktoberfest | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page What is AsyncAPI What Is Hacktoberfest And Why AsyncAPI Initiative Joins It How Can You Help 1. Pick The Right Issue 2. Setup Your Environment And Create A First Pull Request Office Hours Blooper Reel \n![](/img/posts/hacktoberfest.webp)\n HacktoberFest 2020 has finished Check out our summary blog post . There are lots of good insights! What is AsyncAPI AsyncAPI is a specification for describing your event-driven architecture . You are probably using already OpenAPI/Swagger specification for describing your synchronous RESTful APIs. AsyncAPI is something that supplements OpenAPI. As an example, you should use AsyncAPI when your services do not talk to each other directly but through a message broker. In contrast to the OpenAPI Initiative, AsyncAPI Initiative is focused not only on creating and evolving the AsyncAPI specification but also on its tooling. It is a vendor-neutral space for the community to work together on the spec and its tools. We work on tools like specification parsers or docs and code generators. What Is Hacktoberfest And Why AsyncAPI Initiative Joins It Hacktoberfest is a well-known event that promotes open source contributions. In short, you have the entire October to submit four pull requests to any project you want, and in exchange, you get a super cool t-shirt. Is that it? Is it just for a t-shirt? Nah, the t-shirt is nice but what you also get is easy access to open source world. Maintainers of many projects open up for contributions, and it is a great chance to make your first step to joining this fantastic world. AsyncAPI Initiative joins the Hacktoberfest for two main reasons: Promote AsyncAPI Initiative as a place where we don't work on the specification only but also build a lot of great tools Make it much easier for the community to make the first contribution to one of the AsyncAPI repositories In the past, we were also there where you are now, shy and uncertain if we can impact open source community. We want to give you an easy path to take the first baby steps in the world of open source in a welcoming and friendly environment. Don't forget to sign up to the Hacktoberfest How Can You Help There is always a lot of work waiting out there. For the sake of this special event, we prepared around 75 GitHub issues that you can pick up. They represent different areas (for example, JavaScript or HTML), different difficulty (for example, 50 issues are easy), and different repositories. No matter if they are trivial or demanding, all of them are important for us. Even with trivial ones where you, for example, need to remove a semicolon, we will still be super happy because this will improve the quality of the project (SonarCloud reports). In other words, every single issue from this list is important. 1. Pick The Right Issue Here you can find a list of all the issues that you can work on. Most of the issues are about code contribution, but not all of them. There are also issues about documentation or CI/CD configuration (we use GitHub Actions). Just pick the issues you want to work on, one at a time, and let us know in the comments section that you want to work on it. 2. Setup Your Environment And Create A First Pull Request Once you install Git on your machine and get a GitHub account , you need first to decide if you are here just for Hacktoberfest or longer, and make sure if your issue is easy and maybe you can complete it in the GitHub UI. In case you are here just for the Hacktoberfest, and you picked easy issues that involve changes only to a single file, there is no need to install Git and complicate your life. GitHub UI enables you to make changes to a single file online . In case you: want to stay with us longer, you picked up an issue where you need to make changes to more than just one file, you also need to run the project locally to check if it works Then follow this short instruction on how to fork the repository and set it up locally. Once you are ready with your changes, submit a pull request. Be nice and follow our code of conduct and make sure your pull request is described properly . Office Hours Do you feel overwhelmed? No need. You can do it. Just take this blog post seriously. Trust me when I write that every pull request is crucial for us. Trust me when I write that we are a welcoming community. Don't be afraid that you will waste our time. If we would think about it this way, we would not even join the Hacktoberfest. Still not sure if you can make it? Don't worry. We want to host office hours throughout the event, 2x a week, 1h long, and different time zones. You can join whenever you want and ask us anything, or do pair programming with us. We start with the first meeting on Tuesday 6th, 8AM UTC and then on the following days: Tuesday 6th, 8AM UTC Thursday 8th, 4PM UTC Tuesday 13th, 8AM UTC Thursday 15th, 4PM UTC Tuesday 20th, 8AM UTC Thursday 22nd, 4PM UTC Tuesday 27th, 8AM UTC Thursday 29th, 4PM UTC We stream to our official media accounts: https://www.twitch.tv/asyncapi https://www.youtube.com/asyncapi https://twitter.com/AsyncAPISpec You can also join us in a more asynchronous discussion on Slack . For updates and latest news, the best is to follow our Twitter account . Blooper Reel Before you jump to your first contribution, have a look at the making of the videos. It was quite fun. Enjoy the Hacktoberfest!",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/posts/hacktoberfest.webp",
        "alt": ""
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "aa9724b0",
    "title": "Is Hacktoberfest Good For Maintainers? | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/blog/hacktoberfest-summary-2020.html",
    "content": "Is Hacktoberfest Good For Maintainers? | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page tl;dr Hacktoberfest Is Ok Spam Why We Participated in Hacktoberfest What It Takes To Have 70 PRs Merged What We Prepared What We Did During The Event Was It Worth It What Made It Such a Success Open Request to Hacktoberfest Organizers Hall Of Fame \n![](/img/posts/hacktoberfest-summary-2020/cover.webp)\n tl;dr In October, we welcomed 26 new contributors with 70 pull requests (PRs) merged. It was an exhausting but also a fascinating experience. Hacktoberfest Is Ok Don't be afraid of Hacktoberfest . It is an excellent event for both contributors and maintainers. There are haters that will tell you something different. My advice, follow truncated mean measure and always discard extreme opinions, especially if they call for boycotting: Finally, and most importantly, we can remember that this is how DigitalOcean treats the open source maintainer community, and stay away from their products going forward Cancel culture at its best. The fact that someone is good at programming or works at Google or Facebook doesn't make them experts in everything. Remember that celebrities are not good candidates for a role model. There are no perfect events; there are no best solutions. There is always a place for improvement, but it should be followed by open, civilized discussion. Let me conclude by saying that I hope the \"harm to the open source made by DigitalOcean\" is not as significant as the harm that such hate does to open source by discouraging new open-source contributors. However, this is just speculation. How can I consider any of these things harmful if I did not conduct scientific research? I can only confirm that Hacktoberfest did not harm AsyncAPI Initiative . On the contrary, it was pretty neat. Spam During the entire event, we had only two spam PRs. I can imagine that a much more popular and known project might have had more. Nevertheless, adding the invalid label and closing a PR is a super simple operation, three clicks. The definition of spam heavily depends on maintainers. For example, this is not invalid to me, because I don't think of grammar as \"subjective nits\". Why We Participated in Hacktoberfest Our intentions were pretty clear from the very beginning. As I wrote in the previous post , we wanted to: Promote AsyncAPI Initiative as a place where we work not only on the AsyncAPI specification, but also lots of tools Help members of the broader open-source community make their first contributions in a friendly environment My impression is that sometimes the open-source is perceived as a kind of elite gathering. This is quite often blocking people from joining because they feel they cannot help but rather waste others' time. I was there in the past, I thought the same. It's just another variation of the damn impostor syndrome . You can always help, no matter what your experience is. Start small. Don't start with tasks that can be overwhelming. Don't throw yourself into the deep end. We wanted to help others make first baby steps in a secure and inclusive environment, with lots of patience and support. What It Takes To Have 70 PRs Merged It is not enough to label 70 issues with the hacktoberfest label, sorry \ud83d\ude03 First of all, you need to be passionate about open source and dedicated to what you do. It can't just be a task that somebody assigned to you. It would help if you were prepared to treat Hacktoberfest participants as a priority. I would compare it to the onboarding process of new hires. Of course, not all participants join to stay longer, usually they just follow the \"one pull request, and I'm out of here\" approach. It doesn't matter. Please don't make assumptions; assumptions are evil. Be opened, treat every contribution equally, and remember that the onboarding process is a crucial element. If you fail with the onboarding process, you fail big time at the very beginning. What We Prepared We prepared the following materials for potential participants: Blog post about our participation Onboarding videos that explain how to start 78 issues from more than 30 repositories and put them all in one list with additional information about the difficulty level or the technical area, It took me around eight workdays to do it all. The most time-consuming part was to go through all the issues, pick candidates, create new ones, and group them all in a Google Sheet. What We Did During The Event 70 pull requests mean \u2014at least\u2014 70 reviews \ud83d\ude05 If you know your project well, it is not very time-consuming, and anyway, it is the work you have to do as a maintainer. I do not count this time as an extra Hacktoberfest effort. Of course, it can be overwhelming if this is not a standard amount of PRs that you get every month. We also hosted office hours for participants. This was fun, and we wanted to start doing live streams about AsyncAPI anyway. Last but not least, once a week, I advertised our project on the official Hacktoberfest Discord server. \n![](/img/posts/hacktoberfest-summary-2020/feedback-sharkham.webp)\n It looks like we do not need to do more for the next year. Was It Worth It Hell yeah, and I'm already looking forward to Hacktoberfest 2021. It was great to see so many different people interacting with the project and seeing we reached our goal. \n![](/img/posts/hacktoberfest-summary-2020/feedback-juergenbr.webp)\n We got some new features, CI/CD cleanup in all repositories, and solved many trivial SonarCloud-reported issues that we would never found time to solve. What Made It Such a Success Our success was a typical return on investment. \n![](/img/posts/hacktoberfest-summary-2020/feedback-Orodan.webp)\n We asked all contributors to provide feedback on how they learned about us and what was the most helpful resource. 20 out of 26 responded to our request. \n![Figure 1: Ways in which the contributors learned about AsyncAPI participating in Hacktoberfest](/img/posts/hacktoberfest-summary-2020/how-they-learned.webp)\n Figure 1: Ways in which the contributors learned about AsyncAPI participating in Hacktoberfest I think it is pretty clear that introducing the official Discord channel was a great idea. I personally do not like Discord because of the lack of support for threads, but better this than nothing. \n![Figure 2: Resources helpful for contributors](/img/posts/hacktoberfest-summary-2020/what-they-used.webp)\n Figure 2: Resources helpful for contributors Such a simple thing as a Google Sheet with a list of issues grouped by different factors was, in the end, our best resource for contributors. I encourage you to create such a sheet for your contributors next year. Open Request to Hacktoberfest Organizers There is one thing that calls for an improvement for next year. Just one? Yeah, opt-in solution for projects that want to participate in Hacktoberfest was addressed during this event, and I assume it stays on. The number of projects that people can work on is overwhelming, and finding the right issue seems very difficult. Please have a look at the feedback we got from our contributors. It is enough to develop an official application where potential contributors can adequately filter out issues by technology and difficulty. In the end, it doesn't make sense for all maintainers to work on their own Google Sheets and post it on Discord. A better way would be to introduce an app for all. Hall Of Fame Below you can find a list of all contributors that joined AsyncAPI during Hacktoberfest and contributed their time to the project. The list is sorted alphabetically, including the number of PRs created by this contributor. ab510 (2) anbreaker (3) Jes\u00fas Miguel Benito Calzada (1) Barbara Szwarc (8) Mitchell Sawatzky (2) Chenemi Zekeri (2) Charlie Tharas (1) Christeen Fernando (1) danielchu (4) depimomo (4) Miguel Angel Falc\u00f3n Mu\u00f1oz (1) Gabriel Claudino (1) Talmiz Ahmed (5) HUTCHHUTCHHUTCH (11) Jakub Iwanowski (2) Jo\u00e3o Francisco Lino Daniel (1) J\u00fcrgen B. (3) mbeuil (2) Moritz Wiesinger (1) Katrina Knight (2) Jimmy Kasprzak (3) Phil Antiporda (1) Olivier Lechevalier (6) Sanskar Patro (1) Sam (1) GrimPix (1) Cover photo by Ian Schneider on Unsplash",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/posts/hacktoberfest-summary-2020/cover.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/hacktoberfest-summary-2020/feedback-sharkham.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/hacktoberfest-summary-2020/feedback-juergenbr.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/hacktoberfest-summary-2020/feedback-Orodan.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/hacktoberfest-summary-2020/how-they-learned.webp",
        "alt": "Figure 1: Ways in which the contributors learned about AsyncAPI participating in Hacktoberfest"
      },
      {
        "src": "/img/posts/hacktoberfest-summary-2020/what-they-used.webp",
        "alt": "Figure 2: Resources helpful for contributors"
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "b6adb603",
    "title": "AsyncAPI Conference Helsinki and the API Specs and Standards Concept | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/blog/helsinki-and-community.html",
    "content": "AsyncAPI Conference Helsinki and the API Specs and Standards Concept | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page How It All Started AsyncAPI Conf on Tour at APIDays Helsinki 2024 September 18-19 in London December in Paris and the future of the Booth \n![](/img/posts/helsinki-and-community/booth-top.webp)\n How It All Started After three years of hosting online conferences (2020-2022), the AsyncAPI community felt it was time for something different\u2014 an in-person event. We wanted to meet people face-to-face, to confirm that behind the virtual interactions were real humans, the ones you could have meaningful conversations with, not bots! In 2023, we organized multiple events under the brand AsyncAPI Conf on Tour . One of them took place at APIDays Paris , made possible by the amazing folks behind APIDays , who share our belief in the future of strong API specifications and standards. It was a fantastic opportunity, but we had one major concern\u2014how do we find our community members in an event with thousands of attendees? How do we have meaningful conversations? And how do we engage with people who don\u2019t know about AsyncAPI yet? As you probably know, conference talks end, and people scatter. It\u2019s easy to lose them in the crowd. One of the best places to meet people at conferences is at the sponsor booths. But as an open-source, community-driven project, we don\u2019t have the budget for that kind of setup. Once again, APIDays came to the rescue and offered us a booth. We decided to take it one step further\u2014not just a booth for AsyncAPI, but a shared space for other open-source communities. At Paris 2023, we organized the first API Specs & Standards booth, bringing together AsyncAPI, OpenAPI, and JSON Schema experts. We created a vendor-neutral, safe space for knowledge exchange, where experts from different companies shared their expertise without pushing for their products. AsyncAPI Conf on Tour at APIDays Helsinki 2024 Our next stop was APIDays Helsinki 2024 . Hugo kicked things off with a great introduction to the AsyncAPI spec and later wrapped up the track with an excellent session on testing event-driven architectures. \n![Hugo presenting AsyncAPI basics.](/img/posts/helsinki-and-community/hugo.webp)\n Hugo presenting AsyncAPI basics. Jonas followed with a detailed overview of the AsyncAPI tooling ecosystem, showcasing the various tools built around the specification to support developers working with AsyncAPI documents. \n![Jonas presenting the AsyncAPI tooling ecosystem.](/img/posts/helsinki-and-community/jonas.webp)\n Jonas presenting the AsyncAPI tooling ecosystem. I then presented an overview of AsyncAPI use cases, demonstrating how different companies use AsyncAPI in production, all based on real data we\u2019ve gathered over the years. You can explore all of this in our AsyncAPI case studies . \n![Lukasz presenting how AsyncAPI is used in production.](/img/posts/helsinki-and-community/lukasz.webp)\n Lukasz presenting how AsyncAPI is used in production. The talks were engaging, and the questions that followed were great. Slides from the talks are available for download . But the best, most technical, and insightful conversations happened at the API Specs and Standards booth. We teamed up with friends from the OpenAPI Initiative and had deep, meaningful discussions. \n![OpenAPI and AsyncAPI experts side by side. From left: Lukasz, Erik, Frank, Hugo, and Jonas.](/img/posts/helsinki-and-community/booth-front.webp)\n OpenAPI and AsyncAPI experts side by side. From left: Lukasz, Erik, Frank, Hugo, and Jonas. September 18-19 in London I won\u2019t be attending the London event this year, but plenty of other folks will, especially at the API Specs and Standards booth. I hope you all have as much fun there as we did in Helsinki! \n![OpenAPI and AsyncAPI experts getting to know each other during a Helsinki city run.](/img/posts/helsinki-and-community/run.webp)\n OpenAPI and AsyncAPI experts getting to know each other during a Helsinki city run. If you haven\u2019t grabbed your ticket yet, AsyncAPI community members can get free passes. Just check out the agenda and reserve your spot . December in Paris and the future of the Booth Looking ahead to December, we\u2019ll have some free passes for the Paris event too. But honestly, the best experience is joining as a speaker. Not only do you get a free pass, but you also get to attend the speaker\u2019s party the night before the event. Most importantly, it\u2019s a unique opportunity to share your story with the wider AsyncAPI community. CfP is still open. Of course, we\u2019ll have a booth again. This time, it won\u2019t just be AsyncAPI and OpenAPI folks\u2014our friends from JSON Schema will join too. Since it\u2019s the fourth time we\u2019ll be hosting this booth, I have a feeling it\u2019s time to take things up a notch. We need to be more organized, include more community members, and maybe even secure some dedicated funding. A rebranding could be in order, too\u2014perhaps renaming the booth to Open API Standards . We could also broaden the scope to include experts from the open-source tooling ecosystem that builds on top of these standards and operates under open governance. Enjoy!",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/posts/helsinki-and-community/booth-top.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/helsinki-and-community/hugo.webp",
        "alt": "Hugo presenting AsyncAPI basics."
      },
      {
        "src": "/img/posts/helsinki-and-community/jonas.webp",
        "alt": "Jonas presenting the AsyncAPI tooling ecosystem."
      },
      {
        "src": "/img/posts/helsinki-and-community/lukasz.webp",
        "alt": "Lukasz presenting how AsyncAPI is used in production."
      },
      {
        "src": "/img/posts/helsinki-and-community/booth-front.webp",
        "alt": "OpenAPI and AsyncAPI experts side by side. From left: Lukasz, Erik, Frank, Hugo, and Jonas."
      },
      {
        "src": "/img/posts/helsinki-and-community/run.webp",
        "alt": "OpenAPI and AsyncAPI experts getting to know each other during a Helsinki city run."
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "deaddc76",
    "title": "AsyncAPI vs OpenAPI: Answers to Your Burning Questions About Two Leading API Specs | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/blog/openapi-vs-asyncapi-burning-questions.html",
    "content": "AsyncAPI vs OpenAPI: Answers to Your Burning Questions About Two Leading API Specs | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page What are Application Programming Interfaces (APIs)? When did APIs start? What is Swagger and how does it relate to REST APIs? What happened to Swagger? And what is OpenAPI? Are REST API and OpenAPI the same thing? Why do Microservices Architecture and IoT benefit from Asynchronous Communications? Why do Microservices Architecture and IoT benefit from Asynchronous Communications? How does AsyncAPI describe asynchronous APIs? Can an API gateway be asynchronous? If REST is all about HTTP, what protocols does AsyncAPI use? How can I create an Asynchronous API with AsyncAPI? What's next for API specs? \n![](/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-15.webp)\n AsyncAPI and OpenAPI are different ways of defining application programming interfaces (APIs), also commonly known as API specs. Both API specs serve a crucial role in defining and governing distributed computing systems, but AsyncAPI and OpenAPI are used for different styles of integration, as seen here: \n![Figure 1: How API specs AsyncAPI and OpenAPI map to different interaction patterns](/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-01.webp)\n This post AsyncAPI vs OpenAPI: Answers to Your Burning Questions About the Two Most Popular API Specs appeared first on Solace . This post answers the following common questions about AsyncAPI vs OpenAPI and APIs in general\u2026 What are Application Programming Interfaces (APIs)? Application programming interfaces, or simply \u201cAPIs\u201d, are a key part of modern programming that make it easier to exchange information between applications. APIs tell you what information an application expects to receive, and what information an application sends, without needing to know what the internal details of an application. \n![Figure 2: APIs provide the gateway into an application, but hide the messy details](/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-02.webp)\n As long as the API doesn\u2019t change, different teams can invoke the application\u2019s functionality without worrying about the messy details underneath. Because of this, separate teams can work independently on implementations. \n![Figure 3: APIs give developer teams more independence](/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-03.webp)\n When did APIs start? APIs have been around for a while. For instance, the painful Simple Object Access Protocol (SOAP) used APIs in the early 2000s, but they really started getting interesting when representational state transfer (REST) came along. REST, which used the ubiquitous HTTP protocol, was lightweight and fun to work with. Did REST solve all the problems of SOAP by being lightweight, fun, and easy? Not quite, because it was a little too lightweight in some cases. What is Swagger and how does it relate to REST APIs? There was no great way to tell people in your company or a partner what needed to be in REST requests, and what they could expect as a reply. Whether the request needed a PUT or a POST was a constant source of confusion, and without a standard way of describing REST APIs, you had to resort to emailing. \n![Figure 4: Lack of a standard spec made REST APIs difficult to use](/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-04.webp)\n Something needed to happen. Swagger and WADL to the rescue! The goal of these competing standards was to standardize a way of documenting what a REST API looked like that was both readable by humans (somewhat, anyway) and could programmatically validate incoming requests and generate code. \n![Figure 5: Swagger provided a standard way to describe REST APIs](/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-05.webp)\n What happened to Swagger? And what is OpenAPI? The Swagger specification was renamed OpenAPI in 2016 when the Linux Foundation acquired it from the fine folks at SmartBear. Somewhat confusingly, Swagger lives on as a toolset for creating and manipulating OpenAPI specs. \n![Figure 6: Swagger becomes OpenAPI](/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-06.webp)\n Implementing OpenTelemetry typically means instrumenting code so that it can emit monitoring information. This information is then aggregated in a backend system, either on-premises or through monitoring as a service provider. Are REST API and OpenAPI the same thing? They are related but different. OpenAPI describes and documents how a REST API operates in a standard way so that it can be shared widely. \n![Figure 7: OpenAPI describes a REST API](/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-07.webp)\n Why do Microservices Architecture and IoT benefit from Asynchronous Communications? Microservices architecture is the new, cool kid on the street. Its purpose is to split up huge globs of code into tiny, manageable pieces, so different teams can work on them simultaneously. Typically, if a company wants to create something new, it glues different combinations of microservices together using REST calls. This method for microservices architecture worked\u2026 to an extent. People eventually realized that REST wasn\u2019t always the best glue, and recognized the need for a new kind of glue that facilitated asynchronous communication. \n![Figure 8: Microservice architecture decomposes huge applications into tiny services](/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-08.webp)\n Establishing asynchronous communication between microservices makes them more reliable, faster, easier to scale, and more agile to adopt. Here\u2019s a great video explaining why. The internet of things also changed things up. My coffee cup is connected to the Internet now. Which is fantastic. But internet connected gadgets like cars and stoves and refrigerators don\u2019t always have solid internet connections. Again, asynchronous communication seemed like a better way to connect. \n![Figure 9: The Internet of Things connects devices to Internet](/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-09.webp)\n With asynchronous communication, if a device is inaccessible, the information can be stored until it comes back online. Asynchronous communication can also help handle the surge of data than can come from connected devices. For example, think about all the coffee mugs firing up at 7am in the morning\u2026 Why do Microservices Architecture and IoT benefit from Asynchronous Communications? You may be wondering why OpenAPI struggles with asynchronous APIs. Well, prior to version 3.1*, OpenAPI assumed two things: There is a single client connecting to a single server or application. The client requests something from the other server or application. * (OpenAPI 3.1 introduces some async capablities through the ability to define webhooks) As you can see here, that only covers about 25% of the ways that APIs can be implemented. \n![Figure 10: OpenAPI doesn\u2019t address several use cases- modified from Microservice Patterns by Chris Richardson](/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-10.webp)\n Asynchronous communications do not satisfy those assumptions in numerous ways, but two stand out: Information is frequently shared with many consumers at the same time. In the case of one-way notifications, there may not be a request at all. With event-driven architecture, applications proactively send notifications about things that have occurred without being asked for that information. How does AsyncAPI describe asynchronous APIs? Without diving too deep, AsyncAPI adapts many of the core structures of OpenAPI to the asynchronous world. Rather than assuming that information flows in a request-reply style between a single client and server pair, messages are assigned to \u201cchannels\u201d that many applications can send messages to, or receive messages from. If you want to learn more, check out the primer on the AsyncAPI website . \n![Figure 11: AsyncAPI describes asynchronous APIs](/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-11.webp)\n With the combination of OpenAPI and AsyncAPI, many more API possibilities are covered, as you can see in this diagram: \n![Figure 12- The combination of OpenAPI and AsyncAPI covers modern use cases](/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-12.webp)\n Can an API gateway be asynchronous? There\u2019s no reason it can\u2019t be, which is one of the reasons many companies are focusing more on evented API products, along the lines of more traditional API products. Companies like Slack are already letting outsiders use evented APIs. If REST is all about HTTP, what protocols does AsyncAPI use? One of the cool things about AsyncAPI is that you can use a variety of different protocols that are defined by \u201cbindings\u201d. Right now, there are AsyncAPI bindings for over a dozen protocols including Apache Kafka, AMQP, IBM MQ, MQTT, SNS, WebSockets, and JMS. \n![Figure 13: AsyncAPI covers a wide array of asynchronous protocols](/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-13.webp)\n How can I create an Asynchronous API with AsyncAPI? If you want to see examples of how AsyncAPI can help you create an asynchronous API, there\u2019s a great series with WebSockets examples , and you can check out this code generation example from Solace . If you\u2019re looking for how to create an AsyncAPI API from scratch, the easiest way is with the AsyncAPI playground . What's next for API specs? AsyncAPI and OpenAPI are now both part of the Linux Foundation, which means: Both are well supported and have a stable future Both will be open standards with community governance Both should continue to be integrated with open-source tooling and commercial products \n![Figure 14: OpenAPI and AsyncAPI are now roommates at Linux Foundation](/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-14.webp)\n",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-15.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-01.webp",
        "alt": "Figure 1: How API specs AsyncAPI and OpenAPI map to different interaction patterns"
      },
      {
        "src": "/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-02.webp",
        "alt": "Figure 2: APIs provide the gateway into an application, but hide the messy details"
      },
      {
        "src": "/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-03.webp",
        "alt": "Figure 3: APIs give developer teams more independence"
      },
      {
        "src": "/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-04.webp",
        "alt": "Figure 4: Lack of a standard spec made REST APIs difficult to use"
      },
      {
        "src": "/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-05.webp",
        "alt": "Figure 5: Swagger provided a standard way to describe REST APIs"
      },
      {
        "src": "/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-06.webp",
        "alt": "Figure 6: Swagger becomes OpenAPI"
      },
      {
        "src": "/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-07.webp",
        "alt": "Figure 7: OpenAPI describes a REST API"
      },
      {
        "src": "/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-08.webp",
        "alt": "Figure 8: Microservice architecture decomposes huge applications into tiny services"
      },
      {
        "src": "/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-09.webp",
        "alt": "Figure 9: The Internet of Things connects devices to Internet"
      },
      {
        "src": "/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-10.webp",
        "alt": "Figure 10: OpenAPI doesn\u2019t address several use cases- modified from Microservice Patterns by Chris Richardson"
      },
      {
        "src": "/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-11.webp",
        "alt": "Figure 11: AsyncAPI describes asynchronous APIs"
      },
      {
        "src": "/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-12.webp",
        "alt": "Figure 12- The combination of OpenAPI and AsyncAPI covers modern use cases"
      },
      {
        "src": "/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-13.webp",
        "alt": "Figure 13: AsyncAPI covers a wide array of asynchronous protocols"
      },
      {
        "src": "/img/posts/openapi-vs-asyncapi-burning-questions/asyncapi-openapi-post_pic-14.webp",
        "alt": "Figure 14: OpenAPI and AsyncAPI are now roommates at Linux Foundation"
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "fb8ab5e6",
    "title": "Organizing your AsyncAPI documents | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/blog/organizing-asyncapi-documents.html",
    "content": "Organizing your AsyncAPI documents | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Organizing Microservices Common mistakes Organizing Client-Server Summary \n![](/img/posts/organizing-asyncapi-documents.webp)\n A recurring question that I get very often is: \u201chow do I organize my AsyncAPI documents?\u201d. Also, the related one: \u201cI have two services, a publisher and a consumer, should I define both in the same AsyncAPI document?\u201d. Let\u2019s break down some best practices and tips to avoid ending up in a hell of unmanageable documents. Organizing Microservices I\u2019m using the term microservices here because it\u2019s the most common type of distributed architecture that you can find nowadays. The best practice for organizing AsyncAPI files in your microservices architecture is to have a file per microservice. This way, you end up with multiple independent files that define your application. \n![](/img/posts/organizing-asyncapi-documents-1.webp)\n One publisher and one subscriber, both sharing the UserSignUp message. Microservices are meant to do a single thing and to do it well and, very importantly, they must be independently deployable. However, if you have a publisher and multiple consumers, you quickly end up having something like the following: \n![](/img/posts/organizing-asyncapi-documents-2.webp)\n One publisher and various subscribers. All of them sharing the UserSignUp message. It\u2019s clear there\u2019s a dependency between all of them: the UserSignedUp message. If at some point to want to change it, you\u2019ll have to go through all of the files and change it. It\u2019s a tedious task we want to avoid, so we can make use of the $ref capability of AsyncAPI to simplify things: \n![](/img/posts/organizing-asyncapi-documents-3.webp)\n The value of $ref should be \u201ccommon/messages.json#UserSignedUp\u201d. Now, if you have to add something to the UserSignedUp message, it\u2019s just a matter of changing one file. Depending on your setup, you may have to restart your services to get the new definition. However, as simple and straightforward as it may seem, you must take care not to introduce breaking changes in the message definition. Otherwise, you\u2019ll have inconsistent states while some services got the new message definition and some didn\u2019t yet. Here comes the importance of versioning your messages, but that makes for another blog post alone. Common mistakes Since microservices tend to be small in scope, most probably their AsyncAPI document will not be very extensive too. And I found out this is one of the reasons people tend to re-use the same file for many services. They think the file is very small and because the publisher and the subscriber share the same message, why not putting everything there? It\u2019s tempting at first, but the reason why you should avoid doing this is that you lose context and semantics, and it causes problems: If a single document contains publish and subscribe for the same channel (topic), how do you know which one is defining what your application does? Since your document may contain many channels, how do you know if your application is publishing or subscribing to each channel or just a subset of them? That itself causes more problems, for instance, when you want to generate the documentation for a single service but you have a single file defining your whole architecture and thus a single documentation page describing all the services without any clue which one is doing what. An AsyncAPI file is meant to define the behavior of a single application . You can obviously break the rules and use it to define the whole architecture but expect all sorts of problems to appear because you\u2019re using a hammer to saw a piece of wood. The same way you don\u2019t use a single OpenAPI (Swagger) file to define many of your REST APIs, you shouldn\u2019t use a single AsyncAPI document to define many of your message-driven APIs. Organizing Client-Server Say, for instance, you have a WebSockets API and front-end application using it. The paradigm is very similar to the one we\u2019re used to with HTTP APIs, with the subtle difference that the communication is full duplex , i.e., the client can send and receive messages over the same channel, at any time. This case is not very different from the microservices one. If you think about it, we can look at it as a small distributed architecture, where you only have two services: the client and the server. So the recommended best practice is to follow the same approach and have one document for each of the applications \u2014 one for the server and another for the client or front-end. Summary I want to reinforce the point that an AsyncAPI file is meant to define the behavior of a single application . Keep this always in mind, and everything will make sense to you. Happy coding! \u270c\ufe0f AsyncAPI is an open source project running on donations so please consider donating \ud83d\ude4c",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/posts/organizing-asyncapi-documents.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/organizing-asyncapi-documents-1.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/organizing-asyncapi-documents-2.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/organizing-asyncapi-documents-3.webp",
        "alt": ""
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "5e66cdcb",
    "title": "Demystifying the Semantics of Publish and Subscribe | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/blog/publish-subscribe-semantics.html",
    "content": "Demystifying the Semantics of Publish and Subscribe | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page In the beginning What about AsyncAPI? Where's the confusion? What does this mean for using the spec? Summary \n![](/img/posts/publish-subscribe-semantics/cover.webp)\n This post originally appeared on IBM Integration Community As adoption of AsyncAPI increases, a frequent topic of conversation in the community is how to describe publish and subscribe semantics - both now and in future versions of the specification. In this blog post I aim to introduce the discussion and set you on the right path to document your event driven APIs. Or in other words, what code would you expect to be generated for the publish operation in the following AsyncAPI document? \n```javascript\n1    asyncapi: 2.0.0 \n2      info:                   \n3        title: My Application\n4        version: 1.0 \n5    servers:\n6      bootstrap:\n7        url: mybroker.com:3514\n8        protocol: kafka\n9    channels:\n10      myChannel:\n11        publish:\n12          message:\n13            payload:\n14              type: string\n```\n If you would be surprised to hear that this would result in a Kafka Consumer, then you should keep reading! \n![meme with phrase 'you keep using that word, I do not think you know what it means'](/img/posts/publish-subscribe-semantics/meme.webp)\n In the beginning AsyncAPI started as an adaptation of OpenAPI - which describes synchronous request/response based APIs. In an OpenAPI world, you describe the application from the perspective of the client. Or in other words, the OpenAPI document describes how a client should interact with your application. The client and server communicate directly with each other. \n![server communicating with client](/img/posts/publish-subscribe-semantics/REST.webp)\n You document that a GET endpoint exists to access data, a POST endpoint exists to create data, etc. In all cases, a client speaks to the application (server) that is serving these endpoints. If you were implementing an application to honour the contract described in an OpenAPI document, you know to build route handlers that provide the documented endpoints for clients to access. Callbacks and webhooks are asynchronous operations, but in OpenAPI they are still described from the perspective of the client \u2013 the client has to initiate/register with the server before the server will push data to the client. What about AsyncAPI? In an event driven architecture there is no client/server paradigm. Applications do not directly communicate with one another - instead, each application sends and receives events via communication channels provided by s messaging infrastructure such as a broker. The broker ensures that events sent to a channel are delivered to interested applications. It can be considered fire and forget - an application sends an event, but does not have any interest in whether other applications receive or make use of the event. AsyncAPI approaches this by describing an application as having two potential roles: If it sends messages to a channel, it's a \u201cPublisher\". If it is interested in receiving messages from a channel, it is a \u201cSubscriber\". An application can have either one or both roles. What does the following AsyncAPI document describe? \n```javascript\n1    asyncapi: 2.0.0\u00a0\n2      info:\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n3        title: My Application\n4        version: 1.0\u00a0\n5    servers:\n6      bootstrap:\n7        url: mybroker.com:3514\n8        protocol: kafka\n9    channels:\n10      myChannel:\n11        publish:\n12          message:\n13            payload:\n14              type: string\n```\n Is My Application a Publisher or a Subscriber? Answer... it's a Subscriber! Like with OpenAPI, an AsyncAPI documents an application from the client perspective. For a client to interact with My Application , it must publish an event to the myChannel channel on the Kafka broker hosted at mybroker.com:3514 \n![clients communicating via a broker](/img/posts/publish-subscribe-semantics/BROKER.webp)\n The exception to the rule is websockets - there is a client/server paradigm rather than a messaging infrastructure - so other applications will connect directly to the server. However, the semantics remain the same - you describe the server as an application from the client perspective. See Lukasz's previous article for more details. Where's the confusion? An AsyncAPI document can have multiple purposes. It can act as documentation for other developers to understand how to interact with the API. It can also act as documentation for developers to implement the API. In OpenAPI, there is no ambiguity - if you implement the API your server must listen for incoming requests on the documented endpoints, and any clients know to make requests to the documented endpoints. A GET endpoint means the same thing to both client and server. In AsyncAPI, the confusion has arisen because applications can both publish and subscribe - so verbs become interchangeable depending on the perspective of the person reading the document. When describing your architecture - a collection of applications communicating via channels - it can feel more familiar to describe what each application is doing (it publishes event x to channel a and subscribes to events from channel b ). Conversely, if you are intending on socialising your asynchronous API for use by other developers - it is a more familiar paradigm to describe how external developers can interact with the API. Ultimately, that was the decision for v2.0.0 of the AsyncAPI specification. What does this mean for using the spec? The AsyncAPI generator project is designed to facilitate generation of various assets from an AsyncAPI document - including sample or mock applications. The application generators are primarily written to interpret the API as detailed in this blog post - so a publish will generate a Kafka consumer. However, some of the templates have added support for interpreting the document so that a publish generates a Kafka producer. Java Spring Cloud Stream template uses the parameter view=provider - ( provider interprets the AsyncAPI document as describing the behaviours the application provides ) Java Spring template use the parameter inverseOperations=true Summary AsyncAPI documents describe applications. When reading an AsyncAPI document: publish means publish an event to the channel and this application will receive it subscribe means subscribe to this channel to receive events published by this application There is a GitHub issue raised for discussing these semantics moving forward into the next version of the AsyncAPI specification - please do get involved with the discussion!",
    "code_blocks": [
      "1    asyncapi: 2.0.0 \n2      info:                   \n3        title: My Application\n4        version: 1.0 \n5    servers:\n6      bootstrap:\n7        url: mybroker.com:3514\n8        protocol: kafka\n9    channels:\n10      myChannel:\n11        publish:\n12          message:\n13            payload:\n14              type: string",
      "1    asyncapi: 2.0.0\u00a0\n2      info:\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n3        title: My Application\n4        version: 1.0\u00a0\n5    servers:\n6      bootstrap:\n7        url: mybroker.com:3514\n8        protocol: kafka\n9    channels:\n10      myChannel:\n11        publish:\n12          message:\n13            payload:\n14              type: string"
    ],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/posts/publish-subscribe-semantics/cover.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/publish-subscribe-semantics/meme.webp",
        "alt": "meme with phrase 'you keep using that word, I do not think you know what it means'"
      },
      {
        "src": "/img/posts/publish-subscribe-semantics/REST.webp",
        "alt": "server communicating with client"
      },
      {
        "src": "/img/posts/publish-subscribe-semantics/BROKER.webp",
        "alt": "clients communicating via a broker"
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "b05dbbf3",
    "title": "Simplify code generation with React | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/blog/react-as-generator-engine.html",
    "content": "Simplify code generation with React | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Getting started How it works Comparison with Nunjucks Creating reusable parts Using third party packages Cons & Pros Advantages Disadvantages Resources Summary \n![](/img/posts/react-as-generator-engine.webp)\n React permanently changed the way how developers write web-apps. Personally, we love React and knew it would solve many pain points we faced with Nunjucks. Therefore in the last cycle we integrated it as a template rendering engine into our Generator . This post is a short introduction for developers who write or plan to write templates for AsyncAPI specification using React. It also includes a comparison with the default Nunjucks renderer. Getting started Your React template requires @asyncapi/generator-react-sdk as a dependency. You need it to access the File component required as a root component responsible for rendering a file. Furthermore, it provides some common components to make your development easier, like Text or Indent . Let's consider a basic React template file as the one below called MyTemplate.js : \n```javascript\n1import { File, Text } from \"@asyncapi/generator-react-sdk\";\n2\n3export default function({ asyncapi, params, originalAsyncAPI }) {\n4  return (\n5    <File name=\"asyncapi.md\">\n6      <Text>Some text that should render as is</Text>\n7    </File>\n8  );\n9}\n```\n The exported default function returns the File component as a root component that the Generator uses to figure out what file it should generate. In the example above, we overwrite the default functionality of saving the file as MyTemplate.js , and we set asyncapi.md as the filename. Using the Text component, we specify what content should be rendered inside the file. The content of the resulting file is: Some text that should render as is\\n . Notice the \\n character at the end. It is automatically added after the Text component. For further information about components and their props, see the Generator React SDK . The Generator doesn't use React renderer by default. You need to specify in the template configuration that your template is based on React. For that, change the renderer field of generator object inside the template's package.json file: \n```javascript\n1{\n2  ...\n3  \"generator\": {\n4    \"renderer\": \"react\",\n5    ...\n6  }\n7}\n```\n You can find more information about the Generator configuration here . How it works The process of creating content from React components consists of two steps: transpile and render. The SDK has a custom transpiler which ensures that any directory in template's template folder are transpiled using Rollup . Rollup helps bundling all dependencies and transpile them into CommonJS modules. This is required because this library will be used through NodeJS (by AsyncAPI Generator) which does not understand these new modules natively and we do not want to limit the developer in which syntax they prefer nor how they want to separate code. Also, SDK has its own reconciler. It traverses through each element in the template structure and transforms it into a pure string. Prop children is always converted to a regular string and stored in the childrenContent prop in each component. Check the below example, to see how it works. In addition, you can also see how to apply the composition to templates using components: \n```javascript\n1import { Text, Indent, IndentationTypes, render } from '@asyncapi/generator-react-sdk';\n2\n3class ClassComponent extends React.Component {\n4  constructor(props) { \n5    super(props);\n6  }\n7\n8  render() {\n9    // In `childrenContent` prop is stored `text wrapped by custom component\\n\\n`.\n10    // The content of the `children` prop is transformed to string and saved to the `childrenContent` prop.\n11    return this.props.childrenContent;\n12  }\n13}\n14\n15function FunctionComponent() {\n16  return (\n17    <Indent size={3} type={IndentationTypes.TABS}>\n18      indented text\n19      <ClassComponent>\n20        <Text newLines={2}>\n21          text wrapped by custom component\n22        </Text>\n23      </ClassComponent>\n24    </Indent>\n25  );\n26}\n27\n28// content will be `\\t\\t\\tindented text text wrapped by custom component\\n\\n`\n29const content = render(<FunctionComponent />);\n```\n There are some restrictions: React hooks feature is not allowed. HTML tags are not supported. React internal components like Fragments , Suspense , and others are skipped. Comparison with Nunjucks The AsyncAPI generator still uses Nunjucks as a default render engine. It's a templating language, heavily focused on string literals, filters (similar to bash pipes), and partials called macros. The next sections compare how you can accomplish certain things in Nunjucks and React. For more complex examples, see the template-for-generator-templates repository with examples based on React and compare those with nunjucks branch. Creating reusable parts It may sound obvious, but when writing any code, even a template, a programmer wants to create reusable parts that separate repeating logic. In Nunjucks, you can reuse parts of the template using macros , in React, using components . Imagine that you are writing a template that produces Markdown content. You need to create a reusable macro/component that renders a list from an array of strings. Using Nunjucks you can write the code below: \n```javascript\n1{% macro list(data, type = \"-\") %}\n2{% for item in data %}\n3{{type}} {{item}}\n4{% endfor %}\n5{% endmacro %}\n6\n7{% from \"partials/list.njk\" import list %}\n8{{ list([\"one\", \"two\", \"three\"]) }}\n```\n Using React you can write the code below: \n```javascript\n1function List({ list = [], type = \"-\" }) {\n2  return list.map(item => `${type} ${item}\\n`);\n3}\n4\n5// use `List` component in another component\n6export function SimpleList() {\n7  return (\n8    <List list={[\"one\", \"two\", \"three\"]} />\n9  );\n10}\n```\n Looking at both examples we see that in Nujucks we operate on string literals, it means that when passing data to a macro, you always need to know what type of data the macro takes. In React we operate on JS objects/variables. By this, your IDE should always inform you what value, of what type, you must pass to component. Additionally, you must place Nunjucks's macro inside the partials folder of the template. Using React, you can put your components wherever you want. Using third party packages Using helper functions from third-party packages, in Nunjucks you must apply them as filters . For example, you want to use one function from Underscore.string library like cleanDiacritics , which replaces diacritic characters with closest ASCII equivalents. To do this, you must create a function inside filters folder to convert the function to Nunjucks's filter: \n```javascript\n1// filters/cleanDiacritics.js\n2const cleanDiacritics = require('underscore.string/cleanDiacritics');\n3const filter = module.exports;\n4filter.cleanDiacritics = cleanDiacritics;\n```\n And then you can use this function inside your template/macro: \n```javascript\n{{ Urba\u0144czyk | cleanDiacritics }} # will be Urbanczyk\n```\n The main problem with this solution is that it creates an unnecessary boilerplate - you must create a function in a separate file. Another problem is that you operate on the name of this helper function which means you must always remember what filters you have included in your template. In opposite, in React you can use Underscore.string directly in your template: \n```javascript\n1import cleanDiacritics from 'underscore.string/cleanDiacritics';  \n2\n3function MyComponent() {\n4  return cleanDiacritics('Urba\u0144czyk'); // will be Urbanczyk\n5}\n```\n It is worth mentioning that when using packages in this way, you always operate on the reference to the function, not on its name, so you know what functions you have in the file's scope. Cons & Pros Like any solution, React has its advantages as well as disadvantages. Advantages Using React, you use JS directly. You don't need to learn custom Nunjuck's syntax, only how React works under the hood. It provides better debugging functionality that is not possible with Nunjucks. It provides better error stack traces. Better tools support development. You write templates in JavaScript, you use a reference to functions/variables, and therefore your IDE can tell you what you can use in a given scope. Provides better support for separating code into more manageable chunks/components. You don't need to create partials folder. You can create React component wherever you want, also next to the template's source code. You can easily test your components. It is difficult with Nunjucks. You can split template file into separate chunks and test them in separate test cases. Disadvantages Common pain when writing templates with React is related to indentations and new lines. However, we have several helpers in SDK to make your life easier, like Indent or Text components. Some people don't like to mix logic inside template files, so probably React won't be friendly for them. HTML tags at the moment are not supported. The developer must write them as a string literal, like here . Resources We use React render engine already in three official AsyncAPI templates: template-for-generator-templates template showcases features of the AsyncAPI Generator , including the React renderer. It shows how to write templates, reusable parts (components), what are the recommended patterns. It has simple and complex examples. You can also check how the same things could be done using Nunjucks in this branch. markdown-template is written using React. It generates documentation into a Markdown file. ts-nats-template is re-written using React to generate a TypeScript NATS client. If you want to check the source code of React renderer, go to the official repository . Summary There is a long way ahead of us to stabilize React as a render engine. We know about problems that make it unpleasant to write templates using React, such as indents or new lines, but we will work on that. Additionally, we have a couple of improvements on our list that will allow things like File Templates to be simplified in the Generator. We also plan to support TypeScript . We are waiting for your feedback. Happy coding! Cover photo is from Drunken Master movie.",
    "code_blocks": [
      "1import { File, Text } from \"@asyncapi/generator-react-sdk\";\n2\n3export default function({ asyncapi, params, originalAsyncAPI }) {\n4  return (\n5    <File name=\"asyncapi.md\">\n6      <Text>Some text that should render as is</Text>\n7    </File>\n8  );\n9}",
      "1{\n2  ...\n3  \"generator\": {\n4    \"renderer\": \"react\",\n5    ...\n6  }\n7}",
      "1import { Text, Indent, IndentationTypes, render } from '@asyncapi/generator-react-sdk';\n2\n3class ClassComponent extends React.Component {\n4  constructor(props) { \n5    super(props);\n6  }\n7\n8  render() {\n9    // In `childrenContent` prop is stored `text wrapped by custom component\\n\\n`.\n10    // The content of the `children` prop is transformed to string and saved to the `childrenContent` prop.\n11    return this.props.childrenContent;\n12  }\n13}\n14\n15function FunctionComponent() {\n16  return (\n17    <Indent size={3} type={IndentationTypes.TABS}>\n18      indented text\n19      <ClassComponent>\n20        <Text newLines={2}>\n21          text wrapped by custom component\n22        </Text>\n23      </ClassComponent>\n24    </Indent>\n25  );\n26}\n27\n28// content will be `\\t\\t\\tindented text text wrapped by custom component\\n\\n`\n29const content = render(<FunctionComponent />);",
      "1{% macro list(data, type = \"-\") %}\n2{% for item in data %}\n3{{type}} {{item}}\n4{% endfor %}\n5{% endmacro %}\n6\n7{% from \"partials/list.njk\" import list %}\n8{{ list([\"one\", \"two\", \"three\"]) }}",
      "1function List({ list = [], type = \"-\" }) {\n2  return list.map(item => `${type} ${item}\\n`);\n3}\n4\n5// use `List` component in another component\n6export function SimpleList() {\n7  return (\n8    <List list={[\"one\", \"two\", \"three\"]} />\n9  );\n10}",
      "1// filters/cleanDiacritics.js\n2const cleanDiacritics = require('underscore.string/cleanDiacritics');\n3const filter = module.exports;\n4filter.cleanDiacritics = cleanDiacritics;",
      "{{ Urba\u0144czyk | cleanDiacritics }} # will be Urbanczyk",
      "1import cleanDiacritics from 'underscore.string/cleanDiacritics';  \n2\n3function MyComponent() {\n4  return cleanDiacritics('Urba\u0144czyk'); // will be Urbanczyk\n5}"
    ],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/posts/react-as-generator-engine.webp",
        "alt": ""
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "a5bcb24a",
    "title": "AsyncAPI 3.0.0 Release Notes | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/blog/release-notes-3.0.0.html",
    "content": "AsyncAPI 3.0.0 Release Notes | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Overview Operation, channel, and message decoupling Messages instead of message Publish and subscribe confusion Request/Reply Optional channels Unified referencing behaviors Common metadata fields Cleaning up the root object Splitting out server URL into host and pathname More reusable objects in components New trait behavior Schema format and payload definition Simplified Parameters Editorial Changes Acknowledgements \n![](/img/posts/release-notes-3.0.0/cover.webp)\n The new version of the AsyncAPI specification - 3.0.0 - is now available and is packed with goodies! Some clear up confusion, some add features, and others improve maintainability. To make the information as clear as possible, we have split up the information into digestible chunks. If you want to get an overview of: All the changes done in v3, you are in the right place! Migration guide for all the breaking changes between v2 and v3 Overview This post will give you an overview of all the changes done in v3. Operation, channel, and message decoupling In v2, it has never been possible to re-use channels, because it was directly coupled with operations of an application. In v3, this is now possible, with the mindset that a channel and message should be detached from the operations performed. This means for any message broker, for example, for Kafka, channels now ONLY define topics and the messages it contains. For REST interfaces, it's all the paths and corresponding messages across all request types. For WebSocket, it's all the messages flowing through the WebSocket server. For Socket.Io, it defines all the rooms and messages therein. This change makes the channels reusable across multiple AsyncAPI documents. \n```javascript\n1asyncapi: 3.0.0\n2...\n3channels:\n4  UserSignup:\n5    address: user/signedup\n6    messages: \n7      UserMessage: \n8        payload:\n9          type: object\n10          properties:\n11            displayName:\n12              type: string\n13              description: Name of the user\n14operations:\n15  ConsumeUserSignups:\n16    action: receive\n17    channel: \n18      $ref: \"#/channels/UserSignup\"\n```\n Issue(s) PR(s) Migration Guide #618 , #663 #806 , #827 Operation, channel, and message decoupling Messages instead of message As you probably noticed above, messages in channels are no longer singular, and with oneOf , instead, messages are defined as key/value pairs in the Messages Object . This was part of the request-reply feature to enable easier referencing of messages. \n```javascript\n1asyncapi: 3.0.0\n2...\n3channels:\n4  UserSignup:\n5    address: user/signedup\n6    messages: \n7      UserMessage: \n8        ...\n```\n Issue(s) PR(s) Migration Guide #94 #827 Messages instead of message Publish and subscribe confusion In v2, the publish and subscribe operation keywords have always been confusing. Does it mean my application is published to the channel? Does it mean you publish for me? Who are you in this context? In v3, we try to clear this up. You only need to worry about your application's behavior. No more confusion about what and who does what. We achieve this through two new Operation Object keywords, send and receive , i.e. your application either sends or receives something. This description, of course, alters slightly based on protocol; for the generic message brokers, you produce or consume messages, but in the abstract AsyncAPI perspective, you still send or receive messages. \n```javascript\n1asyncapi: 3.0.0\n2...\n3operations: \n4  SendUserSignedUp:\n5    action: send\n6  ReceiveUserSignedUp:\n7    action: receive\n```\n Issue(s) PR(s) Migration Guide #829 #847 Operation keywords Request/Reply One of the longest requested features is request and reply... and it's finally here! One thorn in the eye of this feature has always been the publish and subscribe confusion, which complicated any efforts to achieve a workable solution. However, we now have a solution with that out of the way. \ud83d\udd25 This feature has been designed with the following use cases in mind: Broker-based messaging with well-defined response topic + \"correlationId\". Broker-based messaging with per process individual inbox aka \"replyTopic\" + \"correlationId\". Broker-based messaging with a temporary reply topic for an individual response. WebSocket, which has no topics, where the channel is a TCP connection where messages flow. \n```javascript\n1...\n2action: send | receive\n3reply:\n4  address:\n5    location: '$message.header#/replyTo'\n6  channel:\n7    $ref: '#/channels/userSignupReply'\n8  messages:\n9    - $ref: '#/components/messages/userSignedUpReply'\n```\n Read more about the Operation Reply Object here . Issue(s) PR(s) #94 , #558 #847 Optional channels We have seen many use cases where an AsyncAPI document has been used as a form of menu or collection of definitions. To do this in v2 would require a bit of a hack. But in v3, channels are now entirely optional. This means that it's now possible to have a valid AsyncAPI document as such: \n```javascript\n1asyncapi: 3.0.0\n2...\n3components:\n4  ...\n```\n Issue(s) PR(s) #829 #847 Unified referencing behaviors In v2, there were two instances where we used implicit references; server security configuration, by name referencing security requirement object in components, for channels to reference global servers by name. To stay as consistent as possible, we wanted to unify how references were used, which means that in v3, we ONLY use explicit references. The scopes information in the Security Schema Object is also now an array instead of an object. \n```javascript\n1asyncapi: 3.0.0\n2...\n3servers: \n4  SomeServer:\n5    security:\n6      - $ref: '#/components/securitySchemes/SomeSecurity'\n7channels:\n8  SomeChannel: \n9    servers: \n10      - $ref: '#/servers/SomeServer'\n11components:\n12  securitySchemes:\n13    SomeSecurity:\n14      ...\n15      scopes: [...]\n```\n Issue(s) PR(s) Migration Guide #829 #852 Unifying explicit and implicit references Common metadata fields There has been some inconsistency between which metadata fields are available in the different objects. Now we have added a few extra fields: added title , summary , and externalDocs fields in the Server Object added title and summary fields in the Channel Object added title field in the Operation Object and Operation Trait Object \n```javascript\n1asyncapi: 3.0.0\n2...\n3servers:\n4  SomeServer:\n5    title: Some Server title\n6    summary: This some server is for something\n7    externalDocs:\n8      ...\n9channels:\n10  SomeChannel:\n11    title: Some channel title\n12    summary: Some channel summary\n13operations:\n14  SomeOperation:\n15    title: Some operation title\n16    traits:\n17      - title: Some operation traits title\n```\n Issue(s) PR(s) #795 #796 Cleaning up the root object There was two meta information lingering in the root of the AsyncAPI object, which did not make much sense since we have the info object for all the meta information. Therefore the root tags and externalDocs have been moved to the Info Object . \n```javascript\n1asyncapi: 3.0.0\n2...\n3info:\n4  ...\n5  externalDocs:\n6    description: Find more info here\n7    url: https://www.asyncapi.org\n8  tags:\n9    - name: e-commerce\n10...\n```\n PR(s) Migration Guide #794 Moved metadata Splitting out server URL into host and pathname There has been some confusion about what the url of a server should contain; is it both protocol + host + path? What about the protocol field, then? Therefore each field now has its field for the host, path, and protocol in the Server Object . \n```javascript\n1asyncapi: 3.0.0\n2...\n3servers:\n4  localhost:\n5    host: localhost\n6    path: /api/v1,\n7    protocol: mqtt\n```\n Issue(s) PR(s) Migration Guide #547 , #274 #888 Server URL splitting up More reusable objects in components This is a bit of a mixture between some of the features, that all added a little to this. It's now possible to add more stuff under the Components Object : Replies Reply addresses Tags External docs Operations Channels \n```javascript\n1asyncapi: 3.0.0\n2...\n3components:\n4  ...\n5  replies:\n6    ...\n7  replyAddresses:\n8    ...\n9  tags: \n10    ...\n11  externalDocs:\n12    ...\n13  operations:\n14    ...\n15  channels:\n16    ...\n```\n Issue(s) PR(s) #829 #847 , #792 , #806 , #827 New trait behavior Traits in v2 always replaced any duplicate properties that were defined both in traits and the associated object. This meant, for example, if the message traits defined headers and the message object did as well, only the message trait headers would be applied because it overwrote anything you wrote in the message object. In v3, this has now been changed so that a property on a trait MUST NOT override the same property on the target object . For example, take a look at this message: \n```javascript\n1messageId: userSignup\n2description: A longer description.\n3payload:\n4  $ref: '#/components/schemas/userSignupPayload'\n5traits:\n6  - name: UserSignup\n7    title: User signup\n8    summary: Action to sign a user up.\n9    description: Description from trait.\n```\n Take notice of how description is not overwritten by the traits: \n```javascript\n1messageId: userSignup\n2name: UserSignup\n3title: User signup\n4summary: Action to sign a user up.\n5description: A longer description. # it's still description from \"main\" object\n6payload:\n7  $ref: '#/components/schemas/userSignupPayload'\n```\n Issue(s) PR(s) Migration Guide #505 #517 , #532 , #907 New trait behavior Schema format and payload definition With schemas, one thing that has always been impossible was reusing schemas with different schema formats. That's because the schema format information is part of the message object. That means that if you reference a Schema object, it has no information about the schema format because it's not located together. In v3, schemaFormat has been removed from the Message Object and Message Trait Object , and a new schema Object called Multi Format Schema Object has been introduced, which pairs a schema together with its schema format. Which now enables much better reusability: \n```javascript\n1asyncapi: 3.0.0\n2...\n3components:\n4  schemas:\n5    avroSchema:\n6      schemaFormat: 'application/vnd.apache.avro+yaml;version=1.9.0'\n7      schema:           \n8        type: record\n9        name: User\n10        namespace: com.company\n11        doc: User information\n12        fields:\n13          - name: displayName\n14            type: string\n```\n Issue(s) PR(s) Migration Guide #622 #797 , #910 Schema format and schemas Simplified Parameters In v2, it was possible to use the full power of JSON Schema to define parameters, however, it introduced a lot of complexity to parameters, so for v3 it was dialed way down to only allow a very small set of properties. In v3, the new Parameter object can now only have the following properties: enum , default , description , examples , and location . \n```javascript\n1asyncapi: 3.0.0\n2...\n3channels: \n4  userSignup:\n5    address: user/{userId}/signedup\n6    parameters:\n7      userId:\n8        description: Id of the user.\n```\n By default this means that any parameter is of type string . Issue(s) PR(s) Migration Guide #583 #935 Restricted parameters object Editorial Changes We have removed the note that stated we strived to be compatible with OpenAPI where possible because, with the recent changes, this is no longer the case. That said, we still strive to make the different specs as interoperable as possible i.e., with Avro, RAML, OpenAPI Schema, etc. Acknowledgements Spec 3.0 have been a massive undertaking, so I would like to say a huge \"thank you!\" to everyone who has been involved; maybe you commented on your views, added to discussions, joined the live meetings, championed changes, or reviewed proposed changes; this section is for you! Thank you, Simon Heimler , Vladim\u00edr Gorej , Fran M\u00e9ndez , Lukasz Gornicki , Sergio Moya , Michael Davis , Maciej Urba\u0144czyk , Jesse Menning , Heiko Henning , Gerald Loeffler , c-pius , Ian Cooper , Dale Lane , J\u00f6rg Walter , Nic Townsend , Laurent Broudoux , olamiral , Iv\u00e1n Garc\u00eda Sainz-Aja , Fabian B\u00fchler , John Fallows , Adrian Hope-Bailie , Christian (prdatur) , Karl Morrison , Javier Jim\u00e9nez Roda , Marek Sebera , Nathana\u00ebl L\u00e9caud\u00e9 , Jeremy Whitlock , souvik , Animesh Kumar , Samir AMZANI , Quetzalli Writes , Vaishnavi , Mahfuza , Bhaswati , Cynthia Peter , Arya Gupta , Joy Almeida , Hridyesh , Rohit , Ashish Padhy , Al Amin Muhammad , nickshoe , Khuda Dad Nomani , V Thulisile Sibanda , Ace , Mihael Bosnjak , Sambhav Gupta , Jonas Lagoni , Afzal Ansari",
    "code_blocks": [
      "1asyncapi: 3.0.0\n2...\n3channels:\n4  UserSignup:\n5    address: user/signedup\n6    messages: \n7      UserMessage: \n8        payload:\n9          type: object\n10          properties:\n11            displayName:\n12              type: string\n13              description: Name of the user\n14operations:\n15  ConsumeUserSignups:\n16    action: receive\n17    channel: \n18      $ref: \"#/channels/UserSignup\"",
      "1asyncapi: 3.0.0\n2...\n3channels:\n4  UserSignup:\n5    address: user/signedup\n6    messages: \n7      UserMessage: \n8        ...",
      "1asyncapi: 3.0.0\n2...\n3operations: \n4  SendUserSignedUp:\n5    action: send\n6  ReceiveUserSignedUp:\n7    action: receive",
      "1...\n2action: send | receive\n3reply:\n4  address:\n5    location: '$message.header#/replyTo'\n6  channel:\n7    $ref: '#/channels/userSignupReply'\n8  messages:\n9    - $ref: '#/components/messages/userSignedUpReply'",
      "1asyncapi: 3.0.0\n2...\n3components:\n4  ...",
      "1asyncapi: 3.0.0\n2...\n3servers: \n4  SomeServer:\n5    security:\n6      - $ref: '#/components/securitySchemes/SomeSecurity'\n7channels:\n8  SomeChannel: \n9    servers: \n10      - $ref: '#/servers/SomeServer'\n11components:\n12  securitySchemes:\n13    SomeSecurity:\n14      ...\n15      scopes: [...]",
      "1asyncapi: 3.0.0\n2...\n3servers:\n4  SomeServer:\n5    title: Some Server title\n6    summary: This some server is for something\n7    externalDocs:\n8      ...\n9channels:\n10  SomeChannel:\n11    title: Some channel title\n12    summary: Some channel summary\n13operations:\n14  SomeOperation:\n15    title: Some operation title\n16    traits:\n17      - title: Some operation traits title",
      "1asyncapi: 3.0.0\n2...\n3info:\n4  ...\n5  externalDocs:\n6    description: Find more info here\n7    url: https://www.asyncapi.org\n8  tags:\n9    - name: e-commerce\n10...",
      "1asyncapi: 3.0.0\n2...\n3servers:\n4  localhost:\n5    host: localhost\n6    path: /api/v1,\n7    protocol: mqtt",
      "1asyncapi: 3.0.0\n2...\n3components:\n4  ...\n5  replies:\n6    ...\n7  replyAddresses:\n8    ...\n9  tags: \n10    ...\n11  externalDocs:\n12    ...\n13  operations:\n14    ...\n15  channels:\n16    ...",
      "1messageId: userSignup\n2description: A longer description.\n3payload:\n4  $ref: '#/components/schemas/userSignupPayload'\n5traits:\n6  - name: UserSignup\n7    title: User signup\n8    summary: Action to sign a user up.\n9    description: Description from trait.",
      "1messageId: userSignup\n2name: UserSignup\n3title: User signup\n4summary: Action to sign a user up.\n5description: A longer description. # it's still description from \"main\" object\n6payload:\n7  $ref: '#/components/schemas/userSignupPayload'",
      "1asyncapi: 3.0.0\n2...\n3components:\n4  schemas:\n5    avroSchema:\n6      schemaFormat: 'application/vnd.apache.avro+yaml;version=1.9.0'\n7      schema:           \n8        type: record\n9        name: User\n10        namespace: com.company\n11        doc: User information\n12        fields:\n13          - name: displayName\n14            type: string",
      "1asyncapi: 3.0.0\n2...\n3channels: \n4  userSignup:\n5    address: user/{userId}/signedup\n6    parameters:\n7      userId:\n8        description: Id of the user."
    ],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/posts/release-notes-3.0.0/cover.webp",
        "alt": ""
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "594f63b7",
    "title": "Understanding AsyncAPIs with a Practical Example | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/blog/understanding-asyncapis.html",
    "content": "Understanding AsyncAPIs with a Practical Example | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page The event-driven use case The problem AsyncAPI specification to the rescue Documenting the solution architecture Identify event-driven applications in the solution Documenting the Account service Adding servers Adding channels, operations, and messages Defining messages and payload schema Documenting the Email service What\u2019s next? Code generators Validators Documentation generators Mocking and testing tools Conclusion \n![](/img/posts/understanding-asyncapis.webp)\n Event-driven applications are inherently distributed and loosely-coupled. That potentially leads to having many self-contained components in your architecture, managed by multiple teams. The information exchanged between them must be documented and maintained consistently for everyone\u2019s visibility. AsyncAPI specification steps in to solve that gap. This post explains how to map a simple event-driven application architecture into corresponding AsyncAPI specifications by walking you through an example. The event-driven use case Imagine you are designing a solution to the following use case. Two event-driven microservices are communicating through a message broker in a publish/subscribe manner. The first service, the Account service, publishes the UserSignedUp event when a new user account is created. The second service, the Email service, subscribed to receive those events to send the new user a welcome email. We can come up with a simple solution architecture as follows. \n![solution](/img/posts/understanding-asyncapis/solution.webp)\n The problem Now we have a solution architecture in place. Should we go ahead and start building? No! Not so fast. There are strong reasons behind not doing so. Account and Email services are loosely coupled distributed services, potentially built, operated, and maintained by separated teams. Two services will have their own context boundaries defined. All teams must explicitly define any information exchanged across these boundaries. For example, all teams must maintain broker configurations, topics, and event formats in a central place. Otherwise, maintaining the solution will become a nightmare in the long run. In our solution, the format of the UserSignedUp event must be consistent across two services. If one team makes a change, it has to be visible across the board. Therefore, a proper process must be in place to describe different components of an event-driven system and their interactions. AsyncAPI specification comes into play at this point. AsyncAPI specification to the rescue AsyncAPI is an open-source initiative that provides both a specification to describe and document your asynchronous applications in a machine-readable format and tooling (such as code generators) to make life easier for developers tasked with implementing them. - Marc DiPasquale AsyncAPI is built on the foundation of OpenAPI specification . A brings in critical activities from the REST API world, from documentation to code generation, from discovery to event management. Most of the processes you apply to your REST APIs nowadays would apply to event-driven/asynchronous APIs. Currently, the specification is at version 2.0.0 . Documenting the solution architecture Let\u2019s try to document our solution as per the AsyncAPI specification. Our end goal is to share it with respective teams to generate the implementations, validators, and most importantly, the documentation. An AsyncAPI document is a file that defines and annotates the different components of a specific Event-Driven Application . The file format must be JSON or YAML; however, only the subset of YAML that matches the JSON capabilities is allowed. First, we need to identify Applications in the solution. Identify event-driven applications in the solution The first step of documenting an event-driven architecture is to identify discrete components that produce or consume events. In AsyncAPI terms, they are commonly referred to as Applications . As per the specification: An application is any kind of computer program or a group of them. It MUST be a producer , a consumer or both. An application MAY be a microservice, IoT device (sensor), mainframe process, etc. An application MAY be written in any number of different programming languages as long as they support the selected protocol . An application MUST also use a protocol supported by the server in order to connect and exchange messages . In our solution, both Account service and Email service can be considered as applications as they produce and consume UserSignedUp events, respectively. Hence, both services will get their own AsyncAPI specification file. Let\u2019s start with the Account service first. Documenting the Account service Create a file called account-service.yaml and add the following content to it. \n```javascript\n1asyncapi: 2.0.0\n2info:\n3  title: Account Service\n4  version: '1.0.0'\n5  description: |\n6    Manages user accounts in the system.\n7  license:\n8    name: Apache 2.0\n9    url: https://www.apache.org/licenses/LICENSE-2.0\n```\n The first line of the specification starts with the document type, asyncapi , and the version (2.0.0). This line doesn\u2019t have to be the first one, but it\u2019s a recommended practice. The info object contains the minimum required information about the application. It contains the title , which is a memorable name for the API, and the version. While it\u2019s not mandatory, it is strongly recommended to change the version whenever you make changes to the API. Adding servers Our solution has been designed around a message broker. Therefore, both Account and Email services MUST specify brokers\u2019 necessary information such as URIs, protocols, and security configurations. We can use the servers object to define that information for the Account service. In AsyncAPI terms, a server object defines a message broker, a server, or any other kind of computer program capable of sending or receiving data. \n![servers](/img/posts/understanding-asyncapis/servers.webp)\n Add the following content to the same file. Here, we are using the test MQTT broker available at mosquitto.org. Apart from MQTT, AsyncAPI supports other protocols like AMQP and Kafka. \n```javascript\n1servers:\n2  production:\n3    url: mqtt://test.mosquitto.org\n4    protocol: mqtt\n5    description: Test MQTT broker\n```\n Adding channels, operations, and messages So far, the Account service consumers know where they should connect to send or receive data. The next step is to define operations on the broker. An operation maps to either publish or subscribe method/function in the application. Each operation exchanges one or more messages . Effectively, these messages define different events sent to and received from operations. Operations are bound to a particular channel in the server, along with the messages they exchange. A channel is an addressable component made available by the server for the organization of messages. Producer applications send messages to channels, and consumer applications consume messages from channels. You can think of channels as the interfaces for external parties to communicate with an application. There can be many channel instances in a server, allowing messages with different content to be addressed to different channels. A channel is equivalent to topics, routing keys, event types, or paths based on the server implementation. This relationship is illustrated in the following figure. \n![channels](/img/posts/understanding-asyncapis/channels.webp)\n In our solution, both services publish and consume events on the same channel. Add the following section to define a channel called user/signedup . \n```javascript\n1channels:\n2  user/signedup:\n3    subscribe:\n4      operationId: emitUserSignUpEvent\n5      message:\n6        $ref : '#/components/messages/UserSignedUp'\n```\n The Account service publishes UserSignedUp events to the broker. Hence, it is a publish operation. The operationId specifies the name of the method or function that emits the UserSignedUp event in the generated code. The above operation uses a reference to specify the format of the message that publishes. We\u2019ll get to the schema definitions shortly. Defining messages and payload schema In our solution, both services produce and consume the UserSignedUp event, which has the following format. \n```javascript\n1{\n2  \"firstName\" : \"John\",\n3  \"lastName\" : \"Doe\",\n4  \"email\" : \"aa@bb.cc\",\n5  \"createdAt\" : \"2021-02-12 09:34:123\"\n6}\n```\n The publish operation of the user/signedup channel had a reference to the event payload\u2019s schema. Now we need to define it properly. The schema definitions are done with AsyncAPI schema, which is 100% compatible with JSON Schema Draft 07. Refer to this if you need to explore more on the AsynAPI schemas. Message schemas, security schemes, and bindings are housed by Components object. All objects defined within the components object must be referenced from properties outside the components object. After adding the schemas, the final AsyncAPI definition for the Account service file should look like the following. \n```javascript\n1asyncapi: 2.0.0\n2info:\n3  title: Account Service\n4  version: '1.0.0'\n5  description: |\n6    Manages user accounts in the system.\n7  license:\n8    name: Apache 2.0\n9    url: https://www.apache.org/licenses/LICENSE-2.0\n10\n11servers:\n12  production:\n13    url: mqtt://test.mosquitto.org\n14    protocol: mqtt\n15    description: Test MQTT broker\n16\n17channels:\n18  user/signedup:\n19    subscribe:\n20      operationId: emitUserSignUpEvent\n21      message:\n22        $ref : '#/components/messages/UserSignedUp'\n23\n24components:\n25  messages:\n26    UserSignedUp:\n27      name: userSignedUp\n28      title: User signed up event\n29      summary: Inform about a new user registration in the system\n30      contentType: application/json\n31      payload:\n32        $ref: '#/components/schemas/userSignedUpPayload'\n33\n34  schemas:\n35    userSignedUpPayload:\n36      type: object\n37      properties:\n38        firstName:\n39          type: string\n40          description: \"foo\"\n41        lastName:\n42          type: string\n43          description: \"bar\"\n44        email:\n45          type: string\n46          format: email\n47          description: \"baz\"\n48        createdAt:\n49          type: string\n50          format: date-time\n```\n Documenting the Email service Similar to the above, we can create the AsyncAPI specification for the Email service as follows. \n```javascript\n1asyncapi: 2.0.0\n2info:\n3  title: Email Service\n4  version: '1.0.0'\n5  description: |\n6    Sends emails upon certain events\n7  license:\n8    name: Apache 2.0\n9    url: https://www.apache.org/licenses/LICENSE-2.0\n10\n11servers:\n12  production:\n13    url: mqtt://test.mosquitto.org\n14    protocol: mqtt\n15    description: Test MQTT broker\n16\n17channels:\n18  user/signedup:\n19    publish:\n20      operationId: onUserSignUp\n21      message:\n22        $ref : '#/components/messages/UserSignedUp'\n23\n24components:\n25  messages:\n26    UserSignedUp:\n27      name: userSignedUp\n28      title: User signed up event\n29      summary: Inform about a new user registration in the system\n30      contentType: application/json\n31      payload:\n32        $ref: '#/components/schemas/userSignedUpPayload'\n33\n34  schemas:\n35    userSignedUpPayload:\n36      type: object\n37      properties:\n38        firstName:\n39          type: string\n40          description: \"foo\"\n41        lastName:\n42          type: string\n43          description: \"bar\"\n44        email:\n45          type: string\n46          format: email\n47          description: \"baz\"\n48        createdAt:\n49          type: string\n50          format: date-time\n51          description: \"foo\"\n```\n Notice that the servers, channels, and payloads are the same. The only difference is in the publish operation, bound to the user/signedup channel. It says that messages published to this channel will be received by this service. What\u2019s next? Now we have completed writing AsyncAPI specifications for both Microservices. The next goal is to check-in them into a central location like Git and let both teams collaborate over the design. They can collaboratively edit the spec files to introduce new operations, parameters, versions, etc. Thanks to AsyncAPI, everything can be controlled from a central place, and every change will be visible across the board. I would say this is the pipe dream of an enterprise architect ;) But our journey doesn\u2019t stop here. The AsyncAPI project brings in a rich set of tools for the betterment of event-driven application building. You can find more information on this here . Code generators Application developers can speed up their work by automatically generating scaffoldings by specifying the specification file. This design-first strategy provides boilerplate code for dealing with brokers and marshaling/unmarshalling messages over the wire. Generators are available for mainstream applications like Java, .NET, JavaScript, etc. You can check out this repo for more information. Validators Validators validate a given message by comparing it with the specification. That is useful at the runtime for input validations. Documentation generators These generators generate human-readable documentation from an AsyncAPI document. Output formats are HTML, Markdown, and React (experimental) Mocking and testing tools Tools that take specification documents as input, then publish fake messages to broker destinations for simulation purposes. May also check that publisher messages are compliant with schemas. Conclusion Use AsyncAPI specification to document your event-driven systems to maintain consistency, efficiency, and governance across different teams who own each architectural component. The tooling ecosystem of AsyncAPI helps you speed up application development by automating tedious but necessary tasks such as code generation, documentation generation, validators, etc. Use them whenever you can. Finally, the AsyncAPI community is growing so fast. Your contribution to the community will be valuable in terms of making better event-driven applications. I hope you enjoyed this post. Originally published at https://medium.com/event-driven-utopia Cover image by silviarita from Pixabay",
    "code_blocks": [
      "1asyncapi: 2.0.0\n2info:\n3  title: Account Service\n4  version: '1.0.0'\n5  description: |\n6    Manages user accounts in the system.\n7  license:\n8    name: Apache 2.0\n9    url: https://www.apache.org/licenses/LICENSE-2.0",
      "1servers:\n2  production:\n3    url: mqtt://test.mosquitto.org\n4    protocol: mqtt\n5    description: Test MQTT broker",
      "1channels:\n2  user/signedup:\n3    subscribe:\n4      operationId: emitUserSignUpEvent\n5      message:\n6        $ref : '#/components/messages/UserSignedUp'",
      "1{\n2  \"firstName\" : \"John\",\n3  \"lastName\" : \"Doe\",\n4  \"email\" : \"aa@bb.cc\",\n5  \"createdAt\" : \"2021-02-12 09:34:123\"\n6}",
      "1asyncapi: 2.0.0\n2info:\n3  title: Account Service\n4  version: '1.0.0'\n5  description: |\n6    Manages user accounts in the system.\n7  license:\n8    name: Apache 2.0\n9    url: https://www.apache.org/licenses/LICENSE-2.0\n10\n11servers:\n12  production:\n13    url: mqtt://test.mosquitto.org\n14    protocol: mqtt\n15    description: Test MQTT broker\n16\n17channels:\n18  user/signedup:\n19    subscribe:\n20      operationId: emitUserSignUpEvent\n21      message:\n22        $ref : '#/components/messages/UserSignedUp'\n23\n24components:\n25  messages:\n26    UserSignedUp:\n27      name: userSignedUp\n28      title: User signed up event\n29      summary: Inform about a new user registration in the system\n30      contentType: application/json\n31      payload:\n32        $ref: '#/components/schemas/userSignedUpPayload'\n33\n34  schemas:\n35    userSignedUpPayload:\n36      type: object\n37      properties:\n38        firstName:\n39          type: string\n40          description: \"foo\"\n41        lastName:\n42          type: string\n43          description: \"bar\"\n44        email:\n45          type: string\n46          format: email\n47          description: \"baz\"\n48        createdAt:\n49          type: string\n50          format: date-time",
      "1asyncapi: 2.0.0\n2info:\n3  title: Email Service\n4  version: '1.0.0'\n5  description: |\n6    Sends emails upon certain events\n7  license:\n8    name: Apache 2.0\n9    url: https://www.apache.org/licenses/LICENSE-2.0\n10\n11servers:\n12  production:\n13    url: mqtt://test.mosquitto.org\n14    protocol: mqtt\n15    description: Test MQTT broker\n16\n17channels:\n18  user/signedup:\n19    publish:\n20      operationId: onUserSignUp\n21      message:\n22        $ref : '#/components/messages/UserSignedUp'\n23\n24components:\n25  messages:\n26    UserSignedUp:\n27      name: userSignedUp\n28      title: User signed up event\n29      summary: Inform about a new user registration in the system\n30      contentType: application/json\n31      payload:\n32        $ref: '#/components/schemas/userSignedUpPayload'\n33\n34  schemas:\n35    userSignedUpPayload:\n36      type: object\n37      properties:\n38        firstName:\n39          type: string\n40          description: \"foo\"\n41        lastName:\n42          type: string\n43          description: \"bar\"\n44        email:\n45          type: string\n46          format: email\n47          description: \"baz\"\n48        createdAt:\n49          type: string\n50          format: date-time\n51          description: \"foo\""
    ],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/posts/understanding-asyncapis.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/understanding-asyncapis/solution.webp",
        "alt": "solution"
      },
      {
        "src": "/img/posts/understanding-asyncapis/servers.webp",
        "alt": "servers"
      },
      {
        "src": "/img/posts/understanding-asyncapis/channels.webp",
        "alt": "channels"
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "f6ed35e7",
    "title": "WebSocket, Shrek, and AsyncAPI - An Opinionated Intro | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/blog/websocket-part1.html",
    "content": "WebSocket, Shrek, and AsyncAPI - An Opinionated Intro | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page What is WebSocket Websocket use case Why AsyncAPI WebSocket described with AsyncAPI Playing with WebSocket API Describing API using AsyncAPI \n![](/img/posts/websocket-part1/cover.webp)\n This is a pretty subjective post. I'm sharing my perspective, taking into account years of experience building backend and frontend with user experience in mind. If you do not want to read this article, then watch the recording of the live stream about the same: Everything we hear is an opinion, not a fact. Everything we see is a perspective, not the truth. \u2015 Marcus Aurelius This blog post is the first of a series of blog posts about WebSocket I'm working on. What is WebSocket It is a pretty old protocol used for duplex communication over TCP connection. It was standardized in 2011. Yes, ten years ago means it is old, super old. So why do I even mention it in 2021? It is very widely adopted and will not go away anytime soon because tooling support is excellent and serves its purpose well. Just remind yourself when HTTP/2 showed up and how many years it took everyone to migrate. It would not happen without the strong support and push from all the big players. Sure, there is HTTP/2 multiplexing and protocols like Mercure or GraphQL Subscription . There is also RFC8441 for WebSocket and HTTP/2 and some tools already adopted it, like Envoy or Jetty . Nevertheless, WebSocket is here to stay. Anyway, the future of WebSocket has nothing to do with this post. This post is for the AsyncAPI community looking into the AsyncAPI spec because of WebSockets now, no matter the protocol's future. Websocket use case Do you like to see in Slack that someone is typing a response? Do you like it when a user interface updates without page refresh? Do you like it when your client app knows there are updates available for display? That is what WebSocket is for. You establish a long-living connection between client and server. Through such a connection, the client can send a stream of messages to the server, and this is possible the other way around at the same time. One could say: I don't need WebSocket to achieve that. I could just set up a data polling with REST API. Just ask the API every few seconds if there are updates. Sadly this is not a joke. Engineers do it. Some engineers just take shortcuts, mostly because deadlines hunt them down. HTTP polling was presented very well in Shrek's famous Are we there yet? scene. Don't go that path. Do not perform unnecessary connections to your servers and create more and more traffic with more and more resource consumption. Wasting resources is bad and makes Shrek angry. WebSocket changes a lot there: \n![Figure 1: HTTP Pull vs WebSocket vs Shrek.](/img/posts/websocket-part1/websocket-shrek.webp)\n Figure 1: HTTP Pull vs WebSocket vs Shrek. Why AsyncAPI When building a WebSocket API on a server, you might have some additional needs: Want to document the API for the team that writes a client app, Web UI, Desktop app, or Mobile app. Want to have a way to specify the format of the messages that the server supports to validate them in the runtime. Want to generate a server or/and a client? If not for final production use, then for sure for prototyping and testing. These are just a few common needs. For WebSocket, you only establish a connection over HTTP protocol, and the rest goes over WS, so OpenAPI specification won't help you much here. WebSocket is one of the patterns in event-based systems. In the end, it is all about a stream of messages and asynchronous processing. Yes, it would be best to use AsyncAPI \ud83d\ude03 WebSocket described with AsyncAPI When I google for some public WebSocket API to play with, I find mostly currency trading products: Kraken WebSocket API Gemini WebSocket API CEXIO Websocket API Currency trading is a topic I know nothing about \ud83e\udd37\u200d\u2642 but it feels interesting to explore more. Documentation of the 1st and 2nd API looks familiar from look&feel perspective. I think we can make a bet they are already using AsyncAPI, and Kraken most probably is still running on version 1. Let's release the Kraken then. I'm sorry if you expected me to describe Shrek's API interface using AsyncAPI. It would be fun, but only fun, and I'd also like to teach you something. I will write an AsyncAPI document for Kraken API after playing with the API and basing it on the current documentation . Playing with WebSocket API The best way to play with a WebSocket API is through a CLI. Who didn't hear about curl in the REST API world? For WebSocket, I would recommend websocat . Kraken's API is partially public without authorization which is just great because to play with it, you do not have to set up an account to get an authorization token. Install websocat . For other installation options, check out this list. brew install websocat Establish connection with the API: websocat ws s: // ws .kraken. com Ping the API to see if it responds. Just type the below message and hit Enter: { \"event\" : \"ping\" } Now subscribe to the event ticker stream that sends messages with currency price. Just type the below message and hit Enter: \n```javascript\n{  \"event\": \"subscribe\",  \"pair\": [    \"XBT/USD\",    \"XBT/EUR\"  ],  \"subscription\": {    \"name\": \"ticker\"  }}\n```\n You should now see a constant stream of data sent by the server. You do not have to ask the API every second for an update, as the update is pushed to you. \n```javascript\n1{\"event\":\"heartbeat\"}\n2[340,{\"a\":[\"45520.10000\",6,\"6.78103490\"],\"b\":[\"45520.00000\",0,\"0.00185230\"],\"c\":[\"45520.10000\",\"0.01643250\"],\"v\":[\"1397.95434819\",\"5589.12101024\"],\"p\":[\"44883.49461\",\"44062.07654\"],\"t\":[14350,66782],\"l\":[\"43607.60000\",\"42770.80000\"],\"h\":[\"45811.10000\",\"45811.10000\"],\"o\":[\"43659.30000\",\"44709.10000\"]},\"ticker\",\"XBT/EUR\"]\n3[340,{\"a\":[\"45520.10000\",5,\"5.84803490\"],\"b\":[\"45492.50000\",0,\"0.09374582\"],\"c\":[\"45492.50000\",\"0.00625418\"],\"v\":[\"1398.10526819\",\"5589.26685876\"],\"p\":[\"44883.56109\",\"44062.11477\"],\"t\":[14359,66790],\"l\":[\"43607.60000\",\"42770.80000\"],\"h\":[\"45811.10000\",\"45811.10000\"],\"o\":[\"43659.30000\",\"44709.10000\"]},\"ticker\",\"XBT/EUR\"]\n4{\"event\":\"heartbeat\"}\n5[340,{\"a\":[\"45503.80000\",1,\"1.00000000\"],\"b\":[\"45496.20000\",0,\"0.01426600\"],\"c\":[\"45496.20000\",\"0.00109400\"],\"v\":[\"1398.10636219\",\"5589.26295766\"],\"p\":[\"44883.56157\",\"44062.11447\"],\"t\":[14360,66788],\"l\":[\"43607.60000\",\"42770.80000\"],\"h\":[\"45811.10000\",\"45811.10000\"],\"o\":[\"43659.30000\",\"44709.90000\"]},\"ticker\",\"XBT/EUR\"]\n6{\"event\":\"heartbeat\"}\n```\n Boy, it is always such fun to do it. Like seriously, I always have fun playing with APIs, any APIs. Just making this API \"conversation\". I hope nothing is wrong with me \ud83d\ude05 Now you know how to interact with the Kraken API. Now let's try to describe it using AsyncAPI. Describing API using AsyncAPI I'll explain, in detail, how to describe Websocket API with AsyncAPI in another blog post that will be part of the series. Why? I don't want to make this post super lengthy and discourage others from reading it. Let us learn step by step. For now, I will throw here a full AsyncAPI document I created for the Kraken API. You can also open it up in the AsyncAPI Studio and compare with their current documentation Familiarize with below before you look at the AsyncAPI document: AsyncAPI describes the API interface between the client and the server. In other words, the AsyncAPI document is for the user of the API. It does not describe what the server does but what the user can do with the API. Kraken API is quite complex. It has some beta servers, some private messages, and messages closely related to vocabulary specific for currency trading. I dropped all of those from my research not to overcomplicate things. In other words, the AsyncAPI file that you can see below is not a complete document. Websocket protocol is very flexible, and therefore you can implement the server in many different ways. There is no standard way of doing things, like there is no common way of doing things with AsyncAPI. We can only make some generic assumptions looking at existing implementations: Your server has one entry point, just one endpoint that you communicate with to gain access to the API. It can be a path with some dynamic values , as some data id. It can also be nothing, no path at all, like in the case of below Kraken API. These entry points are channels in AsyncAPI document. Commonly, Websocket API has just one channel that user can send messages to and receive messages at the same time AsyncAPI publish and subscribe operations translates to messages user can send to the API and messages user will receive from the API . Depending on API complexity, sometimes you have an API that sends only one message . You can also have a situation where you can send to the server multiple different messages, and also receive different messages in response. This is when you need to use oneOf as I did in document for Kraken API. Current AsyncAPI limitation is that you cannot specify that once the user sends (publish) message ping , the pong message is a reply. Look at this thread to participate in an ongoing discussion about request/reply pattern support in AsyncAPI. In the below document, you will notice that for such a use case, I use AsyncAPI specification extensions ( x-response ). Message to Kraken API developers and technical writers In case you want to continue the work I started on the AsyncAPI document for Kraken API, feel free to do that. I'm happy to help, just let me know. Reach me out in our AsyncAPI Slack workspace . \n```javascript\n1asyncapi: 2.0.0\n2\n3info:\n4  title: Kraken Websockets API\n5  version: '1.8.0'\n6  description: |\n7    WebSockets API offers real-time market data updates. WebSockets is a bidirectional protocol offering fastest real-time data, helping you build real-time applications. The public message types presented below do not require authentication. Private-data messages can be subscribed on a separate authenticated endpoint. \n8\n9    ### General Considerations\n10\n11    - TLS with SNI (Server Name Indication) is required in order to establish a Kraken WebSockets API connection. See Cloudflare's [What is SNI?](https://www.cloudflare.com/learning/ssl/what-is-sni/) guide for more details.\n12    - All messages sent and received via WebSockets are encoded in JSON format\n13    - All decimal fields (including timestamps) are quoted to preserve precision.\n14    - Timestamps should not be considered unique and not be considered as aliases for transaction IDs. Also, the granularity of timestamps is not representative of transaction rates.\n15    - At least one private message should be subscribed to keep the authenticated client connection open.\n16    - Please use REST API endpoint [AssetPairs](https://www.kraken.com/features/api#get-tradable-pairs) to fetch the list of pairs which can be subscribed via WebSockets API. For example, field 'wsname' gives the supported pairs name which can be used to subscribe.\n17    - Cloudflare imposes a connection/re-connection rate limit (per IP address) of approximately 150 attempts per rolling 10 minutes. If this is exceeded, the IP is banned for 10 minutes.\n18    - Recommended reconnection behaviour is to (1) attempt reconnection instantly up to a handful of times if the websocket is dropped randomly during normal operation but (2) after maintenance or extended downtime, attempt to reconnect no more quickly than once every 5 seconds. There is no advantage to reconnecting more rapidly after maintenance during cancel_only mode.\n19\n20servers:\n21  public:\n22    url: ws.kraken.com\n23    protocol: wss\n24    description: |\n25      Public server available without authorization.\n26      Once the socket is open you can subscribe to a public channel by sending a subscribe request message.\n27  private:\n28    url: ws-auth.kraken.com\n29    protocol: wss\n30    description: |\n31      Private server that requires authorization.\n32      Once the socket is open you can subscribe to private-data channels by sending an authenticated subscribe request message.\n33\n34      The API client must request an authentication \"token\" via the following REST API endpoint \"GetWebSocketsToken\" to connect to WebSockets Private endpoints. For more details read https://support.kraken.com/hc/en-us/articles/360034437672-How-to-retrieve-a-WebSocket-authentication-token-Example-code-in-Python-3\n35\n36      The resulting token must be provided in the \"token\" field of any new private WebSocket feed subscription:\n```\n { \"event\": \"subscribe\", \"subscription\": { \"name\": \"ownTrades\", \"token\": \"WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu\" } } \n```javascript\n1\n2channels:\n3/:\n4publish:\n5description: Send messages to the API\n6operationId: processReceivedMessage\n7message:\n8  oneOf:\n9    - $ref: '#/components/messages/ping'\n10    - $ref: '#/components/messages/subscribe'\n11    - $ref: '#/components/messages/unsubscribe'\n12\n13subscribe:\n14description: Messages that you receive from the API\n15operationId: sendMessage\n16message:\n17  oneOf:\n18    - $ref: '#/components/messages/pong'\n19    - $ref: '#/components/messages/heartbeat'\n20    - $ref: '#/components/messages/systemStatus'\n21    - $ref: '#/components/messages/subscriptionStatus'\n22\n23components:\n24messages:\n25ping:\n26summary: Ping server to determine whether connection is alive\n27description: Client can ping server to determine whether connection is alive, server responds with pong. This is an application level ping as opposed to default ping in websockets standard which is server initiated\n28payload:\n29  $ref: '#/components/schemas/ping'\n30x-response:\n31  $ref: '#/components/messages/pong'\n32heartbeat:\n33description: Server heartbeat sent if no subscription traffic within 1 second (approximately)\n34payload:\n35  $ref: '#/components/schemas/heartbeat'\n36pong:\n37summary: Pong is a response to ping message\n38description: Server pong response to a ping to determine whether connection is alive. This is an application level pong as opposed to default pong in websockets standard which is sent by client in response to a ping\n39payload:\n40  $ref: '#/components/schemas/pong'\n41systemStatus:\n42description: Status sent on connection or system status changes.\n43payload:\n44  $ref: '#/components/schemas/systemStatus'\n45examples:\n46  - payload:\n47      connectionID: 8628615390848610000\n48      event: systemStatus\n49      status: online\n50      version: 1.0.0\n51subscribe:\n52description: Subscribe to a topic on a single or multiple currency pairs.\n53payload:\n54  $ref: '#/components/schemas/subscribe'\n55examples:\n56  - payload:\n57      event: subscribe\n58      pair:\n59        - XBT/USD\n60        - XBT/EUR\n61      subscription:\n62        name: ticker\n63  - payload:\n64      event: subscribe\n65      subscription:\n66        name: ownTrades\n67        token: WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu\n68x-response:\n69  $ref: '#/components/messages/subscriptionStatus'\n70unsubscribe:\n71description: Unsubscribe, can specify a channelID or multiple currency pairs.\n72payload:\n73  $ref: '#/components/schemas/subscribe'\n74examples:\n75  - payload:\n76      event: unsubscribe\n77      pair:\n78        - XBT/EUR\n79        - XBT/USD\n80      subscription:\n81        name: ticker\n82  - payload:\n83      event: unsubscribe\n84      subscription:\n85        name: ownTrades\n86        token: WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu\n87x-response:\n88  $ref: '#/components/messages/subscriptionStatus'\n89subscriptionStatus:\n90description: Subscription status response to subscribe, unsubscribe or exchange initiated unsubscribe.\n91payload:\n92  $ref: '#/components/schemas/subscriptionStatus'\n93examples:\n94  - payload:\n95      channelID: 10001\n96      channelName: ohlc-5\n97      event: subscriptionStatus\n98      pair: XBT/EUR\n99      reqid: 42\n100      status: unsubscribed\n101      subscription:\n102        interval: 5\n103        name: ohlc\n104  - payload:\n105      errorMessage: Subscription depth not supported\n106      event: subscriptionStatus\n107      pair: XBT/USD\n108      status: error\n109      subscription:\n110        depth: 42\n111        name: book\n112\n113schemas:\n114ping:\n115type: object\n116properties:\n117  event:\n118    type: string\n119    const: ping\n120  reqid:\n121    $ref: '#/components/schemas/reqid'\n122required:\n123  - event\n124heartbeat:\n125type: object\n126properties:\n127  event:\n128    type: string\n129    const: heartbeat\n130pong:\n131type: object\n132properties:\n133  event:\n134    type: string\n135    const: pong\n136  reqid:\n137    $ref: '#/components/schemas/reqid'\n138systemStatus:\n139type: object\n140properties:\n141  event:\n142    type: string\n143    const: systemStatus\n144  connectionID:\n145    type: integer\n146    description: The ID of the connection\n147  status:\n148    $ref: '#/components/schemas/status'\n149  version:\n150    type: string\n151status:\n152type: string\n153enum:\n154  - online\n155  - maintenance\n156  - cancel_only\n157  - limit_only\n158  - post_only\n159subscribe:\n160type: object\n161properties:\n162  event:\n163    type: string\n164    const: subscribe\n165  reqid:\n166    $ref: '#/components/schemas/reqid'\n167  pair:\n168    $ref: '#/components/schemas/pair'\n169  subscription:\n170    type: object\n171    properties:\n172      depth:\n173        $ref: '#/components/schemas/depth'\n174      interval:\n175        $ref: '#/components/schemas/interval'\n176      name:\n177        $ref: '#/components/schemas/name'\n178      ratecounter:\n179        $ref: '#/components/schemas/ratecounter'\n180      snapshot:\n181        $ref: '#/components/schemas/snapshot'\n182      token:\n183        $ref: '#/components/schemas/token'\n184    required:\n185      - name\n186required:\n187  - event\n188unsubscribe:\n189type: object\n190properties:\n191  event:\n192    type: string\n193    const: unsubscribe\n194  reqid:\n195    $ref: '#/components/schemas/reqid'\n196  pair:\n197    $ref: '#/components/schemas/pair'\n198  subscription:\n199    type: object\n200    properties:\n201      depth:\n202        $ref: '#/components/schemas/depth'\n203      interval:\n204        $ref: '#/components/schemas/interval'\n205      name:\n206        $ref: '#/components/schemas/name'\n207      token:\n208        $ref: '#/components/schemas/token'\n209    required:\n210      - name\n211required:\n212  - event\n213subscriptionStatus:\n214type: object\n215oneOf:\n216  - $ref: '#/components/schemas/subscriptionStatusError'\n217  - $ref: '#/components/schemas/subscriptionStatusSuccess'\n218subscriptionStatusError:\n219allOf:\n220  - properties:\n221      errorMessage:\n222        type: string\n223    required:\n224      - errorMessage\n225  - $ref: '#/components/schemas/subscriptionStatusCommon'\n226subscriptionStatusSuccess:\n227allOf:\n228  - properties:\n229      channelID:\n230        type: integer\n231        description: ChannelID on successful subscription, applicable to public messages only.\n232      channelName:\n233        type: string\n234        description: Channel Name on successful subscription. For payloads 'ohlc' and 'book', respective interval or depth will be added as suffix.\n235    required:\n236      - channelID\n237      - channelName\n238  - $ref: '#/components/schemas/subscriptionStatusCommon'\n239subscriptionStatusCommon:\n240type: object\n241required:\n242   - event\n243properties:\n244  event:\n245    type: string\n246    const: subscriptionStatus\n247  reqid:\n248    $ref: '#/components/schemas/reqid'\n249  pair:\n250    $ref: '#/components/schemas/pair'\n251  status:\n252    $ref: '#/components/schemas/status'\n253  subscription:\n254    required:\n255      - name\n256    type: object\n257    properties:\n258      depth:\n259        $ref: '#/components/schemas/depth'\n260      interval:\n261        $ref: '#/components/schemas/interval'\n262      maxratecount:\n263        $ref: '#/components/schemas/maxratecount'\n264      name:\n265        $ref: '#/components/schemas/name'\n266      token:\n267        $ref: '#/components/schemas/token'\n268interval:\n269type: integer\n270description: Time interval associated with ohlc subscription in minutes.\n271default: 1\n272enum:\n273  - 1\n274  - 5\n275  - 15\n276  - 30\n277  - 60\n278  - 240\n279  - 1440\n280  - 10080\n281  - 21600\n282name:\n283type: string\n284description: The name of the channel you subscribe too.\n285enum:\n286  - book\n287  - ohlc\n288  - openOrders\n289  - ownTrades\n290  - spread\n291  - ticker\n292  - trade\n293token:\n294type: string\n295description: base64-encoded authentication token for private-data endpoints.\n296depth:\n297type: integer\n298default: 10\n299enum:\n300  - 10\n301  - 25\n302  - 100\n303  - 500\n304  - 1000\n305description: Depth associated with book subscription in number of levels each side.\n306maxratecount:\n307type: integer\n308description: Max rate-limit budget. Compare to the ratecounter field in the openOrders updates to check whether you are approaching the rate limit.\n309ratecounter:\n310type: boolean\n311default: false\n312description: Whether to send rate-limit counter in updates (supported only for openOrders subscriptions)\n313snapshot:\n314type: boolean\n315default: true\n316description: Whether to send historical feed data snapshot upon subscription (supported only for ownTrades subscriptions)\n317reqid:\n318type: integer\n319description: client originated ID reflected in response message.\n320pair:\n321type: array\n322description: Array of currency pairs.\n323items:\n324  type: string\n325  description: Format of each pair is \"A/B\", where A and B are ISO 4217-A3 for standardized assets and popular unique symbol if not standardized.\n326  pattern: '[A-Z\\s]+\\/[A-Z\\s]+'\n```\n Personal note If you can, if you are in a planning phase, new project, etc., then start designing your architecture with AsyncAPI. Don't do the mistake of coding first and then trying to figure out how to describe it with AsyncAPI \ud83d\ude05 Stay tuned for the next blog post that guides you step by step through the above document \u262e\ufe0f I recommend you also read another article from the series about WebSocket: Creating AsyncAPI for WebSocket API - Step by Step .",
    "code_blocks": [
      "{  \"event\": \"subscribe\",  \"pair\": [    \"XBT/USD\",    \"XBT/EUR\"  ],  \"subscription\": {    \"name\": \"ticker\"  }}",
      "1{\"event\":\"heartbeat\"}\n2[340,{\"a\":[\"45520.10000\",6,\"6.78103490\"],\"b\":[\"45520.00000\",0,\"0.00185230\"],\"c\":[\"45520.10000\",\"0.01643250\"],\"v\":[\"1397.95434819\",\"5589.12101024\"],\"p\":[\"44883.49461\",\"44062.07654\"],\"t\":[14350,66782],\"l\":[\"43607.60000\",\"42770.80000\"],\"h\":[\"45811.10000\",\"45811.10000\"],\"o\":[\"43659.30000\",\"44709.10000\"]},\"ticker\",\"XBT/EUR\"]\n3[340,{\"a\":[\"45520.10000\",5,\"5.84803490\"],\"b\":[\"45492.50000\",0,\"0.09374582\"],\"c\":[\"45492.50000\",\"0.00625418\"],\"v\":[\"1398.10526819\",\"5589.26685876\"],\"p\":[\"44883.56109\",\"44062.11477\"],\"t\":[14359,66790],\"l\":[\"43607.60000\",\"42770.80000\"],\"h\":[\"45811.10000\",\"45811.10000\"],\"o\":[\"43659.30000\",\"44709.10000\"]},\"ticker\",\"XBT/EUR\"]\n4{\"event\":\"heartbeat\"}\n5[340,{\"a\":[\"45503.80000\",1,\"1.00000000\"],\"b\":[\"45496.20000\",0,\"0.01426600\"],\"c\":[\"45496.20000\",\"0.00109400\"],\"v\":[\"1398.10636219\",\"5589.26295766\"],\"p\":[\"44883.56157\",\"44062.11447\"],\"t\":[14360,66788],\"l\":[\"43607.60000\",\"42770.80000\"],\"h\":[\"45811.10000\",\"45811.10000\"],\"o\":[\"43659.30000\",\"44709.90000\"]},\"ticker\",\"XBT/EUR\"]\n6{\"event\":\"heartbeat\"}",
      "1asyncapi: 2.0.0\n2\n3info:\n4  title: Kraken Websockets API\n5  version: '1.8.0'\n6  description: |\n7    WebSockets API offers real-time market data updates. WebSockets is a bidirectional protocol offering fastest real-time data, helping you build real-time applications. The public message types presented below do not require authentication. Private-data messages can be subscribed on a separate authenticated endpoint. \n8\n9    ### General Considerations\n10\n11    - TLS with SNI (Server Name Indication) is required in order to establish a Kraken WebSockets API connection. See Cloudflare's [What is SNI?](https://www.cloudflare.com/learning/ssl/what-is-sni/) guide for more details.\n12    - All messages sent and received via WebSockets are encoded in JSON format\n13    - All decimal fields (including timestamps) are quoted to preserve precision.\n14    - Timestamps should not be considered unique and not be considered as aliases for transaction IDs. Also, the granularity of timestamps is not representative of transaction rates.\n15    - At least one private message should be subscribed to keep the authenticated client connection open.\n16    - Please use REST API endpoint [AssetPairs](https://www.kraken.com/features/api#get-tradable-pairs) to fetch the list of pairs which can be subscribed via WebSockets API. For example, field 'wsname' gives the supported pairs name which can be used to subscribe.\n17    - Cloudflare imposes a connection/re-connection rate limit (per IP address) of approximately 150 attempts per rolling 10 minutes. If this is exceeded, the IP is banned for 10 minutes.\n18    - Recommended reconnection behaviour is to (1) attempt reconnection instantly up to a handful of times if the websocket is dropped randomly during normal operation but (2) after maintenance or extended downtime, attempt to reconnect no more quickly than once every 5 seconds. There is no advantage to reconnecting more rapidly after maintenance during cancel_only mode.\n19\n20servers:\n21  public:\n22    url: ws.kraken.com\n23    protocol: wss\n24    description: |\n25      Public server available without authorization.\n26      Once the socket is open you can subscribe to a public channel by sending a subscribe request message.\n27  private:\n28    url: ws-auth.kraken.com\n29    protocol: wss\n30    description: |\n31      Private server that requires authorization.\n32      Once the socket is open you can subscribe to private-data channels by sending an authenticated subscribe request message.\n33\n34      The API client must request an authentication \"token\" via the following REST API endpoint \"GetWebSocketsToken\" to connect to WebSockets Private endpoints. For more details read https://support.kraken.com/hc/en-us/articles/360034437672-How-to-retrieve-a-WebSocket-authentication-token-Example-code-in-Python-3\n35\n36      The resulting token must be provided in the \"token\" field of any new private WebSocket feed subscription:",
      "1\n2channels:\n3/:\n4publish:\n5description: Send messages to the API\n6operationId: processReceivedMessage\n7message:\n8  oneOf:\n9    - $ref: '#/components/messages/ping'\n10    - $ref: '#/components/messages/subscribe'\n11    - $ref: '#/components/messages/unsubscribe'\n12\n13subscribe:\n14description: Messages that you receive from the API\n15operationId: sendMessage\n16message:\n17  oneOf:\n18    - $ref: '#/components/messages/pong'\n19    - $ref: '#/components/messages/heartbeat'\n20    - $ref: '#/components/messages/systemStatus'\n21    - $ref: '#/components/messages/subscriptionStatus'\n22\n23components:\n24messages:\n25ping:\n26summary: Ping server to determine whether connection is alive\n27description: Client can ping server to determine whether connection is alive, server responds with pong. This is an application level ping as opposed to default ping in websockets standard which is server initiated\n28payload:\n29  $ref: '#/components/schemas/ping'\n30x-response:\n31  $ref: '#/components/messages/pong'\n32heartbeat:\n33description: Server heartbeat sent if no subscription traffic within 1 second (approximately)\n34payload:\n35  $ref: '#/components/schemas/heartbeat'\n36pong:\n37summary: Pong is a response to ping message\n38description: Server pong response to a ping to determine whether connection is alive. This is an application level pong as opposed to default pong in websockets standard which is sent by client in response to a ping\n39payload:\n40  $ref: '#/components/schemas/pong'\n41systemStatus:\n42description: Status sent on connection or system status changes.\n43payload:\n44  $ref: '#/components/schemas/systemStatus'\n45examples:\n46  - payload:\n47      connectionID: 8628615390848610000\n48      event: systemStatus\n49      status: online\n50      version: 1.0.0\n51subscribe:\n52description: Subscribe to a topic on a single or multiple currency pairs.\n53payload:\n54  $ref: '#/components/schemas/subscribe'\n55examples:\n56  - payload:\n57      event: subscribe\n58      pair:\n59        - XBT/USD\n60        - XBT/EUR\n61      subscription:\n62        name: ticker\n63  - payload:\n64      event: subscribe\n65      subscription:\n66        name: ownTrades\n67        token: WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu\n68x-response:\n69  $ref: '#/components/messages/subscriptionStatus'\n70unsubscribe:\n71description: Unsubscribe, can specify a channelID or multiple currency pairs.\n72payload:\n73  $ref: '#/components/schemas/subscribe'\n74examples:\n75  - payload:\n76      event: unsubscribe\n77      pair:\n78        - XBT/EUR\n79        - XBT/USD\n80      subscription:\n81        name: ticker\n82  - payload:\n83      event: unsubscribe\n84      subscription:\n85        name: ownTrades\n86        token: WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu\n87x-response:\n88  $ref: '#/components/messages/subscriptionStatus'\n89subscriptionStatus:\n90description: Subscription status response to subscribe, unsubscribe or exchange initiated unsubscribe.\n91payload:\n92  $ref: '#/components/schemas/subscriptionStatus'\n93examples:\n94  - payload:\n95      channelID: 10001\n96      channelName: ohlc-5\n97      event: subscriptionStatus\n98      pair: XBT/EUR\n99      reqid: 42\n100      status: unsubscribed\n101      subscription:\n102        interval: 5\n103        name: ohlc\n104  - payload:\n105      errorMessage: Subscription depth not supported\n106      event: subscriptionStatus\n107      pair: XBT/USD\n108      status: error\n109      subscription:\n110        depth: 42\n111        name: book\n112\n113schemas:\n114ping:\n115type: object\n116properties:\n117  event:\n118    type: string\n119    const: ping\n120  reqid:\n121    $ref: '#/components/schemas/reqid'\n122required:\n123  - event\n124heartbeat:\n125type: object\n126properties:\n127  event:\n128    type: string\n129    const: heartbeat\n130pong:\n131type: object\n132properties:\n133  event:\n134    type: string\n135    const: pong\n136  reqid:\n137    $ref: '#/components/schemas/reqid'\n138systemStatus:\n139type: object\n140properties:\n141  event:\n142    type: string\n143    const: systemStatus\n144  connectionID:\n145    type: integer\n146    description: The ID of the connection\n147  status:\n148    $ref: '#/components/schemas/status'\n149  version:\n150    type: string\n151status:\n152type: string\n153enum:\n154  - online\n155  - maintenance\n156  - cancel_only\n157  - limit_only\n158  - post_only\n159subscribe:\n160type: object\n161properties:\n162  event:\n163    type: string\n164    const: subscribe\n165  reqid:\n166    $ref: '#/components/schemas/reqid'\n167  pair:\n168    $ref: '#/components/schemas/pair'\n169  subscription:\n170    type: object\n171    properties:\n172      depth:\n173        $ref: '#/components/schemas/depth'\n174      interval:\n175        $ref: '#/components/schemas/interval'\n176      name:\n177        $ref: '#/components/schemas/name'\n178      ratecounter:\n179        $ref: '#/components/schemas/ratecounter'\n180      snapshot:\n181        $ref: '#/components/schemas/snapshot'\n182      token:\n183        $ref: '#/components/schemas/token'\n184    required:\n185      - name\n186required:\n187  - event\n188unsubscribe:\n189type: object\n190properties:\n191  event:\n192    type: string\n193    const: unsubscribe\n194  reqid:\n195    $ref: '#/components/schemas/reqid'\n196  pair:\n197    $ref: '#/components/schemas/pair'\n198  subscription:\n199    type: object\n200    properties:\n201      depth:\n202        $ref: '#/components/schemas/depth'\n203      interval:\n204        $ref: '#/components/schemas/interval'\n205      name:\n206        $ref: '#/components/schemas/name'\n207      token:\n208        $ref: '#/components/schemas/token'\n209    required:\n210      - name\n211required:\n212  - event\n213subscriptionStatus:\n214type: object\n215oneOf:\n216  - $ref: '#/components/schemas/subscriptionStatusError'\n217  - $ref: '#/components/schemas/subscriptionStatusSuccess'\n218subscriptionStatusError:\n219allOf:\n220  - properties:\n221      errorMessage:\n222        type: string\n223    required:\n224      - errorMessage\n225  - $ref: '#/components/schemas/subscriptionStatusCommon'\n226subscriptionStatusSuccess:\n227allOf:\n228  - properties:\n229      channelID:\n230        type: integer\n231        description: ChannelID on successful subscription, applicable to public messages only.\n232      channelName:\n233        type: string\n234        description: Channel Name on successful subscription. For payloads 'ohlc' and 'book', respective interval or depth will be added as suffix.\n235    required:\n236      - channelID\n237      - channelName\n238  - $ref: '#/components/schemas/subscriptionStatusCommon'\n239subscriptionStatusCommon:\n240type: object\n241required:\n242   - event\n243properties:\n244  event:\n245    type: string\n246    const: subscriptionStatus\n247  reqid:\n248    $ref: '#/components/schemas/reqid'\n249  pair:\n250    $ref: '#/components/schemas/pair'\n251  status:\n252    $ref: '#/components/schemas/status'\n253  subscription:\n254    required:\n255      - name\n256    type: object\n257    properties:\n258      depth:\n259        $ref: '#/components/schemas/depth'\n260      interval:\n261        $ref: '#/components/schemas/interval'\n262      maxratecount:\n263        $ref: '#/components/schemas/maxratecount'\n264      name:\n265        $ref: '#/components/schemas/name'\n266      token:\n267        $ref: '#/components/schemas/token'\n268interval:\n269type: integer\n270description: Time interval associated with ohlc subscription in minutes.\n271default: 1\n272enum:\n273  - 1\n274  - 5\n275  - 15\n276  - 30\n277  - 60\n278  - 240\n279  - 1440\n280  - 10080\n281  - 21600\n282name:\n283type: string\n284description: The name of the channel you subscribe too.\n285enum:\n286  - book\n287  - ohlc\n288  - openOrders\n289  - ownTrades\n290  - spread\n291  - ticker\n292  - trade\n293token:\n294type: string\n295description: base64-encoded authentication token for private-data endpoints.\n296depth:\n297type: integer\n298default: 10\n299enum:\n300  - 10\n301  - 25\n302  - 100\n303  - 500\n304  - 1000\n305description: Depth associated with book subscription in number of levels each side.\n306maxratecount:\n307type: integer\n308description: Max rate-limit budget. Compare to the ratecounter field in the openOrders updates to check whether you are approaching the rate limit.\n309ratecounter:\n310type: boolean\n311default: false\n312description: Whether to send rate-limit counter in updates (supported only for openOrders subscriptions)\n313snapshot:\n314type: boolean\n315default: true\n316description: Whether to send historical feed data snapshot upon subscription (supported only for ownTrades subscriptions)\n317reqid:\n318type: integer\n319description: client originated ID reflected in response message.\n320pair:\n321type: array\n322description: Array of currency pairs.\n323items:\n324  type: string\n325  description: Format of each pair is \"A/B\", where A and B are ISO 4217-A3 for standardized assets and popular unique symbol if not standardized.\n326  pattern: '[A-Z\\s]+\\/[A-Z\\s]+'"
    ],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/posts/websocket-part1/cover.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/websocket-part1/websocket-shrek.webp",
        "alt": "Figure 1: HTTP Pull vs WebSocket vs Shrek."
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "2feb8e56",
    "title": "Creating AsyncAPI for WebSocket API - Step by Step | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/blog/websocket-part2.html",
    "content": "Creating AsyncAPI for WebSocket API - Step by Step | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Choosing the right road to Rome Kraken API use case Writing a single AsyncAPI document Basic information about the API Provide server information Describing multiple servers Server security Endpoints aka Channels Multiple different messages on the same channel Messages definition Describe responses - specification extensions Schemas vs JSON Schema Schemas complexity Let's have a look at the final document \n![](/img/posts/websocket-part2/cover.webp)\n This step-by-step guide is a continuation of a series of articles about WebSockets. I recommend reading WebSocket, Shrek, and AsyncAPI - An Opinionated Intro first. If you do not want to read this article, then watch the recording of the live stream about the same: All roads lead to Rome, but all those roads are different. First, you need to identify where you are and what is the purpose of your journey. What is your goal? What do you want to use AsyncAPI for? You may invest in using the specification for many different reasons, like for example: documentation testing mocking code generation message validation Depending on your goal, you might need to take different roads to get there. If your only goal is documentation, you might take a different approach to writing an AsyncAPI file than you would take while thinking about code generation. Choosing the right road to Rome Let's say AsyncAPI does not fully cover your use case. You are missing some extra property. You are disappointed that you cannot explicitly provide information that your production servers both support different channels. Server A supports channel AA and AB, while Server B supports channel BA and BB. It is not currently possible with the specification as the assumption is that your application communicates with servers that support the same channels. There are two roads to Rome: Road docs-only : You need AsyncAPI for docs generation only and have no intention of sharing the source document with anyone. It means you do not need to bother much about inventing some specification extension. You can just add missing information to the description of a given object. Road automation : You need AsyncAPI for docs and code generation, which means that all details in your AsyncAPI document must be machine-readable. You can't just put unsupported information in the description. Kraken API use case I'm going to guide you through the process of creating an AsyncAPI document. I'll use the example of Kraken API mentioned in my previous article . The challenge I had here was that I'm trying to document an API basing on public docs with no access to a subject matter expert. I also have zero understanding of the cryptocurrency industry and still do not fully understand the vocabulary. Message to Kraken API developers and technical writers In case you want to continue the work I started on the AsyncAPI document for Kraken API, feel free to do that. I'm happy to help, just let me know. Reach me out in our AsyncAPI Slack workspace . More interesting here are the technical challenges though, caused by the fact that Kraken's API: has two production servers for non-secure and secure message exchange some messages are supported only by the public and some only by a private server has just one entry point for communication. You do not get specific messages from one of many endpoints. You get specific messages after first sending a subscription message. Meaning you have a request message and you get a reply message, so something that is not yet possible to describe with AsyncAPI in a machine-readable way Writing a single AsyncAPI document Because of all these different challenges, I took the docs-only road described in section Choosing the right road to Rome . No worries though, I give tips for the automation road too. Basic information about the API First, provide some basic information that every good AsyncAPI file should have: What AsyncAPI version do you use? What is the name of your API? What version of the API you describe? Do not underestimate the description. Optional != not needed. AsyncAPI supports markdown in descriptions. Provide long generic documentation for your API. Benefit from markdown features to structure it, so it is easier to read In case you think using just one property to add overarching documentation for your API is very limiting, I agree with you \ud83d\ude03 Join discussion here . I believe spec should have better support for docs, and we should first explore it with specification extensions. To be honest, I always thought documentation deserves its specification, but I don't want to bother you with my wicked visions now. \n```javascript\n1asyncapi: 2.0.0\n2info:\n3  title: Kraken Websockets API\n4  version: '1.8'\n5  description: |\n6    WebSockets API offers real-time market data updates. WebSockets is a bidirectional protocol offering fastest real-time data, helping you build real-time applications. The public message types presented below do not require authentication. Private-data messages can be subscribed on a separate authenticated endpoint. \n7\n8    ### General Considerations\n9\n10    - TLS with SNI (Server Name Indication) is required in order to establish a Kraken WebSockets API connection. See Cloudflare's [What is SNI?](https://www.cloudflare.com/learning/ssl/what-is-sni/) guide for more details.\n11    - All messages sent and received via WebSockets are encoded in JSON format.\n12    - All decimal fields (including timestamps) are quoted to preserve precision.\n13    - Timestamps should not be considered unique and not be considered as aliases for transaction IDs. Also, the granularity of timestamps is not representative of transaction rates.\n14    - At least one private message should be subscribed to keep the authenticated client connection open.\n15    - Please use REST API endpoint [AssetPairs](https://www.kraken.com/features/api#get-tradable-pairs) to fetch the list of pairs which can be subscribed via WebSockets API. For example, field 'wsname' gives the supported pairs name which can be used to subscribe.\n16    - Cloudflare imposes a connection/re-connection rate limit (per IP address) of approximately 150 attempts per rolling 10 minutes. If this is exceeded, the IP is banned for 10 minutes.\n17    - Recommended reconnection behaviour is to (1) attempt reconnection instantly up to a handful of times if the websocket is dropped randomly during normal operation but (2) after maintenance or extended downtime, attempt to reconnect no more quickly than once every 5 seconds. There is no advantage to reconnecting more rapidly after maintenance during cancel_only mode.\n```\n Provide server information Describe how to connect to the API: What is the URL of the server? Is there any authorization in place? What is the protocol requirement, is SSL connection required? The Kraken API is an excellent example of how different WebSocket implementations can be and that there is never one way to design your architecture. It all depends on your requirements, the use cases that drive your product. Describing multiple servers Below you can notice two different servers. These are not, as you might think, production and development servers. Here you have a clear division between publicly available data and private-only data. In other words, users use two different servers, not channels/paths/endpoints, to talk to the API. \n```javascript\n1servers:\n2  public:\n3    url: ws.kraken.com\n4    protocol: wss\n5    description: |\n6      Public server available without authorization.\n7      Once the socket is open you can subscribe to a public channel by sending a subscribe request message.\n8  private:\n9    url: ws-auth.kraken.com\n10    protocol: wss\n11    description: |\n12      Private server that requires authorization.\n13      Once the socket is open you can subscribe to private-data channels by sending an authenticated subscribe request message.\n```\n You can verify if above is true by connecting to ws.kraken.com and trying to subscribe to one of the event streams that require a token: \n```javascript\n{ \"event\": \"subscribe\",  \"subscription\": { \"name\": \"ownTrades\", \"token\": \"WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu\" } }\n```\n In response you get an error: \n```javascript\n{\"errorMessage\":\"Private data and trading are unavailable on this endpoint. Try ws-auth.kraken.com\",\"event\":\"subscriptionStatus\",\"status\":\"error\",\"subscription\":{\"name\":\"ownTrades\",\"token\":\"WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu\"}}\n```\n In the documentation, they also indicate beta servers like beta-ws.kraken.com . It is hard to understand their purpose, so I did not put them in the AsyncAPI document. For me, beta means something new, some upgrades, and I would consider writing a separate AsyncAPI document. Is it reasonable to describe API that has two different production servers in one AsyncAPI? As usual, it depends. For docs-only road described in section Choosing the right road to Rome , you can \"workaround\" some AsyncAPI features if they do not support your use case. Check out, for example, what I had to do in section Server security where I was not sure how to describe the specific security of the private server. Short answer: just extend the description. For automation road described in Choosing the right road to Rome section, you need a machine-readable structure. In case you have messages that can be consumed only by the private server, you need a way to specify that the given message can be published only to the private server. It is exactly the case with Kraken API. Imagine you want to read the AsyncAPI document in real-time in your server and validate all incoming messages. Take server ws.kraken.com . The only way to emit errors like Private data and trading are unavailable on this endpoint. Try ws-auth.kraken.com is by writing the code that handles validation manually. You can't generate that as the AsyncAPI file does not specify what messages can go to ws.kraken.com and what messages can't. Why? At the moment, in AsyncAPI, you don't have a way to \"wire\" a server with a message, operation, or a channel. There are no default properties that allow you to provide information that message with the name ownTrades can only be sent to ws-auth.kraken.com server. Solution? Create two AsyncAPI documents. Treat those two servers as separate services that share messages and schemas. Use $ref feature to cross-reference schemas . Server security You can use AsyncAPI also to describe the security of your API. You can describe in a machine-readable way the security mechanism that protects the server. Several security schemes are supported. In Kraken's case, I could not figure out what kind of security scheme they use from their docs. They seem to have a non-standard set up for getting the authorization token, which is why the only option was to put a human-readable-only description there. \n```javascript\n1servers:\n2  public:\n3    url: ws.kraken.com\n4    protocol: wss\n5    description: |\n6      Public server available without authorization.\n7      Once the socket is open, you can subscribe to a public channel by sending a subscribe request message.\n8  private:\n9    url: ws-auth.kraken.com\n10    protocol: wss\n11    description: |\n12      Private server that requires authorization.\n13      Once the socket is open, you can subscribe to private-data channels by sending an authenticated subscribe request message.\n14\n15      The API client must request an authentication \"token\" via the following REST API endpoint \"GetWebSocketsToken\" to connect to WebSockets Private endpoints. For more details, read https://support.kraken.com/hc/en-us/articles/360034437672-How-to-retrieve-a-WebSocket-authentication-token-Example-code-in-Python-3\n16\n17      The resulting token must be provided in the \"token\" field of any new private WebSocket feed subscription: \n18      ```\n19      {\n20        \"event\": \"subscribe\",\n21        \"subscription\":\n22        {\n23          \"name\": \"ownTrades\",\n24          \"token\": \"WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu\"\n25        }\n26      }\n27      ```\n```\n Endpoints aka Channels I saw WebSocket APIs that provide different streams of messages on separate endpoints. It is often the case when you build the WebSocket API for the frontend only and design it for different UI views. In the case of Kraken API we have no endpoints. You connect to the root of the server. No matter what setup you have, just remember you should use channels to describe it. In the case of connecting to the root, it is as simple as: \n```javascript\n1channels:\n2  /:\n```\n Multiple different messages on the same channel You can have one or many different messages coming to your channel. Like in the case of Kraken API, you can even have multiple messages, incoming and outgoing. You can describe it using oneOf on message object as you can see below: \n```javascript\n1channels:\n2  /:\n3    publish:\n4      operationId: sendMessage\n5      message:\n6        oneOf:\n7          - $ref: '#/components/messages/ping'\n8          - $ref: '#/components/messages/subscribe'\n9          - $ref: '#/components/messages/unsubscribe'\n10    subscribe:\n11      operationId: processMessage\n12      message:\n13        oneOf:\n14          - $ref: '#/components/messages/pong'\n15          - $ref: '#/components/messages/heartbeat'\n16          - $ref: '#/components/messages/systemStatus'\n17          - $ref: '#/components/messages/subscriptionStatus'\n```\n Hold on! Where did these publish and subscribe keywords came from. When we talk about WebSocket, we usually do not use words like subscribe and publish, as we do not think about producers and consumers. Just check out the protocol RfC . We are used to sending and receiving messages. Let me present to you an unofficial AsyncAPI vocabulary translator for WebSocket users \ud83d\ude03 WebSocket term AsyncAPI term Meaning from API server perspective Meaning from API user perspective Send Publish The API server receives the given message. The API user can send a given message to the API server. Receive Subscribe The API server sends a given message. The API user can receive a given message from the API server. Messages definition In event-driven architectures (EDA) it's all about the event, right? The message passed in the system. You need to specify many details about the message, like its payload structure, headers, purpose, and many others. Above all, always remember to have good examples. Please don't count on the autogenerated ones, as in most cases, they're useless. \n```javascript\n1messages:\n2  systemStatus:\n3    description: Status sent on connection or system status changes.\n4    payload:\n5      $ref: '#/components/schemas/systemStatus'\n6    examples:\n7      - payload:\n8          connectionID: 8628615390848610000\n9          event: systemStatus\n10          status: online\n11          version: 1.0.0\n```\n Describe responses - specification extensions Describe responses? What responses? It is EDA. Who cares about responses, right? Fire and forget rules! The thing is that request and reply pattern is also used in EDA. This is also the case with Kraken API where communication goes through a single channel with multiple different messages. One message triggers another message in response. The simplest example is the message ping that triggers a pong reply. The current AsyncAPI limitation is that you cannot specify that once the user sends (publish) message ping , the pong message is received in a reply. Look at this thread to participate in an ongoing discussion about request/reply pattern support in AsyncAPI. For docs-only road from section Choosing the right road to Rome , I would be lazy and just put such info in the description of both messages. Even though this is an error-prone approach, I would just make my life easier. For automation road I would choose to use a specification extension. What is specification extension? You can extend every AsyncAPI object in the AsyncAPI document with extra properties. You only need to prefix them with x- . You can also share extensions or reuse extensions from others thanks to extensions catalog . In the below document, you will notice that for the request/reply pattern, I use AsyncAPI specification extensions called x-response . \n```javascript\n1messages:\n2  ping:\n3    summary: Ping server to determine whether connection is alive\n4    description: Client can ping server to determine whether connection is alive, server responds with pong. This is an application level ping as opposed to default ping in websockets standard which is server initiated\n5    payload:\n6      $ref: '#/components/schemas/ping'\n7    x-response:\n8      $ref: '#/components/messages/pong'\n```\n Even though the reference to another object is provided inside the extension that is not part of AsyncAPI, our parser will resolve it correctly. It means that under x-response property, I will have access to the entire message object. Schemas vs JSON Schema Because the message itself is most important in the entire EDA, you need to describe the message payload properly. AsyncAPI allows you to provide payload information in different schema formats. The default format is AsyncAPI Schema that is a superset of JSON Schema. You can use others too, like Avro, for example. From the AsyncAPI document point of view, the most important is that you can reuse schemas. In other words, instead of providing data directly to the payload object, you can $ref them from components.schemas or even an external document. Just DRY, right? The rest, I would say, has nothing to do with AsyncAPI itself. How you structure schemas depends on you and the schema format that you use. It is why the next sections of my article describe something specific, not for the AsyncAPI itself but rather JSON Schema. Simplest example of schemas from Kraken API is a payload for ping message: \n```javascript\n1schemas:\n2  ping:\n3    type: object\n4    properties:\n5      event:\n6        type: string\n7        const: ping\n8      reqid:\n9        $ref: '#/components/schemas/reqid'\n10    required:\n11      - event\n12  reqid:\n13    type: integer\n14    description: client originated ID reflected in response message.\n```\n You can see that ping message is an object that has two properties where only one is required. One property is used across other messages, so is part of many different schemas, so better to keep its definition as a separate schema and reference where needed. Schemas complexity Splitting schemas into reusable chunks with $ref usage is not something complex. It gets complex when messages are complex, when you get different message payload depending on system behavior. Kraken API has a subscriptionStatus message where payload depends on the success of the subscription. In case of successful subscription, you get a message with channelID and channelName properties, but in case of failure, the message doesn't contain these properties but in exchange has errorMessage . In other words, some properties are mutually exclusive. \n```javascript\n1    subscriptionStatus:\n2      type: object\n3      oneOf:\n4        - required:\n5            - errorMessage\n6          not:\n7            required:\n8                - channelID\n9                - channelName\n10        - required:\n11            - channelID\n12            - channelName\n13          not:\n14            required:\n15                - errorMessage\n16      properties:\n17        channelID:\n18          type: integer\n19          description: ChannelID on successful subscription, applicable to public messages only.\n20        channelName:\n21          type: string\n22          description: Channel Name on successful subscription. For payloads 'ohlc' and 'book', respective interval or depth will be added as suffix.\n23        errorMessage:\n24          type: string\n25        event:\n26          type: string\n27          const: subscriptionStatus\n28        reqid:\n29          $ref: '#/components/schemas/reqid'\n30        pair:\n31          $ref: '#/components/schemas/pair'\n32        status:\n33          $ref: '#/components/schemas/status'\n34        subscription:\n35          type: object\n36          properties:\n37            depth:\n38              $ref: '#/components/schemas/depth'\n39            interval:\n40              $ref: '#/components/schemas/interval'\n41            maxratecount:\n42              $ref: '#/components/schemas/maxratecount'\n43            name:\n44              $ref: '#/components/schemas/name'\n45            token:\n46              $ref: '#/components/schemas/token'\n47          required:\n48            - name\n49      required:\n50        - event\n```\n It is what I call a complex schema, where good JSON Schema knowledge is needed. The problem with complex schemas is that not many tools support these kinds of schemas. By the time I write this article, our AsyncAPI tools for documentation rendering will fail to render the above schema correctly. It is why you sometimes need compromises and adjusts schemas, so they get proper tooling support. Below you can see the same schema but structured in a more straightforward way supported by most tools. \n```javascript\n1    subscriptionStatus:\n2      type: object\n3      oneOf:\n4        - $ref: '#/components/schemas/subscriptionStatusError'\n5        - $ref: '#/components/schemas/subscriptionStatusSuccess'\n6    subscriptionStatusError:\n7      allOf:\n8        - properties:\n9            errorMessage:\n10              type: string\n11          required:\n12            - errorMessage\n13        - $ref: '#/components/schemas/subscriptionStatusCommon'\n14    subscriptionStatusSuccess:\n15      allOf:\n16        - properties:\n17            channelID:\n18              type: integer\n19              description: ChannelID on successful subscription, applicable to public messages only.\n20            channelName:\n21              type: string\n22              description: Channel Name on successful subscription. For payloads 'ohlc' and 'book', respective interval or depth will be added as suffix.\n23          required:\n24            - channelID\n25            - channelName\n26        - $ref: '#/components/schemas/subscriptionStatusCommon'\n27    subscriptionStatusCommon:\n28      type: object\n29      required:\n30         - event\n31      properties:\n32        event:\n33          type: string\n34          const: subscriptionStatus\n35        reqid:\n36          $ref: '#/components/schemas/reqid'\n37        pair:\n38          $ref: '#/components/schemas/pair'\n39        status:\n40          $ref: '#/components/schemas/status'\n41        subscription:\n42          required:\n43            - name\n44          type: object\n45          properties:\n46            depth:\n47              $ref: '#/components/schemas/depth'\n48            interval:\n49              $ref: '#/components/schemas/interval'\n50            maxratecount:\n51              $ref: '#/components/schemas/maxratecount'\n52            name:\n53              $ref: '#/components/schemas/name'\n54            token:\n55              $ref: '#/components/schemas/token'\n```\n I managed to get a structure that will be nicely rendered in the UI. Even code generation will work well. It is a bit more complex than initial structure, although this is rather subjective personal-taste-like opinion. Let's have a look at the final document Websocket protocol is very flexible, and therefore you can implement the server in many different ways. The path that Kraken API took is complex but not impossible to describe with the AsyncAPI document. Look at the document's final structure and keep in mind that it is not a complete document for Kraken API and the road that I chose to get to Rome was to focus on documentation rendering only. For automation road described in section Choosing the right road to Rome , the document should be split into two documents: one for private and one for public servers. Common parts, like common messages and schemas, should be stored in separate files and referred from these two AsyncAPI documents using $ref . Another solution would be to use specification extensions to describe relations between messages and servers. You can open this document directly in AsyncAPI Studio by clicking this link. Compare it also with the original documentation . \n```javascript\n1asyncapi: 2.0.0\n2\n3info:\n4  title: Kraken Websockets API\n5  version: '1.8.0'\n6  description: |\n7    WebSockets API offers real-time market data updates. WebSockets is a bidirectional protocol offering fastest real-time data, helping you build real-time applications. The public message types presented below do not require authentication. Private-data messages can be subscribed on a separate authenticated endpoint. \n8\n9    ### General Considerations\n10\n11    - TLS with SNI (Server Name Indication) is required in order to establish a Kraken WebSockets API connection. See Cloudflare's [What is SNI?](https://www.cloudflare.com/learning/ssl/what-is-sni/) guide for more details.\n12    - All messages sent and received via WebSockets are encoded in JSON format\n13    - All decimal fields (including timestamps) are quoted to preserve precision.\n14    - Timestamps should not be considered unique and not be considered as aliases for transaction IDs. Also, the granularity of timestamps is not representative of transaction rates.\n15    - At least one private message should be subscribed to keep the authenticated client connection open.\n16    - Please use REST API endpoint [AssetPairs](https://www.kraken.com/features/api#get-tradable-pairs) to fetch the list of pairs which can be subscribed via WebSockets API. For example, field 'wsname' gives the supported pairs name which can be used to subscribe.\n17    - Cloudflare imposes a connection/re-connection rate limit (per IP address) of approximately 150 attempts per rolling 10 minutes. If this is exceeded, the IP is banned for 10 minutes.\n18    - Recommended reconnection behaviour is to (1) attempt reconnection instantly up to a handful of times if the websocket is dropped randomly during normal operation but (2) after maintenance or extended downtime, attempt to reconnect no more quickly than once every 5 seconds. There is no advantage to reconnecting more rapidly after maintenance during cancel_only mode.\n19\n20servers:\n21  public:\n22    url: ws.kraken.com\n23    protocol: wss\n24    description: |\n25      Public server available without authorization.\n26      Once the socket is open you can subscribe to a public channel by sending a subscribe request message.\n27  private:\n28    url: ws-auth.kraken.com\n29    protocol: wss\n30    description: |\n31      Private server that requires authorization.\n32      Once the socket is open you can subscribe to private-data channels by sending an authenticated subscribe request message.\n33\n34      The API client must request an authentication \"token\" via the following REST API endpoint \"GetWebSocketsToken\" to connect to WebSockets Private endpoints. For more details read https://support.kraken.com/hc/en-us/articles/360034437672-How-to-retrieve-a-WebSocket-authentication-token-Example-code-in-Python-3\n35\n36      The resulting token must be provided in the \"token\" field of any new private WebSocket feed subscription: \n37      ```\n38      {\n39        \"event\": \"subscribe\",\n40        \"subscription\":\n41        {\n42          \"name\": \"ownTrades\",\n43          \"token\": \"WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu\"\n44        }\n45      }\n46      ```\n47\n48channels:\n49  /:\n50    publish:\n51      description: Send messages to the API\n52      operationId: processReceivedMessage\n53      message:\n54        oneOf:\n55          - $ref: '#/components/messages/ping'\n56          - $ref: '#/components/messages/subscribe'\n57          - $ref: '#/components/messages/unsubscribe'\n58\n59    subscribe:\n60      description: Messages that you receive from the API\n61      operationId: sendMessage\n62      message:\n63        oneOf:\n64          - $ref: '#/components/messages/pong'\n65          - $ref: '#/components/messages/heartbeat'\n66          - $ref: '#/components/messages/systemStatus'\n67          - $ref: '#/components/messages/subscriptionStatus'\n68\n69components:\n70  messages:\n71    ping:\n72      summary: Ping server to determine whether connection is alive\n73      description: Client can ping server to determine whether connection is alive, server responds with pong. This is an application level ping as opposed to default ping in websockets standard which is server initiated\n74      payload:\n75        $ref: '#/components/schemas/ping'\n76      x-response:\n77        $ref: '#/components/messages/pong'\n78    heartbeat:\n79      description: Server heartbeat sent if no subscription traffic within 1 second (approximately)\n80      payload:\n81        $ref: '#/components/schemas/heartbeat'\n82    pong:\n83      summary: Pong is a response to ping message\n84      description: Server pong response to a ping to determine whether connection is alive. This is an application level pong as opposed to default pong in websockets standard which is sent by client in response to a ping\n85      payload:\n86        $ref: '#/components/schemas/pong'\n87    systemStatus:\n88      description: Status sent on connection or system status changes.\n89      payload:\n90        $ref: '#/components/schemas/systemStatus'\n91      examples:\n92        - payload:\n93            connectionID: 8628615390848610000\n94            event: systemStatus\n95            status: online\n96            version: 1.0.0\n97    subscribe:\n98      description: Subscribe to a topic on a single or multiple currency pairs.\n99      payload:\n100        $ref: '#/components/schemas/subscribe'\n101      examples:\n102        - payload:\n103            event: subscribe\n104            pair:\n105              - XBT/USD\n106              - XBT/EUR\n107            subscription:\n108              name: ticker\n109        - payload:\n110            event: subscribe\n111            subscription:\n112              name: ownTrades\n113              token: WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu\n114      x-response:\n115        $ref: '#/components/messages/subscriptionStatus'\n116    unsubscribe:\n117      description: Unsubscribe, can specify a channelID or multiple currency pairs.\n118      payload:\n119        $ref: '#/components/schemas/subscribe'\n120      examples:\n121        - payload:\n122            event: unsubscribe\n123            pair:\n124              - XBT/EUR\n125              - XBT/USD\n126            subscription:\n127              name: ticker\n128        - payload:\n129            event: unsubscribe\n130            subscription:\n131              name: ownTrades\n132              token: WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu\n133      x-response:\n134        $ref: '#/components/messages/subscriptionStatus'\n135    subscriptionStatus:\n136      description: Subscription status response to subscribe, unsubscribe or exchange initiated unsubscribe.\n137      payload:\n138        $ref: '#/components/schemas/subscriptionStatus'\n139      examples:\n140        - payload:\n141            channelID: 10001\n142            channelName: ohlc-5\n143            event: subscriptionStatus\n144            pair: XBT/EUR\n145            reqid: 42\n146            status: unsubscribed\n147            subscription:\n148              interval: 5\n149              name: ohlc\n150        - payload:\n151            errorMessage: Subscription depth not supported\n152            event: subscriptionStatus\n153            pair: XBT/USD\n154            status: error\n155            subscription:\n156              depth: 42\n157              name: book\n158\n159  schemas:\n160    ping:\n161      type: object\n162      properties:\n163        event:\n164          type: string\n165          const: ping\n166        reqid:\n167          $ref: '#/components/schemas/reqid'\n168      required:\n169        - event\n170    heartbeat:\n171      type: object\n172      properties:\n173        event:\n174          type: string\n175          const: heartbeat\n176    pong:\n177      type: object\n178      properties:\n179        event:\n180          type: string\n181          const: pong\n182        reqid:\n183          $ref: '#/components/schemas/reqid'\n184    systemStatus:\n185      type: object\n186      properties:\n187        event:\n188          type: string\n189          const: systemStatus\n190        connectionID:\n191          type: integer\n192          description: The ID of the connection\n193        status:\n194          $ref: '#/components/schemas/status'\n195        version:\n196          type: string\n197    status:\n198      type: string\n199      enum:\n200        - online\n201        - maintenance\n202        - cancel_only\n203        - limit_only\n204        - post_only\n205    subscribe:\n206      type: object\n207      properties:\n208        event:\n209          type: string\n210          const: subscribe\n211        reqid:\n212          $ref: '#/components/schemas/reqid'\n213        pair:\n214          $ref: '#/components/schemas/pair'\n215        subscription:\n216          type: object\n217          properties:\n218            depth:\n219              $ref: '#/components/schemas/depth'\n220            interval:\n221              $ref: '#/components/schemas/interval'\n222            name:\n223              $ref: '#/components/schemas/name'\n224            ratecounter:\n225              $ref: '#/components/schemas/ratecounter'\n226            snapshot:\n227              $ref: '#/components/schemas/snapshot'\n228            token:\n229              $ref: '#/components/schemas/token'\n230          required:\n231            - name\n232      required:\n233        - event\n234    unsubscribe:\n235      type: object\n236      properties:\n237        event:\n238          type: string\n239          const: unsubscribe\n240        reqid:\n241          $ref: '#/components/schemas/reqid'\n242        pair:\n243          $ref: '#/components/schemas/pair'\n244        subscription:\n245          type: object\n246          properties:\n247            depth:\n248              $ref: '#/components/schemas/depth'\n249            interval:\n250              $ref: '#/components/schemas/interval'\n251            name:\n252              $ref: '#/components/schemas/name'\n253            token:\n254              $ref: '#/components/schemas/token'\n255          required:\n256            - name\n257      required:\n258        - event\n259    subscriptionStatus:\n260      type: object\n261      oneOf:\n262        - $ref: '#/components/schemas/subscriptionStatusError'\n263        - $ref: '#/components/schemas/subscriptionStatusSuccess'\n264    subscriptionStatusError:\n265      allOf:\n266        - properties:\n267            errorMessage:\n268              type: string\n269          required:\n270            - errorMessage\n271        - $ref: '#/components/schemas/subscriptionStatusCommon'\n272    subscriptionStatusSuccess:\n273      allOf:\n274        - properties:\n275            channelID:\n276              type: integer\n277              description: ChannelID on successful subscription, applicable to public messages only.\n278            channelName:\n279              type: string\n280              description: Channel Name on successful subscription. For payloads 'ohlc' and 'book', respective interval or depth will be added as suffix.\n281          required:\n282            - channelID\n283            - channelName\n284        - $ref: '#/components/schemas/subscriptionStatusCommon'\n285    subscriptionStatusCommon:\n286      type: object\n287      required:\n288         - event\n289      properties:\n290        event:\n291          type: string\n292          const: subscriptionStatus\n293        reqid:\n294          $ref: '#/components/schemas/reqid'\n295        pair:\n296          $ref: '#/components/schemas/pair'\n297        status:\n298          $ref: '#/components/schemas/status'\n299        subscription:\n300          required:\n301            - name\n302          type: object\n303          properties:\n304            depth:\n305              $ref: '#/components/schemas/depth'\n306            interval:\n307              $ref: '#/components/schemas/interval'\n308            maxratecount:\n309              $ref: '#/components/schemas/maxratecount'\n310            name:\n311              $ref: '#/components/schemas/name'\n312            token:\n313              $ref: '#/components/schemas/token'\n314    interval:\n315      type: integer\n316      description: Time interval associated with ohlc subscription in minutes.\n317      default: 1\n318      enum:\n319        - 1\n320        - 5\n321        - 15\n322        - 30\n323        - 60\n324        - 240\n325        - 1440\n326        - 10080\n327        - 21600\n328    name:\n329      type: string\n330      description: The name of the channel you subscribe too.\n331      enum:\n332        - book\n333        - ohlc\n334        - openOrders\n335        - ownTrades\n336        - spread\n337        - ticker\n338        - trade\n339    token:\n340      type: string\n341      description: base64-encoded authentication token for private-data endpoints.\n342    depth:\n343      type: integer\n344      default: 10\n345      enum:\n346        - 10\n347        - 25\n348        - 100\n349        - 500\n350        - 1000\n351      description: Depth associated with book subscription in number of levels each side.\n352    maxratecount:\n353      type: integer\n354      description: Max rate-limit budget. Compare to the ratecounter field in the openOrders updates to check whether you are approaching the rate limit.\n355    ratecounter:\n356      type: boolean\n357      default: false\n358      description: Whether to send rate-limit counter in updates (supported only for openOrders subscriptions)\n359    snapshot:\n360      type: boolean\n361      default: true\n362      description: Whether to send historical feed data snapshot upon subscription (supported only for ownTrades subscriptions)\n363    reqid:\n364      type: integer\n365      description: client originated ID reflected in response message.\n366    pair:\n367      type: array\n368      description: Array of currency pairs.\n369      items:\n370        type: string\n371        description: Format of each pair is \"A/B\", where A and B are ISO 4217-A3 for standardized assets and popular unique symbol if not standardized.\n372        pattern: '[A-Z\\s]+\\/[A-Z\\s]+'\n```\n Stay tuned for more articles around WebSocket and AsyncAPI. Share your feedback and connect with the AsyncAPI community in our Slack workspace .",
    "code_blocks": [
      "1asyncapi: 2.0.0\n2info:\n3  title: Kraken Websockets API\n4  version: '1.8'\n5  description: |\n6    WebSockets API offers real-time market data updates. WebSockets is a bidirectional protocol offering fastest real-time data, helping you build real-time applications. The public message types presented below do not require authentication. Private-data messages can be subscribed on a separate authenticated endpoint. \n7\n8    ### General Considerations\n9\n10    - TLS with SNI (Server Name Indication) is required in order to establish a Kraken WebSockets API connection. See Cloudflare's [What is SNI?](https://www.cloudflare.com/learning/ssl/what-is-sni/) guide for more details.\n11    - All messages sent and received via WebSockets are encoded in JSON format.\n12    - All decimal fields (including timestamps) are quoted to preserve precision.\n13    - Timestamps should not be considered unique and not be considered as aliases for transaction IDs. Also, the granularity of timestamps is not representative of transaction rates.\n14    - At least one private message should be subscribed to keep the authenticated client connection open.\n15    - Please use REST API endpoint [AssetPairs](https://www.kraken.com/features/api#get-tradable-pairs) to fetch the list of pairs which can be subscribed via WebSockets API. For example, field 'wsname' gives the supported pairs name which can be used to subscribe.\n16    - Cloudflare imposes a connection/re-connection rate limit (per IP address) of approximately 150 attempts per rolling 10 minutes. If this is exceeded, the IP is banned for 10 minutes.\n17    - Recommended reconnection behaviour is to (1) attempt reconnection instantly up to a handful of times if the websocket is dropped randomly during normal operation but (2) after maintenance or extended downtime, attempt to reconnect no more quickly than once every 5 seconds. There is no advantage to reconnecting more rapidly after maintenance during cancel_only mode.",
      "1servers:\n2  public:\n3    url: ws.kraken.com\n4    protocol: wss\n5    description: |\n6      Public server available without authorization.\n7      Once the socket is open you can subscribe to a public channel by sending a subscribe request message.\n8  private:\n9    url: ws-auth.kraken.com\n10    protocol: wss\n11    description: |\n12      Private server that requires authorization.\n13      Once the socket is open you can subscribe to private-data channels by sending an authenticated subscribe request message.",
      "{ \"event\": \"subscribe\",  \"subscription\": { \"name\": \"ownTrades\", \"token\": \"WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu\" } }",
      "{\"errorMessage\":\"Private data and trading are unavailable on this endpoint. Try ws-auth.kraken.com\",\"event\":\"subscriptionStatus\",\"status\":\"error\",\"subscription\":{\"name\":\"ownTrades\",\"token\":\"WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu\"}}",
      "1servers:\n2  public:\n3    url: ws.kraken.com\n4    protocol: wss\n5    description: |\n6      Public server available without authorization.\n7      Once the socket is open, you can subscribe to a public channel by sending a subscribe request message.\n8  private:\n9    url: ws-auth.kraken.com\n10    protocol: wss\n11    description: |\n12      Private server that requires authorization.\n13      Once the socket is open, you can subscribe to private-data channels by sending an authenticated subscribe request message.\n14\n15      The API client must request an authentication \"token\" via the following REST API endpoint \"GetWebSocketsToken\" to connect to WebSockets Private endpoints. For more details, read https://support.kraken.com/hc/en-us/articles/360034437672-How-to-retrieve-a-WebSocket-authentication-token-Example-code-in-Python-3\n16\n17      The resulting token must be provided in the \"token\" field of any new private WebSocket feed subscription: \n18      ```\n19      {\n20        \"event\": \"subscribe\",\n21        \"subscription\":\n22        {\n23          \"name\": \"ownTrades\",\n24          \"token\": \"WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu\"\n25        }\n26      }\n27      ```",
      "1channels:\n2  /:",
      "1channels:\n2  /:\n3    publish:\n4      operationId: sendMessage\n5      message:\n6        oneOf:\n7          - $ref: '#/components/messages/ping'\n8          - $ref: '#/components/messages/subscribe'\n9          - $ref: '#/components/messages/unsubscribe'\n10    subscribe:\n11      operationId: processMessage\n12      message:\n13        oneOf:\n14          - $ref: '#/components/messages/pong'\n15          - $ref: '#/components/messages/heartbeat'\n16          - $ref: '#/components/messages/systemStatus'\n17          - $ref: '#/components/messages/subscriptionStatus'",
      "1messages:\n2  systemStatus:\n3    description: Status sent on connection or system status changes.\n4    payload:\n5      $ref: '#/components/schemas/systemStatus'\n6    examples:\n7      - payload:\n8          connectionID: 8628615390848610000\n9          event: systemStatus\n10          status: online\n11          version: 1.0.0",
      "1messages:\n2  ping:\n3    summary: Ping server to determine whether connection is alive\n4    description: Client can ping server to determine whether connection is alive, server responds with pong. This is an application level ping as opposed to default ping in websockets standard which is server initiated\n5    payload:\n6      $ref: '#/components/schemas/ping'\n7    x-response:\n8      $ref: '#/components/messages/pong'",
      "1schemas:\n2  ping:\n3    type: object\n4    properties:\n5      event:\n6        type: string\n7        const: ping\n8      reqid:\n9        $ref: '#/components/schemas/reqid'\n10    required:\n11      - event\n12  reqid:\n13    type: integer\n14    description: client originated ID reflected in response message.",
      "1    subscriptionStatus:\n2      type: object\n3      oneOf:\n4        - required:\n5            - errorMessage\n6          not:\n7            required:\n8                - channelID\n9                - channelName\n10        - required:\n11            - channelID\n12            - channelName\n13          not:\n14            required:\n15                - errorMessage\n16      properties:\n17        channelID:\n18          type: integer\n19          description: ChannelID on successful subscription, applicable to public messages only.\n20        channelName:\n21          type: string\n22          description: Channel Name on successful subscription. For payloads 'ohlc' and 'book', respective interval or depth will be added as suffix.\n23        errorMessage:\n24          type: string\n25        event:\n26          type: string\n27          const: subscriptionStatus\n28        reqid:\n29          $ref: '#/components/schemas/reqid'\n30        pair:\n31          $ref: '#/components/schemas/pair'\n32        status:\n33          $ref: '#/components/schemas/status'\n34        subscription:\n35          type: object\n36          properties:\n37            depth:\n38              $ref: '#/components/schemas/depth'\n39            interval:\n40              $ref: '#/components/schemas/interval'\n41            maxratecount:\n42              $ref: '#/components/schemas/maxratecount'\n43            name:\n44              $ref: '#/components/schemas/name'\n45            token:\n46              $ref: '#/components/schemas/token'\n47          required:\n48            - name\n49      required:\n50        - event",
      "1    subscriptionStatus:\n2      type: object\n3      oneOf:\n4        - $ref: '#/components/schemas/subscriptionStatusError'\n5        - $ref: '#/components/schemas/subscriptionStatusSuccess'\n6    subscriptionStatusError:\n7      allOf:\n8        - properties:\n9            errorMessage:\n10              type: string\n11          required:\n12            - errorMessage\n13        - $ref: '#/components/schemas/subscriptionStatusCommon'\n14    subscriptionStatusSuccess:\n15      allOf:\n16        - properties:\n17            channelID:\n18              type: integer\n19              description: ChannelID on successful subscription, applicable to public messages only.\n20            channelName:\n21              type: string\n22              description: Channel Name on successful subscription. For payloads 'ohlc' and 'book', respective interval or depth will be added as suffix.\n23          required:\n24            - channelID\n25            - channelName\n26        - $ref: '#/components/schemas/subscriptionStatusCommon'\n27    subscriptionStatusCommon:\n28      type: object\n29      required:\n30         - event\n31      properties:\n32        event:\n33          type: string\n34          const: subscriptionStatus\n35        reqid:\n36          $ref: '#/components/schemas/reqid'\n37        pair:\n38          $ref: '#/components/schemas/pair'\n39        status:\n40          $ref: '#/components/schemas/status'\n41        subscription:\n42          required:\n43            - name\n44          type: object\n45          properties:\n46            depth:\n47              $ref: '#/components/schemas/depth'\n48            interval:\n49              $ref: '#/components/schemas/interval'\n50            maxratecount:\n51              $ref: '#/components/schemas/maxratecount'\n52            name:\n53              $ref: '#/components/schemas/name'\n54            token:\n55              $ref: '#/components/schemas/token'",
      "1asyncapi: 2.0.0\n2\n3info:\n4  title: Kraken Websockets API\n5  version: '1.8.0'\n6  description: |\n7    WebSockets API offers real-time market data updates. WebSockets is a bidirectional protocol offering fastest real-time data, helping you build real-time applications. The public message types presented below do not require authentication. Private-data messages can be subscribed on a separate authenticated endpoint. \n8\n9    ### General Considerations\n10\n11    - TLS with SNI (Server Name Indication) is required in order to establish a Kraken WebSockets API connection. See Cloudflare's [What is SNI?](https://www.cloudflare.com/learning/ssl/what-is-sni/) guide for more details.\n12    - All messages sent and received via WebSockets are encoded in JSON format\n13    - All decimal fields (including timestamps) are quoted to preserve precision.\n14    - Timestamps should not be considered unique and not be considered as aliases for transaction IDs. Also, the granularity of timestamps is not representative of transaction rates.\n15    - At least one private message should be subscribed to keep the authenticated client connection open.\n16    - Please use REST API endpoint [AssetPairs](https://www.kraken.com/features/api#get-tradable-pairs) to fetch the list of pairs which can be subscribed via WebSockets API. For example, field 'wsname' gives the supported pairs name which can be used to subscribe.\n17    - Cloudflare imposes a connection/re-connection rate limit (per IP address) of approximately 150 attempts per rolling 10 minutes. If this is exceeded, the IP is banned for 10 minutes.\n18    - Recommended reconnection behaviour is to (1) attempt reconnection instantly up to a handful of times if the websocket is dropped randomly during normal operation but (2) after maintenance or extended downtime, attempt to reconnect no more quickly than once every 5 seconds. There is no advantage to reconnecting more rapidly after maintenance during cancel_only mode.\n19\n20servers:\n21  public:\n22    url: ws.kraken.com\n23    protocol: wss\n24    description: |\n25      Public server available without authorization.\n26      Once the socket is open you can subscribe to a public channel by sending a subscribe request message.\n27  private:\n28    url: ws-auth.kraken.com\n29    protocol: wss\n30    description: |\n31      Private server that requires authorization.\n32      Once the socket is open you can subscribe to private-data channels by sending an authenticated subscribe request message.\n33\n34      The API client must request an authentication \"token\" via the following REST API endpoint \"GetWebSocketsToken\" to connect to WebSockets Private endpoints. For more details read https://support.kraken.com/hc/en-us/articles/360034437672-How-to-retrieve-a-WebSocket-authentication-token-Example-code-in-Python-3\n35\n36      The resulting token must be provided in the \"token\" field of any new private WebSocket feed subscription: \n37      ```\n38      {\n39        \"event\": \"subscribe\",\n40        \"subscription\":\n41        {\n42          \"name\": \"ownTrades\",\n43          \"token\": \"WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu\"\n44        }\n45      }\n46      ```\n47\n48channels:\n49  /:\n50    publish:\n51      description: Send messages to the API\n52      operationId: processReceivedMessage\n53      message:\n54        oneOf:\n55          - $ref: '#/components/messages/ping'\n56          - $ref: '#/components/messages/subscribe'\n57          - $ref: '#/components/messages/unsubscribe'\n58\n59    subscribe:\n60      description: Messages that you receive from the API\n61      operationId: sendMessage\n62      message:\n63        oneOf:\n64          - $ref: '#/components/messages/pong'\n65          - $ref: '#/components/messages/heartbeat'\n66          - $ref: '#/components/messages/systemStatus'\n67          - $ref: '#/components/messages/subscriptionStatus'\n68\n69components:\n70  messages:\n71    ping:\n72      summary: Ping server to determine whether connection is alive\n73      description: Client can ping server to determine whether connection is alive, server responds with pong. This is an application level ping as opposed to default ping in websockets standard which is server initiated\n74      payload:\n75        $ref: '#/components/schemas/ping'\n76      x-response:\n77        $ref: '#/components/messages/pong'\n78    heartbeat:\n79      description: Server heartbeat sent if no subscription traffic within 1 second (approximately)\n80      payload:\n81        $ref: '#/components/schemas/heartbeat'\n82    pong:\n83      summary: Pong is a response to ping message\n84      description: Server pong response to a ping to determine whether connection is alive. This is an application level pong as opposed to default pong in websockets standard which is sent by client in response to a ping\n85      payload:\n86        $ref: '#/components/schemas/pong'\n87    systemStatus:\n88      description: Status sent on connection or system status changes.\n89      payload:\n90        $ref: '#/components/schemas/systemStatus'\n91      examples:\n92        - payload:\n93            connectionID: 8628615390848610000\n94            event: systemStatus\n95            status: online\n96            version: 1.0.0\n97    subscribe:\n98      description: Subscribe to a topic on a single or multiple currency pairs.\n99      payload:\n100        $ref: '#/components/schemas/subscribe'\n101      examples:\n102        - payload:\n103            event: subscribe\n104            pair:\n105              - XBT/USD\n106              - XBT/EUR\n107            subscription:\n108              name: ticker\n109        - payload:\n110            event: subscribe\n111            subscription:\n112              name: ownTrades\n113              token: WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu\n114      x-response:\n115        $ref: '#/components/messages/subscriptionStatus'\n116    unsubscribe:\n117      description: Unsubscribe, can specify a channelID or multiple currency pairs.\n118      payload:\n119        $ref: '#/components/schemas/subscribe'\n120      examples:\n121        - payload:\n122            event: unsubscribe\n123            pair:\n124              - XBT/EUR\n125              - XBT/USD\n126            subscription:\n127              name: ticker\n128        - payload:\n129            event: unsubscribe\n130            subscription:\n131              name: ownTrades\n132              token: WW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbiBnb2VzIGhlcmUu\n133      x-response:\n134        $ref: '#/components/messages/subscriptionStatus'\n135    subscriptionStatus:\n136      description: Subscription status response to subscribe, unsubscribe or exchange initiated unsubscribe.\n137      payload:\n138        $ref: '#/components/schemas/subscriptionStatus'\n139      examples:\n140        - payload:\n141            channelID: 10001\n142            channelName: ohlc-5\n143            event: subscriptionStatus\n144            pair: XBT/EUR\n145            reqid: 42\n146            status: unsubscribed\n147            subscription:\n148              interval: 5\n149              name: ohlc\n150        - payload:\n151            errorMessage: Subscription depth not supported\n152            event: subscriptionStatus\n153            pair: XBT/USD\n154            status: error\n155            subscription:\n156              depth: 42\n157              name: book\n158\n159  schemas:\n160    ping:\n161      type: object\n162      properties:\n163        event:\n164          type: string\n165          const: ping\n166        reqid:\n167          $ref: '#/components/schemas/reqid'\n168      required:\n169        - event\n170    heartbeat:\n171      type: object\n172      properties:\n173        event:\n174          type: string\n175          const: heartbeat\n176    pong:\n177      type: object\n178      properties:\n179        event:\n180          type: string\n181          const: pong\n182        reqid:\n183          $ref: '#/components/schemas/reqid'\n184    systemStatus:\n185      type: object\n186      properties:\n187        event:\n188          type: string\n189          const: systemStatus\n190        connectionID:\n191          type: integer\n192          description: The ID of the connection\n193        status:\n194          $ref: '#/components/schemas/status'\n195        version:\n196          type: string\n197    status:\n198      type: string\n199      enum:\n200        - online\n201        - maintenance\n202        - cancel_only\n203        - limit_only\n204        - post_only\n205    subscribe:\n206      type: object\n207      properties:\n208        event:\n209          type: string\n210          const: subscribe\n211        reqid:\n212          $ref: '#/components/schemas/reqid'\n213        pair:\n214          $ref: '#/components/schemas/pair'\n215        subscription:\n216          type: object\n217          properties:\n218            depth:\n219              $ref: '#/components/schemas/depth'\n220            interval:\n221              $ref: '#/components/schemas/interval'\n222            name:\n223              $ref: '#/components/schemas/name'\n224            ratecounter:\n225              $ref: '#/components/schemas/ratecounter'\n226            snapshot:\n227              $ref: '#/components/schemas/snapshot'\n228            token:\n229              $ref: '#/components/schemas/token'\n230          required:\n231            - name\n232      required:\n233        - event\n234    unsubscribe:\n235      type: object\n236      properties:\n237        event:\n238          type: string\n239          const: unsubscribe\n240        reqid:\n241          $ref: '#/components/schemas/reqid'\n242        pair:\n243          $ref: '#/components/schemas/pair'\n244        subscription:\n245          type: object\n246          properties:\n247            depth:\n248              $ref: '#/components/schemas/depth'\n249            interval:\n250              $ref: '#/components/schemas/interval'\n251            name:\n252              $ref: '#/components/schemas/name'\n253            token:\n254              $ref: '#/components/schemas/token'\n255          required:\n256            - name\n257      required:\n258        - event\n259    subscriptionStatus:\n260      type: object\n261      oneOf:\n262        - $ref: '#/components/schemas/subscriptionStatusError'\n263        - $ref: '#/components/schemas/subscriptionStatusSuccess'\n264    subscriptionStatusError:\n265      allOf:\n266        - properties:\n267            errorMessage:\n268              type: string\n269          required:\n270            - errorMessage\n271        - $ref: '#/components/schemas/subscriptionStatusCommon'\n272    subscriptionStatusSuccess:\n273      allOf:\n274        - properties:\n275            channelID:\n276              type: integer\n277              description: ChannelID on successful subscription, applicable to public messages only.\n278            channelName:\n279              type: string\n280              description: Channel Name on successful subscription. For payloads 'ohlc' and 'book', respective interval or depth will be added as suffix.\n281          required:\n282            - channelID\n283            - channelName\n284        - $ref: '#/components/schemas/subscriptionStatusCommon'\n285    subscriptionStatusCommon:\n286      type: object\n287      required:\n288         - event\n289      properties:\n290        event:\n291          type: string\n292          const: subscriptionStatus\n293        reqid:\n294          $ref: '#/components/schemas/reqid'\n295        pair:\n296          $ref: '#/components/schemas/pair'\n297        status:\n298          $ref: '#/components/schemas/status'\n299        subscription:\n300          required:\n301            - name\n302          type: object\n303          properties:\n304            depth:\n305              $ref: '#/components/schemas/depth'\n306            interval:\n307              $ref: '#/components/schemas/interval'\n308            maxratecount:\n309              $ref: '#/components/schemas/maxratecount'\n310            name:\n311              $ref: '#/components/schemas/name'\n312            token:\n313              $ref: '#/components/schemas/token'\n314    interval:\n315      type: integer\n316      description: Time interval associated with ohlc subscription in minutes.\n317      default: 1\n318      enum:\n319        - 1\n320        - 5\n321        - 15\n322        - 30\n323        - 60\n324        - 240\n325        - 1440\n326        - 10080\n327        - 21600\n328    name:\n329      type: string\n330      description: The name of the channel you subscribe too.\n331      enum:\n332        - book\n333        - ohlc\n334        - openOrders\n335        - ownTrades\n336        - spread\n337        - ticker\n338        - trade\n339    token:\n340      type: string\n341      description: base64-encoded authentication token for private-data endpoints.\n342    depth:\n343      type: integer\n344      default: 10\n345      enum:\n346        - 10\n347        - 25\n348        - 100\n349        - 500\n350        - 1000\n351      description: Depth associated with book subscription in number of levels each side.\n352    maxratecount:\n353      type: integer\n354      description: Max rate-limit budget. Compare to the ratecounter field in the openOrders updates to check whether you are approaching the rate limit.\n355    ratecounter:\n356      type: boolean\n357      default: false\n358      description: Whether to send rate-limit counter in updates (supported only for openOrders subscriptions)\n359    snapshot:\n360      type: boolean\n361      default: true\n362      description: Whether to send historical feed data snapshot upon subscription (supported only for ownTrades subscriptions)\n363    reqid:\n364      type: integer\n365      description: client originated ID reflected in response message.\n366    pair:\n367      type: array\n368      description: Array of currency pairs.\n369      items:\n370        type: string\n371        description: Format of each pair is \"A/B\", where A and B are ISO 4217-A3 for standardized assets and popular unique symbol if not standardized.\n372        pattern: '[A-Z\\s]+\\/[A-Z\\s]+'"
    ],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/posts/websocket-part2/cover.webp",
        "alt": ""
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "5237d562",
    "title": "AsyncAPI Case Studies | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/casestudies/adeogroup.html",
    "content": "AsyncAPI Case Studies | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Adeo Group Ludovic Dussart Industry: Retail Customers: 500M Revenue: 25.6B EURO turnover, including 768M EURO online. Adeo owns different brands in retail industry focused on home improvement and DIY markets, like Leroy Merlin. tl;dr just go and have a look at full production-used AsyncAPI document Challenges Cost Component Repository product, part of the ADEO tech products, is used to calculate and publish transfer prices between different internal locations globally. Different business units use different information systems. It is hard to learn how each business unit shares information about its systems, API and accuracy. The initial solution was a developer portal with a list of all applications and reference to dedicated documentation. Some legacy systems had docs written in MS Excel. There was a need for a standart way of describing event-driven architecture. Solution The API is now described with AsyncAPI. The AsyncAPI file, stored with the source code, generates HTML documentation in the same release pipeline for the product. Documentation is exposed internally as part of the product for other company units depending on the API. Payloads are described with Avro schema. These schemas generate models and are referenced directly in AsyncAPI files thanks to the schemaFormat feature and $ref . This way, they make sure the code is aligned with the docs. Shift to using AsyncAPI also enables the team to implement more use cases using AsyncAPI files. Use Case Document the API of the product, so its users know how it works and how to use it. AsyncAPI was selected as the standard that allows you to generate documentation from a machine-readable document that describes the API. The goal was to document API in a standardized way, so other internal products could follow to unify how APIs are documented across the company. More Details Languages: Java Frameworks: Spring Protocols: Kafka Testing strategy For Kafka, e2e tests are done with Zerocode . Load tests are handled with JMeter with the kloadgen plugin that supports Kafka and Avro. Approach to code generation Java models generation. Avro schemas used as a source. Architecture The following enterprise integration patterns are applied: Request/Reply Described with description field in AsyncAPI. Reply goes to dedicated reply channel. Example description of response channel: \n```javascript\n1description: >\n2This topic is used to REPLY Costing Requests and is targeted by the\n3`REPLY_TOPIC` header.\n```\n Return Address Info that needs to be provided by the client so producer knows where to send a response. Information is sent in the message header with the REPLY_TOPIC property. The AsyncAPI file documents information as part of the Message Header object. Example of request message header with REPLY_TOPIC : \n```javascript\n1headers:\n2  type: object\n3  required:\n4    - REPLY_TOPIC\n5  properties:\n6    REPLY_TOPIC:\n7      $ref: \"#/components/schemas/ReplyTopic\"\n```\n Correlation Identifier This pattern enables the identification of the request given to the sent response. The REQUEST_ID property is in the request message header. The CORRELATION_ID property is in the response message header. Both headers are described in the AsyncAPI Message Header object and referred to in the AsyncAPI correlationID property. This means that correlation identifier is represented by different property in the message header, depending if it is a request or reply. Example of request message header with REQUEST_ID : \n```javascript\n1headers:\n2  type: object\n3  required:\n4    - REQUEST_ID\n5  properties:\n6    REQUEST_ID:\n7      $ref: \"#/components/schemas/RequestId\"\n```\n Example of how correlationId points to REQUEST_ID : \n```javascript\n1correlationId:\n2  description: >\n3    This correlation ID is used for message tracing and messages\n4    correlation.\n5    This correlation ID is generated at runtime based on the `REQUEST_ID`\n6    and sent to the RESPONSE message.\n7  location: $message.header#/REQUEST_ID\n```\n DeadLetter Channel Also known as Dead Letter Queue. In Kafka, it is just another channel where undelivered messages are sent. Not part of the AsyncAPI file, as API consumers will not listen to this channel. Consumers know what happens with wrong events. Invalid Message Channel Invalid messages are routed to the dedicated channel for rejected requests but are not part of the AsyncAPI file, as API consumers will not listen to this channel. Consumers know what happens with wrong events. \n![Architecture Diagram](/img/casestudies/adeo/architecture.webp)\n More Details about AsyncAPI Version: 2.4.0 Who maintains documents: Developers Internal users: true External users: false How AsyncAPI documents are stored Git repository where source code is. Where maintainers edit AsyncAPI documents IntelliJ without any special plugins. Sometimes people use AsyncAPI Studio, but not regularly because of lack of support for references to local drive. What extensions are used Extensions are used to describe details about custom security: \n```javascript\n1  x-sasl.jaas.config: >-\n2    org.apache.kafka.common.security.plain.PlainLoginModule required\n3    username=\"<CLUSTER_API_KEY>\" password=\"<CLUSTER_API_SECRET>\";\n4  x-security.protocol: SASL_SSL\n5  x-ssl.endpoint.identification.algorithm: https\n6  x-sasl.mechanism: PLAIN\n```\n How documentation is generated Documentation generated from AsyncAPI is hosted as part of the product on a dedicated endpoint using Spring controller. Publishing is part of the CI/CD pipeline for the product using GithubActions. Related Maven configuration used to trigger docs generation with AsyncAPI Generator industry: \n```javascript\n1 <profile>\n2        <id>generate-asyncapi-doc</id>\n3        <build>\n4            <plugins>\n5                <plugin>\n6                    <groupId>com.github.eirslett</groupId>\n7                    <artifactId>frontend-maven-plugin</artifactId>\n8                    <!-- Use the latest released version:\n9                    https://repo1.maven.org/maven2/com/github/eirslett/frontend-maven-plugin/ -->\n10                    <version>${frontend-maven-plugin.version}</version>\n11                    <configuration>\n12                        <nodeVersion>v12.18.4</nodeVersion>\n13                        <installDirectory>${node.installation.path}</installDirectory>\n14                        <workingDirectory>${node.installation.path}</workingDirectory>\n15                    </configuration>\n16                    <executions>\n17                        <execution>\n18                            <id>install node and npm</id>\n19                            <goals>\n20                                <goal>install-node-and-npm</goal>\n21                            </goals>\n22                            <phase>generate-resources</phase>\n23                        </execution>\n24                        <execution>\n25                            <id>install @asyncapi/generator globally</id>\n26                            <goals>\n27                                <goal>npm</goal>\n28                            </goals>\n29                            <configuration>\n30                                <arguments>install @asyncapi/generator@${asyncapi.generator.version}</arguments>\n31                            </configuration>\n32                        </execution>\n33                    </executions>\n34                </plugin>\n35                <plugin>\n36                    <groupId>org.codehaus.mojo</groupId>\n37                    <artifactId>exec-maven-plugin</artifactId>\n38                    <version>1.6.0</version>\n39\n40                    <executions>\n41                        <execution>\n42                            <id>execute-generation</id>\n43                            <goals>\n44                                <goal>exec</goal>\n45                            </goals>\n46                            <phase>generate-resources</phase>\n47\n48                            <configuration>\n49                                <!-- Access binary file in node_modules because it doesn't work on windows otherwise. -->\n50                                <executable>${node.modules.installation.path}/${ag.binary.name}</executable>\n51                                <commandlineArgs>\n52                                    ${project.basedir}/src/docs/asyncapi/asyncapi.yaml @asyncapi/html-template@${asyncapi.htmltemplate.version} -p sidebarOrganization=byTags -p\n53                                    version=${project.version} -o ${asyncapi.generation.dir}\n54                                </commandlineArgs>\n55                            </configuration>\n56                        </execution>\n57                    </executions>\n58                </plugin>\n59                <plugin>\n60                    <groupId>org.apache.maven.plugins</groupId>\n61                    <artifactId>maven-resources-plugin</artifactId>\n62                    <executions>\n63                        <execution>\n64                            <id>copy-resources</id>\n65                            <!-- here the phase you need -->\n66                            <phase>generate-resources</phase>\n67                            <goals>\n68                                <goal>copy-resources</goal>\n69                            </goals>\n70                            <configuration>\n71                                <outputDirectory>${asyncapi.generation.dir}/assets</outputDirectory>\n72                                <resources>\n73                                    <resource>\n74                                        <directory>src/docs/asyncapi/assets</directory>\n75                                        <filtering>true</filtering>\n76                                    </resource>\n77                                </resources>\n78                            </configuration>\n79                        </execution>\n80                    </executions>\n81                </plugin>\n82            </plugins>\n83        </build>\n84    </profile>\n```\n Critical features of AsyncAPI related to documentation: use of version parameter in the generator command to display the release version from the Maven pom descriptions that support CommonMark (Markdown) as they allow to put detailed structured descriptions and screenshots inside generated docs examples and validation information. In this case converted from Avro to JSON Schema to show it in documentation and have examples generated Tags for tagging operations to categorize them to make it easier to navigate in documentation UI What bindings are used All Kafka bindings are used. Server, channel, operation and message bindings. Example of server bindings: \n```javascript\n1bindings:\n2  kafka:\n3    schema.registry.url: >-\n4      https://schema-registry.prod.url/\n```\n Example of channel bindings: \n```javascript\n1bindings:\n2  kafka:\n3    replicas: 3\n4    partitions: 3\n5    cleanup.policy: delete\n6    retention.ms: 7 days\n```\n Example of operation bindings: \n```javascript\n1bindings:\n2  kafka:\n3    groupId:\n4      type: string\n5      description: >\n6        The groupId must be prefixed by your `svc` account, deliver by the\n7        Adeo Kafka team.\n8        This `svc` must have the write access to the topic.\n9    value.subject.name.strategy:\n10      type: string\n11      description: >\n12        We use the RecordNameStrategy to infer the messages schema.\n13        Use\n14        `value.subject.name.strategy=io.confluent.kafka.serializers.subject.RecordNameStrategy`\n15        in your producer configuration.\n```\n Example of message bindings: \n```javascript\n1bindings:\n2  kafka:\n3    key:\n4      $ref: \"https://asyncapi.com/resources/casestudies/adeo/CostingResponseKey.avsc\"\n```\n What tools are used AsyncAPI Generator : HTML Template with parameters like sidebarOrganization=byTags and version . AsyncAPI JavaScript Parser with Avro Schema Parser . Schemas Spec: Avro 1.9 Storage strategy Git repository where source code is. During release they are published to Confluent Schema Registry. Schema Registry Confluent Schema Registry. Versioning of schemas Versioning is based on git tags. The schema version pushed to Confluent Schema Registry matches the git tag version of the product. Every schema has a version information that matches with product tag version. Example Avro schema with version information: \n```javascript\n1{\n2  \"namespace\": \"com.adeo.casestudy.costingrequest\",\n3  \"type\": \"record\",\n4  \"name\": \"CostingRequestPayload\",\n5  \"version\": \"1.1.0\",\n6  \"fields\": [ ... ]\n7}\n```\n Validation of message schemas Based on validation using Confluent Schema Registry. Additional Resources Watch this video presentation about AsyncAPI case study from Ludovic Dussart, Ineat & Antoine Delequeuche, Adeo. Production-use AsyncAPI document \n```javascript\n1asyncapi: 2.4.0\n2info:\n3  title: Adeo AsyncAPI Case Study\n4  version: \"%REPLACED_BY_MAVEN%\"\n5  description: >\n6    This Adeo specification illustrates how ADEO uses AsyncAPI to document some of their exchanges.\n7  contact:\n8    name: AsyncAPI Community\n9    email: case-study@asyncapi.com\n10servers:\n11  production:\n12    url: \"prod.url:9092\"\n13    protocol: kafka\n14    description: Kafka PRODUCTION cluster\n15    security:\n16      - sasl-ssl: []\n17    bindings:\n18      kafka:\n19        schema.registry.url: >-\n20          https://schema-registry.prod.url/\n21  staging:\n22    url: \"staging.url:9092\"\n23    protocol: kafka\n24    description: Kafka STAGING cluster for `uat` and `preprod` environments\n25    security:\n26      - sasl-ssl: []\n27    bindings:\n28      kafka:\n29        schema.registry.url: >-\n30          https://schema-registry.staging.url/\n31  dev:\n32    url: \"dev.url:9092\"\n33    protocol: kafka\n34    description: Kafka DEV cluster for `dev` and `sit` environments\n35    security:\n36      - sasl-ssl: []\n37    bindings:\n38      kafka:\n39        schema.registry.url: >-\n40          https://schema-registry.dev.url/\n41tags:\n42  - name: costing\n43    description: \"Costing channels, used by Costing clients.\"\n44channels:\n45  \"adeo-{env}-case-study-COSTING-REQUEST-{version}\":\n46    description: >\n47      Use this topic to do a Costing Request to Costing product.\n48      We use the\n49      [**RecordNameStrategy**](https://docs.confluent.io/platform/current/schema-registry/serdes-develop/index.html#subject-name-strategy)\n50      to infer the messages schema.\n51      You have to define `value.subject.name.strategy` to\n52      `io.confluent.kafka.serializers.subject.RecordNameStrategy` in your\n53      producer to use the schema we manage.\n54      The schema below illustrates how Costing Request messages are\n55      handled.\n56      ![](https://user-images.githubusercontent.com/5501911/188920831-689cec5f-8dc3-460b-8794-0b54ec8b0ac8.png)\n57    parameters:\n58      env:\n59        $ref: \"#/components/parameters/Env\"\n60      version:\n61        $ref: \"#/components/parameters/Version\"\n62    bindings:\n63      kafka:\n64        replicas: 3\n65        partitions: 3\n66        cleanup.policy: delete\n67        retention.ms: 7 days\n68    publish:\n69      operationId: requestCosting\n70      summary: |\n71        [COSTING] Request one or more Costing calculation for any product\n72      description: >\n73        You can try a costing request using our [Conduktor producer\n74        template](https://conduktor.url)\n75      tags:\n76        - name: costing\n77      message:\n78        oneOf:\n79          - $ref: \"#/components/messages/costingRequestV1\"\n80      bindings:\n81        kafka:\n82          groupId:\n83            type: string\n84            description: >\n85              The groupId must be prefixed by your `svc` account, deliver by the\n86              Adeo Kafka team.\n87              This `svc` must have the write access to the topic.\n88          value.subject.name.strategy:\n89            type: string\n90            description: >\n91              We use the RecordNameStrategy to infer the messages schema.\n92              Use\n93              `value.subject.name.strategy=io.confluent.kafka.serializers.subject.RecordNameStrategy`\n94              in your producer configuration.\n95  \"adeo-{env}-case-study-COSTING-RESPONSE-{version}\":\n96    description: >\n97      This topic is used to REPLY Costing Requests and is targeted by the\n98      `REPLY_TOPIC` header.\n99      **You must grant PUBLISH access to our `svc-ccr-app` service account.**.\n100      We use the\n101      [**RecordNameStrategy**](https://docs.confluent.io/platform/current/schema-registry/serdes-develop/index.html#subject-name-strategy)\n102      to infer the messages schema.\n103      You have to define `key.subject.name.strategy` and\n104      `value.subject.name.strategy` to\n105      `io.confluent.kafka.serializers.subject.RecordNameStrategy` in your\n106      consumer.\n107      The schema below illustrates how Costing Response messages are\n108      handled.\n109           ![](https://user-images.githubusercontent.com/5501911/188920831-689cec5f-8dc3-460b-8794-0b54ec8b0ac8.png)\n110    parameters:\n111      env:\n112        $ref: \"#/components/parameters/Env\"\n113      version:\n114        $ref: \"#/components/parameters/Version\"\n115    bindings:\n116      kafka:\n117        groupId:\n118          type: string\n119          description: >\n120            The groupId must be prefixed by your `svc` account, deliver by the\n121            Adeo Kafka team.\n122            This `svc` must have the read access to the topic.\n123        key.subject.name.strategy:\n124          type: string\n125          description: >\n126            We use the RecordNameStrategy to infer the messages schema.\n127            Use\n128            `key.subject.name.strategy=io.confluent.kafka.serializers.subject.RecordNameStrategy`\n129            in your consumer configuration.\n130        value.subject.name.strategy:\n131          type: string\n132          description: >\n133            We use the RecordNameStrategy to infer the messages schema.\n134            Use\n135            `value.subject.name.strategy=io.confluent.kafka.serializers.subject.RecordNameStrategy`\n136            in your consumer configuration.\n137    subscribe:\n138      operationId: getCostingResponse\n139      summary: >\n140        [COSTING] Get the costing responses matching an initial Costing\n141        Request.\n142      tags:\n143        - name: costing\n144      message:\n145        $ref: \"#/components/messages/costingResponse\"\n146components:\n147  correlationIds:\n148    costingCorrelationId:\n149      description: >\n150        This correlation ID is used for message tracing and messages\n151        correlation.\n152        This correlation ID is generated at runtime based on the `REQUEST_ID`\n153        and sent to the RESPONSE message.\n154      location: $message.header#/REQUEST_ID\n155  messages:\n156    costingRequestV1:\n157      name: CostingRequestV1\n158      title: Costing Request V1\n159      summary: Costing Request V1 inputs.\n160      tags:\n161        - name: costing\n162      schemaFormat: application/vnd.apache.avro;version=1.9.0\n163      correlationId:\n164        $ref: \"#/components/correlationIds/costingCorrelationId\"\n165      headers:\n166        type: object\n167        required:\n168          - REQUESTER_ID\n169          - REQUESTER_CODE\n170          - REQUEST_ID\n171          - REPLY_TOPIC\n172        properties:\n173          REQUEST_ID:\n174            $ref: \"#/components/schemas/RequestId\"\n175          REPLY_TOPIC:\n176            $ref: \"#/components/schemas/ReplyTopic\"\n177          REQUESTER_ID:\n178            $ref: \"#/components/schemas/RequesterId\"\n179          REQUESTER_CODE:\n180            $ref: \"#/components/schemas/RequesterCode\"\n181      payload:\n182        $ref: \"https://asyncapi.com/resources/casestudies/adeo/CostingRequestPayload.avsc\"\n183    costingResponse:\n184      name: CostingResponse\n185      title: Costing Response\n186      summary: Costing Response ouputs.\n187      tags:\n188        - name: costing\n189      description: >\n190        Please refer to the `CostingResponseKey.avsc` schema, available on [our\n191        github\n192        project](https://github.url/).\n193      schemaFormat: application/vnd.apache.avro;version=1.9.0\n194      correlationId:\n195        $ref: \"#/components/correlationIds/costingCorrelationId\"\n196      headers:\n197        type: object\n198        properties:\n199          CALCULATION_ID:\n200            $ref: \"#/components/schemas/MessageId\"\n201          CORRELATION_ID:\n202            $ref: \"#/components/schemas/CorrelationId\"\n203          REQUEST_TIMESTAMP:\n204            type: string\n205            format: date-time\n206            description: Timestamp of the costing request\n207          CALCULATION_TIMESTAMP:\n208            type: string\n209            format: date-time\n210            description: Technical timestamp for the costing calculation\n211      bindings:\n212        kafka:\n213          key:\n214            $ref: \"https://asyncapi.com/resources/casestudies/adeo/CostingResponseKey.avsc\"\n215      payload:\n216        $ref: \"https://asyncapi.com/resources/casestudies/adeo/CostingResponsePayload.avsc\"\n217  schemas:\n218    RequesterId:\n219      type: string\n220      description: The Costing requester service account used to produce costing request.\n221      example: svc-ecollect-app\n222    RequesterCode:\n223      type: string\n224      description: >-\n225        The Costing requester code (generally the BU Code). The requester code\n226        is useful to get the dedicated context (tenant).\n227      example: 1\n228    MessageId:\n229      type: string\n230      format: uuid\n231      description: A unique Message ID.\n232      example: 1fa6ef40-8f47-40a8-8cf6-f8607d0066ef\n233    RequestId:\n234      type: string\n235      format: uuid\n236      description: >-\n237        A unique Request ID needed to define a `CORRELATION_ID` for exchanges,\n238        which will be sent back in the Costing Responses.\n239      example: 1fa6ef40-8f47-40a8-8cf6-f8607d0066ef\n240    CorrelationId:\n241      type: string\n242      format: uuid\n243      description: >-\n244        A unique Correlation ID defined from the `REQUEST_ID` or the\n245        `MESSAGE_ID` provided in the Costing Request.\n246      example: 1fa6ef40-8f47-40a8-8cf6-f8607d0066ef\n247    BuCode:\n248      type: string\n249      description: The Business Unit code for which data are applicable.\n250      example: 1\n251    ReplyTopic:\n252      type: string\n253      description: >\n254        The Kafka topic where to send the Costing Response. This is required for\n255        the [Return Address EIP\n256        pattern](https://www.enterpriseintegrationpatterns.com/patterns/messaging/ReturnAddress.html).\n257        **You must grant WRITE access to our `svc-ccr-app` service account.**\n258      example: adeo-case-study-COSTING-RESPONSE-V1\n259    ErrorStep:\n260      type: string\n261      description: |\n262        The woker that has thrown the error.\n263      example: EXPOSE_RESULT\n264    ErrorMessage:\n265      type: string\n266      description: |\n267        The error message describing the error.\n268      example: Error message\n269    ErrorCode:\n270      type: string\n271      description: |\n272        The error code.\n273      example: CURRENCY_NOT_FOUND\n274  parameters:\n275    Env:\n276      description: Adeo Kafka Environement for messages publications.\n277      schema:\n278        type: string\n279        enum:\n280          - dev\n281          - sit\n282          - uat1\n283          - preprod\n284          - prod\n285    Version:\n286      description: the topic version you want to use\n287      schema:\n288        type: string\n289        example: V1\n290        default: V1\n291  securitySchemes:\n292    sasl-ssl:\n293      type: plain\n294      x-sasl.jaas.config: >-\n295        org.apache.kafka.common.security.plain.PlainLoginModule required\n296        username=\"<CLUSTER_API_KEY>\" password=\"<CLUSTER_API_SECRET>\";\n297      x-security.protocol: SASL_SSL\n298      x-ssl.endpoint.identification.algorithm: https\n299      x-sasl.mechanism: PLAIN\n300      description: >\n301        Use [SASL authentication with SSL\n302        encryption](https://docs.confluent.io/platform/current/security/security_tutorial.html#configure-clients)\n303        to connect to the ADEO Broker.\n```\n",
    "code_blocks": [
      "1description: >\n2This topic is used to REPLY Costing Requests and is targeted by the\n3`REPLY_TOPIC` header.",
      "1headers:\n2  type: object\n3  required:\n4    - REPLY_TOPIC\n5  properties:\n6    REPLY_TOPIC:\n7      $ref: \"#/components/schemas/ReplyTopic\"",
      "1headers:\n2  type: object\n3  required:\n4    - REQUEST_ID\n5  properties:\n6    REQUEST_ID:\n7      $ref: \"#/components/schemas/RequestId\"",
      "1correlationId:\n2  description: >\n3    This correlation ID is used for message tracing and messages\n4    correlation.\n5    This correlation ID is generated at runtime based on the `REQUEST_ID`\n6    and sent to the RESPONSE message.\n7  location: $message.header#/REQUEST_ID",
      "1  x-sasl.jaas.config: >-\n2    org.apache.kafka.common.security.plain.PlainLoginModule required\n3    username=\"<CLUSTER_API_KEY>\" password=\"<CLUSTER_API_SECRET>\";\n4  x-security.protocol: SASL_SSL\n5  x-ssl.endpoint.identification.algorithm: https\n6  x-sasl.mechanism: PLAIN",
      "1 <profile>\n2        <id>generate-asyncapi-doc</id>\n3        <build>\n4            <plugins>\n5                <plugin>\n6                    <groupId>com.github.eirslett</groupId>\n7                    <artifactId>frontend-maven-plugin</artifactId>\n8                    <!-- Use the latest released version:\n9                    https://repo1.maven.org/maven2/com/github/eirslett/frontend-maven-plugin/ -->\n10                    <version>${frontend-maven-plugin.version}</version>\n11                    <configuration>\n12                        <nodeVersion>v12.18.4</nodeVersion>\n13                        <installDirectory>${node.installation.path}</installDirectory>\n14                        <workingDirectory>${node.installation.path}</workingDirectory>\n15                    </configuration>\n16                    <executions>\n17                        <execution>\n18                            <id>install node and npm</id>\n19                            <goals>\n20                                <goal>install-node-and-npm</goal>\n21                            </goals>\n22                            <phase>generate-resources</phase>\n23                        </execution>\n24                        <execution>\n25                            <id>install @asyncapi/generator globally</id>\n26                            <goals>\n27                                <goal>npm</goal>\n28                            </goals>\n29                            <configuration>\n30                                <arguments>install @asyncapi/generator@${asyncapi.generator.version}</arguments>\n31                            </configuration>\n32                        </execution>\n33                    </executions>\n34                </plugin>\n35                <plugin>\n36                    <groupId>org.codehaus.mojo</groupId>\n37                    <artifactId>exec-maven-plugin</artifactId>\n38                    <version>1.6.0</version>\n39\n40                    <executions>\n41                        <execution>\n42                            <id>execute-generation</id>\n43                            <goals>\n44                                <goal>exec</goal>\n45                            </goals>\n46                            <phase>generate-resources</phase>\n47\n48                            <configuration>\n49                                <!-- Access binary file in node_modules because it doesn't work on windows otherwise. -->\n50                                <executable>${node.modules.installation.path}/${ag.binary.name}</executable>\n51                                <commandlineArgs>\n52                                    ${project.basedir}/src/docs/asyncapi/asyncapi.yaml @asyncapi/html-template@${asyncapi.htmltemplate.version} -p sidebarOrganization=byTags -p\n53                                    version=${project.version} -o ${asyncapi.generation.dir}\n54                                </commandlineArgs>\n55                            </configuration>\n56                        </execution>\n57                    </executions>\n58                </plugin>\n59                <plugin>\n60                    <groupId>org.apache.maven.plugins</groupId>\n61                    <artifactId>maven-resources-plugin</artifactId>\n62                    <executions>\n63                        <execution>\n64                            <id>copy-resources</id>\n65                            <!-- here the phase you need -->\n66                            <phase>generate-resources</phase>\n67                            <goals>\n68                                <goal>copy-resources</goal>\n69                            </goals>\n70                            <configuration>\n71                                <outputDirectory>${asyncapi.generation.dir}/assets</outputDirectory>\n72                                <resources>\n73                                    <resource>\n74                                        <directory>src/docs/asyncapi/assets</directory>\n75                                        <filtering>true</filtering>\n76                                    </resource>\n77                                </resources>\n78                            </configuration>\n79                        </execution>\n80                    </executions>\n81                </plugin>\n82            </plugins>\n83        </build>\n84    </profile>",
      "1bindings:\n2  kafka:\n3    schema.registry.url: >-\n4      https://schema-registry.prod.url/",
      "1bindings:\n2  kafka:\n3    replicas: 3\n4    partitions: 3\n5    cleanup.policy: delete\n6    retention.ms: 7 days",
      "1bindings:\n2  kafka:\n3    groupId:\n4      type: string\n5      description: >\n6        The groupId must be prefixed by your `svc` account, deliver by the\n7        Adeo Kafka team.\n8        This `svc` must have the write access to the topic.\n9    value.subject.name.strategy:\n10      type: string\n11      description: >\n12        We use the RecordNameStrategy to infer the messages schema.\n13        Use\n14        `value.subject.name.strategy=io.confluent.kafka.serializers.subject.RecordNameStrategy`\n15        in your producer configuration.",
      "1bindings:\n2  kafka:\n3    key:\n4      $ref: \"https://asyncapi.com/resources/casestudies/adeo/CostingResponseKey.avsc\"",
      "1{\n2  \"namespace\": \"com.adeo.casestudy.costingrequest\",\n3  \"type\": \"record\",\n4  \"name\": \"CostingRequestPayload\",\n5  \"version\": \"1.1.0\",\n6  \"fields\": [ ... ]\n7}",
      "1asyncapi: 2.4.0\n2info:\n3  title: Adeo AsyncAPI Case Study\n4  version: \"%REPLACED_BY_MAVEN%\"\n5  description: >\n6    This Adeo specification illustrates how ADEO uses AsyncAPI to document some of their exchanges.\n7  contact:\n8    name: AsyncAPI Community\n9    email: case-study@asyncapi.com\n10servers:\n11  production:\n12    url: \"prod.url:9092\"\n13    protocol: kafka\n14    description: Kafka PRODUCTION cluster\n15    security:\n16      - sasl-ssl: []\n17    bindings:\n18      kafka:\n19        schema.registry.url: >-\n20          https://schema-registry.prod.url/\n21  staging:\n22    url: \"staging.url:9092\"\n23    protocol: kafka\n24    description: Kafka STAGING cluster for `uat` and `preprod` environments\n25    security:\n26      - sasl-ssl: []\n27    bindings:\n28      kafka:\n29        schema.registry.url: >-\n30          https://schema-registry.staging.url/\n31  dev:\n32    url: \"dev.url:9092\"\n33    protocol: kafka\n34    description: Kafka DEV cluster for `dev` and `sit` environments\n35    security:\n36      - sasl-ssl: []\n37    bindings:\n38      kafka:\n39        schema.registry.url: >-\n40          https://schema-registry.dev.url/\n41tags:\n42  - name: costing\n43    description: \"Costing channels, used by Costing clients.\"\n44channels:\n45  \"adeo-{env}-case-study-COSTING-REQUEST-{version}\":\n46    description: >\n47      Use this topic to do a Costing Request to Costing product.\n48      We use the\n49      [**RecordNameStrategy**](https://docs.confluent.io/platform/current/schema-registry/serdes-develop/index.html#subject-name-strategy)\n50      to infer the messages schema.\n51      You have to define `value.subject.name.strategy` to\n52      `io.confluent.kafka.serializers.subject.RecordNameStrategy` in your\n53      producer to use the schema we manage.\n54      The schema below illustrates how Costing Request messages are\n55      handled.\n56      ![](https://user-images.githubusercontent.com/5501911/188920831-689cec5f-8dc3-460b-8794-0b54ec8b0ac8.png)\n57    parameters:\n58      env:\n59        $ref: \"#/components/parameters/Env\"\n60      version:\n61        $ref: \"#/components/parameters/Version\"\n62    bindings:\n63      kafka:\n64        replicas: 3\n65        partitions: 3\n66        cleanup.policy: delete\n67        retention.ms: 7 days\n68    publish:\n69      operationId: requestCosting\n70      summary: |\n71        [COSTING] Request one or more Costing calculation for any product\n72      description: >\n73        You can try a costing request using our [Conduktor producer\n74        template](https://conduktor.url)\n75      tags:\n76        - name: costing\n77      message:\n78        oneOf:\n79          - $ref: \"#/components/messages/costingRequestV1\"\n80      bindings:\n81        kafka:\n82          groupId:\n83            type: string\n84            description: >\n85              The groupId must be prefixed by your `svc` account, deliver by the\n86              Adeo Kafka team.\n87              This `svc` must have the write access to the topic.\n88          value.subject.name.strategy:\n89            type: string\n90            description: >\n91              We use the RecordNameStrategy to infer the messages schema.\n92              Use\n93              `value.subject.name.strategy=io.confluent.kafka.serializers.subject.RecordNameStrategy`\n94              in your producer configuration.\n95  \"adeo-{env}-case-study-COSTING-RESPONSE-{version}\":\n96    description: >\n97      This topic is used to REPLY Costing Requests and is targeted by the\n98      `REPLY_TOPIC` header.\n99      **You must grant PUBLISH access to our `svc-ccr-app` service account.**.\n100      We use the\n101      [**RecordNameStrategy**](https://docs.confluent.io/platform/current/schema-registry/serdes-develop/index.html#subject-name-strategy)\n102      to infer the messages schema.\n103      You have to define `key.subject.name.strategy` and\n104      `value.subject.name.strategy` to\n105      `io.confluent.kafka.serializers.subject.RecordNameStrategy` in your\n106      consumer.\n107      The schema below illustrates how Costing Response messages are\n108      handled.\n109           ![](https://user-images.githubusercontent.com/5501911/188920831-689cec5f-8dc3-460b-8794-0b54ec8b0ac8.png)\n110    parameters:\n111      env:\n112        $ref: \"#/components/parameters/Env\"\n113      version:\n114        $ref: \"#/components/parameters/Version\"\n115    bindings:\n116      kafka:\n117        groupId:\n118          type: string\n119          description: >\n120            The groupId must be prefixed by your `svc` account, deliver by the\n121            Adeo Kafka team.\n122            This `svc` must have the read access to the topic.\n123        key.subject.name.strategy:\n124          type: string\n125          description: >\n126            We use the RecordNameStrategy to infer the messages schema.\n127            Use\n128            `key.subject.name.strategy=io.confluent.kafka.serializers.subject.RecordNameStrategy`\n129            in your consumer configuration.\n130        value.subject.name.strategy:\n131          type: string\n132          description: >\n133            We use the RecordNameStrategy to infer the messages schema.\n134            Use\n135            `value.subject.name.strategy=io.confluent.kafka.serializers.subject.RecordNameStrategy`\n136            in your consumer configuration.\n137    subscribe:\n138      operationId: getCostingResponse\n139      summary: >\n140        [COSTING] Get the costing responses matching an initial Costing\n141        Request.\n142      tags:\n143        - name: costing\n144      message:\n145        $ref: \"#/components/messages/costingResponse\"\n146components:\n147  correlationIds:\n148    costingCorrelationId:\n149      description: >\n150        This correlation ID is used for message tracing and messages\n151        correlation.\n152        This correlation ID is generated at runtime based on the `REQUEST_ID`\n153        and sent to the RESPONSE message.\n154      location: $message.header#/REQUEST_ID\n155  messages:\n156    costingRequestV1:\n157      name: CostingRequestV1\n158      title: Costing Request V1\n159      summary: Costing Request V1 inputs.\n160      tags:\n161        - name: costing\n162      schemaFormat: application/vnd.apache.avro;version=1.9.0\n163      correlationId:\n164        $ref: \"#/components/correlationIds/costingCorrelationId\"\n165      headers:\n166        type: object\n167        required:\n168          - REQUESTER_ID\n169          - REQUESTER_CODE\n170          - REQUEST_ID\n171          - REPLY_TOPIC\n172        properties:\n173          REQUEST_ID:\n174            $ref: \"#/components/schemas/RequestId\"\n175          REPLY_TOPIC:\n176            $ref: \"#/components/schemas/ReplyTopic\"\n177          REQUESTER_ID:\n178            $ref: \"#/components/schemas/RequesterId\"\n179          REQUESTER_CODE:\n180            $ref: \"#/components/schemas/RequesterCode\"\n181      payload:\n182        $ref: \"https://asyncapi.com/resources/casestudies/adeo/CostingRequestPayload.avsc\"\n183    costingResponse:\n184      name: CostingResponse\n185      title: Costing Response\n186      summary: Costing Response ouputs.\n187      tags:\n188        - name: costing\n189      description: >\n190        Please refer to the `CostingResponseKey.avsc` schema, available on [our\n191        github\n192        project](https://github.url/).\n193      schemaFormat: application/vnd.apache.avro;version=1.9.0\n194      correlationId:\n195        $ref: \"#/components/correlationIds/costingCorrelationId\"\n196      headers:\n197        type: object\n198        properties:\n199          CALCULATION_ID:\n200            $ref: \"#/components/schemas/MessageId\"\n201          CORRELATION_ID:\n202            $ref: \"#/components/schemas/CorrelationId\"\n203          REQUEST_TIMESTAMP:\n204            type: string\n205            format: date-time\n206            description: Timestamp of the costing request\n207          CALCULATION_TIMESTAMP:\n208            type: string\n209            format: date-time\n210            description: Technical timestamp for the costing calculation\n211      bindings:\n212        kafka:\n213          key:\n214            $ref: \"https://asyncapi.com/resources/casestudies/adeo/CostingResponseKey.avsc\"\n215      payload:\n216        $ref: \"https://asyncapi.com/resources/casestudies/adeo/CostingResponsePayload.avsc\"\n217  schemas:\n218    RequesterId:\n219      type: string\n220      description: The Costing requester service account used to produce costing request.\n221      example: svc-ecollect-app\n222    RequesterCode:\n223      type: string\n224      description: >-\n225        The Costing requester code (generally the BU Code). The requester code\n226        is useful to get the dedicated context (tenant).\n227      example: 1\n228    MessageId:\n229      type: string\n230      format: uuid\n231      description: A unique Message ID.\n232      example: 1fa6ef40-8f47-40a8-8cf6-f8607d0066ef\n233    RequestId:\n234      type: string\n235      format: uuid\n236      description: >-\n237        A unique Request ID needed to define a `CORRELATION_ID` for exchanges,\n238        which will be sent back in the Costing Responses.\n239      example: 1fa6ef40-8f47-40a8-8cf6-f8607d0066ef\n240    CorrelationId:\n241      type: string\n242      format: uuid\n243      description: >-\n244        A unique Correlation ID defined from the `REQUEST_ID` or the\n245        `MESSAGE_ID` provided in the Costing Request.\n246      example: 1fa6ef40-8f47-40a8-8cf6-f8607d0066ef\n247    BuCode:\n248      type: string\n249      description: The Business Unit code for which data are applicable.\n250      example: 1\n251    ReplyTopic:\n252      type: string\n253      description: >\n254        The Kafka topic where to send the Costing Response. This is required for\n255        the [Return Address EIP\n256        pattern](https://www.enterpriseintegrationpatterns.com/patterns/messaging/ReturnAddress.html).\n257        **You must grant WRITE access to our `svc-ccr-app` service account.**\n258      example: adeo-case-study-COSTING-RESPONSE-V1\n259    ErrorStep:\n260      type: string\n261      description: |\n262        The woker that has thrown the error.\n263      example: EXPOSE_RESULT\n264    ErrorMessage:\n265      type: string\n266      description: |\n267        The error message describing the error.\n268      example: Error message\n269    ErrorCode:\n270      type: string\n271      description: |\n272        The error code.\n273      example: CURRENCY_NOT_FOUND\n274  parameters:\n275    Env:\n276      description: Adeo Kafka Environement for messages publications.\n277      schema:\n278        type: string\n279        enum:\n280          - dev\n281          - sit\n282          - uat1\n283          - preprod\n284          - prod\n285    Version:\n286      description: the topic version you want to use\n287      schema:\n288        type: string\n289        example: V1\n290        default: V1\n291  securitySchemes:\n292    sasl-ssl:\n293      type: plain\n294      x-sasl.jaas.config: >-\n295        org.apache.kafka.common.security.plain.PlainLoginModule required\n296        username=\"<CLUSTER_API_KEY>\" password=\"<CLUSTER_API_SECRET>\";\n297      x-security.protocol: SASL_SSL\n298      x-ssl.endpoint.identification.algorithm: https\n299      x-sasl.mechanism: PLAIN\n300      description: >\n301        Use [SASL authentication with SSL\n302        encryption](https://docs.confluent.io/platform/current/security/security_tutorial.html#configure-clients)\n303        to connect to the ADEO Broker."
    ],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/casestudies/adeo/architecture.webp",
        "alt": "Architecture Diagram"
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "08737abf",
    "title": "AsyncAPI Case Studies | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/casestudies/hdiglobal.html",
    "content": "AsyncAPI Case Studies | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page HDI Global SE Vladislav Zwenihorodski Industry: Insurance Customers: 5000 Revenue: 9.1B EUR The HDI brand operates in Germany and internationally, offering life and property/casualty insurance services. They cater to both private individuals and corporate clients, and have been providing industrial insurance since 2016. tl;dr just go and have a look at full production-used AsyncAPI document Challenges The HDI has various platform teams, among them the Integration Platform team, which offers three products: Azure API Management, Azure Event Hub, and the Azure Service Bus. For synchronous communication OpenAPI is used as a standard. For asynchronous scenarios we want to use AsyncAPI to achieve the same level of transparency and discoverability. We as platform team offer the Azure Service Bus with self-service capabilities. Our customers are able to manage their own topics and subscriptions by maintaining a custom configuration model in a GitOps fashion. We want to establish AsyncAPI as documentation standard in HDI's organization. Information about the available message formats and topics is already available in distributed sources (e.g. repositories) and needs to be aggregated. To achieve discoverability the creation of a comprehensive catalog of existing topics is necessary, allowing potential subscribers access to information about messages from the available topics, so they can choose which ones to subscribe to. Solution The solution is to create AsyncAPI documents where each topic owned by the customer is represented as a channel. As we are using the GitOps setup it is straightforward to run pipeline whenever there is a change (commit) in the topic configuration. The necessary information is read from the customer repositories and then passed to a bash script as input. After successful creation, this file, along with a generated markdown for it, is saved within a documentation repository. This documentation repository serves as the basis for our Azure DevOps wiki, ensuring that all project documentation is centralized and easily accessible. As the documentation wiki is public the information is accessible to every developer, allowing easy access to messages from any topics of their choice. This approach makes our asynchronous communication as transparent and discoverable as our synchronous communication. Use Case The AsyncAPI documents are used for documentation purposes by the platform team. It provides a comprehensive overview of the asynchronous communication in our system, including the available topics and the structure of the messages. (Outlook) The AsyncAPI document will be used to generate Java DTOs, ensuring type safety and clear data structure understanding. (Outlook) Having the AsyncAPI documents at hand we are currently planning to use them to configure an internal developer portal (IDP) that will aggregate async and sync APIs among other things. (Outlook) Evaluate if replacing the custom configuration model and use AsyncAPI documents in the center to configure asynchronous communication instead. More Details Languages: java, .net, bash Frameworks: Spring Boot Protocols: AMQP Testing strategy n/a Approach to code generation Our team currently does not use or ofer a code generation tool. However, our customers are free to use any tool they prefer to generate DTOs from the AsyncAPI document. Architecture The following enterprise integration patterns are applied : Message Channel Each channel in the AsyncAPI document corresponds to an existing Service Bus topic that can be subscribed to. \n```javascript\n1channels:\n2  claimStatus-emea:\n3    servers:\n4      - $ref: '#/servers/box-emea'\n5    address: https://namespace.servicebus.windows.net/topic/example/claimStatus\n```\n Message The 'messages' section under each channel in the AsyncAPI document adheres to this pattern. Each message is identified by a name and contains a payload, which represents the data transferred between applications. \n```javascript\n1    messages:\n2      claimStatus:\n3        name: claimStatus-Message\n4        contentType: application/json\n```\n Document Message The 'payload' under each message in the AsyncAPI document adheres to this pattern. The payload is a self-contained document that describes the message and is comprehensible to the message receiver. \n```javascript\n1payload:\n2  $ref: '#/components/schemas/claimStatus-example.json'\n```\n In our repository structure, the message-schema file is stored separately and just referenced in the Topic configs. To make sure that all information is accessible in one place, the schema is directly copied to the AsyncAPI document. \n```javascript\n1components:\n2  schemas:\n3      claimStatus-example.json: {\n4        \"$schema\": \"http://json-schema.org/draft-06/schema#\",\n5        \"type\": \"object\",\n6        \"properties\": {\n7          \"message\": {\n8            \"type\": \"object\",\n9            \"properties\": {\n10              \"version\": {\n11                \"type\": \"string\"\n12              },\n13              \"header\": {\n14                \"type\": \"object\",\n15                \"properties\": {\n16                  \"messageId\": {\n17                    \"type\": \"string\"\n18                  },\n19                  \"entityType\": {\n20                    \"type\": \"string\"\n21                  },\n22                  \"eventType\": {\n23                    \"type\": \"object\",\n24                    \"enum\": [\n25                      \"create\",\n26                      \"update\"\n27                    ]\n28                  }\n29                },\n30                \"required\": [\n31                  \"messageId\",\n32                  \"entityType\",\n33                  \"eventType\"\n34                ]\n35              },\n36              \"data\": {\n37                \"type\": \"object\",\n38                \"properties\": {\n39                  \"par\": {\n40                    \"type\": \"object\",\n41                    \"properties\": {\n42                      \"tenantNumber\": {\n43                        \"type\": \"string\"\n44                      },\n45                      \"policyNumber\": {\n46                        \"type\": \"number\"\n47                      },\n48                      \"contractNumber\": {\n49                        \"type\": \"number\"\n50                      },\n51                      \"sourceSystem\": {\n52                        \"type\": \"string\"\n53                      },\n54                      \"claimStatus\": {\n55                        \"type\": \"string\"\n56                      },\n57                      \"currencyCode\": {\n58                        \"type\": \"string\"\n59                      },\n60                      \"registrYear\": {\n61                        \"type\": \"number\"\n62                      },\n63                      \"broker\": {\n64                        \"type\": \"string\"\n65                      },\n66                      \"insured\": {\n67                        \"type\": \"string\"\n68                      },\n69                      \"lineOfBusiness\": {\n70                        \"type\": \"number\"\n71                      },\n72                      \"claimCountry\": {\n73                        \"type\": \"string\"\n74                      },\n75                      \"isNewClaim\": {\n76                        \"type\": \"boolean\"\n77                      },\n78                      \"dateOfLoss\": {\n79                        \"type\": \"string\",\n80                        \"format\": \"date\"\n81                      },\n82                      \"creationDate\": {\n83                        \"type\": \"string\",\n84                        \"format\": \"date\"\n85                      },\n86                      \"notificationDate\": {\n87                        \"type\": \"string\",\n88                        \"format\": \"date\"\n89                      },\n90                      \"businessDate\": {\n91                        \"type\": \"string\",\n92                        \"format\": \"date\"\n93                      }\n94                    },\n95                    \"required\": [\n96                      \"tenantNumber\"\n97                    ]\n98                  }\n99                },\n100                \"required\": [\n101                  \"par\"\n102                ]\n103              }\n104            },\n105            \"required\": [\n106              \"version\",\n107              \"header\",\n108              \"data\"\n109            ]\n110          }\n111        },\n112        \"required\": [\n113          \"message\"\n114        ]\n115      }\n116\n```\n More Details about AsyncAPI Version: 3.0.0 Who maintains documents: Customers maintain this document automatically by maintaining their own topic configurations. Internal users: true External users: false How AsyncAPI documents are stored A seperate Git repository functions as a \"customer Wiki\", serving as a central location for all relevant documents about the existing infrastructure. This includes the AsyncAPI document, which provides a comprehensive overview of the asynchronous communication in our system. Where maintainers edit AsyncAPI documents If changes for any topic are applied by a customer, the documentation pipeline is triggered. This pipeline uses a bash script to read the updated configuration from the customer's repository. It then generates a new AsyncAPI document reflecting these changes. The AsyncAPI document is validated using the AsyncAPI CLI to confirm that the document is correctly formatted and adheres to the AsyncAPI specification right after creation and before being commited to the documentation repository. What extensions are used none How documentation is generated Documentation is generated via AsyncAPI CLI and published to the Azure DevOps wiki right after the AsyncAPI file is generated. What bindings are used none What tools are used AsyncAPI CLI AsyncAPI Generator : markdown-template . Schemas Spec: JSON Schema Storage strategy A Git repository functions as a self-service portal where customers can manage their own configurations for the Azure Service Bus. This includes defining their own message schemas for any topics they own. Schema Registry none Versioning of schemas The customer has the freedom to choose the versioning for their own message-schema files. Validation of message schemas Validation using Ajv is used solely for the purpose of ensuring that the JSON data adheres to the expected schema. This validation is performed for each customer by the Pull Request pipeline we provide. It does not perform any other form of validation or processing on the data. Additional Resources Production-use AsyncAPI document \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: customer-example\n4  version: 1.0.0\n5  description: |\n6    This is an AsyncAPI document for customer-example.\n7    It contains every Topic owned by the customer in form of channel. \n8    Dowload the coresponding schema files from the following link:\n9servers:\n10  box-apac:\n11    host: namespace.servicebus.windows.net\n12    protocol: amqp\n13    description: Azure Service Bus namespace endpoint for box.\n14  box-emea:\n15    host: namespace.servicebus.windows.net\n16    protocol: amqp\n17    description: Azure Service Bus namespace endpoint for box.\n18channels:\n19  claimStatus-emea:\n20    servers:\n21      - $ref: '#/servers/box-emea'\n22    address: https://namespace.servicebus.windows.net/topic/example/claimStatus\n23    messages:\n24      claimStatus:\n25        name: claimStatus-Message\n26        contentType: application/json\n27        payload:\n28          $ref: '#/components/schemas/claimStatus-example.json'\n29  claimDetails-emea:\n30    servers:\n31      - $ref: '#/servers/box-emea'\n32    address: https://namespace.servicebus.windows.net/topic/example/claimDetails\n33    messages:\n34      claimDetails:\n35        name: claimDetails-Message\n36        contentType: application/json\n37        payload:\n38          $ref: '#/components/schemas/claimDetails-example.json'\n39operations:\n40  claimStatus-emea:\n41    action: send\n42    channel:\n43      $ref: '#/channels/claimStatus-emea'\n44    messages:\n45      - $ref: '#/channels/claimStatus-emea/messages/claimStatus'\n46  claimDetails-emea:\n47    action: send\n48    channel:\n49      $ref: '#/channels/claimDetails-emea'\n50    messages:\n51      - $ref: '#/channels/claimDetails-emea/messages/claimDetails'\n52components:\n53  schemas:\n54      claimDetails-example.json: {\n55  \"$schema\": \"http://json-schema.org/draft-06/schema#\",\n56  \"type\": \"object\",\n57  \"properties\": {\n58    \"policyNumber\": {\n59      \"type\": \"string\"\n60    },\n61    \"claimNumber\": {\n62      \"type\": \"string\"\n63    },\n64    \"notificationDate\": {\n65      \"type\": \"string\"\n66    },\n67    \"occurrenceDate\": {\n68      \"type\": \"string\"\n69    },\n70    \"claimAmount\": {\n71      \"type\": \"integer\"\n72    },\n73    \"description\": {\n74      \"type\": \"string\"\n75    },\n76    \"editor\": {\n77      \"type\": \"string\"\n78    },\n79    \"location\": {\n80      \"type\": \"string\"\n81    },\n82    \"country\": {\n83      \"type\": \"string\"\n84    },\n85    \"currency\": {\n86      \"type\": \"string\"\n87    },\n88    \"movements\": {\n89      \"type\": \"array\",\n90      \"items\": [\n91        {\n92          \"type\": \"object\",\n93          \"properties\": {\n94            \"amount\": {\n95              \"type\": \"integer\"\n96            },\n97            \"movementType\": {\n98              \"type\": \"string\"\n99            },\n100            \"benefitType\": {\n101              \"type\": \"string\"\n102            }\n103          },\n104          \"required\": [\n105            \"amount\",\n106            \"movementType\",\n107            \"benefitType\"\n108          ]\n109        },\n110        {\n111          \"type\": \"object\",\n112          \"properties\": {\n113            \"amount\": {\n114              \"type\": \"integer\"\n115            },\n116            \"movementType\": {\n117              \"type\": \"string\"\n118            },\n119            \"benefitType\": {\n120              \"type\": \"string\"\n121            }\n122          },\n123          \"required\": [\n124            \"amount\",\n125            \"movementType\",\n126            \"benefitType\"\n127          ]\n128        },\n129        {\n130          \"type\": \"object\",\n131          \"properties\": {\n132            \"amount\": {\n133              \"type\": \"integer\"\n134            },\n135            \"movementType\": {\n136              \"type\": \"string\"\n137            },\n138            \"benefitType\": {\n139              \"type\": \"string\"\n140            }\n141          },\n142          \"required\": [\n143            \"amount\",\n144            \"movementType\",\n145            \"benefitType\"\n146          ]\n147        }\n148      ]\n149    }\n150  },\n151  \"required\": [\n152    \"policyNumber\",\n153    \"claimNumber\"\n154  ]\n155}\n156      claimStatus-example.json: {\n157  \"$schema\": \"http://json-schema.org/draft-06/schema#\",\n158  \"type\": \"object\",\n159  \"properties\": {\n160    \"message\": {\n161      \"type\": \"object\",\n162      \"properties\": {\n163        \"version\": {\n164          \"type\": \"string\"\n165        },\n166        \"header\": {\n167          \"type\": \"object\",\n168          \"properties\": {\n169            \"messageId\": {\n170              \"type\": \"string\"\n171            },\n172            \"entityType\": {\n173              \"type\": \"string\"\n174            },\n175            \"eventType\": {\n176              \"type\": \"object\",\n177              \"enum\": [\n178                \"create\",\n179                \"update\"\n180              ]\n181            }\n182          },\n183          \"required\": [\n184            \"messageId\",\n185            \"entityType\",\n186            \"eventType\"\n187          ]\n188        },\n189        \"data\": {\n190          \"type\": \"object\",\n191          \"properties\": {\n192            \"par\": {\n193              \"type\": \"object\",\n194              \"properties\": {\n195                \"tenantNumber\": {\n196                  \"type\": \"string\"\n197                },\n198                \"policyNumber\": {\n199                  \"type\": \"number\"\n200                },\n201                \"contractNumber\": {\n202                  \"type\": \"number\"\n203                },\n204                \"sourceSystem\": {\n205                  \"type\": \"string\"\n206                },\n207                \"claimStatus\": {\n208                  \"type\": \"string\"\n209                },\n210                \"currencyCode\": {\n211                  \"type\": \"string\"\n212                },\n213                \"registrYear\": {\n214                  \"type\": \"number\"\n215                },\n216                \"broker\": {\n217                  \"type\": \"string\"\n218                },\n219                \"insured\": {\n220                  \"type\": \"string\"\n221                },\n222                \"lineOfBusiness\": {\n223                  \"type\": \"number\"\n224                },\n225                \"claimCountry\": {\n226                  \"type\": \"string\"\n227                },\n228                \"isNewClaim\": {\n229                  \"type\": \"boolean\"\n230                },\n231                \"dateOfLoss\": {\n232                  \"type\": \"string\",\n233                  \"format\": \"date\"\n234                },\n235                \"creationDate\": {\n236                  \"type\": \"string\",\n237                  \"format\": \"date\"\n238                },\n239                \"notificationDate\": {\n240                  \"type\": \"string\",\n241                  \"format\": \"date\"\n242                },\n243                \"businessDate\": {\n244                  \"type\": \"string\",\n245                  \"format\": \"date\"\n246                }\n247              },\n248              \"required\": [\n249                \"tenantNumber\"\n250              ]\n251            }\n252          },\n253          \"required\": [\n254            \"par\"\n255          ]\n256        }\n257      },\n258      \"required\": [\n259        \"version\",\n260        \"header\",\n261        \"data\"\n262      ]\n263    }\n264  },\n265  \"required\": [\n266    \"message\"\n267  ]\n268}\n```\n",
    "code_blocks": [
      "1channels:\n2  claimStatus-emea:\n3    servers:\n4      - $ref: '#/servers/box-emea'\n5    address: https://namespace.servicebus.windows.net/topic/example/claimStatus",
      "1    messages:\n2      claimStatus:\n3        name: claimStatus-Message\n4        contentType: application/json",
      "1payload:\n2  $ref: '#/components/schemas/claimStatus-example.json'",
      "1components:\n2  schemas:\n3      claimStatus-example.json: {\n4        \"$schema\": \"http://json-schema.org/draft-06/schema#\",\n5        \"type\": \"object\",\n6        \"properties\": {\n7          \"message\": {\n8            \"type\": \"object\",\n9            \"properties\": {\n10              \"version\": {\n11                \"type\": \"string\"\n12              },\n13              \"header\": {\n14                \"type\": \"object\",\n15                \"properties\": {\n16                  \"messageId\": {\n17                    \"type\": \"string\"\n18                  },\n19                  \"entityType\": {\n20                    \"type\": \"string\"\n21                  },\n22                  \"eventType\": {\n23                    \"type\": \"object\",\n24                    \"enum\": [\n25                      \"create\",\n26                      \"update\"\n27                    ]\n28                  }\n29                },\n30                \"required\": [\n31                  \"messageId\",\n32                  \"entityType\",\n33                  \"eventType\"\n34                ]\n35              },\n36              \"data\": {\n37                \"type\": \"object\",\n38                \"properties\": {\n39                  \"par\": {\n40                    \"type\": \"object\",\n41                    \"properties\": {\n42                      \"tenantNumber\": {\n43                        \"type\": \"string\"\n44                      },\n45                      \"policyNumber\": {\n46                        \"type\": \"number\"\n47                      },\n48                      \"contractNumber\": {\n49                        \"type\": \"number\"\n50                      },\n51                      \"sourceSystem\": {\n52                        \"type\": \"string\"\n53                      },\n54                      \"claimStatus\": {\n55                        \"type\": \"string\"\n56                      },\n57                      \"currencyCode\": {\n58                        \"type\": \"string\"\n59                      },\n60                      \"registrYear\": {\n61                        \"type\": \"number\"\n62                      },\n63                      \"broker\": {\n64                        \"type\": \"string\"\n65                      },\n66                      \"insured\": {\n67                        \"type\": \"string\"\n68                      },\n69                      \"lineOfBusiness\": {\n70                        \"type\": \"number\"\n71                      },\n72                      \"claimCountry\": {\n73                        \"type\": \"string\"\n74                      },\n75                      \"isNewClaim\": {\n76                        \"type\": \"boolean\"\n77                      },\n78                      \"dateOfLoss\": {\n79                        \"type\": \"string\",\n80                        \"format\": \"date\"\n81                      },\n82                      \"creationDate\": {\n83                        \"type\": \"string\",\n84                        \"format\": \"date\"\n85                      },\n86                      \"notificationDate\": {\n87                        \"type\": \"string\",\n88                        \"format\": \"date\"\n89                      },\n90                      \"businessDate\": {\n91                        \"type\": \"string\",\n92                        \"format\": \"date\"\n93                      }\n94                    },\n95                    \"required\": [\n96                      \"tenantNumber\"\n97                    ]\n98                  }\n99                },\n100                \"required\": [\n101                  \"par\"\n102                ]\n103              }\n104            },\n105            \"required\": [\n106              \"version\",\n107              \"header\",\n108              \"data\"\n109            ]\n110          }\n111        },\n112        \"required\": [\n113          \"message\"\n114        ]\n115      }\n116",
      "1asyncapi: 3.0.0\n2info:\n3  title: customer-example\n4  version: 1.0.0\n5  description: |\n6    This is an AsyncAPI document for customer-example.\n7    It contains every Topic owned by the customer in form of channel. \n8    Dowload the coresponding schema files from the following link:\n9servers:\n10  box-apac:\n11    host: namespace.servicebus.windows.net\n12    protocol: amqp\n13    description: Azure Service Bus namespace endpoint for box.\n14  box-emea:\n15    host: namespace.servicebus.windows.net\n16    protocol: amqp\n17    description: Azure Service Bus namespace endpoint for box.\n18channels:\n19  claimStatus-emea:\n20    servers:\n21      - $ref: '#/servers/box-emea'\n22    address: https://namespace.servicebus.windows.net/topic/example/claimStatus\n23    messages:\n24      claimStatus:\n25        name: claimStatus-Message\n26        contentType: application/json\n27        payload:\n28          $ref: '#/components/schemas/claimStatus-example.json'\n29  claimDetails-emea:\n30    servers:\n31      - $ref: '#/servers/box-emea'\n32    address: https://namespace.servicebus.windows.net/topic/example/claimDetails\n33    messages:\n34      claimDetails:\n35        name: claimDetails-Message\n36        contentType: application/json\n37        payload:\n38          $ref: '#/components/schemas/claimDetails-example.json'\n39operations:\n40  claimStatus-emea:\n41    action: send\n42    channel:\n43      $ref: '#/channels/claimStatus-emea'\n44    messages:\n45      - $ref: '#/channels/claimStatus-emea/messages/claimStatus'\n46  claimDetails-emea:\n47    action: send\n48    channel:\n49      $ref: '#/channels/claimDetails-emea'\n50    messages:\n51      - $ref: '#/channels/claimDetails-emea/messages/claimDetails'\n52components:\n53  schemas:\n54      claimDetails-example.json: {\n55  \"$schema\": \"http://json-schema.org/draft-06/schema#\",\n56  \"type\": \"object\",\n57  \"properties\": {\n58    \"policyNumber\": {\n59      \"type\": \"string\"\n60    },\n61    \"claimNumber\": {\n62      \"type\": \"string\"\n63    },\n64    \"notificationDate\": {\n65      \"type\": \"string\"\n66    },\n67    \"occurrenceDate\": {\n68      \"type\": \"string\"\n69    },\n70    \"claimAmount\": {\n71      \"type\": \"integer\"\n72    },\n73    \"description\": {\n74      \"type\": \"string\"\n75    },\n76    \"editor\": {\n77      \"type\": \"string\"\n78    },\n79    \"location\": {\n80      \"type\": \"string\"\n81    },\n82    \"country\": {\n83      \"type\": \"string\"\n84    },\n85    \"currency\": {\n86      \"type\": \"string\"\n87    },\n88    \"movements\": {\n89      \"type\": \"array\",\n90      \"items\": [\n91        {\n92          \"type\": \"object\",\n93          \"properties\": {\n94            \"amount\": {\n95              \"type\": \"integer\"\n96            },\n97            \"movementType\": {\n98              \"type\": \"string\"\n99            },\n100            \"benefitType\": {\n101              \"type\": \"string\"\n102            }\n103          },\n104          \"required\": [\n105            \"amount\",\n106            \"movementType\",\n107            \"benefitType\"\n108          ]\n109        },\n110        {\n111          \"type\": \"object\",\n112          \"properties\": {\n113            \"amount\": {\n114              \"type\": \"integer\"\n115            },\n116            \"movementType\": {\n117              \"type\": \"string\"\n118            },\n119            \"benefitType\": {\n120              \"type\": \"string\"\n121            }\n122          },\n123          \"required\": [\n124            \"amount\",\n125            \"movementType\",\n126            \"benefitType\"\n127          ]\n128        },\n129        {\n130          \"type\": \"object\",\n131          \"properties\": {\n132            \"amount\": {\n133              \"type\": \"integer\"\n134            },\n135            \"movementType\": {\n136              \"type\": \"string\"\n137            },\n138            \"benefitType\": {\n139              \"type\": \"string\"\n140            }\n141          },\n142          \"required\": [\n143            \"amount\",\n144            \"movementType\",\n145            \"benefitType\"\n146          ]\n147        }\n148      ]\n149    }\n150  },\n151  \"required\": [\n152    \"policyNumber\",\n153    \"claimNumber\"\n154  ]\n155}\n156      claimStatus-example.json: {\n157  \"$schema\": \"http://json-schema.org/draft-06/schema#\",\n158  \"type\": \"object\",\n159  \"properties\": {\n160    \"message\": {\n161      \"type\": \"object\",\n162      \"properties\": {\n163        \"version\": {\n164          \"type\": \"string\"\n165        },\n166        \"header\": {\n167          \"type\": \"object\",\n168          \"properties\": {\n169            \"messageId\": {\n170              \"type\": \"string\"\n171            },\n172            \"entityType\": {\n173              \"type\": \"string\"\n174            },\n175            \"eventType\": {\n176              \"type\": \"object\",\n177              \"enum\": [\n178                \"create\",\n179                \"update\"\n180              ]\n181            }\n182          },\n183          \"required\": [\n184            \"messageId\",\n185            \"entityType\",\n186            \"eventType\"\n187          ]\n188        },\n189        \"data\": {\n190          \"type\": \"object\",\n191          \"properties\": {\n192            \"par\": {\n193              \"type\": \"object\",\n194              \"properties\": {\n195                \"tenantNumber\": {\n196                  \"type\": \"string\"\n197                },\n198                \"policyNumber\": {\n199                  \"type\": \"number\"\n200                },\n201                \"contractNumber\": {\n202                  \"type\": \"number\"\n203                },\n204                \"sourceSystem\": {\n205                  \"type\": \"string\"\n206                },\n207                \"claimStatus\": {\n208                  \"type\": \"string\"\n209                },\n210                \"currencyCode\": {\n211                  \"type\": \"string\"\n212                },\n213                \"registrYear\": {\n214                  \"type\": \"number\"\n215                },\n216                \"broker\": {\n217                  \"type\": \"string\"\n218                },\n219                \"insured\": {\n220                  \"type\": \"string\"\n221                },\n222                \"lineOfBusiness\": {\n223                  \"type\": \"number\"\n224                },\n225                \"claimCountry\": {\n226                  \"type\": \"string\"\n227                },\n228                \"isNewClaim\": {\n229                  \"type\": \"boolean\"\n230                },\n231                \"dateOfLoss\": {\n232                  \"type\": \"string\",\n233                  \"format\": \"date\"\n234                },\n235                \"creationDate\": {\n236                  \"type\": \"string\",\n237                  \"format\": \"date\"\n238                },\n239                \"notificationDate\": {\n240                  \"type\": \"string\",\n241                  \"format\": \"date\"\n242                },\n243                \"businessDate\": {\n244                  \"type\": \"string\",\n245                  \"format\": \"date\"\n246                }\n247              },\n248              \"required\": [\n249                \"tenantNumber\"\n250              ]\n251            }\n252          },\n253          \"required\": [\n254            \"par\"\n255          ]\n256        }\n257      },\n258      \"required\": [\n259        \"version\",\n260        \"header\",\n261        \"data\"\n262      ]\n263    }\n264  },\n265  \"required\": [\n266    \"message\"\n267  ]\n268}"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "4f10bb3f",
    "title": "AsyncAPI Ambassador Program | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/community/ambassadors.html",
    "content": "AsyncAPI Ambassador Program | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets Teachers. Champions. Ambassadors! Passionate about event-driven architectures or message-driven APIs? Become an AsyncAPI Ambassador and help the OSS community build the future of APIs. Become an AsyncAPI Ambassador \n![ambassador-cover](/img/homepage/ambassador-cover.svg)\n AsyncAPI Ambassador Contributions AsyncAPI Ambassadors are passionate about APIs and AsyncAPI. They share their interest, expertise, and excitement within their communities to help others build better software. \n![Written content](/img/illustrations/blog.svg)\n Written content Write guides, step-by-step tutorials, community documentation, AsyncAPI blog posts, and beyond. \n![Video content](/img/illustrations/video-creation.svg)\n Video content Produce educational videos on YouTube and other platforms for AsyncAPI. \n![Live streams](/img/illustrations/live.svg)\n Live streams Moderate or host live streams that demo the AsyncAPI ecosystem. \n![Give talks](/img/illustrations/speaking.svg)\n Give talks Speak at meetups and conferences; we\u2019ll help with slides, abstract submissions, and travel budget. \n![Interactive Learning](/img/illustrations/learning-app.svg)\n Interactive Learning Gamify educational content and create interactive learning paths for teaching AsyncAPI and event-driven architectures. \n![Build real-life usecases example](/img/illustrations/codes.svg)\n Build real-life usecases example Develop real-life usecase project example using the AsyncaAPI specification \n![AsyncAPI Contributions](/img/illustrations/advisor.svg)\n AsyncAPI Contributions Collaborate with the AsyncAPI community via diverse contributions and improvements. \n![Gather Use-Cases](/img/illustrations/meeting.jpg)\n Gather Use-Cases Collect data from existing AsyncAPI users and create use-case studies. Join these AsyncAPI Ambassadors Learn and share knowledge with community members Daniel Kocot \ud83c\udde9\ud83c\uddea \n![Daniel Kocot](https://www.github.com/danielkocot.png)\n Senior Solution Architect / Head of API Experience and Operations Daniel has been part of the codecentric team since October 2016. Since the beginning of 2022 he works as Senior Solution Architect at the Dortmund branch. Starting as a consultant with a focus on application lifecycle management, his focus shifted more and more towards APIs. In addition to numerous customer projects and his involvement in the open source world around APIs, our Head of API Experience & Operations is also a frequent speaker at conferences. Twitter \u2197 Github \u2197 Linkedin \u2197 Giri Venkatesan \ud83c\uddee\ud83c\uddf3 \n![Giri Venkatesan](https://www.github.com/gvensan.png)\n Developer Advocate, Office of the CTO at Solace Giri Venkatesan, a follower and proponent of AsyncAPI and teams up with companies & SIs to design event-driven architecture and asynchronous APIs. To guide those discussions, I draw upon years of integration and implementation experience, particularly with Solace platforms. I've been a follower of AsyncAPI since 2022, and written blogs and delivered talks at conferences and AsyncAPI confrence tours. Twitter \u2197 Github \u2197 Linkedin \u2197 Hari Krishnan \ud83c\uddee\ud83c\uddf3 \n![Hari Krishnan](https://www.github.com/harikrishnan83.png)\n Co-founder and CTO at Specmatic, Founder, and CEO at Polarizer Technologies Co-creator of Specmatic and Perfiz. I also advise organizations, both large and small, on their transformation journey. Apart from bringing ideas to life as working software products, I coach developers, project managers, product owners, and engineering leaders. I have spoken at several conferences, including AACoT 2023, API Specification Conference (#ASC2022), API World, SeleniumConf, Agile2021, Agile India, TestingUY 2021, SREConf, PyCon Singapore, RubyConf India. My areas of interest include distributed systems, concurrency, high-performance application architecture, coaching, and training. Twitter \u2197 Github \u2197 Linkedin \u2197 Hugo Guerrero \n![Hugo Guerrero](https://www.github.com/hguerrero.png)\n Head of Technical Marketing Hugo Guerrero is a developer advocate for APIs and Event-driven Architecture. He assists organizations in this role by creating, editing, and curating product content shared with the community through webinars, conferences, and other activities. He works on open source software with major private and federal public sector clients looking to connect and extend their system architecture. He has over 20 years of experience as a developer, consultant, architect, and software development manager. Twitter \u2197 Github \u2197 Linkedin \u2197 Ivan Garcia Sainz-Aja \n![Ivan Garcia Sainz-Aja](https://www.github.com/ivangsa.png)\n Java Architect. Speaker. Building ZenWave 360\u00b0. Java Architect with a deep understanding of Java, Spring-Boot, Spring-Cloud technologies, specializing in Domain-Driven Design (DDD) and Event-Driven Architectures creating Software Easy to Understand. Building ZenWave 360\u00ba. ZenWave 360\u00ba is a set of tools built on the foundations of Domain Driven Design and API-First principles for Event-Driven Architectures, to help you create software easy to understand. https://www.zenwave360.io/ Twitter \u2197 Github \u2197 Linkedin \u2197 Laurent Broudoux \ud83c\uddeb\ud83c\uddf7 \n![Laurent Broudoux](https://www.github.com/lbroudoux.png)\n Solutions Architect / DevRel Laurent is a Cloud-Native Architecture expert and Enterprise Integration problem lover. He is the founder and lead developer of the Microcks.io open-source project: a cloud-native tool for API mocking and testing. For this, he is using his 10+ years experience as an architect in Financial Services where he defined API transformation strategies, including governance and delivery process. Twitter \u2197 Github \u2197 Linkedin \u2197 Lorna Mitchell UK \n![Lorna Mitchell](https://www.github.com/lornajane.png)\n APIs and Open Source Lorna is based in Yorkshire, UK; she is a technology leader and expert in developer experience, passionate about enhancing APIs and developer tools. In her day job as VP of Developer Experience at Redocly, she works on API and documentation tools for technical teams. Lorna is a published author and a regular speaker at conferences, sharing her insights on a variety of tech-related topics. Lorna serves on the OpenUK board, is on the Technical Steering Committee for OpenAPI specification, and maintains open source projects. To learn more about Lorna's activities, visit her website at https://lornajane.net. Twitter \u2197 Github \u2197 Linkedin \u2197 Ludovic Dussart \ud83c\uddeb\ud83c\uddf7 \n![Ludovic Dussart](https://www.github.com/M3lkior.png)\n Solutions Architect / DevRel Ludovic is a Solutions Architect, working with his customers to build EDA-oriented digital products wherever possible. His first contributions to AsyncAPI date back to 2020 around the kafka and avro specifications. Since then, Ludovic has been spreading the word about AsyncAPI to companies in Northern France, to accelerate adoption of the initiative. Twitter \u2197 Github \u2197 Linkedin \u2197 Manuel Ottlik \ud83c\udde9\ud83c\uddea \n![Manuel Ottlik](https://www.github.com/manuelottlik.png)\n Product Owner Integration Platform & PBAC Platform Manuel is the Product Owner of the Global Integration Platform at HDI Global SE. He sold his first software at the age of thirteen and has been developing software ever since. After graduating, he joined the financial industry in API management and eventually moved to HDI Global SE to merge a service bus, API management and an event broker into an integration platform for the cloud division. In addition to his work at HDI Global SE, he is co-founder of a small company in the education software sector and freelance writer for heise.de and its magazines. Twitter \u2197 Github \u2197 Linkedin \u2197 Quetzalli Writes \ud83c\uddf2\ud83c\uddfd \n![Quetzalli Writes](https://www.github.com/quetzalliwrites.png)\n DevRel & DevDocs @AsyncAPI Quetzalli Writes is an author of the book titled 'Docs-as-Ecosystem', which was published by the Apress Publishing Company. Quetzalli has been in tech for 9 years, working with SEO, Paid Search, Full-Stack development, UX, Developer Relations, and Technical Writing (Engineering Documentation). She's currently a core OSS contributor for Docs, DevRel, and Community Building at AsyncAPI Initiative. She's also a member of the AsyncAPI Technical Steering Committee (TSC). Twitter \u2197 Github \u2197 Linkedin \u2197 Tokens of our appreciation We appreciate your commitment and passion for sharing your knowledge with your communities. Let us support you! \ud83d\uddfa\ufe0f Travel Ambassadors are provided free entry to AsyncAPI conferences. \ud83c\udf1f Recognition Ambassadors receive community-wide recognition. \ud83c\udf81 Special Swags Community members recognize you by gifting you exclusive AsyncAPI Ambassador swag. \ud83e\uddf0 Workshop Swags Ambassadors are gifted swag from AsyncAPI conferences and workshops. Become an AsyncAPI Ambassador The AsyncAPI Ambassador program is now open for applications! If you're selected, you'll join AsyncAPI's mission of helping community members all over the world, build the future of Event-Driven APIs. Become an Ambassador now Learn more Subscribe to our newsletter to receive news about AsyncAPI. We respect your inbox. No spam, promise \u270c\ufe0f",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/homepage/ambassador-cover.svg",
        "alt": "ambassador-cover"
      },
      {
        "src": "/img/illustrations/blog.svg",
        "alt": "Written content"
      },
      {
        "src": "/img/illustrations/video-creation.svg",
        "alt": "Video content"
      },
      {
        "src": "/img/illustrations/live.svg",
        "alt": "Live streams"
      },
      {
        "src": "/img/illustrations/speaking.svg",
        "alt": "Give talks"
      },
      {
        "src": "/img/illustrations/learning-app.svg",
        "alt": "Interactive Learning"
      },
      {
        "src": "/img/illustrations/codes.svg",
        "alt": "Build real-life usecases example"
      },
      {
        "src": "/img/illustrations/advisor.svg",
        "alt": "AsyncAPI Contributions"
      },
      {
        "src": "/img/illustrations/meeting.jpg",
        "alt": "Gather Use-Cases"
      },
      {
        "src": "https://www.github.com/danielkocot.png",
        "alt": "Daniel Kocot"
      },
      {
        "src": "https://www.github.com/gvensan.png",
        "alt": "Giri Venkatesan"
      },
      {
        "src": "https://www.github.com/harikrishnan83.png",
        "alt": "Hari Krishnan"
      },
      {
        "src": "https://www.github.com/hguerrero.png",
        "alt": "Hugo Guerrero"
      },
      {
        "src": "https://www.github.com/ivangsa.png",
        "alt": "Ivan Garcia Sainz-Aja"
      },
      {
        "src": "https://www.github.com/lbroudoux.png",
        "alt": "Laurent Broudoux"
      },
      {
        "src": "https://www.github.com/lornajane.png",
        "alt": "Lorna Mitchell"
      },
      {
        "src": "https://www.github.com/M3lkior.png",
        "alt": "Ludovic Dussart"
      },
      {
        "src": "https://www.github.com/manuelottlik.png",
        "alt": "Manuel Ottlik"
      },
      {
        "src": "https://www.github.com/quetzalliwrites.png",
        "alt": "Quetzalli Writes"
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "e66223ec",
    "title": "AsyncAPI - Dashboard | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/community/dashboard.html",
    "content": "AsyncAPI - Dashboard | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets AsyncAPI - Dashboard Dashboard Visualize our progress. Get involved. Contribution Guide View on Github Join on Slack Tooltip content Hot Topics asyncapi/community chore: introduce governance board asyncapi/bindings feat: initial ROS2 AsyncAPI contribution by SIEMENS AG asyncapi/website Add new page for collecting user testing participants enhancement Epic keep-open area/design area/javascript asyncapi/community [DESIGN] Holopin Design Tracking good first issue \ud83c\udfa8 design area/design asyncapi/website Redesign the AsyncAPI Website and Implement Dark Theme gsoc asyncapi/html-template remove puppeteer from dependencies enhancement asyncapi/website feat: enabled viewing historical finance data asyncapi/community Meeting Banners Storage asyncapi/community docs: added asyncapi student ambassador md file asyncapi/studio Please support File References enhancement keep-open asyncapi/community docs: expand community docs - Following Conventional Commits asyncapi/.github Automate `paper work` around project governance enhancement stale gsoc Good First Issues asyncapi/cli [Improvement]: Improve the error message while generating project fromgenerate command asyncapi/cli [Improvement]: Make the steps of Asyncapi start studio command interactive asyncapi/cli [BUG] AsyncAPI/generator needs to upgrade bug gsoc asyncapi/community [\ud83d\udcd1 Docs]: update Community Readme.md \ud83d\udcd1 docs asyncapi/website [Docs Bug \ud83d\udc1e report]: Few outdated info on /tools/generator and /tools/cli \ud83d\udc1e docs bug asyncapi/website fix: Update code to support @octokit/request v9 and @octokit/graphql v8 asyncapi/website [FEATURE] <Social Sharing Buttons on Blogs> enhancement asyncapi/parser-js [BUG] Missing server.summary() function bug asyncapi/parser-js [BUG] Missing server.title() function bug asyncapi/community [BUG] Slack groups are not updated bug asyncapi/website [BUG] : Comminutiy newsroom latest news section is not ui friendly. bug asyncapi/cli [BUG] Inaccurate error in `asyncapi optimize` bug asyncapi/conference-website Return to top arrow feature/button enhancement asyncapi/website Create Custom LogService Using Winston for Error Logging asyncapi/asyncapi-react A fragment with only one child is redundant. Hacktoberfest asyncapi/asyncapi-react Remove this redundant \"undefined\" Hacktoberfest asyncapi/community [DESIGN] Holopin Design Tracking \ud83c\udfa8 design asyncapi/modelina [BUG] Implement avro schema data type avro asyncapi/generator Improve arborist (npm installation) to have no hacks enhancement asyncapi/parser-js Parser do not validate and throw error when `parameters` are provided but address is null bug keep-open asyncapi/cli Parallel execution command asyncapi generate got error bug bounty level/advanced asyncapi/java-spring-template Support decimal min and max bug asyncapi/website Create a research page to have participants sign up for the research study enhancement \ud83c\udfa8 design asyncapi/glee Glee crashes when body is not proper json in http request bug",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "82b21f2d",
    "title": "AsyncAPI events | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/community/events.html",
    "content": "AsyncAPI events | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets Join an AsyncAPI event from anywhere in the world. Add to Google Calendar Download ICS File All events/meetings are live streamed to all AsyncAPI social media accounts. To learn more about meetings setup and automation read our FAQ . Watch the AsyncAPI 2023 conference recordings from anywhere around the world for free Watch now All Events All Upcoming Recorded \n![Design WG Meeting ](https://github.com/asyncapi/community/assets/40604284/01c2b8de-fa5c-44dd-81a5-70cb96df4813)\n Design WG Meeting April 3, 2025 \n![AsyncAPI Community Working Group Meeting](https://github.com/user-attachments/assets/e0c22c5a-94a8-488c-970c-14aa1697283c)\n AsyncAPI Community Working Group Meeting April 8, 2025 \n![Preventing API Drift: Ensuring Your APIs Stay True to Their Spec](https://github.com/user-attachments/assets/d80ddc94-7f0e-445c-8e8a-7c5e4ce764bd)\n Preventing API Drift: Ensuring Your APIs Stay True to Their Spec April 10, 2025 \n![Marketing WG Meeting](https://github.com/asyncapi/community/assets/40604284/01c2b8de-fa5c-44dd-81a5-70cb96df4813)\n Marketing WG Meeting April 29, 2025 \n![Marketing WG Meeting](https://github.com/asyncapi/community/assets/40604284/01c2b8de-fa5c-44dd-81a5-70cb96df4813)\n Marketing WG Meeting View Recording \n![AsyncAPI Community Working Group Meeting](https://github.com/user-attachments/assets/e0c22c5a-94a8-488c-970c-14aa1697283c)\n AsyncAPI Community Working Group Meeting View Recording \n![Design WG Meeting ](https://github.com/asyncapi/community/assets/40604284/01c2b8de-fa5c-44dd-81a5-70cb96df4813)\n Design WG Meeting View Recording \n![Marketing WG Meeting](https://github.com/asyncapi/community/assets/40604284/01c2b8de-fa5c-44dd-81a5-70cb96df4813)\n Marketing WG Meeting View Recording \n![Let's talk about contributing Google Summer Of Code 2025 Experience](https://github.com/user-attachments/assets/f91f9fb9-1a9a-421b-9e3d-fc7df80b265b)\n Let's talk about contributing Google Summer Of Code 2025 Experience View Recording \n![AsyncAPI Community Working Group Meeting](https://github.com/user-attachments/assets/e0c22c5a-94a8-488c-970c-14aa1697283c)\n AsyncAPI Community Working Group Meeting View Recording \n![AsyncAPI Community Working Group Meeting](https://github.com/user-attachments/assets/e0c22c5a-94a8-488c-970c-14aa1697283c)\n AsyncAPI Community Working Group Meeting View Recording \n![Design Meeting](https://github.com/asyncapi/community/assets/40604284/01c2b8de-fa5c-44dd-81a5-70cb96df4813)\n Design Meeting View Recording \n![Marketing WG Meeting](https://github.com/asyncapi/community/assets/40604284/01c2b8de-fa5c-44dd-81a5-70cb96df4813)\n Marketing WG Meeting View Recording \n![AsyncAPI Community Working Group Meeting](https://github.com/user-attachments/assets/e0c22c5a-94a8-488c-970c-14aa1697283c)\n AsyncAPI Community Working Group Meeting View Recording \n![Marketing WG Meeting](https://github.com/asyncapi/community/assets/40604284/01c2b8de-fa5c-44dd-81a5-70cb96df4813)\n Marketing WG Meeting View Recording Event Types Explore numerous AsyncAPI's livestreams, specifically curated Subscribe to our newsletter to receive news about AsyncAPI. We respect your inbox. No spam, promise \u270c\ufe0f",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "https://github.com/asyncapi/community/assets/40604284/01c2b8de-fa5c-44dd-81a5-70cb96df4813",
        "alt": "Design WG Meeting "
      },
      {
        "src": "https://github.com/user-attachments/assets/e0c22c5a-94a8-488c-970c-14aa1697283c",
        "alt": "AsyncAPI Community Working Group Meeting"
      },
      {
        "src": "https://github.com/user-attachments/assets/d80ddc94-7f0e-445c-8e8a-7c5e4ce764bd",
        "alt": "Preventing API Drift: Ensuring Your APIs Stay True to Their Spec"
      },
      {
        "src": "https://github.com/asyncapi/community/assets/40604284/01c2b8de-fa5c-44dd-81a5-70cb96df4813",
        "alt": "Marketing WG Meeting"
      },
      {
        "src": "https://github.com/asyncapi/community/assets/40604284/01c2b8de-fa5c-44dd-81a5-70cb96df4813",
        "alt": "Marketing WG Meeting"
      },
      {
        "src": "https://github.com/user-attachments/assets/e0c22c5a-94a8-488c-970c-14aa1697283c",
        "alt": "AsyncAPI Community Working Group Meeting"
      },
      {
        "src": "https://github.com/asyncapi/community/assets/40604284/01c2b8de-fa5c-44dd-81a5-70cb96df4813",
        "alt": "Design WG Meeting "
      },
      {
        "src": "https://github.com/asyncapi/community/assets/40604284/01c2b8de-fa5c-44dd-81a5-70cb96df4813",
        "alt": "Marketing WG Meeting"
      },
      {
        "src": "https://github.com/user-attachments/assets/f91f9fb9-1a9a-421b-9e3d-fc7df80b265b",
        "alt": "Let's talk about contributing Google Summer Of Code 2025 Experience"
      },
      {
        "src": "https://github.com/user-attachments/assets/e0c22c5a-94a8-488c-970c-14aa1697283c",
        "alt": "AsyncAPI Community Working Group Meeting"
      },
      {
        "src": "https://github.com/user-attachments/assets/e0c22c5a-94a8-488c-970c-14aa1697283c",
        "alt": "AsyncAPI Community Working Group Meeting"
      },
      {
        "src": "https://github.com/asyncapi/community/assets/40604284/01c2b8de-fa5c-44dd-81a5-70cb96df4813",
        "alt": "Design Meeting"
      },
      {
        "src": "https://github.com/asyncapi/community/assets/40604284/01c2b8de-fa5c-44dd-81a5-70cb96df4813",
        "alt": "Marketing WG Meeting"
      },
      {
        "src": "https://github.com/user-attachments/assets/e0c22c5a-94a8-488c-970c-14aa1697283c",
        "alt": "AsyncAPI Community Working Group Meeting"
      },
      {
        "src": "https://github.com/asyncapi/community/assets/40604284/01c2b8de-fa5c-44dd-81a5-70cb96df4813",
        "alt": "Marketing WG Meeting"
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "3ef69821",
    "title": "AsyncAPI events | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/community/meetings.html",
    "content": "AsyncAPI events | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets Join an AsyncAPI event from anywhere in the world. Add to Google Calendar Download ICS File All events/meetings are live streamed to all AsyncAPI social media accounts. To learn more about meetings setup and automation read our FAQ . Watch the AsyncAPI 2023 conference recordings from anywhere around the world for free Watch now All Events All Upcoming Recorded \n![Design WG Meeting ](https://github.com/asyncapi/community/assets/40604284/01c2b8de-fa5c-44dd-81a5-70cb96df4813)\n Design WG Meeting April 3, 2025 \n![AsyncAPI Community Working Group Meeting](https://github.com/user-attachments/assets/e0c22c5a-94a8-488c-970c-14aa1697283c)\n AsyncAPI Community Working Group Meeting April 8, 2025 \n![Preventing API Drift: Ensuring Your APIs Stay True to Their Spec](https://github.com/user-attachments/assets/d80ddc94-7f0e-445c-8e8a-7c5e4ce764bd)\n Preventing API Drift: Ensuring Your APIs Stay True to Their Spec April 10, 2025 \n![Marketing WG Meeting](https://github.com/asyncapi/community/assets/40604284/01c2b8de-fa5c-44dd-81a5-70cb96df4813)\n Marketing WG Meeting April 29, 2025 \n![Marketing WG Meeting](https://github.com/asyncapi/community/assets/40604284/01c2b8de-fa5c-44dd-81a5-70cb96df4813)\n Marketing WG Meeting View Recording \n![AsyncAPI Community Working Group Meeting](https://github.com/user-attachments/assets/e0c22c5a-94a8-488c-970c-14aa1697283c)\n AsyncAPI Community Working Group Meeting View Recording \n![Design WG Meeting ](https://github.com/asyncapi/community/assets/40604284/01c2b8de-fa5c-44dd-81a5-70cb96df4813)\n Design WG Meeting View Recording \n![Marketing WG Meeting](https://github.com/asyncapi/community/assets/40604284/01c2b8de-fa5c-44dd-81a5-70cb96df4813)\n Marketing WG Meeting View Recording \n![Let's talk about contributing Google Summer Of Code 2025 Experience](https://github.com/user-attachments/assets/f91f9fb9-1a9a-421b-9e3d-fc7df80b265b)\n Let's talk about contributing Google Summer Of Code 2025 Experience View Recording \n![AsyncAPI Community Working Group Meeting](https://github.com/user-attachments/assets/e0c22c5a-94a8-488c-970c-14aa1697283c)\n AsyncAPI Community Working Group Meeting View Recording \n![AsyncAPI Community Working Group Meeting](https://github.com/user-attachments/assets/e0c22c5a-94a8-488c-970c-14aa1697283c)\n AsyncAPI Community Working Group Meeting View Recording \n![Design Meeting](https://github.com/asyncapi/community/assets/40604284/01c2b8de-fa5c-44dd-81a5-70cb96df4813)\n Design Meeting View Recording \n![Marketing WG Meeting](https://github.com/asyncapi/community/assets/40604284/01c2b8de-fa5c-44dd-81a5-70cb96df4813)\n Marketing WG Meeting View Recording \n![AsyncAPI Community Working Group Meeting](https://github.com/user-attachments/assets/e0c22c5a-94a8-488c-970c-14aa1697283c)\n AsyncAPI Community Working Group Meeting View Recording \n![Marketing WG Meeting](https://github.com/asyncapi/community/assets/40604284/01c2b8de-fa5c-44dd-81a5-70cb96df4813)\n Marketing WG Meeting View Recording Event Types Explore numerous AsyncAPI's livestreams, specifically curated Subscribe to our newsletter to receive news about AsyncAPI. We respect your inbox. No spam, promise \u270c\ufe0f",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "https://github.com/asyncapi/community/assets/40604284/01c2b8de-fa5c-44dd-81a5-70cb96df4813",
        "alt": "Design WG Meeting "
      },
      {
        "src": "https://github.com/user-attachments/assets/e0c22c5a-94a8-488c-970c-14aa1697283c",
        "alt": "AsyncAPI Community Working Group Meeting"
      },
      {
        "src": "https://github.com/user-attachments/assets/d80ddc94-7f0e-445c-8e8a-7c5e4ce764bd",
        "alt": "Preventing API Drift: Ensuring Your APIs Stay True to Their Spec"
      },
      {
        "src": "https://github.com/asyncapi/community/assets/40604284/01c2b8de-fa5c-44dd-81a5-70cb96df4813",
        "alt": "Marketing WG Meeting"
      },
      {
        "src": "https://github.com/asyncapi/community/assets/40604284/01c2b8de-fa5c-44dd-81a5-70cb96df4813",
        "alt": "Marketing WG Meeting"
      },
      {
        "src": "https://github.com/user-attachments/assets/e0c22c5a-94a8-488c-970c-14aa1697283c",
        "alt": "AsyncAPI Community Working Group Meeting"
      },
      {
        "src": "https://github.com/asyncapi/community/assets/40604284/01c2b8de-fa5c-44dd-81a5-70cb96df4813",
        "alt": "Design WG Meeting "
      },
      {
        "src": "https://github.com/asyncapi/community/assets/40604284/01c2b8de-fa5c-44dd-81a5-70cb96df4813",
        "alt": "Marketing WG Meeting"
      },
      {
        "src": "https://github.com/user-attachments/assets/f91f9fb9-1a9a-421b-9e3d-fc7df80b265b",
        "alt": "Let's talk about contributing Google Summer Of Code 2025 Experience"
      },
      {
        "src": "https://github.com/user-attachments/assets/e0c22c5a-94a8-488c-970c-14aa1697283c",
        "alt": "AsyncAPI Community Working Group Meeting"
      },
      {
        "src": "https://github.com/user-attachments/assets/e0c22c5a-94a8-488c-970c-14aa1697283c",
        "alt": "AsyncAPI Community Working Group Meeting"
      },
      {
        "src": "https://github.com/asyncapi/community/assets/40604284/01c2b8de-fa5c-44dd-81a5-70cb96df4813",
        "alt": "Design Meeting"
      },
      {
        "src": "https://github.com/asyncapi/community/assets/40604284/01c2b8de-fa5c-44dd-81a5-70cb96df4813",
        "alt": "Marketing WG Meeting"
      },
      {
        "src": "https://github.com/user-attachments/assets/e0c22c5a-94a8-488c-970c-14aa1697283c",
        "alt": "AsyncAPI Community Working Group Meeting"
      },
      {
        "src": "https://github.com/asyncapi/community/assets/40604284/01c2b8de-fa5c-44dd-81a5-70cb96df4813",
        "alt": "Marketing WG Meeting"
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "e1d79c59",
    "title": "AsyncAPI Newsroom | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/community/newsroom.html",
    "content": "AsyncAPI Newsroom | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets Latest Updates Get a glimpse of latest news, events, and blog posts. Want to publish a blog post? We love community stories. Submit yours! From the blog Check out these articles written by community members Read all blog posts \n![](/img/posts/2025-blog-banner/banner-february.webp)\n Communication Monthly Community Update: February 2025 AsyncAPI community status and project updates for February 2025 March 3, 2025 \u00b7 3 min read \n![](/img/posts/release-notes-3.0.0/cover.webp)\n Communication AsyncAPI 3.0.0 Release Notes The release of AsyncAPI v3 is packed with changes such as request/reply, reusable channels, and more! December 5, 2023 \u00b7 10 min read \n![](/img/posts/mascot-banner.webp)\n Community AsyncAPI Mascot Redesign - The Biography of Eve and Chan The story behind Eve and Chan\u2014how they started, why they changed, and where they\u2019re headed next. March 24, 2025 \u00b7 4 min read \n![](/img/posts/marketing-images/ashmit-story.webp)\n Communication From Mentee to Maintainer: The Ashmit GSoC Story! Being patient is important as a maintainer because sometimes the contributors don't have it, so you have to keep yours. Says Ashmit. A third-year Bachelor of Technology student in Computer Science from India. March 17, 2025 \u00b7 8 min read \n![](/img/posts/2024-conference/banner-2024.webp)\n Communication AsyncAPI Conference 2024 Report AsyncAPI Conference Summary for 2024 January 28, 2025 \u00b7 5 min read Latest News Read about what people are saying about AsyncAPI Follow us on Twitter March 15, 2022 Made by Technology June 16, 2021 AsyncAPI and Its Horizontal Working System October 26, 2021 AsyncAPI: Transparency as a Value January 5, 2022 Multiculturalism in technology and its limits: AsyncAPI and the long road to open source utopia April 29, 2021 AsyncAPI 2.0: Enabling the Event-Driven World May 19, 2021 eBay Adopts AsyncAPI for Asynchronous API Contracts Video & Live Streams Watch our latest videos and live streams on the AsyncAPI YouTube channel Visit our YouTube channel \n![video](https://i.ytimg.com/vi/GVL846mrWUA/hqdefault.jpg)\n AsyncAPI Community Working Group Meeting, March 25th 2025 AsyncAPI Community Working Group Meeting Agenda: Welcome and agenda alignment (3:00 PM - 3:05 PM) \u27a2 Facilitator: Thulie ... Watch on Youtube \n![video](https://i.ytimg.com/vi/KYSsSRkUPqM/hqdefault.jpg)\n AsyncAPI Community Working Group Meeting, March 25th 2025 AsyncAPI Community Working Group Meeting Agenda: Welcome and agenda alignment (3:00 PM - 3:05 PM) \u27a2 Facilitator: Thulie ... Watch on Youtube \n![video](https://i.ytimg.com/vi/vO6Gy6_0O6A/hqdefault.jpg)\n AsyncAPI Marketing Working Group Meeting, March 18th 2025 https://github.com/asyncapi/community/issues/1754. Watch on Youtube \n![video](https://i.ytimg.com/vi/R7pl1F2dYLo/hqdefault.jpg)\n Google Summer Of Code 2025 Experience Thinking about joining us for GSoC 2025 but not sure where to start? In this stream, I'll break down everything\u2014from finding the ... Watch on Youtube \n![video](https://i.ytimg.com/vi/awfB_mwUp1c/hqdefault.jpg)\n Event-Driven and OpenTelemetry with Eduardo Implementing distributed tracing between producers and consumers. Watch on Youtube",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/posts/2025-blog-banner/banner-february.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/release-notes-3.0.0/cover.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/mascot-banner.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/marketing-images/ashmit-story.webp",
        "alt": ""
      },
      {
        "src": "/img/posts/2024-conference/banner-2024.webp",
        "alt": ""
      },
      {
        "src": "https://i.ytimg.com/vi/GVL846mrWUA/hqdefault.jpg",
        "alt": "video"
      },
      {
        "src": "https://i.ytimg.com/vi/KYSsSRkUPqM/hqdefault.jpg",
        "alt": "video"
      },
      {
        "src": "https://i.ytimg.com/vi/vO6Gy6_0O6A/hqdefault.jpg",
        "alt": "video"
      },
      {
        "src": "https://i.ytimg.com/vi/R7pl1F2dYLo/hqdefault.jpg",
        "alt": "video"
      },
      {
        "src": "https://i.ytimg.com/vi/awfB_mwUp1c/hqdefault.jpg",
        "alt": "video"
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "aa295922",
    "title": "Technical Steering Committee | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/community/tsc.html",
    "content": "Technical Steering Committee | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets What is a TSC? The Technical Steering Committee (TSC) is responsible for the oversight of the AsyncAPI Initiative. Maintainers (aka committers) make decisions at the given repository/project level. The TSC helps to make decisions on a higher level, or when maintainers cannot find a consensus. How can I become a TSC member? Anybody can become a member of the TSC. All you have to do is become a maintainer of one of the AsyncAPI projects! To become a maintainer, you just need to regularly contribute to one of the projects and then other maintainers will invite you to join. You can also build a great AsyncAPI-based project that we don't have yet in our GitHub organization and donate it (we'll ask you to stay as a maintainer). Follow this Link to know more! Our governance model AsyncAPI Initiative runs under an Open Governance Model that gives power to the people actively involved and working on the project. No matter if you are an individual contributor or backed by a company, you have equal rights. Read this article to learn more. Get notified when TSC is voting You'll receive an email whenever someone requests the TSC to vote. Current TSC members (in alphabetical order) \n![Aayush Sahu](https://www.github.com/aayushmau5.png)\n Aayush Sahu Individual Member GitHub Twitter Linkedin Maintainer of: diff \n![Aayush Saini](https://www.github.com/AayushSaini101.png)\n Aayush Saini Available for hire GitHub Twitter Linkedin Maintainer of: cli \n![Abir Pal](https://www.github.com/imabp.png)\n Abir Pal Individual Member GitHub Twitter Linkedin Maintainer of: problem \n![Aishat Muibudeen](https://www.github.com/Mayaleeeee.png)\n Aishat Muibudeen Available for hire GitHub Twitter Linkedin Maintainer of: website conference-website brand \n![Akshat Nema](https://www.github.com/akshatnema.png)\n Akshat Nema Available for hire GitHub Twitter Linkedin Maintainer of: website \n![Alexander Wichmann](https://www.github.com/VisualBean.png)\n Alexander Wichmann The LEGO Group GitHub Linkedin Maintainer of: spec-json-schemas bindings saunter \n![Ansh Goyal](https://www.github.com/anshgoyalevil.png)\n Ansh Goyal Available for hire GitHub Twitter Linkedin Maintainer of: website \n![Ashish Padhy](https://www.github.com/Shurtu-gal.png)\n Ashish Padhy Available for hire GitHub Twitter Linkedin Maintainer of: studio cli \n![Ashmit Jagtap](https://www.github.com/ashmit-coder.png)\n Ashmit Jagtap Available for hire GitHub Twitter Linkedin Maintainer of: conference-website \n![Ashmit JaiSarita Gupta](https://www.github.com/devilkiller-ag.png)\n Ashmit JaiSarita Gupta Available for hire GitHub Twitter Linkedin Maintainer of: website modelina \n![Azeez Elegbede](https://www.github.com/AceTheCreator.png)\n Azeez Elegbede Individual Member GitHub Twitter Linkedin Maintainer of: asyncapi-react conference-website chatbot \n![Cameron Rushton](https://www.github.com/CameronRushton.png)\n Cameron Rushton Solace GitHub Maintainer of: spec-json-schemas bindings java-spring-cloud-stream-template python-paho-template \n![Charles d'Avernas](https://www.github.com/cdavernas.png)\n Charles d'Avernas Individual Member GitHub Linkedin Maintainer of: net-sdk \n![Dale Lane](https://www.github.com/dalelane.png)\n Dale Lane IBM GitHub Twitter Linkedin Maintainer of: spec spec-json-schemas bindings avro-schema-parser java-template \n![Daniel Raper](https://www.github.com/dan-r.png)\n Daniel Raper Individual Member GitHub Linkedin Maintainer of: java-template \n![David Pereira](https://www.github.com/BOLT04.png)\n David Pereira Create IT GitHub Twitter Linkedin Maintainer of: server-api \n![Florence Njeri](https://www.github.com/Florence-Njeri.png)\n Florence Njeri Available for hire GitHub Twitter Linkedin Maintainer of: generator \n![Fran M\u00e9ndez](https://www.github.com/fmvilas.png)\n Fran M\u00e9ndez Individual Member GitHub Linkedin Maintainer of: spec spec-json-schemas asyncapi-react extensions-catalog converter-js bindings enterprise-patterns raml-dt-schema-parser openapi-schema-parser html-template markdown-template nodejs-ws-template glee brand \n![HariKrishnan](https://www.github.com/harikrishnan83.png)\n HariKrishnan Individual Member GitHub Twitter Linkedin Maintainer of: jasyncapi \n![Heiko Henning](https://www.github.com/GreenRover.png)\n Heiko Henning mtrail GmbH GitHub Maintainer of: spec spec-json-schemas bindings protobuf-schema-parser \n![Ivan Garcia Sainz-Aja](https://www.github.com/ivangsa.png)\n Ivan Garcia Sainz-Aja SNGULAR GitHub Linkedin Maintainer of: vs-asyncapi-preview \n![Jean-Baptiste Bianchi](https://www.github.com/jbbianchi.png)\n Jean-Baptiste Bianchi Individual Member GitHub Twitter Linkedin Maintainer of: net-sdk \n![Jeremy Whitlock](https://www.github.com/whitlockjc.png)\n Jeremy Whitlock Google GitHub Twitter Linkedin Maintainer of: spec-json-schemas bindings \n![Jonas Lagoni](https://www.github.com/jonaslagoni.png)\n Jonas Lagoni EventStack GitHub Linkedin Maintainer of: spec-json-schemas generator parser-js converter-js generator-react-sdk modelina simulator parser-api EDAVisualiser \n![Kenneth Aasan](https://www.github.com/kennethaasan.png)\n Kenneth Aasan Sportradar GitHub Twitter Maintainer of: modelina \n![Khuda Dad Nomani](https://www.github.com/KhudaDad414.png)\n Khuda Dad Nomani Postman GitHub Twitter Linkedin Maintainer of: spec-json-schemas studio .github optimizer glee \n![Lukasz Gornicki](https://www.github.com/derberg.png)\n Lukasz Gornicki Available for hire GitHub Twitter Linkedin Maintainer of: spec website spec-json-schemas generator extensions-catalog bindings enterprise-patterns html-template markdown-template nodejs-template nodejs-ws-template java-spring-template .github vs-asyncapi-preview template-for-generator-templates community diff chatbot \n![Maciej Urba\u0144czyk](https://www.github.com/magicmatatjahu.png)\n Maciej Urba\u0144czyk Travelping GmbH GitHub Linkedin Maintainer of: generator asyncapi-react parser-go parser-js converter-js converter-go studio html-template markdown-template template-for-generator-templates generator-react-sdk modelina template-for-go-projects diff chatbot server-api EDAVisualiser problem \n![Pavel Bodiachevskii](https://www.github.com/Pakisan.png)\n Pavel Bodiachevskii Individual Member GitHub Twitter Maintainer of: spec-json-schemas tck jasyncapi jasyncapi-idea-plugin \n![Philip Schlesinger](https://www.github.com/theschles.png)\n Philip Schlesinger Individual Member GitHub Twitter Maintainer of: jasyncapi-idea-plugin \n![Prince Rajpoot](https://www.github.com/princerajpoot20.png)\n Prince Rajpoot Available for hire GitHub Twitter Linkedin Maintainer of: studio \n![Quetzalli Writes](https://www.github.com/quetzalliwrites.png)\n Quetzalli Writes Available for hire GitHub Twitter Linkedin Maintainer of: website community \n![Richard Coppen](https://www.github.com/rcoppen.png)\n Richard Coppen IBM GitHub Linkedin Maintainer of: spec-json-schemas bindings \n![Rohit T](https://www.github.com/TRohit20.png)\n Rohit T Available for hire GitHub Twitter Linkedin Maintainer of: website \n![Sambhav Gupta](https://www.github.com/sambhavgupta0705.png)\n Sambhav Gupta Available for hire GitHub Twitter Linkedin Maintainer of: website \n![Samir AMZANI](https://www.github.com/Amzani.png)\n Samir AMZANI Apideck GitHub Twitter Linkedin Maintainer of: studio cli \n![Samridhi Agrawal](https://www.github.com/Samridhi-98.png)\n Samridhi Agrawal ThoughtWorks GitHub Linkedin Maintainer of: modelina \n![Semen Tenishchev](https://www.github.com/Tenischev.png)\n Semen Tenishchev Available for hire GitHub Linkedin Maintainer of: java-spring-template \n![Sergio Moya](https://www.github.com/smoya.png)\n Sergio Moya Timescale GitHub Twitter Linkedin Maintainer of: spec spec-json-schemas parser-go parser-js converter-go bindings raml-dt-schema-parser openapi-schema-parser avro-schema-parser go-watermill-template template-for-go-projects parser-api server-api \n![Souvik De](https://www.github.com/Souvikns.png)\n Souvik De Codemate GitHub Twitter Linkedin Maintainer of: cli glee bundler \n![Thulisile Sibanda](https://www.github.com/thulieblack.png)\n Thulisile Sibanda AsyncAPI Initiative GitHub Twitter Linkedin Maintainer of: website conference-website community \n![Vishvamsinh Vaghela](https://www.github.com/vishvamsinh28.png)\n Vishvamsinh Vaghela Available for hire GitHub Twitter Linkedin Maintainer of: website Want to become a member? Follow this Link to know more!",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "https://www.github.com/aayushmau5.png",
        "alt": "Aayush Sahu"
      },
      {
        "src": "https://www.github.com/AayushSaini101.png",
        "alt": "Aayush Saini"
      },
      {
        "src": "https://www.github.com/imabp.png",
        "alt": "Abir Pal"
      },
      {
        "src": "https://www.github.com/Mayaleeeee.png",
        "alt": "Aishat Muibudeen"
      },
      {
        "src": "https://www.github.com/akshatnema.png",
        "alt": "Akshat Nema"
      },
      {
        "src": "https://www.github.com/VisualBean.png",
        "alt": "Alexander Wichmann"
      },
      {
        "src": "https://www.github.com/anshgoyalevil.png",
        "alt": "Ansh Goyal"
      },
      {
        "src": "https://www.github.com/Shurtu-gal.png",
        "alt": "Ashish Padhy"
      },
      {
        "src": "https://www.github.com/ashmit-coder.png",
        "alt": "Ashmit Jagtap"
      },
      {
        "src": "https://www.github.com/devilkiller-ag.png",
        "alt": "Ashmit JaiSarita Gupta"
      },
      {
        "src": "https://www.github.com/AceTheCreator.png",
        "alt": "Azeez Elegbede"
      },
      {
        "src": "https://www.github.com/CameronRushton.png",
        "alt": "Cameron Rushton"
      },
      {
        "src": "https://www.github.com/cdavernas.png",
        "alt": "Charles d'Avernas"
      },
      {
        "src": "https://www.github.com/dalelane.png",
        "alt": "Dale Lane"
      },
      {
        "src": "https://www.github.com/dan-r.png",
        "alt": "Daniel Raper"
      },
      {
        "src": "https://www.github.com/BOLT04.png",
        "alt": "David Pereira"
      },
      {
        "src": "https://www.github.com/Florence-Njeri.png",
        "alt": "Florence Njeri"
      },
      {
        "src": "https://www.github.com/fmvilas.png",
        "alt": "Fran M\u00e9ndez"
      },
      {
        "src": "https://www.github.com/harikrishnan83.png",
        "alt": "HariKrishnan"
      },
      {
        "src": "https://www.github.com/GreenRover.png",
        "alt": "Heiko Henning"
      },
      {
        "src": "https://www.github.com/ivangsa.png",
        "alt": "Ivan Garcia Sainz-Aja"
      },
      {
        "src": "https://www.github.com/jbbianchi.png",
        "alt": "Jean-Baptiste Bianchi"
      },
      {
        "src": "https://www.github.com/whitlockjc.png",
        "alt": "Jeremy Whitlock"
      },
      {
        "src": "https://www.github.com/jonaslagoni.png",
        "alt": "Jonas Lagoni"
      },
      {
        "src": "https://www.github.com/kennethaasan.png",
        "alt": "Kenneth Aasan"
      },
      {
        "src": "https://www.github.com/KhudaDad414.png",
        "alt": "Khuda Dad Nomani"
      },
      {
        "src": "https://www.github.com/derberg.png",
        "alt": "Lukasz Gornicki"
      },
      {
        "src": "https://www.github.com/magicmatatjahu.png",
        "alt": "Maciej Urba\u0144czyk"
      },
      {
        "src": "https://www.github.com/Pakisan.png",
        "alt": "Pavel Bodiachevskii"
      },
      {
        "src": "https://www.github.com/theschles.png",
        "alt": "Philip Schlesinger"
      },
      {
        "src": "https://www.github.com/princerajpoot20.png",
        "alt": "Prince Rajpoot"
      },
      {
        "src": "https://www.github.com/quetzalliwrites.png",
        "alt": "Quetzalli Writes"
      },
      {
        "src": "https://www.github.com/rcoppen.png",
        "alt": "Richard Coppen"
      },
      {
        "src": "https://www.github.com/TRohit20.png",
        "alt": "Rohit T"
      },
      {
        "src": "https://www.github.com/sambhavgupta0705.png",
        "alt": "Sambhav Gupta"
      },
      {
        "src": "https://www.github.com/Amzani.png",
        "alt": "Samir AMZANI"
      },
      {
        "src": "https://www.github.com/Samridhi-98.png",
        "alt": "Samridhi Agrawal"
      },
      {
        "src": "https://www.github.com/Tenischev.png",
        "alt": "Semen Tenishchev"
      },
      {
        "src": "https://www.github.com/smoya.png",
        "alt": "Sergio Moya"
      },
      {
        "src": "https://www.github.com/Souvikns.png",
        "alt": "Souvik De"
      },
      {
        "src": "https://www.github.com/thulieblack.png",
        "alt": "Thulisile Sibanda"
      },
      {
        "src": "https://www.github.com/vishvamsinh28.png",
        "alt": "Vishvamsinh Vaghela"
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "e791d307",
    "title": "AsyncAPI Ambassador Program | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/community/ambassadors/danielkocot.html",
    "content": "AsyncAPI Ambassador Program | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets Daniel Kocot \ud83c\udde9\ud83c\uddea Daniel has been part of the codecentric team since October 2016. Since the beginning of 2022 he works as Senior Solution Architect at the Dortmund branch. Starting as a consultant with a focus on application lifecycle management, his focus shifted more and more towards APIs. In addition to numerous customer projects and his involvement in the open source world around APIs, our Head of API Experience & Operations is also a frequent speaker at conferences. Contributions AsyncAPI - Documentation of event and message-driven architectures article September - 2021 AsyncAPI specification updates article February - 2022 AsyncAPI 101 presentation May - 2022 Adopting AsyncAPI in Enterprisey Contexts, AsyncAPI Conference presentation November - 2022",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "7c881295",
    "title": "AsyncAPI Ambassador Program | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/community/ambassadors/gvensan.html",
    "content": "AsyncAPI Ambassador Program | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets Giri Venkatesan \ud83c\uddee\ud83c\uddf3 Giri Venkatesan, a follower and proponent of AsyncAPI and teams up with companies & SIs to design event-driven architecture and asynchronous APIs. To guide those discussions, I draw upon years of integration and implementation experience, particularly with Solace platforms. I've been a follower of AsyncAPI since 2022, and written blogs and delivered talks at conferences and AsyncAPI confrence tours. Contributions Bridging Design and Runtime Gaps: AsyncAPI in Event-Driven Architecture article February - 2024 Bridging the Gap between Design and Runtime in EDA with AsyncAPI and CI/CD talk November - 2023 Bridging the Gap between Design and Runtime in EDA with AsyncAPI talk August - 2023 AsyncAPI + Spring Cloud Stream = Event-Driven Microservices Made Easy article November - 2021",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "c37f913c",
    "title": "AsyncAPI Ambassador Program | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/community/ambassadors/harikrishnan83.html",
    "content": "AsyncAPI Ambassador Program | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets Hari Krishnan \ud83c\uddee\ud83c\uddf3 Co-creator of Specmatic and Perfiz. I also advise organizations, both large and small, on their transformation journey. Apart from bringing ideas to life as working software products, I coach developers, project managers, product owners, and engineering leaders. I have spoken at several conferences, including AACoT 2023, API Specification Conference (#ASC2022), API World, SeleniumConf, Agile2021, Agile India, TestingUY 2021, SREConf, PyCon Singapore, RubyConf India. My areas of interest include distributed systems, concurrency, high-performance application architecture, coaching, and training. \n![Hari Krishnan](https://raw.githubusercontent.com/harikrishnan83/harikrishnan83/master/HariKrishnan-profile.jpg)\n Contributions Kafka and JMS Mocking with AsyncAPI talk November - 2023 Unshackling Your System Under Test: Shift-Left Testing Through Dependency Isolation (Kafka Mocks with AsyncAPI specification) talk June - 2024 Using API spec as an Executable Contract To Mock and Test Microservices talk October - 2024 Contract-Driven Development for Event-Driven Architectures talk December - 2024",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "https://raw.githubusercontent.com/harikrishnan83/harikrishnan83/master/HariKrishnan-profile.jpg",
        "alt": "Hari Krishnan"
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "9f9040c8",
    "title": "AsyncAPI Ambassador Program | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/community/ambassadors/hguerrero.html",
    "content": "AsyncAPI Ambassador Program | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets Hugo Guerrero Hugo Guerrero is a developer advocate for APIs and Event-driven Architecture. He assists organizations in this role by creating, editing, and curating product content shared with the community through webinars, conferences, and other activities. He works on open source software with major private and federal public sector clients looking to connect and extend their system architecture. He has over 20 years of experience as a developer, consultant, architect, and software development manager. Contributions Speed-Up Kafka Delivery with AsyncAPI & Microcks presentation July - 2021 Automated Apache Kafka Mocking and Testing with AsyncAPI presentation September - 2021 Event-driven APIs & Schema governance for Apache Kafka, Apidays LIVE Hong Kong presentation August - 2021 Event-driven APIs & Schema governance for Apache Kafka, API Specification Conference presentation August - 2021 Getting started with Event-Driven APIs, Apidays LIVE Paris presentation December - 2021",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "fcf0405c",
    "title": "AsyncAPI Ambassador Program | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/community/ambassadors/ivangsa.html",
    "content": "AsyncAPI Ambassador Program | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets Ivan Garcia Sainz-Aja Java Architect with a deep understanding of Java, Spring-Boot, Spring-Cloud technologies, specializing in Domain-Driven Design (DDD) and Event-Driven Architectures creating Software Easy to Understand. Building ZenWave 360\u00ba. ZenWave 360\u00ba is a set of tools built on the foundations of Domain Driven Design and API-First principles for Event-Driven Architectures, to help you create software easy to understand. https://www.zenwave360.io/ Contributions AsyncAPI Conference On Tour 2023 - Madrid iniciative_driver October - 2023 ZenWave SDK - Code Generator for AsyncAPI with Spring Cloud Streams iniciative_driver 2022 - 2024 API-First with AsyncAPI article March - 2023 ZenWave AsyncAPI Code Generator article March - 2023 Generating AsyncAPI definition files from JDL with ZenWaveSDK article April - 2023 KIT - API-First with AsyncAPI for Event Driven Architectures presentation May - 2023 Practical Event Storming with AsyncAPI v3 and ZenWave SDK presentation October - 2023 Code Generation For Enterprise Integration Patterns w/ AsyncAPI & ZenWave SDK presentation October - 2023",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "f6250719",
    "title": "AsyncAPI Ambassador Program | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/community/ambassadors/lbroudoux.html",
    "content": "AsyncAPI Ambassador Program | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets Laurent Broudoux \ud83c\uddeb\ud83c\uddf7 Laurent is a Cloud-Native Architecture expert and Enterprise Integration problem lover. He is the founder and lead developer of the Microcks.io open-source project: a cloud-native tool for API mocking and testing. For this, he is using his 10+ years experience as an architect in Financial Services where he defined API transformation strategies, including governance and delivery process. Contributions AsyncAPI unit testing - from nightmares to sweet dreams talk December - 2024 Using Testcontainers for AsyncAPI unit testing talk September - 2024 Quoi de neuf dans AsyncAPI v3 ? D\u00e9couvrez le en live avec la migration du use-case Adeo presentation December - 2023 Elevating Event-Driven Architecture: Boost your delivery with AsyncAPI and Microcks talk December - 2023 AsyncAPI Recipes for EDA Gourmet presentation November - 2022 AsyncAPI or CloudEvents? Both My Captain! presentation November - 2021",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "893a9366",
    "title": "AsyncAPI Ambassador Program | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/community/ambassadors/lornajane.html",
    "content": "AsyncAPI Ambassador Program | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets Lorna Mitchell UK Lorna is based in Yorkshire, UK; she is a technology leader and expert in developer experience, passionate about enhancing APIs and developer tools. In her day job as VP of Developer Experience at Redocly, she works on API and documentation tools for technical teams. Lorna is a published author and a regular speaker at conferences, sharing her insights on a variety of tech-related topics. Lorna serves on the OpenUK board, is on the Technical Steering Committee for OpenAPI specification, and maintains open source projects. To learn more about Lorna's activities, visit her website at https://lornajane.net. \n![Lorna Mitchell](https://lornajane.net/wp-content/uploads/2011/08/IMG_9410-smaller.jpg)\n Contributions API Governance for AsyncAPI presentation September - 2023 AsyncAPI for Apache Kafka presentation May - 2021 Lint AsyncAPI with Redocly CLI article August - 2023",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "https://lornajane.net/wp-content/uploads/2011/08/IMG_9410-smaller.jpg",
        "alt": "Lorna Mitchell"
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "2739e8f9",
    "title": "AsyncAPI Ambassador Program | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/community/ambassadors/M3lkior.html",
    "content": "AsyncAPI Ambassador Program | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets Ludovic Dussart \ud83c\uddeb\ud83c\uddf7 Ludovic is a Solutions Architect, working with his customers to build EDA-oriented digital products wherever possible. His first contributions to AsyncAPI date back to 2020 around the kafka and avro specifications. Since then, Ludovic has been spreading the word about AsyncAPI to companies in Northern France, to accelerate adoption of the initiative. Contributions From specification to production, how to provide a living doc of your asynchronous exchanges? presentation November - 2021 AsyncApi Conference 2021 - Panel discussion presentation November - 2021 Building the future of Event-Driven Architecture - Meetup Ineat presentation January - 2022 Building the future of Event-Driven Architecture at AXA presentation March - 2022 Building the future of Event-Driven Architecture at NoConsulting presentation March - 2022 Building the future of Event-Driven Architecture at Adeo presentation April - 2022 Building the future of Event-Driven Architecture at Decathlon presentation April - 2022 Building the future of Event-Driven Architecture at Sfeir Lille presentation January - 2023 AsyncAPI - Adeo case study article - 2023 Building the future of Event-Driven Architecture at Sfeir Paris presentation March - 2023 Standardisez votre monde d'\u00e9v\u00e9nements en documentant vos EDA avec AsyncAPI ! - Cloud Nord 2023 presentation October - 2023 Stay at API Days AsyncAPI Booth to share with attendees. special contribution December - 2023 Quoi de neuf dans AsyncAPI v3 ? D\u00e9couvrez le en live avec la migration du use-case Adeo presentation December - 2023",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "01c91195",
    "title": "AsyncAPI Ambassador Program | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/community/ambassadors/manuelottlik.html",
    "content": "AsyncAPI Ambassador Program | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets Manuel Ottlik \ud83c\udde9\ud83c\uddea Manuel is the Product Owner of the Global Integration Platform at HDI Global SE. He sold his first software at the age of thirteen and has been developing software ever since. After graduating, he joined the financial industry in API management and eventually moved to HDI Global SE to merge a service bus, API management and an event broker into an integration platform for the cloud division. In addition to his work at HDI Global SE, he is co-founder of a small company in the education software sector and freelance writer for heise.de and its magazines. Contributions Event-Driven Architecture und REST-APIs: Es gibt keine Konkurrenz! talk April - 2023 Event-driven Architecture and REST-APIs: It's not a competition talk May - 2023 Event-driven Architecture and REST-APIs: It's not a competition talk September - 2023 Event-Driven Architecture und REST-APIs: Es gibt keine Konkurrenz! talk October - 2023 Event-driven Architecture and REST-APIs: It's not a competition talk December - 2023 Eine Registry, sie alle zu knechten: Schemata von Entit\u00e4ten mit xRegistry f\u00fcr alle Integrationsprodukte zentralisieren talk April - 2024 AsyncAPI - HDI Global SE Case Study article July - 2024",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "1708f992",
    "title": "AsyncAPI Ambassador Program | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/community/ambassadors/quetzalliwrites.html",
    "content": "AsyncAPI Ambassador Program | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets Quetzalli Writes \ud83c\uddf2\ud83c\uddfd Quetzalli Writes is an author of the book titled 'Docs-as-Ecosystem', which was published by the Apress Publishing Company. Quetzalli has been in tech for 9 years, working with SEO, Paid Search, Full-Stack development, UX, Developer Relations, and Technical Writing (Engineering Documentation). She's currently a core OSS contributor for Docs, DevRel, and Community Building at AsyncAPI Initiative. She's also a member of the AsyncAPI Technical Steering Committee (TSC). Contributions How to contribute to AsyncAPI Dev Docs, AsyncAPI Conference presentation November - 2021 Workshop on contributing to AsyncAPI, CCOSS workshop October - 2021 Change is coming to our AsyncAPI Developer Documentation article December - 2021 Driver and promoter of Google Season of Docs at AsyncAPI iniciative_driver December - 2022",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "d9c9c7fe",
    "title": "Overview | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/community.html",
    "content": "Overview | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Community: Guidelines and resources around community. Contribute to the AsyncAPI Community section Overview Found an error? Have a suggestion? Edit this page on GitHub Community: Guidelines and resources around community. Welcome to AsyncAPI Community ! Our Community section documents the community guidelines and resources. Remember Contribute to the AsyncAPI Community section Code isn't the only way to contribute to OSS; Dev Docs are a huge help that benefit the entire OSS ecosystem. At AsyncAPI, we value Doc contributions as much as every other type of contribution. \u2764\ufe0f To get started as a Docs contributor: Familiarize yourself with our project's Contribution Guide and our Code of Conduct . Head over to our AsyncAPI Docs Board . Pick an issue you would like to contribute to and leave a comment introducing yourself. This is also the perfect place to leave any questions you may have on how to get started. If there is no work done in that Docs issue yet, feel free to open a PR and get started! Docs contributor questions Do you have a documentation contributor question and you're wondering how to tag me into a GitHub discussion or PR? Never fear! Tag me in your AsyncAPI Doc PRs or GitHub Discussions via my GitHub handle, quetzalliwrites \ud83d\udc19 . Go Back Migrations - Migrating to v3 Up Next Style guide - Introduction Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "7b8f8ce2",
    "title": "Overview | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/concepts.html",
    "content": "Overview | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Concepts Contribute to AsyncAPI Concepts Overview Found an error? Have a suggestion? Edit this page on GitHub Concepts Welcome to AsyncAPI Concepts ! This section defines AsyncAPI features and capabilities. Remember Contribute to AsyncAPI Concepts Code isn't the only way to contribute to OSS; Dev Docs are a huge help that benefit the entire OSS ecosystem. At AsyncAPI, we value Doc contributions as much as every other type of contribution. \u2764\ufe0f To get started as a Docs contributor: Familiarize yourself with our project's Contribution Guide and our Code of Conduct . Head over to our AsyncAPI Docs Board . Pick an issue you would like to contribute to and leave a comment introducing yourself. This is also the perfect place to leave any questions you may have on how to get started. If there is no work done in that Docs issue yet, feel free to open a PR and get started! Docs contributor questions Do you have a documentation contributor question and you're wondering how to tag me into a GitHub discussion or PR? Never fear! Tag me in your AsyncAPI Doc PRs or GitHub Discussions via my GitHub handle, quetzalliwrites \ud83d\udc19 . Go Back Welcome - Welcome Up Next Server Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "f92666f7",
    "title": "Introduction | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/getting-started.html",
    "content": "Introduction | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets Introduction Found an error? Have a suggestion? Edit this page on GitHub AsyncAPI is an open source initiative that seeks to improve the current state of Event-Driven Architectures (EDA). Our long-term goal is to make working with EDAs as easy as working with REST APIs. That goes from documentation to code generation, and from discovery to event management. Most of the processes you apply to your REST APIs nowadays would be applicable to your event-driven/asynchronous APIs too. To make this happen, the first step is to create a specification that allows developers, architects, and product managers to define the interfaces of an async API. Much like OpenAPI (aka Swagger) does for REST APIs. The AsyncAPI specification lays the foundation for a greater and better tooling ecosystem for EDAs . If you are looking for a solution to automate and formalize the documentation or code generation of your event-driven (micro)services, you are in the right place. Likewise, if you are aiming to establish solid standards for your events and improve the governance of your asynchronous APIs, welcome to your new home. Go Back Tutorials - Overview Up Next Event-Driven Architectures Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "8b3f2348",
    "title": "Overview | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/guides.html",
    "content": "Overview | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Guides: Teaches AsyncAPI's capabilities at a high level Contribute to AsyncAPI Guides Overview Found an error? Have a suggestion? Edit this page on GitHub Guides: Teaches AsyncAPI's capabilities at a high level Welcome to AsyncAPI Guides ! Our Guides section teaches AsyncAPI's capabilities and features at a high level. Remember Contribute to AsyncAPI Guides Code isn't the only way to contribute to OSS; Dev Docs are a huge help that benefit the entire OSS ecosystem. At AsyncAPI, we value Doc contributions as much as every other type of contribution. \u2764\ufe0f To get started as a Docs contributor: Familiarize yourself with our project's Contribution Guide and our Code of Conduct . Head over to our AsyncAPI Docs Board . Pick an issue you would like to contribute to and leave a comment introducing yourself. This is also the perfect place to leave any questions you may have on how to get started. If there is no work done in that Docs issue yet, feel free to open a PR and get started! Docs contributor questions Do you have a documentation contributor question and you're wondering how to tag me into a GitHub discussion or PR? Never fear! Tag me in your AsyncAPI Doc PRs or GitHub Discussions via my GitHub handle, quetzalliwrites \ud83d\udc19 . Go Back Tools - Crypto Websockets - Interactive (Alpha) Up Next Validate AsyncAPI documents Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "a0075e2c",
    "title": "Overview | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/migration.html",
    "content": "Overview | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets Overview Found an error? Have a suggestion? Edit this page on GitHub Migration to a new major version is always difficult, and AsyncAPI is no exception, but we want to provide as smooth a transition as possible. If you are just looking to update your AsyncAPI document, then we suggest you use the AsyncAPI converter . You can do this directly in the CLI with: \n```javascript\nasyncapi convert asyncapi.json --output=new_asyncapi.json --target-version=x.x.x\n```\n For a detailed read-through about all the changes (non-breaking as well), please do read the release notes for the desired version before hand, as it will give you some more context about the changes. Here are all the migration guides: Migrating to v3 Go Back Reference - Overview Up Next Migrating to v3 Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "asyncapi convert asyncapi.json --output=new_asyncapi.json --target-version=x.x.x"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "cab512b5",
    "title": "Overview | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/reference.html",
    "content": "Overview | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Reference: AsyncAPI Specification Contribute to the AsyncAPI Reference section Overview Found an error? Have a suggestion? Edit this page on GitHub Reference: AsyncAPI Specification Welcome to AsyncAPI Reference ! Our Reference section documents the AsyncAPI specification. Remember Contribute to the AsyncAPI Reference section Code isn't the only way to contribute to OSS; Dev Docs are a huge help that benefit the entire OSS ecosystem. At AsyncAPI, we value Doc contributions as much as every other type of contribution. \u2764\ufe0f To get started as a Docs contributor: Familiarize yourself with our project's Contribution Guide and our Code of Conduct . Head over to our AsyncAPI Docs Board . Pick an issue you would like to contribute to and leave a comment introducing yourself. This is also the perfect place to leave any questions you may have on how to get started. If there is no work done in that Docs issue yet, feel free to open a PR and get started! Docs contributor questions Do you have a documentation contributor question and you're wondering how to tag me into a GitHub discussion or PR? Never fear! Tag me in your AsyncAPI Doc PRs or GitHub Discussions via my GitHub handle, quetzalliwrites \ud83d\udc19 . Go Back Guides - Message validation Up Next Specification - 3.0.0 Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "fb65dfb6",
    "title": "Overview | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools.html",
    "content": "Overview | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Tools: the AsyncAPI tools ecosystem Contribute to AsyncAPI Tools AsyncAPI Tools List Overview Found an error? Have a suggestion? Edit this page on GitHub Tools: the AsyncAPI tools ecosystem Welcome to AsyncAPI Tools ! Our Tools section documents the AsyncAPI tools ecosystem. Remember Contribute to AsyncAPI Tools Code isn't the only way to contribute to OSS; Dev Docs are a huge help that benefit the entire OSS ecosystem. At AsyncAPI, we value Doc contributions as much as every other type of contribution. \u2764\ufe0f To get started as a Docs contributor: Familiarize yourself with our project's Contribution Guide and our Code of Conduct . Head over to our AsyncAPI Docs Board . Pick an issue you would like to contribute to and leave a comment introducing yourself. This is also the perfect place to leave any questions you may have on how to get started. If there is no work done in that Docs issue yet, feel free to open a PR and get started! Docs contributor questions Do you have a documentation contributor question and you're wondering how to tag me into a GitHub discussion or PR? Never fear! Tag me in your AsyncAPI Doc PRs or GitHub Discussions via my GitHub handle, quetzalliwrites \ud83d\udc19 . AsyncAPI Tools List Check out the complete list of AsyncAPI tools in our AsyncAPI Tools Dashboard . Would you like to add your AsyncAPI tool to the list? Read the docs for adding tools in our AsyncAPI Tools Dashboard. . Go Back Tutorials - Kafka bindings Up Next Generator - Introduction Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "d192768d",
    "title": "Overview | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tutorials.html",
    "content": "Overview | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Tutorials: Learn how AsyncAPI works Contribute to AsyncAPI Tutorials Overview Found an error? Have a suggestion? Edit this page on GitHub Tutorials: Learn how AsyncAPI works Welcome to AsyncAPI Tutorials ! Our Tutorials section teaches beginner processes with AsyncAPI by doing. Remember Contribute to AsyncAPI Tutorials Code isn't the only way to contribute to OSS; Dev Docs are a huge help that benefit the entire OSS ecosystem. At AsyncAPI, we value Doc contributions as much as every other type of contribution. \u2764\ufe0f To get started as a Docs contributor: Familiarize yourself with our project's Contribution Guide and our Code of Conduct . Head over to our AsyncAPI Docs Board . Pick an issue you would like to contribute to and leave a comment introducing yourself. This is also the perfect place to leave any questions you may have on how to get started. If there is no work done in that Docs issue yet, feel free to open a PR and get started! Docs contributor questions Do you have a documentation contributor question and you're wondering how to tag me into a GitHub discussion or PR? Never fear! Tag me in your AsyncAPI Doc PRs or GitHub Discussions via my GitHub handle, quetzalliwrites \ud83d\udc19 . Go Back Concepts - Add servers Up Next Getting Started - Introduction Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "fbfd5aca",
    "title": "Introduction | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/community/onboarding-guide.html",
    "content": "Introduction | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Technical writer onboarding guide Introduction Found an error? Have a suggestion? Edit this page on GitHub Technical writer onboarding guide The AsyncAPI technical writer onboarding guide teaches new community members how to contribute to our documentation effectively. For a comprehensive understanding of the various ways you can contribute to the AsyncAPI Initiative, please consult the AsyncAPI contributing guidelines . The goal is providing docs contributors with the necessary tools and knowledge to: Understand our documentation tools, technologies, and processes. Comprehend our documentation target audiences. Connect with teammates and subject matter experts (SMEs). Report documentation bugs via issues. Implement and propose updates to our documentation. Obtain and incorporate reviewers' feedback. Publish changes successfully. Go Back Community - SEO Up Next Technical writer contributor responsibilities Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "b90fab43",
    "title": "Introduction | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/community/styleguide.html",
    "content": "Introduction | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page AsyncAPI Style Guide Introduction Found an error? Have a suggestion? Edit this page on GitHub AsyncAPI Style Guide The AsyncAPI style guide helps community members learn how to contribute to our documentation effectively. It provides guidelines to ensure consistency and clarity, establish a uniform voice and tone, facilitate collaboration among multiple writers on a single document, and maintain accurate and up-to-date information. The goal is to provide docs contributors with the same guidelines to make it easier for readers to find the necessary information. For a comprehensive understanding of the various ways you can contribute to the AsyncAPI Initiative, please consult the AsyncAPI contributing guidelines . Go Back Community - Overview Up Next About Style Guide Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "64fe999b",
    "title": "Overview | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/community/tooling.html",
    "content": "Overview | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Tools: the AsyncAPI tools ecosystem Contribute to AsyncAPI Tools AsyncAPI Tools List Overview Found an error? Have a suggestion? Edit this page on GitHub Tools: the AsyncAPI tools ecosystem Welcome to AsyncAPI Tools ! Our Tools section documents the AsyncAPI tools ecosystem. Remember Contribute to AsyncAPI Tools Code isn't the only way to contribute to OSS; Dev Docs are a huge help that benefit the entire OSS ecosystem. At AsyncAPI, we value Doc contributions as much as every other type of contribution. \u2764\ufe0f To get started as a Docs contributor: Familiarize yourself with our project's Contribution Guide and our Code of Conduct . Head over to our AsyncAPI Docs Board . Pick an issue you would like to contribute to and leave a comment introducing yourself. This is also the perfect place to leave any questions you may have on how to get started. If there is no work done in that Docs issue yet, feel free to open a PR and get started! Docs contributor questions Do you have a documentation contributor question and you're wondering how to tag me into a GitHub discussion or PR? Never fear! Tag me in your AsyncAPI Doc PRs or GitHub Discussions via my GitHub handle, quetzalliwrites \ud83d\udc19 . AsyncAPI Tools List Check out the complete list of AsyncAPI tools in our AsyncAPI Tools Dashboard . Would you like to add your AsyncAPI tool to the list? Read the docs for adding tools in our AsyncAPI Tools Dashboard. . Go Back Tutorials - Kafka bindings Up Next Generator - Introduction Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "9a1619e6",
    "title": "Onboarding Guide for AsyncAPI Ambassadors | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/community/onboarding-guide/ambassador-guide.html",
    "content": "Onboarding Guide for AsyncAPI Ambassadors | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Ambassador duties Ambassador benefits Additional resources Onboarding Guide for AsyncAPI Ambassadors Found an error? Have a suggestion? Edit this page on GitHub Welcome to the AsyncAPI Ambassador Program! We are happy you chose to join the ambassador program and make valuable contributions to promote AsyncAPI. Your tenure as an ambassador begins on the date you are accepted and shall be renewed annually. For example, if you were accepted as an ambassador on January 11, 2025, your tenure would end on January 10, 2026. At the end of your tenure, we will review your performance to determine if you can continue as an ambassador. As an ambassador, you are expected to make a minimum of four contributions per year. Contributions can include articles, talks, videos, podcasts, driving initiatives, and more. Articles, videos, and podcasts can be published on the AsyncAPI blog or other platforms. Please note that we do not encourage blogs or articles that promote/market certain other products or tools. Talks and presentations should focus primarily on AsyncAPI. Contributions to improve the visibility of the community. Volunteering at booths during events. Examples: If you publish three articles and propel one initiative about AsyncAPI in eight months, you will become an ambassador for the whole year. If you make one presentation, write two articles, and propel one initiative about AsyncAPI, you will become an ambassador for the whole year. Ambassador duties Be in tune with AsyncAPI's mission and values. Always respect the code of conduct . Be active in your role as an ambassador. Ambassador benefits Invitation to AsyncAPI Initiative organization . A special swag pack for Ambassadors. Free entry to AsyncAPI conferences. Community-wide recognition. Our sincere gratitude and respect for your contributions! Additional resources AsyncAPI Ambassador Program Go Back Onboarding Guide for AsyncAPI Maintainers Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "7d27de0b",
    "title": "Contribute to docs | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/community/onboarding-guide/contribute-to-docs.html",
    "content": "Contribute to docs | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Contribute to docs Contribute to docs Found an error? Have a suggestion? Edit this page on GitHub Contribute to docs There are several ways to request your first AsyncAPI docs task: Connect with a docs maintainer: Ask for a good-first-issue in the #13_docs channel of the AsyncAPI Slack workspace. Update current docs: Surf the existing documentation, look for typos , grammar , errors , create an issue, and submit a Pull Request. Propose new docs: If you have any ideas or suggestions for necessary documentation, create a new docs issue and propose yourself as the assignee. Go Back Tools and setup Up Next Create new docs directories Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "cea0a461",
    "title": "Create new docs directories | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/community/onboarding-guide/create-new-docs-directories.html",
    "content": "Create new docs directories | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Create new docs directories Create new docs directories Found an error? Have a suggestion? Edit this page on GitHub Create new docs directories Create a new docs directory (folder) via the following steps: Identify the content bucket under which your document falls. Open the project locally in your code editor of choice and navigate to the parent folder. Right-click on the parent folder and click \"new folder\". Give an appropriate name to the new folder. Add the following two files to the new folder: index.md : Used as the main content for a website's directory or specific webpage. It's named index because many web servers are configured to automatically look for an index file when accessing a directory. When you access a directory on a web server, if an index.md file is present, it will be displayed as the default page for that directory. _section.md : Used for reusable components or partial content within a website's structure. It defines the page's title and weight . The title defines a human-readable title, and weight controls the order in which sections (directories) are displayed. You can edit the index page after successfully creating these pages. Go Back Contribute to docs Up Next Create new docs pull request Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "d4bf341d",
    "title": "AsyncAPI docs community | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/community/onboarding-guide/docs-community.html",
    "content": "AsyncAPI docs community | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Docs and education community discussions AsyncAPI Slack workspace and docs channels AsyncAPI documentation roadmap 2024 AsyncAPI docs community Found an error? Have a suggestion? Edit this page on GitHub Join OPEN docs community meetings via Zoom, a regular space for docs contributors to meet and help each other. Add the AsyncAPI calendar in the AsyncAPI events page to get docs meetings automatically added to your calendar of choice. Watch past AsyncAPI docs meetings on the AsyncAPI YouTube channel . Schedule your own docs meetings . Docs and education community discussions Visit the public AsyncAPI Docs & Education discussion board to discuss docs-related issues and propose improvements. AsyncAPI Slack workspace and docs channels Join the AsyncAPI documentation Slack channel to meet other technical writers: #13_docs: A space for all technical writers to start discussions, ask questions, share new ideas, and request good first issues. AsyncAPI documentation roadmap 2024 Stay tuned for new opportunities on our Docs\u2019 Community discussions or reach out in the AsyncAPI Slack channel #13_docs . Docs Roadmap Ongoing Docs Projects Timeline Contribution Type AsyncAPI Style Guide AsyncAPI Style Guide Ongoing Regular contribution AsyncAPI Tools\u2019 Docs Modelina Docs Parser Docs GitHub Actions Docs Studio Docs Generator Docs CLI Docs Ongoing Regular contribution Technical Writer Onboarding Guide Onboarding Guide for new docs contributors Ongoing Regular contribution Go Back Prerequisite knowledge Up Next Tools and setup Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "e91408b4",
    "title": "Docs onboarding checklist | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/community/onboarding-guide/docs-onboarding-checklist.html",
    "content": "Docs onboarding checklist | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page AsyncAPI docs onboarding checklist Docs onboarding checklist Found an error? Have a suggestion? Edit this page on GitHub AsyncAPI docs onboarding checklist As an open-source initiative with a global community, technical writer contributors should learn about our governance documents, documentation processes, and communication channels. Complete in order the following onboarding tasks: Read the AsyncAPI Code of Conduct . Read the AsyncAPI Slack etiquette . Join the AsyncAPI Slack workspace . Add the AsyncAPI calendar found in the AsyncAPI events page . Read the list of technical writer contributor responsibilities . Read and familiarize yourself with the prerequisite knowledge topics . Familiarize yourself with the work-in-progress AsyncAPI Style Guide . Read all docs under the following content buckets: Concepts , Tutorials , Reference . (Take the time to go through each tutorial.) Set up your local environment following our instructions for the AsyncAPI git workflow . Introduce yourself in AsyncAPI Slack in the #01_introductions channel and the #13_docs channel. Ask docs-related questions in #13_docs. Request a good first docs issue in the #13_docs Slack channel . Attend OPEN docs meetings to chat with other maintainers, ask docs questions, and request help on docs blockers. Go Back Technical writer contributor responsibilities Up Next Prerequisite knowledge Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "17f46e8a",
    "title": "Onboarding Guide for AsyncAPI Maintainers | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/community/onboarding-guide/maintainer-guide.html",
    "content": "Onboarding Guide for AsyncAPI Maintainers | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Who is an AsyncAPI Maintainer? Steps to becoming a Maintainer 1. Pick an Issue 2. Open a PR 3. Get your PR merged 4. Receive an invitation to become a Maintainer \ud83c\udf89 Onboarding Guide for AsyncAPI Maintainers Found an error? Have a suggestion? Edit this page on GitHub Welcome to the AsyncAPI Maintainer Onboarding Guide! This document aims to provide comprehensive guidelines about everything you need to know to begin your journey as a maintainer within the AsyncAPI ecosystem. Maintainers are the backbone of any open-source project, helping with different activities that help the project stay on track and foster a healthy, productive community. Before we go into getting you started, let's try and clarify just who a maintainer is. Who is an AsyncAPI Maintainer? A maintainer is an individual who plays a crucial role in overseeing and guiding the development and growth of an open-source project. As a maintainer for AsyncAPI, you'll be responsible for: Overseeing the technical direction of the project Helping with reviewing and resolving issues and pull requests (PR) Managing workflows and GitHub Actions to automate tasks Enforcing coding standards Enforcing relevant and up-to-date documentation Identifying and appointing new maintainers Mentoring new contributors and helping them navigate their journey Recognizing and rewarding contributions to foster community engagement But being a maintainer goes beyond these responsibilities\u2014it\u2019s about ownership and leadership . You\u2019re not just merging code; you\u2019re shaping the project\u2019s future. This means stepping up to unblock contributors stuck on a PR, advocating for improvements in the roadmap, or leading releases to ensure smooth deployments. You\u2019ll proactively identify risks, mediate discussions to align decisions with AsyncAPI\u2019s vision, and celebrate wins to keep the community motivated. Maintainers also lead by example . You\u2019ll mentor others not just by answering questions but by teaching contributors why coding standards matter or how to structure a feature. You\u2019ll balance technical rigor with empathy, ensuring decisions serve both the project\u2019s goals and its people. Essentially, you serve as a person who binds the project together and guarantees that everything runs smoothly. Steps to becoming a Maintainer Before you can become a maintainer , you need to start as a contributor . The journey from contributor to maintainer is a rewarding one, and it involves the following steps: 1. Pick an Issue Join existing PR reviews : If you're not sure where to start, begin by reviewing open PR within the organization. This will give you a high-level understanding of the projects and where your contributions might fit in. Look for \" good first issue \" labels : These issues are beginner-friendly and will help you get familiar with the project\u2019s structure. Additionally, you can check out the #97_bot-github-new-issues-prs channel on Slack for new issues and PRs. Participate in live streams : AsyncAPI maintainers sometimes host live streams where they walk through parts of the project. You can request a session on the specific area you want to contribute to. [!NOTE] Make sure whatever issue you pick isn't marked \"Do-not-merge,\" or else your PR won't be merged. 2. Open a PR For a comprehensive guide on how to create a fork and start contributing, refer to the AsyncAPI Git Workflow Guide . Fork the repository : Fork the repository you want to contribute to and create a new branch for your changes. Make changes : Implement the changes required to resolve the issue you picked. Ensure your code adheres to the project\u2019s coding standards. Submit a PR : Once you\u2019re done with the changes, submit a PR to the main repository. Make sure to include a detailed description of your changes. Participate in discussions : Engage with maintainers and other contributors in the PR comments section. This will help you understand the project better and improve your contributions. 3. Get your PR merged PR review process : After submitting a PR, maintainers need to review it. Contact maintainers : If a PR is not being reviewed (which is rare) or needs urgent review, contact maintainers on Slack or GitHub. Ensure smooth merge : Ensure all checks (tests, style checks, etc.) pass before merging your PR. 4. Receive an invitation to become a Maintainer \ud83c\udf89 Recognition : After contributing consistently and demonstrating leadership \u2014 whether through code, reviews, mentorship, or strategic input \u2014 the maintainers will invite you to join the team. This invitation is a recognition of your ownership and dedication to AsyncAPI\u2019s success. If you haven't received an invitation despite contributing consistently, you can open an issue in the corresponding repository to discuss your contributions with the maintainers. You can see an example of such an issue here . Go Back Create new docs pull request Up Next Onboarding Guide for AsyncAPI Ambassadors Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "744278f2",
    "title": "Create new docs pull request | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/community/onboarding-guide/open-docs-pull-request.html",
    "content": "Create new docs pull request | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Create a new docs pull request Create new docs pull request Found an error? Have a suggestion? Edit this page on GitHub Create a new docs pull request Create and submit a docs pull request (PR) via the following steps: A Docs\u2019 PR should solve one documentation problem. If there is no current issue for the docs task you want to accomplish, please open a docs issue before creating a PR. Use the conventional commit style when creating PRs. Always create a docs issue or PR with the docs: prefix in the title. Please check your contribution and ensure it follows the AsyncAPI style guide. Tag other technical writers to review your document. Tag an engineer or subject matter expert (SME) to review the technical details. After implementing all the feedback you requested, please update your PR and wait for further feedback before it can be merged. Go Back Create new docs directories Up Next Onboarding Guide for AsyncAPI Maintainers Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "1e146d28",
    "title": "Prerequisite knowledge | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/community/onboarding-guide/prerequisite-knowledge.html",
    "content": "Prerequisite knowledge | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Di\u00e1taxis framework and content buckets Markdown syntax and mermaid.js diagrams AsyncAPI concepts JSON and YAML Understanding Event-Driven Architecture Protocols used with AsyncAPI Prerequisite knowledge Found an error? Have a suggestion? Edit this page on GitHub The prerequisite knowledge section highlights the key technologies, concepts, and skills our technical writers need for working with AsyncAPI documentation. You must understand the main concepts behind our documentation processes, content classification, and the AsyncAPI specification. Di\u00e1taxis framework and content buckets AsyncAPI adopted the Di\u00e1taxis framework to meet our specific needs, classifying our documentation into content buckets (categories). Concepts define the concepts of AsyncAPI features. Tutorials teach beginner processes with AsyncAPI by doing, taking you step-by-step from Point A to Point B. Tools documents the AsyncAPI tools ecosystem. Guide teaches troubleshooting and understanding AsyncAPI's capabilities at a high level. Reference documents the AsyncAPI specification. Migration guides how to upgrade to a newer AsyncAPI version. Community explains our documentation processes, guidelines, and resources to community members. Markdown syntax and mermaid.js diagrams AsyncAPI's docs are written in Markdown syntax . Our diagrams are created with Mermaid markdown syntax thanks to the mermaid.js dependency. AsyncAPI concepts Before contributing to the documentation, you should understand the purpose of AsyncAPI and essential AsyncAPI concepts (i.e., servers, producers, consumers, channels, messages, etc.) . You should also fundamentally understand the AsyncAPI specification . JSON and YAML Because an AsyncAPI definition can be written in JSON and YAML, you must learn how to read, write, and validate these formats. Understanding Event-Driven Architecture Event-Driven Architecture (EDA) uses events to trigger and communicate between services. (AsyncAPI is an open-source initiative that seeks to improve the current state of EDAs.) Protocols used with AsyncAPI AsyncAPI supports several protocols, such as Kafka, AMQP, MQTT, and more. You will benefit from acquiring a basic understanding of protocols most used with AsyncAPI , including their use cases and how they work with AsyncAPI. Go Back Docs onboarding checklist Up Next AsyncAPI docs community Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "b7c4bf85",
    "title": "Technical writer contributor responsibilities | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/community/onboarding-guide/technical-writer-contributor-responsibilities.html",
    "content": "Technical writer contributor responsibilities | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets Technical writer contributor responsibilities Found an error? Have a suggestion? Edit this page on GitHub In the AsyncAPI community, technical writers collaborate with other technical writers, Subject Matter Experts (SME), designers, engineers, and core maintainers. Technical writer contributor responsibilities include: Create quality, easy-to-use, clear, and accurate documentation for all audience levels. Collaborate with other contributors to propose, create, and maintain documentation. Support fellow technical writers and community members. Engage in documentation review processes and incorporate feedback. Join documentation community meetings/streams to connect with the community. Go Back Introduction Up Next Docs onboarding checklist Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "48083da6",
    "title": "Tools and setup | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/community/onboarding-guide/tools-and-setup.html",
    "content": "Tools and setup | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Tools for technical writers Setup your AsyncAPI local environment Tools and setup Found an error? Have a suggestion? Edit this page on GitHub Tools for technical writers Technical writer contributors need the following tools to contribute to AsyncAPI documentation effectively: A laptop or desktop computer capable of running the tools necessary to contribute to the project. Stable internet access to clone the project repository, submit contributions, and stay updated on project changes. A GitHub account. AsyncAPI hosts all its project's source code and documentation on GitHub. You'll need a GitHub account to create issues, fork the repository, submit pull requests, and more. If you're new to GitHub, familiarize yourself with basic GitHub functionalities and workflows . A code editor, such as VS Code , capable of handling Markdown files. Git , a version control system. Setup your AsyncAPI local environment Fork the repository by clicking the Fork option on the top right of the main repository. Open Command Prompt on your local computer. Clone the forked repository by adding your GitHub username instead of <username> . For multiple contributions, follow the proper configuration of a forked AsyncAPI repo . git clone https://github.com/<username>/website/ Navigate to the website directory. cd website Install all website dependencies. npm install Run the website locally. npm run dev Access the live development server at localhost:3000 . Go Back AsyncAPI docs community Up Next Contribute to docs Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "a46f7cc5",
    "title": "About Style Guide | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/community/styleguide/aboutguide.html",
    "content": "About Style Guide | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Introduction Writing Style Identify target audience Research Plagiarism Follow writing principles Prune and polish Address feedback About Style Guide Found an error? Have a suggestion? Edit this page on GitHub Introduction Welcome to the AsyncAPI Style Guide. This page guides contributors on how to write, structure, and format content in documentation. These guidelines help us maintain language, tone, and voice throughout the website, also making it easier for multiple contributors to collaborate and work together on a single document, while ensuring consistency, accuracy, and clarity. Writing Style Below are some recommendations to consider when writing your pages. Identify target audience Before you begin planning and constructing your content, knowing who you are writing for and how the readers will benefit from your content is important. This will help you in strategizing and simplifying your writing process. Research Before creating your first draft, it is beneficial to research similar resources and use them as references. Avoid plagiarism or copying and pasting from other websites unless the content already exists on our site. Plagiarism Plagiarism can be defined as an act of using someone else's work as your own, without giving any acknowledgment or credit. Below are some scenarios that can be considered as plagiarism: Scenario 1 Jane Doe is writing a docs page about APIs. She copies and pastes the content generated from ChatGPT word for word. Scenario 2 John Doe is assigned a task to update graphics. He replicates some diagrams from an engineering book and doesn't give any credit to the author. You can avoid plagiarism by: Paraphrasing and adding your own thoughts. For instance, in the first scenario, you can use content generated from ChatGPT for research and reference purposes. Quoting or citing your sources. Using plagiarism checker tools such as Grammarly, SmallSEOTools, and Plagiarism Detector. Follow writing principles When writing documentation, we aim to achieve the following: Clear - It is very important that your writing is as clear as possible. Avoid using jargon or ambiguous words. Explain technical terms in simple and easy-to-understand words while considering your target audience. Additionally, keep your sentences short and sweet. Concise - It is crucial to be concise when conveying information. Removing redundancy caters to the reader's needs while providing value. Consistent - Maintaining consistency makes it easy for multiple collaborators to work together efficiently. This ensures professionalism while making it easy to implement updates and changes. Friendly - Your documentation should be relatable. Always use an active voice instead of a passive tone when writing. Moreover, adding visual graphics and real-life examples helps the reader understand the information more practically. Accurate - Lastly, your content/documentation must be accurate and precise. The information provided should be well-researched, appropriate, and not misleading. Readers rely on our content/documentation to solve their needs while saving them time doing unnecessary research. Prune and polish It is always crucial to check grammar, punctuation, and spelling. View your work with a constructive eye while putting yourself in the reader's shoes. Thoroughly proofread your work and use writing tools such as Grammarly to polish up your work. Address feedback A whole community of contributors is willing to support you via detailed feedback. All documentation pull requests go through several rewriting, editing, and proofreading rounds before they're ready to merge. Go Back Introduction Up Next Accessibility Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "75b141be",
    "title": "Accessibility | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/community/styleguide/accessibility.html",
    "content": "Accessibility | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Accessibility Language Text Links Multimedia UI Accessibility Found an error? Have a suggestion? Edit this page on GitHub Accessibility At AsyncAPI, we strive to make our documentation/content inclusive, accessible, and unbiased to everyone. We encourage all contributors to have diversity and inclusivity in mind when writing. To ensure this, we have provided an overview of general guidelines to follow that will help you write inclusive and accessible documents. Language Be clear and concise when writing. Avoid the use of complex language, technical jargon, and verbose explanations. Keep paragraphs and sentences short, simple, and to the point. Keep your sentences as crisp as possible, avoid having nested sentences. Always maintain a uniform structure. Use descriptive headings and subheadings to make navigation easy. Use inclusive language and always keep the reader in mind when writing. Text Use the appropriate heading hierarchy. H1 is used for the main heading while H2 to H6 are used for subsection headings. Properly align text for easy readability. Avoid using camel case or any unnecessary fonts and formatting. Define acronyms or abbreviations and always spell out any signs or symbols. Structure your text in a uniform format. Links Use descriptive and meaningful link text. For example, do not use phrases like click here or follow this link instead use Read the accessibility guidelines or Explore best practices for inclusivity . Always use an external link icon if a link opens up in a new tab. Make sure your links or URLs are valid and redirect to the correct/desired destination. Multimedia Alt text must be clear and descriptive. Not more than 50 characters. Always use text rather than images, unless necessary. Use SVG instead of PNG or JPEG. It retains quality. Provide transcripts and captions for video content. Make sure your captions can be translated into various languages. Avoid auto-playing media, always provide controls. UI Use the correct terminologies for UI elements. Format tables correctly and keep the text within the grid. Use basic HTML for button elements. Add icons to describe a function. Use the aria-label attribute when unsure of the icon name. Go Back About Style Guide Up Next Content Buckets Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "75141305",
    "title": "Content Buckets | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/community/styleguide/content-buckets.html",
    "content": "Content Buckets | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Content Buckets Content Buckets Found an error? Have a suggestion? Edit this page on GitHub Content Buckets To structure our documentation, we adopt a systematic approach from the Di\u00e1taxis framework. We ensure our docs are presented in a manner that is easy to understand by organizing and classifying them into content buckets. \n![Di\u00e1taxis framework](https://www.asyncapi.com/img/posts/changes-coming-docs/diataxis.webp)\n Documentation structure based on the Di\u00e1taxis framework . At AsyncAPI our docs are classified into the following content buckets: Concepts - This section is where we define various features and capabilities AsyncAPI offers. All docs pages under this bucket need to be accurate, easy to understand and accompanied by an engineering diagram. We utilize Mermaid.js syntax to create diagrams and visualizations. Tutorials - Our tutorial section offers practical guidance to individuals who are beginners or new to AsyncAPI. Docs under this content bucket need to be hands-on and provide step-by-step guidance using real-world examples. The docs should be engaging and interactive to help users develop the required knowledge. Guides - The guides section teaches individuals about higher-level AsyncAPI features. Content under this bucket helps users gain a deeper understanding and provide different ways to solve a problem. The tone should be concise. You can think of guides as a recipe for cooking a meal. Reference - This section provides detailed technical information about the specification. Under this bucket, you'll find release notes, API and internal documents such as function definitions and parameter descriptions. References need to be precise, straight to the point and accurate. Go Back Accessibility Up Next Inclusive Language style guide Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "https://www.asyncapi.com/img/posts/changes-coming-docs/diataxis.webp",
        "alt": "Di\u00e1taxis framework"
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "f77072d9",
    "title": "Formatting | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/community/styleguide/formatting.html",
    "content": "Formatting | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Documentation formatting Notes and warning blocks Code blocks Spacing Formatting Found an error? Have a suggestion? Edit this page on GitHub Documentation formatting Documentation formatting refers to how the document appears on the page and how the content is organized, which includes font selection, font size, and presentation (such as bold or italics), spacing, margins, alignment, columns, indentation, and lists. Formatting helps the reader perceive the information and makes it more accessible. Notes and warning blocks Notes and warning blocks are used to draw attention to important information. Use the following markdown features when necessary: Use a clear and concise heading to introduce the note or warning. Use short paragraphs or bullet points to convey the information. Keep the language simple and direct. Use an > in markdown to indicate the nature of the note or warning. Use the following syntax to apply a style. Currently our documentation supports Remember <Remember> : Surround the text you want to style with an opening Remember tag and a closing tag. Note that the word 'Remember' does not need to be included within the tags, as it automatically provides the necessary styling. Use the following syntax to apply a style: <Remember> No need to add a prefix; the tag automatically provides one </Remember> The output: Remember No need to add a prefix; the tag automatically provides one Code blocks Code blocks are used to display code examples or snippets. In a Markdown document, use the <CodeBlock> tag and specify the language. Use the following syntax to apply a code block: \n```javascript\n1<CodeBlock language=\"bash\">\n2{`npm start`}\n3</CodeBlock>\n```\n The output: 1 npm start Use code style for filenames, directories, and paths. For example: Go to the /docs/tutorials directory. Choose a consistent number of spaces for indentation, such as 2 or 4 spaces, and use it consistently throughout the document. Indent the code properly to show its structure and hierarchy. Each level of indentation should align with the appropriate scope. Avoid using tabs for indentation, as they may not render consistently across different platforms or text editors. For example, when writing code in Markdown, use four spaces for each level of indentation: \n```javascript\n1function myFunction() {\n2    if (condition) {\n3        console.log(\"Condition is true.\");\n4    } else {\n5        console.log(\"Condition is false.\");\n6    }\n7}\n```\n Use single backticks to enclose inline code. For example, asyncapi new --example=tutorial.yml --no-tty Remove any trailing spaces in the code. Trailing spaces can disrupt the readability and formatting of the code, so ensure they are removed. Use triple backticks to enclose YAML code blocks. Specify the language as \"yaml\" within the backticks. This syntax is specifically for displaying code blocks that contain YAML content. Use this syntax: ```yaml asyncapi: '3.0.0' info: title: Account Service version: 1.0.0 ``` The output: \n```javascript\n1asyncapi: '2.5.0'\n2info:\n3title: Account Service\n4version: 1.0.0\n```\n Spacing Line spacing, or the vertical space between lines of text in a paragraph, can aid or hinder reading. Adequate line spacing helps readers navigate from the end of one line to the start of the next. Leave a blank line between paragraphs to visually separate them. This helps readers distinguish between different sections of content. For headings and subheadings, leave a blank line before and after them to provide clear visual separation. Leave a single line spacing after bullet points or numbered lists to enhance readability. Use consistent indentation to show the hierarchy of the content. Indentation can be achieved with either 2 or 4 spaces, depending on your preference or the coding style guidelines of your project. Choose one and use it consistently throughout the document. Use indentation to show nested content, such as code blocks, lists, or paragraphs within a list item. Indent code blocks by an additional indentation level to differentiate them from regular text. Go Back Punctuation style guide Up Next SEO Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1<CodeBlock language=\"bash\">\n2{`npm start`}\n3</CodeBlock>",
      "1function myFunction() {\n2    if (condition) {\n3        console.log(\"Condition is true.\");\n4    } else {\n5        console.log(\"Condition is false.\");\n6    }\n7}",
      "1asyncapi: '2.5.0'\n2info:\n3title: Account Service\n4version: 1.0.0"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "35390de7",
    "title": "Inclusive Language style guide | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/community/styleguide/inclusive-language.html",
    "content": "Inclusive Language style guide | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Inclusive Language 1. Culturally inclusive language 2. Gender neutral language 3. Accessibility and Disability 4. Slang-free language 5. Ageism-free language 6. Knowledge level assumption-free language Inclusive Language style guide Found an error? Have a suggestion? Edit this page on GitHub Inclusive Language While writing documentation, we are directly speaking to thousands of people all around the globe. Thus, we must ensure our diverse audience can connect with our information. 1. Culturally inclusive language Certain phrases and words are commonly used in specific regions of the world. Avoid using region-specific language in the documentation. Some examples of region-specific language are - \u201cIt\u2019s not rocket science\u201d is commonly used in the USA, and non-US people might not be able to relate to it as intended. Phrases written in regional languages instead of English. \u201cIt\u2019s a piece of cake\u201d is commonly used in the USA, and non-US people might be unable to relate to it as intended. Terms like \"gypsy\" is considered derogatory in Romani community, \"eskimo\" is considered offensive in artic community. Terms like \"tipping point\" is considered offensive in African American cultures. 2. Gender neutral language Some phrases and words target men or men/women specifically, resulting in other gender groups feeling left out while reading our documentation. Using only male pronouns also make women in technology feel excluded or overlooked. Similarly, we should also try to include nonbinary groups of people in our writing. Some examples of gender-neutral language are - Using \u201cthey/them\u201d instead of \u201chis/him\u201d or \u201cshe/her\u201d. Using \u201cHello everyone\u201d instead of \u201cHello guys\u201d. Using \u201cChairperson\u201d instead of \u201cChairman\u201d or \u201cChairwoman\u201d. Using \"people\", \"guests\" or \"folks\" instead of \"ladies and gentlemen\". Using \"Mx\" or \"Ms\" instead of using \"Mr\" or \"Mrs\". Using \"humankind\" instead of \"mankind\". Avoid using stereotypes such as linking \"male\" with \"strength\", \"women\" with \"care work\", or \"male homosexuality\" with \"sensitivity\". 3. Accessibility and Disability The placement of the word \u201cPeople\u201d matters a lot when writing documentation. Using the word \u201cPeople\u201d in the beginning makes it more pleasant as the problem is not displayed initially. The phrasing of sentences should not be in a manner that depicts Ableism or discrimination against individuals with disabilities or the assumption that people with disabilities are inferior to those without disabilities. Some examples of gender-neutral language are - Using \u201cPeople with a mental health condition\u201d instead of \u201cMentally Unstable People\u201d. Using \u201cDeaf\u201d instead of \u201cPerson with deafness\u201d. Using \"People with a disability\" instead of \"Disabled people\". Using \"Wheelchair Users\" instead of \"Wheelchair bound\". Using \"People experiencing homelessness\" instead of \"Homeless people\" Avoid using derogatory terms that refer to people with disabilities like \"crazy\", \"retarded\", spaz, and \"lame\". Try using phrases like \"overlook\" or \"ignore\" instead of \"turn a blind eye\", or using \"unheard\" or \"unnoticed\" instead of saying \"falling on deaf ears\". 4. Slang-free language While framing the documentation, we must ensure that we are not including any vulgar language, even if it is included indirectly in our work. We should be mindful of inadvertently including slang words within phrases that may have unintended or inappropriate connotations. Some examples include - Using \u201csimple\u201d or \u201ceasy\" instead of \u201cno-brainer\u201d. Using \"simple\" or \"straightforward\" instead of \"easy-peasy\". Avoid using any racist, sexist, or any discriminatory language like \"stupid\" or \"retarted\". Use \"easy\" or \"simple\" instead of \"piece of cake\". Using \"excellent\" or \"impressive\" instead of \"dope\" 5. Ageism-free language When constructing the documentation, avoiding words or phrases that may disproportionately emphasize a specific age group is important, as this can make other age groups feel excluded. Some examples include - Avoid mentioning the exact age like \u201c60 years\u201d old. Using \"experienced\" instead of \"old-timer\" Avoid phrases like \"you are too old to understand\" or \"you are too young to understand\" Using \u201clively\u201d instead of \u201cyoung\u201d. Avoid making assumptions about a person's abilities or interests based on their age, like assuming an older adult will not be tech-savvy. 6. Knowledge level assumption-free language While building the documentation, we should always ensure that we don\u2019t presume the knowledge level of the readers. Assuming that our readers are highly skilled or have advanced experience, we might inadvertently skip explaining or linking some important concepts. Also, we should avoid labelling some steps as \u201ceasy\u201d because this might make some readers question their technical abilities. Some examples include - Using \u201cfixing the navbar is good to start with\u201d instead of \u201cfixing the navbar is very easy\u201d. Linking complex topics that most of our audience won\u2019t understand. Avoid phrases like \"As you already know, the Fourier series is a mathematical method used to represent periodic functions.\" Avoid including phrases like \"You're probably familiar with the concept of compound interest so that I won't go into too much detail about it.\" Go Back Content Buckets Up Next Voice and Tone Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "1d1b63a1",
    "title": "Punctuation style guide | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/community/styleguide/punctuation.html",
    "content": "Punctuation style guide | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Punctuation 1. Period (.) 2. Comma (,) 3. Semi-colon (;) 4. Colon (:) 5. Dash (\u2014 or -) 6. Question Mark (?) 7. Exclamation Point (!) 8. Quotation Marks (\" \") 9. Ellipsis (...) Punctuation style guide Found an error? Have a suggestion? Edit this page on GitHub Punctuation Writing documentation is important because it allows us to communicate indirectly with many people around the world. Punctuation is a crucial part of writing because it helps us make our message clear and consistent. To ensure our documents follow the same standards and are consistent with others in the industry, it's important to use the style guides that have already been recognised. 1. Period (.) Use a Period to end a declarative sentence or a statement. Some examples include: \"I went to the store.\" \"The cat is sleeping.\" 2. Comma (,) Use a Comma to separate items in a list (including the Oxford comma). Some examples include: \"She bought apples, oranges, and bananas.\" \"He went to the store, picked up some milk, and returned home.\" Note: The Oxford comma is the optional comma before the conjunction in a list of three or more items. Its usage can vary based on style guides or personal preference. 3. Semi-colon (;) Use a semicolon to separate two independent clauses that are closely related but could be separate sentences. Some examples include: \"She finished her work; then she went home.\" \"I need to buy groceries; I'm running out of food.\" 4. Colon (:) Use a Colon to introduce a list, explanation, or an example. Some examples include: \"Please bring the following items: a pen, a notebook, and a calculator.\" \"There are three primary colours: red, blue, and yellow.\" 5. Dash (\u2014 or -) An em Dash (\u2014) indicates a sudden break or interruption in a sentence or provides emphasis. Some examples include: \"She went to the store\u2014despite the rain\u2014to buy some groceries.\" \"She received an unexpected gift\u2014a brand new car!\" A hyphen (-) joins compound words or prefixes. Example: \"The well-known actor starred in the movie.\" 6. Question Mark (?) Use a Question mark at the end of a direct question. Some examples include: \"What time is the meeting?\" \"What is your favourite movie?\" 7. Exclamation Point (!) Use an Exclamation point to show strong emotion, emphasis, or surprise. Some examples include: \"Congratulations on your success!\" \"Happy birthday!\" 8. Quotation Marks (\" \") Use Quotation marks to indicate direct speech or to enclose a quote. Some examples include: She said, \"I will be there by 5 o'clock.\" He asked, \"Can you lend me a hand?\" 9. Ellipsis (...) Use an Ellipsis to indicate the omission of words or a pause in speech. Some examples include: \"I can't believe you...\" \"The best is yet to come...\" Go Back Voice and Tone Up Next Formatting Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "abe86c02",
    "title": "SEO | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/community/styleguide/seo-guide.html",
    "content": "SEO | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page What is SEO? Why is SEO important in technical documentation? SEO best practices Headings? Strategies for making SEO-friendly headings Examples of SEO-friendly headings from AsyncAPI's documentation What are URLS? Strategies for making SEO-friendly URLs What is Anchor Text? Strategies for making SEO-friendly anchor texts Examples of SEO-friendly anchor texts from AsyncAPI's documentation What is Internal Linking? Strategies for making SEO-friendly internal links Examples of SEO-friendly anchor texts from AsyncAPI's website What are meta descriptions? Strategies for making SEO-friendly meta descriptions Examples of SEO-friendly meta descriptions from AsyncAPI's website Why is mobile-friendliness important to technical documentation when making it SEO-friendly? Strategies for making mobile and SEO-friendly content Why is quality important when making technical documentation that is SEO-friendly? Strategies for making high-quality and SEO-friendly content Images Strategies for making images SEO-friendly SEO Found an error? Have a suggestion? Edit this page on GitHub What is SEO? Search Engine Optimization (SEO) encompasses various techniques and strategies to improve a website's visibility in search engine results. Effective SEO can increase organic traffic by ensuring relevant content reaches the intended audience. Why is SEO important in technical documentation? Integrating SEO practices into technical documentation makes it easier for users and contributors to discover valuable resources and ultimately fosters community engagement and collaboration, enhancing the overall knowledge base. SEO best practices Headings? Headings are HTML tags that create a structured hierarchy in content, making it easier for readers to navigate and for search engines to index. Strategies for making SEO-friendly headings Use Hierarchical Order: Begin with the <h1> tag for the main title, followed by <h2> for major subsections, <h3> for sub-subsections, and so forth, ensuring a clear structure throughout the documentation. Incorporate Relevant Keywords: Utilize keywords strategically, particularly within <h1> and <h2> tags, as these are among the first elements users engage with. Examples of SEO-friendly headings from AsyncAPI's documentation \n```javascript\n1# Server\n2## What is a Server?\n3## What is the purpose of servers?\n4### Client and Server\n```\n What are URLS? URLs serve as the addresses for web pages and other online resources. An SEO-friendly URL structure improves user experience and enhances discoverability. Strategies for making SEO-friendly URLs Keep It Short: Short URLs are simpler for users to remember and share. Include Keywords: Effective keyword incorporation helps search engines index the URL successfully. Avoid Special Characters and Spaces: Use hyphens (-) instead of underscores (_) to separate words, as search engines interpret hyphens as spaces. Here are some examples of SEO-friendly URLs from AsyncAPI's documentation: https://www.asyncapi.com/docs/concepts/application https://www.asyncapi.com/docs/concepts/server https://www.asyncapi.com/docs/concepts/message These URLs are concise and relevant to the documentation's topics, avoiding special characters. What is Anchor Text? Anchor text refers to the clickable text in a hyperlink, providing context about the linked webpage's content. Strategies for making SEO-friendly anchor texts Use Descriptive Phrases: Ensure the anchor text is relevant to the linked content, incorporating keywords without overstuffing. Consider User Intent: Tailor the anchor text based on what users will likely search for within the documentation. Update Regularly: As AsyncAPI evolves, it is important to refine the anchor text regularly to match updated content. Examples of SEO-friendly anchor texts from AsyncAPI's documentation AsyncAPI Server Object \"The many meanings of Event-Driven Architecture\" These links include relevant keywords such as \"AsyncAPI\", \"Server Object\", and \"the many meanings of Event-Driven Architecture\", which accurately describe the content they are linked to. What is Internal Linking? Internal linking involves creating hyperlinks within a document that connect to other sections or relevant resources. The practice enhances navigation within AsyncAPI's content. Strategies for making SEO-friendly internal links Develop an internal link structure : Consider deciding the types of internal links to use when writing a blog post or documentation for AsyncAPI. Doing so would help increase the chances of the content appearing in the search results. To learn more about the different styles of internal links, check out the Types of Internal Links section in \"Internal Links for SEO: An Actionable Guide\" . Create unique anchor texts: Use distinct text for different links to avoid user confusion and clarify the destination content. Include keywords in your anchor text : Including relevant keywords in internal links helps search engines understand the content's focus. Examples of SEO-friendly anchor texts from AsyncAPI's website \"In this case, in your AsyncAPI file, you describe the server , and therefore, the Server Object holds information about the actual server, including its physical location.\" \"JSON Schema Draft 07 is 100% compatible with AsyncAPI schemas. You can also use other standards to describe payload schema, such as Avro .\" \"Furthermore, the Pub/sub is appealing for IoT use cases due to two key features: support for flexible coupling between publishers/subscribers and inherent support for point-to-multipoint transmission.\" What are meta descriptions? Meta descriptions are short snippets of HTML that briefly summarize a web page's content. They appear below the page title in search results and can influence click-through rates. [!NOTE] Meta descriptions are often written in YAML format for AsyncAPI's documentation. Strategies for making SEO-friendly meta descriptions Be Concise and Informative: Summarize the content, keeping it under 160 characters to ensure it displays fully in search results. Include Keywords: Use relevant keywords to improve search visibility while accurately reflecting the page content. Engage the Reader: Write compelling descriptions encouraging search engine results clicks. Examples of SEO-friendly meta descriptions from AsyncAPI's website title: Kafka bindings description: Learn how to configure Kafka bindings in your AsyncAPI document. title: \"Validate AsyncAPI documents\" description: In this guide, you'll learn multiple ways to validate AsyncAPI documents. title: Generate code description: In this tutorial, you'll learn how to generate code from your AsyncAPI document. In addition to having information that correlates to the content's topic, these meta descriptions are concise and contain keywords. Why is mobile-friendliness important to technical documentation when making it SEO-friendly? With most online content consumed on smartphones, tablets, and computers, ensuring that AsyncAPI's mobile-friendly content is essential. Research shows that users are more likely to return to and positively view a website if it is mobile-friendly . Additionally, technical documentation that is optimized for mobile devices tends to rank higher in search results. Strategies for making mobile and SEO-friendly content Here are some ways to make blog posts and documentation for AsyncAPI's website mobile and SEO-friendly. Use Smaller Images and Videos : Large media files can slow down page loading times, leading to a poor user experience. Opt for smaller, optimized files whenever possible. Select Mobile-Friendly Fonts : Some fonts can be difficult to read on smaller screens. Choose adaptable font styles for body text, and it should ideally be between 14-16 points for headings and 12 points for body text. Create Individual Pages or Sections for Each Topic : Providing dedicated pages or sections for different topics and links to related content will enhance navigation and usability. Why is quality important when making technical documentation that is SEO-friendly? Search engines prioritize content that delivers real value to users. Therefore, ensuring that your content is of high quality is crucial. Strategies for making high-quality and SEO-friendly content When writing for AsyncAPI's blog or documentation, ask yourself the following questions to ensure your content meets quality standards: Is the content interactive and engaging? Is the information presented accurate? Is the content too technical for its intended audience? Images How images are incorporated into technical documentation can significantly impact search engine rankings. Therefore, it is vital to optimize images effectively. Strategies for making images SEO-friendly To make SEO-friendly images, it is recommended to use the following methods: Create Descriptive Alt Text : Ensure each image has alt text that accurately describes its context and purpose. It helps with SEO and improves accessibility for users who may not see the image. Use Supported Image Formats : Formats such as WEBP are widely used throughout AsyncAPI and are recognized by search engines, making them preferable for web use. Optimize File Sizes : Large image files can slow a website's loading times. Compress and reduce the file sizes before including them in your documentation or blog posts to enhance performance. By implementing these best practices, you can enhance the SEO of your technical documentation, making it more accessible and valuable to users and contributing to a thriving community. Go Back Formatting Up Next Onboarding guide - Introduction Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1# Server\n2## What is a Server?\n3## What is the purpose of servers?\n4### Client and Server"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "aed34b6f",
    "title": "Voice and Tone | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/community/styleguide/voice-and-tone.html",
    "content": "Voice and Tone | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Introduction Our Voice Our Tone Style Tips Voice and Tone Found an error? Have a suggestion? Edit this page on GitHub Introduction Voice and tone are essential parts of writing effective documentation for AsyncAPI. How we write significantly impacts how our readers perceive and interact with our documentation. We communicate in a clear, instructive voice and a friendly tone to help readers understand complex technical concepts and feel confident in using the AsyncAPI specification. Our Voice At AsyncAPI, we consider our voice to be: Clear and concise throughout the documentation. This way, readers can get helpful information quickly, even at a glance. Example \"A protocol is a set of rules that specifies how information is exchanged between applications and/or servers.\" The above sentence uses clear and straightforward language to define a protocol in the context of the AsyncAPI specification. An active voice to make the documentation more engaging and easier to understand. Example \"The Generator receives Template and params as input.\" (active) \"The input of Template and params is received by the Generator.\"(passive) From the above example sentences, the active voice is easier to understand than the passive. Inclusive in terms of language, meaning welcoming to all readers and avoidance of internet slang such as YMMV (your method may vary), IMO (in my opinion), etc. A voice that is accessible to both technical and non-technical audiences. Our Tone Remember While your voice remains constant, your tone may vary based on the audience's needs in certain contexts. At AsyncAPI, we consider our tone to be: Friendly and approachable, which puts the reader at ease. A helpful tone that addresses the reader's concerns or questions. An authoritative tone that establishes trust in the documentation and its authors. A consistent tone throughout the documentation to maintain coherence. Style Tips Here are a few key elements of writing AsyncAPI's voice: Use \"you\" to address the reader directly, e.g., \"You will be using the Eclipse Mosquitto broker.\" Use \"we\" to refer to the documentation authors, e.g., \"We recommend using the latest version of the AsyncAPI specification.\" Use short sentences and paragraphs to make the documentation easier to read and digest. Use headings, subheadings with proper hierarchy, and bullet points to break up texts and make them more scannable. Use examples and code snippets to illustrate concepts and provide practical guidance. Use contractions to make the language more conversational, e.g., \"You've now added a new section called servers in your AsyncAPI document.\" Go Back Inclusive Language style guide Up Next Punctuation style guide Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "a2984f71",
    "title": "Application | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/concepts/application.html",
    "content": "Application | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page What is an application? Why do we need applications? Applications: producers and consumers Application Found an error? Have a suggestion? Edit this page on GitHub What is an application? An application is a computer program or a group of them. An application can be a micro-service, IoT (Internet of things) device (for example, a sensor), mainframe process, and more. Users can create applications using various programming languages that support the chosen protocols. Why do we need applications? In Event-Driven Architecture (EDA), an application can either be a producer, a consumer, or both. Additionally, if an application wants to connect and exchange messages with the server, it must adhere to the protocols supported by the server. Applications: producers and consumers The diagram above illustrates a message transmission between a Producer application and a Consumer application through a channel. Go Back Channel Up Next Protocol Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "8db21e86",
    "title": "Introduction | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/concepts/asyncapi-document.html",
    "content": "Introduction | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets Introduction Found an error? Have a suggestion? Edit this page on GitHub The AsyncAPI Specification defines a set of fields that can be used in an AsyncAPI document to describe an application\u2019s API. While the document may reference other files for additional details or shared fields, it usually serves as a single, primary document that encapsulates the API description. Furthermore, the AsyncAPI document acts as a communication contract between receivers and senders within an event-driven system. It specifies the payload content necessary for a service to send a message and provides clear guidance to the receiver about the message's properties. \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: Cool Example\n4  version: 0.1.0\n5channels:\n6  userSignedUp:\n7    address: user/signedup\n8    messages:\n9      userSignedUp:\n10        description: An event describing that a user just signed up.\n11        payload:\n12          type: object\n13          properties:\n14            fullName:\n15              type: string\n16            email:\n17              type: string\n18              format: email\n19            age:\n20              type: integer\n21              minimum: 18\n22operations: \n23  userSignedUp:\n24    action: send\n25    channel: \n26      $ref: '#/channels/userSignedUp'\n```\n Remember Depending on the implemented protocol (such as MQTT, AMQP, Kafka, etc.), you may have additional fields in your AsyncAPI document. For example, for configuring Kafka bindings . Go Back Concepts - Message Up Next AsyncAPI document structure Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1asyncapi: 3.0.0\n2info:\n3  title: Cool Example\n4  version: 0.1.0\n5channels:\n6  userSignedUp:\n7    address: user/signedup\n8    messages:\n9      userSignedUp:\n10        description: An event describing that a user just signed up.\n11        payload:\n12          type: object\n13          properties:\n14            fullName:\n15              type: string\n16            email:\n17              type: string\n18              format: email\n19            age:\n20              type: integer\n21              minimum: 18\n22operations: \n23  userSignedUp:\n24    action: send\n25    channel: \n26      $ref: '#/channels/userSignedUp'"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "70fbf303",
    "title": "Channel | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/concepts/channel.html",
    "content": "Channel | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page What is a channel? Why do we need channels? Channel Found an error? Have a suggestion? Edit this page on GitHub What is a channel? A channel is a mechanism created by the server that facilitates the organization and transmission of messages. Depending on the used protocol, users can define channels as a topic , queue , routing key , path , or subject . Why do we need channels? Channels are pivotal for establishing communication between producers and consumers. They enable producers to send messages, while consumers receive messages from specific channels. The primary function of a channel is to ensure that the intended messages reach the appropriate consumers. The diagram above illustrates the communication process between a producer and a consumer. The producer sends a message through the channel, which then queues the message for delivery to the specific consumer. The diagram above illustrates the communication process between a producer and multiple consumers. The producer sends a message through the channel, which then queues the message for delivery to the appropriate consumers. Go Back Consumer Up Next Application Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "1bccb2ff",
    "title": "Consumer | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/concepts/consumer.html",
    "content": "Consumer | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page What is a consumer? Why do we need consumers? Consumer Found an error? Have a suggestion? Edit this page on GitHub What is a consumer? A consumer is an application that subscribes to a specific event from a broker and responds accordingly. Why do we need consumers? Unlike traditional REST APIs, in Event-Driven Architecture (EDA), event consumers are asynchronous, which means they are not required to respond immediately on the same connection. In this architecture, consumers are unaware of the producers or other consumers. All they know is that when a broker sends them an event, it is because they have subscribed to it. When you want your application to process events asynchronously, the consumer plays a crucial role in completing the event data flow through the event channel. The diagram above illustrates a sample flow of events from the producer to the broker to the consumers . In this scenario, the producer publishes two events (A and B) and sends them to the broker . Subsequently, each consumer subscribes to receive those events. Remember Subscribers can also be producers . Go Back Producer Up Next Channel Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "d8c1cf90",
    "title": "Message | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/concepts/message.html",
    "content": "Message | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page What is a message? Messages vs Events Message Found an error? Have a suggestion? Edit this page on GitHub What is a message? A message is a communication asset that transmits or exchanges information from a sender to the receiver through channels. One message can also be defined as an event or command and can be consumed by multiple independent receivers. The sender encodes a payload of data (serialized into a suitable format, such as JSON, XML, binary, or others) that requires processing by the receiver. Additionally, the message may include metadata , which is information that describes the message itself. This metadata is commonly referred to as headers or properties . The diagram above illustrates how a sender application transmits a message through a channel to a receiver application, demonstrating the basic flow of message-based communication. Messages vs Events A message conveys information between applications, while an event is a message that provides details of something that has already occurred. A crucial aspect to note is that depending on the type of information a message carries, it can either be an event, query, or command. Check the diagram below. Summing up, events are messages, but not all messages are events. Go Back Protocol Up Next AsyncAPI Document - Introduction Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "9826b9e8",
    "title": "Producer | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/concepts/producer.html",
    "content": "Producer | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page What is a Producer? Why do we need Producers? Producer Found an error? Have a suggestion? Edit this page on GitHub What is a Producer? A producer is an application that detects state changes ( events ) and publishes these events as messages. An event signifies a state change or update triggered by a user\u2019s or device\u2019s action. The following are sample events: Adding an item to a shopping cart on an e-commerce website. Clicking the subscribe button on a YouTube channel. Detecting a temperature change using a sensor. Why do we need Producers? The publish/subscribe communication model is one of the core concepts of event-driven architecture. In this model, producers are publishers, acting as the first logical layer responsible for distributing messages to the broker, enabling others to subscribe and receive these messages. The diagram above illustrates the communication flow between a producer who publishes events to a specific channel in a broker and a consumer who subscribes to the same channel. In some cases, an entity can simultaneously function as both a producer, publishing messages to a specific channel in the broker, and a consumer, subscribing to messages from a different channel in the broker. In the diagram above, there is a producer publishing messages to a specific channel and a consumer subscribing to messages from that channel. Also, there is a second producer publishing to one channel and subscribing to messages from another channel. Go Back Server Up Next Consumer Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "182eb075",
    "title": "Protocol | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/concepts/protocol.html",
    "content": "Protocol | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page What is a protocol? Why do we need protocols? Protocol Found an error? Have a suggestion? Edit this page on GitHub What is a protocol? A protocol is a set of rules that governs the exchange of information between applications and/or servers. Protocol examples: WebSockets HTTP Kafka MQTT Why do we need protocols? Protocols play a crucial role in message transmission. Whenever a producer detects a state change (events) and publishes those events as messages, a protocol carries those messages to the channel and then to the consumer. The diagram above illustrates the message exchange flow from producer to broker to consumer using the MQTT protocol with QoS0 (quality of service 0). In other words, the information transferred from the producer to broker to consumer is delivered at most once. The quality of service information rule is defined at the protocol level. Broker implementations and other involved parties must adhere to this rule. In AsyncAPI documents, all protocol-specific details that the application follows can be described using bindings . Go Back Application Up Next Message Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "a010cda3",
    "title": "Server | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/concepts/server.html",
    "content": "Server | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page What is a server? What is the purpose of servers? Clients and Server Broker Centric Server Found an error? Have a suggestion? Edit this page on GitHub What is a server? A server acts as a messaging broker system, establishing connections and facilitating communication between producers and consumers . Unlike traditional API servers that rely on request-response interactions, message broker interactions occur bidirectionally across various channels. What is the purpose of servers? Servers play a crucial role in establishing a connection between producers and consumers. In the context of designing and setting up an event-driven application, servers are responsible for delivering asynchronous messages from the producer to the consumers through the use of channels . Additionally, servers can integrate various messaging protocols to facilitate the transmission and exchange of messages between clients . Clients and Server The diagram above illustrates a bidirectional communication between one server and several clients. In this case, in your AsyncAPI file, you describe the server , so the Server Object holds information about the actual server, including its physical location. Broker Centric The diagram above illustrates the Broker-centric Architecture. In this case, there are three AsyncAPI files for the producer , consumer1 , and consumer2 . In these AsyncAPI files, the Server Object provides information about the broker , so that API users know where to connect to start receiving or sending messages. Go Back Overview Up Next Producer Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "5ab446c3",
    "title": "Add servers | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/concepts/asyncapi-document/add-server.html",
    "content": "Add servers | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Define servers Server reusability Channel only on specific server Add servers Found an error? Have a suggestion? Edit this page on GitHub A server often acts as a message broker, managing communication between producers and consumers. However, it can represent different concepts too. To understand this better, please first review our server concepts doc . Adding and defining servers is important because it specifies how and where connections are made, enabling the sending and receiving of messages. Unique keys identify the server and contain information about the server's connection details, such as the host, protocol, and authentication. Here is a diagram of server information with selected fields: The server is one of the main sections of the AsyncAPI document next to others like info , channels , or operations . Define servers Include server definitions in your AsyncAPI document to specify which server a channel or operation connects to. Here is an example of defining a server in AsyncAPI: \n```javascript\n1servers:\n2  prod:\n3    host: test.mosquitto.org\n4    protocol: mqtt\n5    description: Test MQTT server\n```\n The previous example shows a server setup using the MQTT protocol, where messages are sent to or received from the test.mosquitto.org host. Server reusability Add server definitions in a single location, such as components.servers , and then refer to them using the $ref keyword for easy reuse. Here's an example of an AsyncAPI document with two servers referenced from the components section: \n```javascript\n1servers:\n2  kafka-test:\n3    $ref: '#/components/servers/kafka-test'\n4  mqtt-test:\n5    $ref: '#/components/servers/mqtt-test'\n6components:\n7  servers:\n8    kafka-test:\n9      host: my.kafka.pl\n10      protocol: kafka-secure\n11      description: Test Kafka server\n12    mqtt-test:\n13      host: test.mosquitto.org\n14      protocol: mqtt\n15      description: Test MQTT server\n```\n In this example, the main servers section lists multiple servers with sharable definitions. You can also store these server definitions separately and use them across various AsyncAPI documents. Channel only on specific server Your AsyncAPI document can outline an application that receives messages on a channel from an MQTT server, while sending messages on a different channel via a Kafka server. This setup requires defining two servers, with each channel being exclusive to one server \u2013 one channel is only available on the MQTT server and the other only on the Kafka server. The AsyncAPI document describes this by adding a servers array to each channel, containing references to the respective server definitions. Here's an example of how to add a server reference to a channel: \n```javascript\n1servers:\n2  kafka-test:\n3    host: my.kafka.pl\n4    protocol: kafka-secure\n5    description: Test Kafka server\n6  mqtt-test:\n7    host: test.mosquitto.org\n8    protocol: mqtt\n9    description: Test MQTT server\n10channels:\n11  myChannel:\n12    servers:\n13      $ref: \"#/servers/mqtt-test\"\n14    message:\n15      $ref: '#/components/messages/myMessage'\n```\n In this example, the myChannel channel is only available on the mqtt-test server. Go Back Reusable parts Up Next Tutorials - Overview Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1servers:\n2  prod:\n3    host: test.mosquitto.org\n4    protocol: mqtt\n5    description: Test MQTT server",
      "1servers:\n2  kafka-test:\n3    $ref: '#/components/servers/kafka-test'\n4  mqtt-test:\n5    $ref: '#/components/servers/mqtt-test'\n6components:\n7  servers:\n8    kafka-test:\n9      host: my.kafka.pl\n10      protocol: kafka-secure\n11      description: Test Kafka server\n12    mqtt-test:\n13      host: test.mosquitto.org\n14      protocol: mqtt\n15      description: Test MQTT server",
      "1servers:\n2  kafka-test:\n3    host: my.kafka.pl\n4    protocol: kafka-secure\n5    description: Test Kafka server\n6  mqtt-test:\n7    host: test.mosquitto.org\n8    protocol: mqtt\n9    description: Test MQTT server\n10channels:\n11  myChannel:\n12    servers:\n13      $ref: \"#/servers/mqtt-test\"\n14    message:\n15      $ref: '#/components/messages/myMessage'"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "fb8a3ad3",
    "title": "Adding bindings | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/concepts/asyncapi-document/adding-bindings.html",
    "content": "Adding bindings | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Server bindings Channel bindings Message bindings Operation bindings Adding bindings Found an error? Have a suggestion? Edit this page on GitHub Bindings in AsyncAPI provide a way to add protocol-specific information to the AsyncAPI documentation. They can be added to different document parts, such as servers, channels, or messages; they specify standard details specific to a particular protocol. The purpose of bindings is to enhance the API's understanding and usage by providing additional context and configuration options for different protocols. The following diagram highlights the sections where bindings can be implemented: Server bindings Server bindings provide protocol-specific information related to the server configuration. For example, if you use Pulsar as your message broker, you can specify the tenant name in the server bindings. Here is a diagram explaining server bindings: This diagram shows where server bindings fit into the AsyncAPI document structure. The next example showcases how to use server bindings to detail protocol-specific configurations for the server: \n```javascript\n1servers:\n2  production:\n3    bindings:\n4      pulsar:\n5        tenant: contoso\n6        bindingVersion: '0.1.0'\n```\n The previous document shows how to set up server bindings for a server that is a Pulsar broker. Channel bindings Channel bindings are used to specify protocol-specific information for a specific channel. For example, in Kafka, you can specify number of partitions for a given topic. Here is a diagram explaining where channel bindings fit into the AsyncAPI document structure: Here is an example of using channel bindings to specify protocol-specific information for a specific channel: \n```javascript\n1channels:\n2  user-signedup:\n3    bindings:\n4      kafka:\n5        topic: 'my-specific-topic-name'\n6        partitions: 20\n7        replicas: 3\n8        topicConfiguration:\n9          cleanup.policy: [\"delete\", \"compact\"]\n10          retention.ms: 604800000\n11          retention.bytes: 1000000000\n12          delete.retention.ms: 86400000\n13          max.message.bytes: 1048588\n14        bindingVersion: '0.4.0'\n```\n The previous document shows how to configure channel bindings for a Kafka topic-representative channel. Message bindings Message bindings provide protocol-specific information for a specific message. For example, for the AMQP protocol, you can specify the message type in a protocol-specific notation. Here is a diagram explaining where message bindings fit into the AsyncAPI document structure: Here is an example of using message bindings to provide protocol-specific information for a specific message: \n```javascript\n1channels:\n2  userSignup:\n3    address: 'user/signup'\n4    messages:\n5      userSignupMessage:\n6        bindings:\n7          amqp:\n8            contentEncoding: gzip\n9            messageType: 'user.signup'\n10            bindingVersion: 0.3.0\n```\n The previous document shows how to set up message bindings for a message transported using the AMQP protocol. Operation bindings Operation bindings allow you to specify protocol-specific information for a specific operation. For example, for MQTT, you can specify the quality of the service for a given operation. Here is a diagram explaining where operation bindings fit into the AsyncAPI document structure: Here is an example of using operation bindings to specify protocol-specific information for a specific operation: \n```javascript\n1channels:\n2  user/signup:\n3operations:\n4  userSignup:\n5    action: receive\n6    bindings:\n7      mqtt:\n8        qos: 2\n9        retain: true\n10        bindingVersion: 0.2.0\n```\n The previous document shows how to set up operation bindings for an operation that describes how an application that uses MQTT as transport, receives the message. Using bindings helps you enhance the AsyncAPI documentation with protocol-specific details, making it easier to understand and implement the API. Go Back Extending specification Up Next Payload schema Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1servers:\n2  production:\n3    bindings:\n4      pulsar:\n5        tenant: contoso\n6        bindingVersion: '0.1.0'",
      "1channels:\n2  user-signedup:\n3    bindings:\n4      kafka:\n5        topic: 'my-specific-topic-name'\n6        partitions: 20\n7        replicas: 3\n8        topicConfiguration:\n9          cleanup.policy: [\"delete\", \"compact\"]\n10          retention.ms: 604800000\n11          retention.bytes: 1000000000\n12          delete.retention.ms: 86400000\n13          max.message.bytes: 1048588\n14        bindingVersion: '0.4.0'",
      "1channels:\n2  userSignup:\n3    address: 'user/signup'\n4    messages:\n5      userSignupMessage:\n6        bindings:\n7          amqp:\n8            contentEncoding: gzip\n9            messageType: 'user.signup'\n10            bindingVersion: 0.3.0",
      "1channels:\n2  user/signup:\n3operations:\n4  userSignup:\n5    action: receive\n6    bindings:\n7      mqtt:\n8        qos: 2\n9        retain: true\n10        bindingVersion: 0.2.0"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "facd1373",
    "title": "Adding channels | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/concepts/asyncapi-document/adding-channels.html",
    "content": "Adding channels | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Channel availability on specific servers Adding channels Found an error? Have a suggestion? Edit this page on GitHub Incorporating channels in the AsyncAPI document facilitates message organization and categorization, streamlining message routing to suitable consumers. It also enables the decoupling of producers and consumers, which contributes to the API's scalability and extensibility. Moreover, it offers comprehensive documentation and transparent communication about the API's communication patterns. Additionally, alternative names for channels can be user-defined to suit specific contexts and preferences. Here is an example of how to define channels: \n```javascript\n1userSignedUp:\n2  address: 'user.signedup'\n3  messages:\n4    userSignedUp:\n5      $ref: '#/components/messages/userSignedUp'\n```\n The previous AsyncAPI document sets up an interface for a userSignedUp channel, where the address field holds the actual address of the channel ( user.signedup ). Channel availability on specific servers When you add a channel to the AsyncAPI document, by default it is expected to be available on any server described in the document. In other words, if you have two servers, production-kafka-secure and development-kafka , the channel described in the AsyncAPI document must be present on both servers. It's possible to encounter a scenario where an AsyncAPI document describes an application communicating in a production environment through multiple servers, each utilizing distinct protocols. For example, the application might receive messages from a channel on an MQTT server while concurrently sending messages to a different channel on a Kafka server. In such cases, it's imperative to distinctly specify the exclusive availability of one channel on the MQTT server and another channel solely on the Kafka server. Here is an example of how you might specify that a channel is available only on specific servers: \n```javascript\n1channels:\n2  lightTurnOn:\n3    address: light.on\n4    messages:\n5      lightOn:\n6        description: An event describing that lights are on\n7    servers:\n8      - $ref: '#/servers/serverA'\n9  lightTurnOnOff:\n10    address: light/onoff\n11    messages:\n12      lightOnOff:\n13        description: An event describing that light is either on or off\n14    servers:\n15      - $ref: '#/servers/serverB'\n16servers:\n17  serverA:\n18    host: serverA.example.com\n19    protocol: kafka\n20  serverB:\n21    host: serverB.example.com\n22    protocol: mqtt\n```\n The above example shows two different channels available only on selected servers. Notice the servers field under each channel. It means that the lightTurnOn channel is only available on serverA which uses Kafka protocol, and the lightTurnOnOff channel is available only on serverB which uses MQTT protocol. Go Back Tags Up Next Parameters in channel address Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1userSignedUp:\n2  address: 'user.signedup'\n3  messages:\n4    userSignedUp:\n5      $ref: '#/components/messages/userSignedUp'",
      "1channels:\n2  lightTurnOn:\n3    address: light.on\n4    messages:\n5      lightOn:\n6        description: An event describing that lights are on\n7    servers:\n8      - $ref: '#/servers/serverA'\n9  lightTurnOnOff:\n10    address: light/onoff\n11    messages:\n12      lightOnOff:\n13        description: An event describing that light is either on or off\n14    servers:\n15      - $ref: '#/servers/serverB'\n16servers:\n17  serverA:\n18    host: serverA.example.com\n19    protocol: kafka\n20  serverB:\n21    host: serverB.example.com\n22    protocol: mqtt"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "afbe103e",
    "title": "Adding messages | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/concepts/asyncapi-document/adding-messages.html",
    "content": "Adding messages | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Add messages Channels section messages section Identifier of the message Messages under operations Adding messages Found an error? Have a suggestion? Edit this page on GitHub In an AsyncAPI document, adding messages mainly means setting up channels and operations. This is key for explaining how data moves between your applications. However, sometimes you might just want to use the AsyncAPI document to describe the messages themselves, without anything else. Add messages In an AsyncAPI document, you define message definitions under channels. However, the best practice is to first define these messages under the 'components' section as reusable definitions. That way, you can reference them easily from a channel. Here is a diagram showing some channel fields and the relation between channel messages and components messages: Channels section Define the channels section in your AsyncAPI document, including the messages your channel accepts. For example: \n```javascript\n1channels:\n2  allCommentsLiked:\n3    address: comment/liked\n4    messages:\n5      commentLiked:\n6        description: Message that is being sent when a comment has been liked by someone.\n7        payload:\n8           type: object\n9           title: commentLikedPayload\n10           additionalProperties: false\n11           properties:\n12               commentId: \n13                 type: string\n14                 description: Id of the comment that was liked\n15    description: Notification channel for all the services that need to know comment is liked.\n```\n The above example presents an application that communicates over the allCommentsLiked channel, which only accepts one message called commentLiked . messages section In your AsyncAPI document, create a components.messages section to define each message your application uses as a reusable message. When setting up multiple channels, you won't have to repeat the same message definitions. For example: \n```javascript\n1components:\n2  messages:\n3    commentLiked:\n4        description: Message that is being sent when a comment has been liked by someone.\n5        payload:\n6           type: object\n7           title: commentLikedPayload\n8           additionalProperties: false\n9           properties:\n10               commentId: \n11                 type: string\n12                 description: Id of the comment that was liked\n```\n You can reuse messages using the Reference Object . For example: \n```javascript\n1    messages:\n2      commentLiked:\n3        $ref: '#/components/messages/commentLiked'\n```\n Here's the complete AsyncAPI document with channels reusing the same message: \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: Example API\n4  version: '1.0.0'\n5channels:\n6  allCommentsLiked:\n7    address: comment/liked\n8    messages:\n9      commentLiked:\n10        $ref: '#/components/messages/commentLikedUnliked'\n11    description: Notification channel for all the services that need to know comment is liked.\n12  allCommentUnliked:\n13    address: comment/unliked\n14    messages:\n15      commentUnliked:\n16        $ref: '#/components/messages/commentLikedUnliked'\n17    description: Notification channel for all the services that need to know comment is liked.\n18components:\n19  messages:\n20    commentLikedUnliked:\n21        description: Message that is being sent when a comment has been liked or unliked by someone.\n22        payload:\n23           type: object\n24           title: commentInfoPayload\n25           additionalProperties: false\n26           properties:\n27               commentId: \n28                 type: string\n29                 description: Id of the comment that was liked or unliked\n```\n Identifier of the message The key name that represents a message in your AsyncAPI document must be interpreted as messageId . If your document defines channels, the message key defined in the channel is the messageId . \n```javascript\n1channels:\n2  allCommentsLiked:\n3    address: comment/liked\n4    messages:\n5      commentLiked:\n6        $ref: '#/components/messages/commentLikedUnliked'\n7    description: Notification channel for all the services that need to know comment is liked.\n```\n The above example shows a commentLiked message under the allCommentsLiked channel. It references a reusable message definition from the components section represented by the commentLikedUnliked key. In this setup, the commentLiked key is the messageId and not commentLikedUnliked . Messages under operations Operations specify which channels they interact with. If a channel has several messages, but your operation only involves one, indicate which specific message the operation uses. \n```javascript\n1channels:\n2  allComments:\n3    address: comments\n4    messages:\n5      commentLiked:\n6        $ref: '#/components/messages/commentLikedMsg'\n7      commentUnliked:\n8        $ref: '#/components/messages/commentUnlikedMsg'\n9    description: Notification channel for all the services that need to know comment is liked.\n10operations:\n11  onCommentLiked:\n12    action: receive\n13    channel:\n14      $ref: '#/channels/allComments'\n15    messages:\n16      - $ref: '#/channels/allComments/messages/commentLiked'\n```\n The above example demonstrates how to specify the message for the onCommentsLiked operation received from the allCommentLiked channel. It's important to note that the message reference points to the channel, not the components section. That ensures accurate information about the messageId , which in this case is commentLiked , not commentLikedMsg . Go Back Operation security Up Next Reusability with traits Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1channels:\n2  allCommentsLiked:\n3    address: comment/liked\n4    messages:\n5      commentLiked:\n6        description: Message that is being sent when a comment has been liked by someone.\n7        payload:\n8           type: object\n9           title: commentLikedPayload\n10           additionalProperties: false\n11           properties:\n12               commentId: \n13                 type: string\n14                 description: Id of the comment that was liked\n15    description: Notification channel for all the services that need to know comment is liked.",
      "1components:\n2  messages:\n3    commentLiked:\n4        description: Message that is being sent when a comment has been liked by someone.\n5        payload:\n6           type: object\n7           title: commentLikedPayload\n8           additionalProperties: false\n9           properties:\n10               commentId: \n11                 type: string\n12                 description: Id of the comment that was liked",
      "1    messages:\n2      commentLiked:\n3        $ref: '#/components/messages/commentLiked'",
      "1asyncapi: 3.0.0\n2info:\n3  title: Example API\n4  version: '1.0.0'\n5channels:\n6  allCommentsLiked:\n7    address: comment/liked\n8    messages:\n9      commentLiked:\n10        $ref: '#/components/messages/commentLikedUnliked'\n11    description: Notification channel for all the services that need to know comment is liked.\n12  allCommentUnliked:\n13    address: comment/unliked\n14    messages:\n15      commentUnliked:\n16        $ref: '#/components/messages/commentLikedUnliked'\n17    description: Notification channel for all the services that need to know comment is liked.\n18components:\n19  messages:\n20    commentLikedUnliked:\n21        description: Message that is being sent when a comment has been liked or unliked by someone.\n22        payload:\n23           type: object\n24           title: commentInfoPayload\n25           additionalProperties: false\n26           properties:\n27               commentId: \n28                 type: string\n29                 description: Id of the comment that was liked or unliked",
      "1channels:\n2  allCommentsLiked:\n3    address: comment/liked\n4    messages:\n5      commentLiked:\n6        $ref: '#/components/messages/commentLikedUnliked'\n7    description: Notification channel for all the services that need to know comment is liked.",
      "1channels:\n2  allComments:\n3    address: comments\n4    messages:\n5      commentLiked:\n6        $ref: '#/components/messages/commentLikedMsg'\n7      commentUnliked:\n8        $ref: '#/components/messages/commentUnlikedMsg'\n9    description: Notification channel for all the services that need to know comment is liked.\n10operations:\n11  onCommentLiked:\n12    action: receive\n13    channel:\n14      $ref: '#/channels/allComments'\n15    messages:\n16      - $ref: '#/channels/allComments/messages/commentLiked'"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "5cc749b0",
    "title": "Adding operations | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/concepts/asyncapi-document/adding-operations.html",
    "content": "Adding operations | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Defining operations Adding operations Adding operations Found an error? Have a suggestion? Edit this page on GitHub In a messaging system, 'operations' are how messages are sent and received between participants or components. In AsyncAPI, understanding operations helps you see how the system sends asynchronous messages back and forth without waiting for responses. They serve as a vital tool, aiding users in comprehending the range of tasks and functionalities that the API is capable of performing. In an AsyncAPI document, operations describe your application's behaviors and capabilities by exchanging messages through channels configured in the AsyncAPI document. An operation represents a particular action or interaction that can be performed. The purpose of operations is to provide a standardized means for describing the process of sending, receiving from, requesting, or replying to messages within the messaging system. Defining operations Operations can be defined as an independent object in the AsyncAPI document. More information about each field name that is used to define operations can be found in the reference documentation of the specification . The following diagram declares the field names that are frequently used to define operations in an AsyncAPI document: Adding operations In the AsyncAPI document, 'operations' are distinct fields located at the root level of the document, alongside 'channels' and other key fields. Operations must specify on what channel they are performed by referencing the channel with $ref . For example: \n```javascript\n1onUserSignUp:\n2  title: User sign up\n3  summary: React and process information about new user sign up.\n4  description: Process information about user sign up and update the information in the table that counts numbers of currently signed up users.\n5  action: receive\n6  channel:\n7    $ref: '#/channels/userSignup'\n```\n The operation definition mentioned above gives the details needed for the application to send a message. Its 'title' and 'summary' clearly show that it's about receiving an event when a new user signs up to the system. Some fields are missing from this example: No messages field means that this operation processes any message coming from the userSignup channel. No security field means that there are no special security measures related to this operation and that the security should be applied the same as for other operations. Essentially, the security from the server level should be respected. No reply field means that after reacting to the user sign up, this application will not send any reply as a reaction. Go Back Parameters in channel address Up Next Operation security Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1onUserSignUp:\n2  title: User sign up\n3  summary: React and process information about new user sign up.\n4  description: Process information about user sign up and update the information in the table that counts numbers of currently signed up users.\n5  action: receive\n6  channel:\n7    $ref: '#/channels/userSignup'"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "48be1131",
    "title": "Payload schema | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/concepts/asyncapi-document/define-payload.html",
    "content": "Payload schema | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Define schema Attach examples Reuse schemas between messages Schema formats Schema formats and limitations related to their structures Payload schema Found an error? Have a suggestion? Edit this page on GitHub The payload schema sets the format, data types, and properties of a message. Such an approach ensures the message's payload follows a specific structure and data format. It's recommended to use AsyncAPI Schema (a superset of JSON Schema) for handling complex messages and structured data. AsyncAPI Schema helps consumers understand the payload's structure and data types. However, AsyncAPI allows any schema format. For example, when using the Avro schema format, define your message payload in Avro directly instead of trying to represent it in JSON Schema format. Define schema Define the schema for the message payload with one of the following methods: Inline: Define the JSON schema within the message payload property. Components reference: Specify the schema using a reference to the components.schemas section, such as $ref: '#/components/schemas/user . Remote reference: Specify the schema using an absolute remote endpoint, such as $ref: 'https://schemas.example.com/user' . Local file reference: Specify the schema using a relative reference, such as $ref: './user-signedup.json' . The diagram below describes how payload referencing works within the component reference: Here is an example of an AsyncAPI document where the payload's schema is defined directly within it: \n```javascript\n1channels:\n2  exampleChannel:\n3    address: exampleChannel\n4    messages:\n5      SimpleSignup:\n6        payload:\n7          type: object\n8          properties:\n9            name:\n10              type: string\n11            email:\n12              type: string\n```\n Attach examples Although optional, attaching examples to the AsyncAPI document is highly recommended. You can use JSON or YAML format for binary encodings. Attach the examples to the examples property within the message payload definition. For example: \n```javascript\n1examples:\n2  - name: SimpleSignup\n3    summary: A simple UserSignup example message\n4    payload:\n5      user:\n6        name: Demo\n7        email: demo@demo.io\n```\n Reuse schemas between messages To reuse a schema in your AsyncAPI document, define it in the components/schemas section and reference it using the $ref keyword. Using $ref avoids duplication and ensures consistency. Here's an example of reusing a schema from components in AsyncAPI: \n```javascript\n1components:\n2  messages:\n3    SimpleSignup:\n4      name: SimpleSignup\n5      contentType: application/json\n6      payload:\n7        $ref: '#/components/schemas/SimpleSignup'\n8    examples:\n9    - name: SimpleSignup\n10      payload: \n11        user:\n12          name: Demo\n13          email: demo@demo.io\n14  schemas:\n15    SimpleSignup:\n16      type: object\n17      properties:\n18        name:\n19          type: string\n20        email:\n21          type: string\n```\n Schema formats The default schema in an AsyncAPI document is the AsyncAPI schema itself. However, you can choose from other formats like JSON Schema, Avro, OpenAPI Schema, Protobuf, and more. Remember to indicate in your AsyncAPI document which schema format you're using. You specify the format of the schema inside the payload field. The type of information you can put in payload can be described as a tuple. (A tuple is an ordered sequence of elements that can't be changed during a program's execution.) When using AsyncAPI Schema, the payload must represent a reference or the payload schema definition as described in previous sections. If you're using various formats, the payload field should include both payload.schemaFormat and payload.schema . For example: \n```javascript\n1  payload:\n2    schemaFormat: application/vnd.apache.avro;version=1.9.0\n3    schema:\n4      $ref: \"https://www.asyncapi.com/resources/casestudies/adeo/CostingRequestPayload.avsc\"\n```\n The above example specifies that the provided schema of the message payload is in Avro, version 1.9.0. It also specifies where the Avro schema file is located. Schema formats and limitations related to their structures Some schema formats are too challenging to manage in JSON/YAML. Complex schema formats \u2014 Avro, AsyncAPI schemas, and other JSON-based schemas \u2014 can be directly included in the AsyncAPI document or referenced using $ref for specific sections. \n```javascript\n1    payload:\n2        schemaFormat: 'application/vnd.apache.avro;version=1.9.0'\n3        schema: # The following is an Avro schema in YAML format (JSON format is also supported)\n4          type: record\n5          name: User\n6          namespace: com.company\n7          doc: User information\n8          fields:\n9            - name: displayName\n10              type: string\n11            - name: email\n12              type: string\n13            - name: age\n14              type: int\n```\n The process is more complex for Protobuf schemas, as their Protocol Buffers are not JSON-based. You cannot use $ref to reference parts of the schema. Instead, you must include the entire Protobuf schema definition as a string: \n```javascript\n1      payload:\n2        schemaFormat: application/vnd.google.protobuf;version=3\n3        schema: |\n4            message Point {\n5                required int32 x = 1;\n6                required int32 y = 2;\n7                optional string label = 3;\n8            }\n9\n10            message Line {\n11                required Point start = 1;\n12                required Point end = 2;\n13                optional string label = 3;\n14            }\n```\n Go Back Adding bindings Up Next Server variables Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1channels:\n2  exampleChannel:\n3    address: exampleChannel\n4    messages:\n5      SimpleSignup:\n6        payload:\n7          type: object\n8          properties:\n9            name:\n10              type: string\n11            email:\n12              type: string",
      "1examples:\n2  - name: SimpleSignup\n3    summary: A simple UserSignup example message\n4    payload:\n5      user:\n6        name: Demo\n7        email: demo@demo.io",
      "1components:\n2  messages:\n3    SimpleSignup:\n4      name: SimpleSignup\n5      contentType: application/json\n6      payload:\n7        $ref: '#/components/schemas/SimpleSignup'\n8    examples:\n9    - name: SimpleSignup\n10      payload: \n11        user:\n12          name: Demo\n13          email: demo@demo.io\n14  schemas:\n15    SimpleSignup:\n16      type: object\n17      properties:\n18        name:\n19          type: string\n20        email:\n21          type: string",
      "1  payload:\n2    schemaFormat: application/vnd.apache.avro;version=1.9.0\n3    schema:\n4      $ref: \"https://www.asyncapi.com/resources/casestudies/adeo/CostingRequestPayload.avsc\"",
      "1    payload:\n2        schemaFormat: 'application/vnd.apache.avro;version=1.9.0'\n3        schema: # The following is an Avro schema in YAML format (JSON format is also supported)\n4          type: record\n5          name: User\n6          namespace: com.company\n7          doc: User information\n8          fields:\n9            - name: displayName\n10              type: string\n11            - name: email\n12              type: string\n13            - name: age\n14              type: int",
      "1      payload:\n2        schemaFormat: application/vnd.google.protobuf;version=3\n3        schema: |\n4            message Point {\n5                required int32 x = 1;\n6                required int32 y = 2;\n7                optional string label = 3;\n8            }\n9\n10            message Line {\n11                required Point start = 1;\n12                required Point end = 2;\n13                optional string label = 3;\n14            }"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "4cf66e90",
    "title": "Parameters in channel address | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/concepts/asyncapi-document/dynamic-channel-address.html",
    "content": "Parameters in channel address | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Add parameters Channels section parameters section Parameters in channel address Found an error? Have a suggestion? Edit this page on GitHub In the context of channel addresses within AsyncAPI documents, parameters play a crucial role in defining the dynamic components of an address. That aspect is particularly beneficial in setups like IoT, where topics are often assigned per device or device segment. In this scenario, your AsyncAPI document would describe a system composed of multiple channels. While these channels share the same definition, messages, and purpose, they differ in their channel addresses, which vary according to each device's identifier. To efficiently manage this setup, you provide a singular channel definition. The dynamic segment of each channel address, which corresponds to the device identifier, is then articulated through the use of parameters. Add parameters You can add parameters to the channel.address by adding a parameter between curly braces like {braces} . Next, use channel.parameters to define your parameters. Finally, leverage the components.parameters to enable reusable parameters' definitions across multiple channels. The diagram below describes how to use reusable parameters in AsyncAPI. First, configure the variables in address . Next, define reusable variables in components.parameters . Finally, ensure that your channel.parameters references definitions in the components.parameters using $ref . Channels section Here is an example of a parametrized channel address: \n```javascript\n1  lightingMeasured:\n2    address: 'smartylighting/streetlights/1/0/event/{streetlightId}/lighting/measured'\n3    description: The topic on which measured values may be produced and consumed.\n4    parameters:\n5      streetlightId:\n6        description: The ID of the streetlight.\n```\n In the above example, you can see a definition of a lightingMeasured channel that contains a streetlight parameter. During runtime, there can be two or more channels serving the same purpose, but with different devices. For example, you could have channels for smartylighting/streetlights/1/0/event/2/lighting/measured and smartylighting/streetlights/1/0/event/1/lighting/measured . parameters section In your AsyncAPI document, it's important to carefully define the components.parameters section. For each parameter utilized in the channel address , provide a comprehensive description along with other pertinent details. Avoid repeating the parameter definitions. For example: \n```javascript\n1components:\n2  parameters:\n3    streetlightId:\n4      description: The ID of the streetlight.\n```\n You can reuse parameters using the Reference Object like in the following example: \n```javascript\n1    parameters:\n2      streetlightId:\n3        $ref: '#/components/parameters/streetlightId'\n```\n Here's the complete AsyncAPI document with the channels' parameters for the address field: \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: Example API\n4  version: '1.0.0'\n5channels:\n6  lightingMeasured:\n7    address: 'smartylighting/streetlights/1/0/event/{streetlightId}/lighting/measured'\n8    description: The topic on which measured values may be produced and consumed.\n9    parameters:\n10      streetlightId:\n11        $ref: '#/components/parameters/streetlightId'\n12components:\n13  parameters:\n14    streetlightId:\n15      description: The ID of the streetlight.\n```\n Go Back Adding channels Up Next Adding operations Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1  lightingMeasured:\n2    address: 'smartylighting/streetlights/1/0/event/{streetlightId}/lighting/measured'\n3    description: The topic on which measured values may be produced and consumed.\n4    parameters:\n5      streetlightId:\n6        description: The ID of the streetlight.",
      "1components:\n2  parameters:\n3    streetlightId:\n4      description: The ID of the streetlight.",
      "1    parameters:\n2      streetlightId:\n3        $ref: '#/components/parameters/streetlightId'",
      "1asyncapi: 3.0.0\n2info:\n3  title: Example API\n4  version: '1.0.0'\n5channels:\n6  lightingMeasured:\n7    address: 'smartylighting/streetlights/1/0/event/{streetlightId}/lighting/measured'\n8    description: The topic on which measured values may be produced and consumed.\n9    parameters:\n10      streetlightId:\n11        $ref: '#/components/parameters/streetlightId'\n12components:\n13  parameters:\n14    streetlightId:\n15      description: The ID of the streetlight."
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "258a6404",
    "title": "Extending specification | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/concepts/asyncapi-document/extending-specification.html",
    "content": "Extending specification | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Specification extensions Extending unsupported features Extending specification Found an error? Have a suggestion? Edit this page on GitHub Extending the AsyncAPI specification allows you to include specific information for your domain or use case that's not currently supported by the original specification or the protocol bindings. Extension capability allows for customization, making it possible to integrate unique aspects into APIs that the standard AsyncAPI specification doesn't normally accommodate. Specification extensions The AsyncAPI Specification allows the addition of custom properties through patterned fields prefixed with an x- . That way, you can create unique things without causing problems in future updates. The x- prefix is used to define custom properties. These properties are user-defined and won't conflict with future specification versions because any property starting with x- is reserved for user definitions. Extensions can be used in any part of the AsyncAPI document. Here is an example of how to extend the AsyncAPI document with a custom property: \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: Cool Example\n4  version: 0.1.0\n5  x-linkedin: '/company/asyncapi'\n```\n The above document shows an info object extended with custom information about a company's LinkedIn account that owns the application. Custom information is represented via a custom property called x-linkedin . Remember AsyncAPI tools might not support AsyncAPI extensions. Our tools can be extended to understand and handle the added data, especially if the tools are internal or open source. Extending unsupported features If you need a feature not covered by the AsyncAPI specification, you can create an extension for it. Should this extension be useful to others, consider contributing it back to the AsyncAPI community. You can do this by opening a spec issue in the AsyncAPI GitHub repository. Before contributing, review the AsyncAPI contribution guidelines . Go Back Adding reply info Up Next Adding bindings Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1asyncapi: 3.0.0\n2info:\n3  title: Cool Example\n4  version: 0.1.0\n5  x-linkedin: '/company/asyncapi'"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "7c5bbe9e",
    "title": "Adding reply info | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/concepts/asyncapi-document/reply-info.html",
    "content": "Adding reply info | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Dynamic response channel Multiple channels with single message when reply address is known Multiple messages over the same channel when reply address is known Adding reply info Found an error? Have a suggestion? Edit this page on GitHub Request/Reply is a communication pattern where one entity, the 'requestor,' sends a message to another, the 'replier', and waits for a response. Such a pattern is used when a component (or service) needs to initiate an action and receive a specific response in return, either synchronously or asynchronously. In Event-Driven Architectures, this communication pattern is asynchronous, meaning that the requester does not block and wait for an immediate response. Instead, it can continue processing other tasks or even send out other requests while waiting for the reply to arrive. In the case of multiple requests made, each request is processed independently and sends the reply/response to the corresponding requestor when ready. Here is diagram to illustrate the working of a basic request/reply pattern: The request/reply pattern in AsyncAPI works in the same fashion while supporting all the different sub-patterns. Irrespective of the sub-pattern you would like to represent, the request/reply pattern can be implemented in the AsyncAPI document in the Operation object. You can add the reply info using the Operation Reply object under the Operation object. The reply field represents the response details. In AsyncAPI, you have the flexibility to represent the request/reply pattern in two different ways. The first approach is when the requester specifies at runtime, within the request itself, where the response should be sent. Such an approach allows for the dynamic determination of the reply address based on factors such as the request message payload or header. The second approach is when the requester already knows exactly where the response should be sent. In such cases, the address of the reply channel is directly specified in the AsyncAPI document. Dynamic response channel There are situations where you do not know the reply channel at the design time. Instead, the reply address is dynamically determined at runtime, based on factors such as the request message payload or header. In the case where you don't know the address of the reply yet, you have the option to either assign null to the address property or omit the property entirely indicating that the address is not known at the moment. The address property being referred to in this case is part of the channel that the operation with the reply references to. To dynamically specify where the reply should be sent, you can use the Operation Reply Address object. The Operation Reply Address object has a property called location that allows you to define a runtime expression that specifies the address of the reply channel. For instance, this pattern allows the replier to direct its response to a specific channel as defined by the requestor. This is typically achieved by including a replyTo property in the request header. The requestor specifies this property to indicate where it expects to receive the response, guiding the communication flow in a structured and predictable manner. \n```javascript\n1asyncapi: 3.0.0\n2\n3info:\n4  title: Ping/pong example for a requester with a dynamic reply channel\n5  version: 1.0.0\n6  description: Example with a requester that initiates a request/reply interaction, with the response directed to the destination specified in the request's `replyTo` header.\n7\n8channels:\n9  ping:\n10    address: /ping\n11    messages:\n12      ping:\n13        $ref: '#/components/messages/ping'\n14  pong:\n15    address: null\n16    messages:\n17      pong:\n18        $ref: '#/components/messages/pong'\n19\n20operations:\n21  pingRequest:\n22    action: send\n23    channel: \n24      $ref: '#/channels/ping'\n25    reply:\n26      address:\n27        description: The response destination is dynamically set according to the `replyTo` field in the request header\n28        location: \"$message.header#/replyTo\"\n29      channel: \n30        $ref: '#/channels/pong'\n```\n Multiple channels with single message when reply address is known The request/reply pattern can also be implemented over multiple channels with a single message. You can do this by specifying multiple channels with a single message and specifying the same address for both the requester and the replier. Here's an example of setting up both the requestor and replier over the same address: \n```javascript\n1asyncapi: 3.0.0\n2\n3info:\n4  title: Ping/pong example with requester over the same channel\n5  version: 1.0.0\n6  description: Requester example initiating a request-reply interaction, utilizing the same channel for both sending the request and receiving the reply.\n7\n8channels:\n9  ping:\n10    address: /\n11    messages:\n12      ping:\n13        $ref: '#/components/messages/ping'\n14  pong:\n15    address: /\n16    messages:\n17      pong:\n18        $ref: '#/components/messages/pong'\n19\n20operations:\n21  pingRequest:\n22    action: send\n23    channel: \n24      $ref: '#/channels/ping'\n25    reply:\n26      channel: \n27        $ref: '#/channels/pong'\n```\n Multiple messages over the same channel when reply address is known In some cases, representing the same information might require a different approach. You can do so by specifying multiple messages under the same channel. In such scenarios, use the messages property in the Operation object to explicitly define which message among the multiple messages available over the same channel is a request and which is a reply. Consider an example where multiple messages are transmitted over a single channel, all sharing the same address. In this setup, the Operation object is utilized to distinctly specify which of these messages serves as the request and which functions as the reply: \n```javascript\n1asyncapi: 3.0.0\n2\n3info:\n4  title: Ping/pong example when a channel contains multiple messages\n5  version: 1.0.0\n6  description: Requester example that initiates the request-reply pattern within a root channel that contains multiple messages\n7\n8channels:\n9  rootChannel:\n10    address: /\n11    messages:\n12      ping:\n13        $ref: '#/components/messages/ping'\n14      pong:\n15        $ref: '#/components/messages/pong'\n16\n17operations:\n18  pingRequest:\n19    action: send\n20    channel: \n21      $ref: '#/channels/rootChannel'\n22    messages:\n23      - $ref: \"/components/messages/ping\"\n24    reply:\n25      messages:\n26        - $ref: \"/components/messages/pong\"\n27      channel: \n28        $ref: '#/channels/rootChannel'\n```\n Go Back Server security Up Next Extending specification Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1asyncapi: 3.0.0\n2\n3info:\n4  title: Ping/pong example for a requester with a dynamic reply channel\n5  version: 1.0.0\n6  description: Example with a requester that initiates a request/reply interaction, with the response directed to the destination specified in the request's `replyTo` header.\n7\n8channels:\n9  ping:\n10    address: /ping\n11    messages:\n12      ping:\n13        $ref: '#/components/messages/ping'\n14  pong:\n15    address: null\n16    messages:\n17      pong:\n18        $ref: '#/components/messages/pong'\n19\n20operations:\n21  pingRequest:\n22    action: send\n23    channel: \n24      $ref: '#/channels/ping'\n25    reply:\n26      address:\n27        description: The response destination is dynamically set according to the `replyTo` field in the request header\n28        location: \"$message.header#/replyTo\"\n29      channel: \n30        $ref: '#/channels/pong'",
      "1asyncapi: 3.0.0\n2\n3info:\n4  title: Ping/pong example with requester over the same channel\n5  version: 1.0.0\n6  description: Requester example initiating a request-reply interaction, utilizing the same channel for both sending the request and receiving the reply.\n7\n8channels:\n9  ping:\n10    address: /\n11    messages:\n12      ping:\n13        $ref: '#/components/messages/ping'\n14  pong:\n15    address: /\n16    messages:\n17      pong:\n18        $ref: '#/components/messages/pong'\n19\n20operations:\n21  pingRequest:\n22    action: send\n23    channel: \n24      $ref: '#/channels/ping'\n25    reply:\n26      channel: \n27        $ref: '#/channels/pong'",
      "1asyncapi: 3.0.0\n2\n3info:\n4  title: Ping/pong example when a channel contains multiple messages\n5  version: 1.0.0\n6  description: Requester example that initiates the request-reply pattern within a root channel that contains multiple messages\n7\n8channels:\n9  rootChannel:\n10    address: /\n11    messages:\n12      ping:\n13        $ref: '#/components/messages/ping'\n14      pong:\n15        $ref: '#/components/messages/pong'\n16\n17operations:\n18  pingRequest:\n19    action: send\n20    channel: \n21      $ref: '#/channels/rootChannel'\n22    messages:\n23      - $ref: \"/components/messages/ping\"\n24    reply:\n25      messages:\n26        - $ref: \"/components/messages/pong\"\n27      channel: \n28        $ref: '#/channels/rootChannel'"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "9500ce48",
    "title": "Reusability with traits | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/concepts/asyncapi-document/reusability-with-traits.html",
    "content": "Reusability with traits | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Defining traits Applying traits from components Trait merging mechanism Reusability with traits Found an error? Have a suggestion? Edit this page on GitHub Traits work only with the operations and messages fields. Traits allow the definition of properties to be reused across multiple messages and operations within the specification. Reusing traits promotes code maintainability and reduces duplication while making your AsyncAPI documents cleaner to manage. Defining traits Traits are meant to be reused, so it's best to define them in the components section of your AsyncAPI document, either under operationTraits or messageTraits . Choose depending on whether they're for operations or messages. Give each trait a unique name and list the properties it includes. You can reference these traits with the $ref keyword, allowing you to keep traits in a separate file outside the AsyncAPI document. For more on using $ref and reusability, check out the reusable parts document . Message traits do not fully cover all fields that a normal message has, such as the payload . The same is true with Operation traits which represent only selected fields usually used in an operation. Here is a part of a message that has a trait defined inline in a message: \n```javascript\n1description: Example description.\n2traits:\n3  - name: UserSignup\n4    description: Trait description.\n5  - tags:\n6      - name: user\n```\n When traits are combined with a message object, the resulting message will look like the example shown below: \n```javascript\n1name: UserSignup\n2description: Example description.\n3tags:\n4  - name: user\n```\n Notice that the trait description didn't override the already defined description in a message outside the trait. Applying traits from components Once a trait is defined, you can apply it to an operation or a message using the $ref keyword in the traits section. The $ref value should point to the path of the trait within the components section. For example, let's say we have a trait named commonHeaders defined in messageTraits : \n```javascript\n1components:\n2  messageTraits:\n3    commonHeaders:\n4      headers:\n5        type: object\n6        properties:\n7          content-type:\n8            type: integer\n```\n To apply the above trait to a message object, you can do: \n```javascript\n1name: lightMeasured\n2title: Light measured\n3summary: Inform about environmental lighting conditions of a particular streetlight.\n4headers:\n5  type: object\n6  properties:\n7    custom-header:\n8      type: string\n9traits:\n10  - $ref: '#/components/messageTraits/commonHeaders'\n```\n Notice how the commonHeaders trait includes a content-type header and is merged into the headers object in a message: \n```javascript\n1name: lightMeasured\n2title: Light measured\n3summary: Inform about environmental lighting conditions of a particular streetlight.\n4headers:\n5  type: object\n6  properties:\n7    content-type:\n8      type: integer\n9    custom-header:\n10      type: string\n```\n Trait merging mechanism In the AsyncAPI document, traits are merged into the operation or message object in the order they are defined, without overriding any properties. For detailed information on how this merging works, refer to the specification's section on the traits merge mechanism . Go Back Adding messages Up Next Server security Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1description: Example description.\n2traits:\n3  - name: UserSignup\n4    description: Trait description.\n5  - tags:\n6      - name: user",
      "1name: UserSignup\n2description: Example description.\n3tags:\n4  - name: user",
      "1components:\n2  messageTraits:\n3    commonHeaders:\n4      headers:\n5        type: object\n6        properties:\n7          content-type:\n8            type: integer",
      "1name: lightMeasured\n2title: Light measured\n3summary: Inform about environmental lighting conditions of a particular streetlight.\n4headers:\n5  type: object\n6  properties:\n7    custom-header:\n8      type: string\n9traits:\n10  - $ref: '#/components/messageTraits/commonHeaders'",
      "1name: lightMeasured\n2title: Light measured\n3summary: Inform about environmental lighting conditions of a particular streetlight.\n4headers:\n5  type: object\n6  properties:\n7    content-type:\n8      type: integer\n9    custom-header:\n10      type: string"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "e1a2c54b",
    "title": "Reusable parts | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/concepts/asyncapi-document/reusable-parts.html",
    "content": "Reusable parts | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Same document Another local file External URL Reusable parts Found an error? Have a suggestion? Edit this page on GitHub Reusable parts in AsyncAPI provide flexibility, modularity, and code reusability. You can reuse the majority of document sections like messages, schema definitions, channels, operations, and more. Reusable parts allow you to split up the AsyncAPI document into many files and reference them using the Reference Object . You can use the $ref keyword to reference the same document, another local file, or an external URL. The diagram below describes how to reuse parts in AsyncAPI: Same document You can use the $ref keyword to reference a component in an AsyncAPI document. In the example below, you define a component called MyMessageSchema under the schemas section to describe the structure of a message. Under the myChannel channel, you have a message with a payload definition that's represented as a reference to the MyMessageSchema schema via the $ref keyword. \n```javascript\n1channels:\n2  myChannel:\n3    message:\n4      myMessage:\n5        payload:\n6          $ref: '#/components/schemas/MyMessageSchema'\n7components:\n8  schemas:\n9    MyMessageSchema:\n10      type: object\n11      properties:\n12        message:\n13          type: string\n```\n Another local file You can reference another local document using the $ref keyword. Ensure the path to the local file is correct and accessible from your main AsyncAPI document. In the code below, you reference the component from another local document, such as message-schema.yaml . \n```javascript\n1UserSignup:\n2  name: UserSignup\n3  title: User signup\n4  summary: Action to sign a user up.\n5  description: A longer description\n6  contentType: application/json\n7  payload: null\n```\n In the code below, you use another local document, message-schema.yaml , through a reference inside the AsyncAPI document. \n```javascript\n1channels:\n2  signUp:\n3    address: user/signedup\n4    messages:\n5      UserSignup:\n6        $ref: './message-schema.yaml#/UserSignup'\n7operations:\n8  user/signedup.publish:\n9    action: receive\n10    channel:\n11      $ref: '#/channels/signUp'\n12    messages:\n13      - $ref: '#/channels/signUp/messages/UserSignup'\n```\n External URL You can reference an external URL using the $ref keyword. Ensure the external URL provides the referenced component in a compatible format, such as YAML or JSON. In the example below, you reference the component from an external URL. The $ref value specifies the full URL to the external resource and the component's location. \n```javascript\n1channels:\n2  signUp:\n3    address: user/signedup\n4    messages:\n5      UserSignup:\n6        $ref: https://example.com/my-components.yaml#/schemas/MySchema\n7operations:\n8  user/signedup.publish:\n9    action: receive\n10    channel:\n11      $ref: '#/channels/signUp'\n12    messages:\n13      - $ref: '#/channels/signUp/messages/UserSignup'\n```\n Go Back Server variables Up Next Add servers Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1channels:\n2  myChannel:\n3    message:\n4      myMessage:\n5        payload:\n6          $ref: '#/components/schemas/MyMessageSchema'\n7components:\n8  schemas:\n9    MyMessageSchema:\n10      type: object\n11      properties:\n12        message:\n13          type: string",
      "1UserSignup:\n2  name: UserSignup\n3  title: User signup\n4  summary: Action to sign a user up.\n5  description: A longer description\n6  contentType: application/json\n7  payload: null",
      "1channels:\n2  signUp:\n3    address: user/signedup\n4    messages:\n5      UserSignup:\n6        $ref: './message-schema.yaml#/UserSignup'\n7operations:\n8  user/signedup.publish:\n9    action: receive\n10    channel:\n11      $ref: '#/channels/signUp'\n12    messages:\n13      - $ref: '#/channels/signUp/messages/UserSignup'",
      "1channels:\n2  signUp:\n3    address: user/signedup\n4    messages:\n5      UserSignup:\n6        $ref: https://example.com/my-components.yaml#/schemas/MySchema\n7operations:\n8  user/signedup.publish:\n9    action: receive\n10    channel:\n11      $ref: '#/channels/signUp'\n12    messages:\n13      - $ref: '#/channels/signUp/messages/UserSignup'"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "4a6d6a23",
    "title": "Operation security | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/concepts/asyncapi-document/securing-operations.html",
    "content": "Operation security | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Add security Operation section securitySchemes section Operation security Found an error? Have a suggestion? Edit this page on GitHub The server security concept in AsyncAPI means that the security settings specified at the server level automatically apply to all operations across all channels. If you want to modify these default security settings for a particular operation, you need to specify the security details directly on that operation. Add security To accommodate such scenarios, the AsyncAPI document allows you to use the security field at the operation level. You can have multiple security schemes, but only one must be satisfied to authorize such an operation. The diagram below describes how to implement reusable security schemes: Operation section Security information for an operation is defined using a Security Scheme at the operation level. You can reference a scheme from another location, such as components.securitySchemes , using the $ref keyword. \n```javascript\n1operations:\n2  sendAuthRevoke:\n3    action: send\n4    channel:\n5      $ref: '#/channels/authRevoke'\n6    security:\n7      - type: oauth2\n8        description: The oauth security descriptions\n9        flows:\n10          clientCredentials:\n11            tokenUrl: 'https://example.com/api/oauth/dialog'\n12            availableScopes:\n13              'subscribe:auth_revocations': Scope required for authorization revocation topic\n14        scopes:\n15          - 'subscribe:auth_revocations'\n```\n The previous example, featuring the sendAuthRevoke operation in an AsyncAPI document, demonstrates the capabilities of a client application with an existing notification service. If a server has its own security requirements, this operation must also comply with those. securitySchemes section To reuse security schemes between operations, place them in components.securitySchemes and reference them via the $ref keyword in your operation: \n```javascript\n1operations:\n2  sendAuthRevoke:\n3    action: send\n4    channel:\n5      $ref: '#/channels/authRevoke'\n6    security:\n7      - $ref: '#/components/securitySchemes/oauth'\n8\n9components:\n10  securitySchemes:\n11    oauth:\n12       type: oauth2\n13        description: The oauth security descriptions\n14        flows:\n15          clientCredentials:\n16            tokenUrl: 'https://example.com/api/oauth/dialog'\n17            availableScopes:\n18              'subscribe:auth_revocations': Scope required for authorization revocation topic\n19        scopes:\n20          - 'subscribe:auth_revocations'\n```\n The previous code snippet shows the approach for reusing schema within multiple operations, even across multiple AsyncAPI documents. Go Back Adding operations Up Next Adding messages Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1operations:\n2  sendAuthRevoke:\n3    action: send\n4    channel:\n5      $ref: '#/channels/authRevoke'\n6    security:\n7      - type: oauth2\n8        description: The oauth security descriptions\n9        flows:\n10          clientCredentials:\n11            tokenUrl: 'https://example.com/api/oauth/dialog'\n12            availableScopes:\n13              'subscribe:auth_revocations': Scope required for authorization revocation topic\n14        scopes:\n15          - 'subscribe:auth_revocations'",
      "1operations:\n2  sendAuthRevoke:\n3    action: send\n4    channel:\n5      $ref: '#/channels/authRevoke'\n6    security:\n7      - $ref: '#/components/securitySchemes/oauth'\n8\n9components:\n10  securitySchemes:\n11    oauth:\n12       type: oauth2\n13        description: The oauth security descriptions\n14        flows:\n15          clientCredentials:\n16            tokenUrl: 'https://example.com/api/oauth/dialog'\n17            availableScopes:\n18              'subscribe:auth_revocations': Scope required for authorization revocation topic\n19        scopes:\n20          - 'subscribe:auth_revocations'"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "e162f1b4",
    "title": "Server security | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/concepts/asyncapi-document/server-security.html",
    "content": "Server security | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets Server security Found an error? Have a suggestion? Edit this page on GitHub Server security refers to the measures and practices implemented to protect servers from unauthorized access, data breaches, and other security threats. Server security involves implementing various security mechanisms to ensure the confidentiality, integrity, and availability of server resources. In the context of AsyncAPI, securing servers ensures secure exchange of messages between clients and servers. While also protecting sensitive data, preventing unauthorized access, and maintaining the overall security of the API or server. You can describe how your server is secured with the security property where you define which security schemes can be used with the server in context. Each server in the AsyncAPI document can have one or more security schemes declared. A security scheme defines a security requirement that must be satisfied to authorize an operation, such as an API key or a username and password. Here is an example of adding security to your server, demonstrating that different servers can employ various security mechanisms: \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: Streetlights Kafka API\n4  version: 1.0.0\n5servers:\n6  scram-connections:\n7    host: 'test.mykafkacluster.org:18092'\n8    protocol: kafka-secure\n9    description: Test broker secured with scramSha256\n10    security:\n11      - $ref: '#/components/securitySchemes/saslScram'\n12  mtls-connections:\n13    host: 'test.mykafkacluster.org:28092'\n14    protocol: kafka-secure\n15    description: Test broker secured with X509\n16    security:\n17      - $ref: '#/components/securitySchemes/certs'\n18components:\n19  securitySchemes:\n20    saslScram:\n21      type: scramSha256\n22      description: Provide your username and password for SASL/SCRAM authentication\n23    certs:\n24      type: X509\n25      description: Download the certificate files from service provider\n```\n Here is an illustration of securing servers: Here are some of the security schemes that AsyncAPI supports: User/Password type : userPassword API key (either as a user or as a password) \n```javascript\n1type: apiKey\n2in: user\n```\n X.509 certificate type : X509 End-to-end encryption (either symmetric or asymmetric) type : symmetricEncryption HTTP authentication \n```javascript\n1type: http\n2scheme: basic\n```\n HTTP API key \n```javascript\n1type: httpApiKey\n2name: api_key\n3in: header\n```\n JWT Bearer \n```javascript\n1type: http\n2scheme: bearer\n3bearerFormat: JWT\n```\n Implicit oauth2 \n```javascript\n1type: oauth2\n2flows:\n3  implicit:\n4    authorizationUrl: https://example.com/api/oauth/dialog\n5    availableScopes:\n6      write:pets: modify pets in your account\n7      read:pets: read your pets\n8scopes:\n9  - 'write:pets'\n```\n SASL (Simple Authentication and Security Layer) as defined in RFC4422 type : scramSha512 Although the security property is not mandatory, it is a good practice to always secure your server(s) in production. Similarly, having multiple security schemes declared does not necessarily mean that the server is more secure; it depends on other factors such as the protocol used, use case, business perspective, and more. Additionally, you can also add security at the operation level . Go Back Reusability with traits Up Next Adding reply info Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1asyncapi: 3.0.0\n2info:\n3  title: Streetlights Kafka API\n4  version: 1.0.0\n5servers:\n6  scram-connections:\n7    host: 'test.mykafkacluster.org:18092'\n8    protocol: kafka-secure\n9    description: Test broker secured with scramSha256\n10    security:\n11      - $ref: '#/components/securitySchemes/saslScram'\n12  mtls-connections:\n13    host: 'test.mykafkacluster.org:28092'\n14    protocol: kafka-secure\n15    description: Test broker secured with X509\n16    security:\n17      - $ref: '#/components/securitySchemes/certs'\n18components:\n19  securitySchemes:\n20    saslScram:\n21      type: scramSha256\n22      description: Provide your username and password for SASL/SCRAM authentication\n23    certs:\n24      type: X509\n25      description: Download the certificate files from service provider",
      "1type: apiKey\n2in: user",
      "1type: http\n2scheme: basic",
      "1type: httpApiKey\n2name: api_key\n3in: header",
      "1type: http\n2scheme: bearer\n3bearerFormat: JWT",
      "1type: oauth2\n2flows:\n3  implicit:\n4    authorizationUrl: https://example.com/api/oauth/dialog\n5    availableScopes:\n6      write:pets: modify pets in your account\n7      read:pets: read your pets\n8scopes:\n9  - 'write:pets'"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "9e90e9fc",
    "title": "AsyncAPI document structure | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/concepts/asyncapi-document/structure.html",
    "content": "AsyncAPI document structure | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Root elements info field servers field channels field operations field components field AsyncAPI document structure Found an error? Have a suggestion? Edit this page on GitHub The structure of an AsyncAPI document is defined in a specific format and must follow the AsyncAPI specification . The structure of an AsyncAPI document has certain fields that you need to follow, although not all of them are mandatory. Root elements Root elements of an AsyncAPI document provide an overview of the API's characteristics and behavior. These root elements collectively define the metadata, channels, components, and more of an AsyncAPI document. They provide a comprehensive overview of the API's characteristics and behavior. info field The info field in an API document offers crucial metadata, including the API's title, version, description, contact details, and license. This field provides a comprehensive overview of the API, aiding developers, architects, and other stakeholders in quickly grasping its purpose and capabilities. As a mandatory element of the AsyncAPI specification, the info field often serves as the initial reference point for users navigating the API documentation. The info field encompasses various fields such as: title : API title. version : API version. description : Brief description describing the API's purpose and features. termsOfService : URL or document specifying the API's terms of service. contact : Contact information of the API's owner or maintainer (name, email, and URL). license : API's license information, including name and URL. tags : Tags for categorizing and organizing API documentation. Also used for grouping applications logically. externalDocs : Links to additional, external documentation related to the API. Here's a visual representation of the info field and its properties: Below is an example of the info field: \n```javascript\n1info:\n2  title: My Event-Driven API\n3  version: 1.0.0\n4  description: This API provides real-time event streaming capabilities.\n5  termsOfService: https://example.com/terms-of-service\n6  contact:\n7    name: Rohit\n8    email: rohitwashere@asyncapi.com\n9  license:\n10    name: Apache 2.0\n11    url: https://www.apache.org/licenses/LICENSE-2.0.html\n12  tags:\n13    - name: Events\n14      description: APIs related to event streaming\n15    - name: Authentication\n16      description: APIs for authentication and authorization\n17  externalDocs:\n18    description: Additional documentation \n19    url: https://example.com/docs\n```\n servers field The servers field allows you to detail a range of servers, outlining the network endpoints or message brokers to which applications can connect. That field includes vital connection information like protocol, host, port, and other options, facilitating connectivity across various environments such as production, staging, or development. Some of the fields of individual servers field are: host : The server host name. It may include the port. protocol : The protocol or messaging protocol used by the server (e.g., AMQP, MQTT, WebSocket). protocolVersion : The version of the protocol used for the connection. pathname : The path to a resource in the host. description : An optional string describing the server. title : A human-friendly title for the server. summary : A summary of the server. security : A declaration of which security schemes can be used with this server. tags : A list of tags for logical grouping and categorization of servers. externalDocs : Additional external documentation for this server. bindings : A map where the keys describe the name of the protocol and the values describe protocol-specific definitions for the server. Here's a visual representation of the server object and its properties: Below is an example of the servers field with multiple servers: \n```javascript\n1servers:\n2  production:\n3    host: rabbitmq.in.mycompany.com:5672\n4    pathname: /v1\n5    protocol: amqp\n6    protocolVersion: \"1.0\"\n7    description: Production RabbitMQ broker (uses the `production` vhost).\n8    title: Production Server\n9    summary: Production environment server\n10    security:\n11      - type: http\n12        scheme: bearer\n13    tags:\n14      - name: production\n15        description: Production environment\n16    externalDocs:\n17      description: Additional documentation for the production server\n18      url: https://example.com/docs/production\n19    bindings:\n20      amqp:\n21        exchange: my-exchange\n22        queue: my-queue\n23  staging:\n24    host: rabbitmq.in.mycompany.com:5672\n25    pathname: /v1\n26    protocol: amqp\n27    protocolVersion: \"1.0\"\n28    description: Staging RabbitMQ broker (uses the `staging` vhost).\n29    title: Staging Server\n30    summary: Staging environment server\n31    security:\n32      - type: apiKey\n33        in: user\n34        description: Provide your API key as the user and leave the password empty.\n35    tags:\n36      - name: staging\n37        description: Staging environment\n38    externalDocs:\n39      description: Additional documentation for the staging server\n40      url: https://example.com/docs/staging\n41    bindings:\n42      amqp:\n43        exchange: my-exchange\n44        queue: my-queue\n```\n channels field With the channels field, you can provide a map of different channels the application communicates with during runtime. The channels represent the communication pathways through which messages are exchanged. You can specify their purpose, address, and the expected message formats for communication. Consumers of the specific API can understand the supported message-based interactions and the corresponding data models. Key components within the channels field include: address : A string representation of this channel's address. messages : A map of the messages that will be sent to this channel by any application at any time. title : A human-readable title for the channel. summary : A short yet brief summary of the channel. description : A description of the channel, providing additional context and details of the message. servers : An array of $ref pointers to the definition of the servers in which this channel is available. If servers are absent or empty, this channel must be available on all the servers defined in the servers field. parameters : A map of the parameters included in the channel address. tags : A list of tags for logical grouping of channels. externalDocs : Additional external documentation for this channel. bindings : A map where the keys describe the name of the protocol and the values describe protocol-specific definitions for the channel. Here's a visual representation of the channels field and its properties: Below is an example of of the channels field with one channel: \n```javascript\n1channels:\n2  user:\n3    address: 'users.{userId}'\n4    title: Users channel\n5    description: This channel is used to exchange messages about user events.\n6    messages:\n7      userSignedUp:\n8        $ref: '#/components/messages/userSignedUp'\n9      userCompletedOrder:\n10        $ref: '#/components/messages/userCompletedOrder'\n11    parameters:\n12      userId:\n13        $ref: '#/components/parameters/userId'\n14    servers:\n15      - $ref: '#/servers/production'\n16    bindings:\n17      amqp:\n18        is: queue\n19        queue:\n20          exclusive: true\n21    tags:\n22      - name: user\n23        description: User-related messages\n24    externalDocs:\n25      description: 'Find more info here'\n26      url: 'https://example.com'\n```\n operations field The operations field is used to comprehensively outline the various operations performed by the application. It offers a clear, structured description, detailing whether the application sends or receives messages and the specific purpose of each operation. Key components within the operations field include: action : Use send type when it's expected that the application will send a message to the given channel, and receive type when the application should expect to receive messages from the given channel. channel : A $ref pointer to the definition of the channel in which this operation is performed. title : A human-friendly title for the operation. summary : A short summary of what the operation is about. description : A verbose explanation of the operation. security : A declaration of which security schemes are associated with this operation. tags : A list of tags for logical grouping and categorization of operations. externalDocs : Additional external documentation for this operation. bindings A map where the keys describe the name of the protocol and the values describe protocol-specific definitions for the operation. traits : A list of traits to apply to the operation object. messages : A list of $ref pointers pointing to the supported Message Objects that can be processed by this operation. reply : The definition of the reply in a reply/request operation. Here's a visual representation of the operations field and its properties: Below is an example of of the operations field with one operation: \n```javascript\n1operations:\n2  sendUserSignUp:\n3    action: send\n4    title: User sign up\n5    summary: Action to sign a user up.\n6    description: A longer description\n7    channel:\n8      $ref: '#/channels/user'\n9    security:\n10      - type: oauth2\n11        description: The oauth security descriptions\n12        flows:\n13          clientCredentials:\n14            tokenUrl: 'https://example.com/api/oauth/dialog'\n15            availableScopes:\n16              'subscribe:auth_revocations': Scope required for authorization revocation topic\n17        scopes:\n18          - 'subscribe:auth_revocations'\n19    tags:\n20      - name: user\n21      - name: signup\n22      - name: register\n23    bindings:\n24      amqp:\n25        ack: false\n26    traits:\n27      - $ref: \"#/components/operationTraits/kafka\"\n28    messages:\n29      - $ref: '#/components/messages/userSignedUp'\n30    reply:\n31      address:\n32        location: '$message.header#/replyTo'\n33      channel:\n34        $ref: '#/channels/userSignupReply'\n35      messages:\n36        - $ref: '#/channels/userSignupReply/messages/userSignedUpReply'\n```\n components field The components field allows for the definition of reusable structures or definitions applicable across various sections of your document. Items detailed within components only become part of the API when explicitly referenced by properties external to this field. Utilize it to avoid repetition and enhance the document's maintainability. Key components of the components field include: schemas : An object to hold the reusable Schema Object . servers : An object to hold the reusable Server Objects . channels : An object to hold the reusable Channel Objects . operations : An object to hold the reusable Operation Item Objects . messages : An object to hold the reusable Messages Objects . securitySchemes : An object to hold the reusable Security Scheme Objects . serverVariables : An object to hold the reusable Server Variable Objects . parameters : Contains reusable Parameter Objects that can be used in various parts of the AsyncAPI document. correlationIds : An object to hold the reusable Correlation ID Objects . replies : An object to hold the reusable Operation Reply Objects . replyAddresses : An object to hold the reusable Operation Reply Address Objects . externalDocs : An object to hold the reusable External Documentation Objects . tags : An object to hold the reusable Tag Objects . operationTraits : An object to hold the reusable Operation Trait Objects . messageTraits : Represents common traits or characteristics that can be applied to messages or hold reusable Message Trait Objects . serverBindings : An object to hold the reusable Server Bindings Objects . channelBindings : An object to hold the reusable Channel Bindings Objects . operationBindings : An object to hold the reusable Operation Bindings Objects . messageBindings : An object to hold the reusable Message Bindings Objects . Here's a visual representation of the components field and its properties: Here's a code example of the components object in an AsyncAPI document: \n```javascript\n1components:\n2\n3  schemas:\n4    Category:\n5      type: object\n6      properties:\n7        id:\n8          type: integer\n9          format: int64\n10    AvroExample:\n11      schemaFormat: application/vnd.apache.avro+json;version=1.9.0\n12      schema:\n13        $ref: 'path/to/user-create.avsc/#UserCreate'\n14\n15  servers:\n16    development:\n17      host: '{stage}.in.mycompany.com'\n18      protocol: amqp\n19      description: RabbitMQ broker\n20      bindings:\n21        $ref: '#/components/serverBindings/devAmqp'\n22      variables:\n23        stage:\n24          $ref: '#/components/serverVariables/stage'\n25      security:\n26        - $ref: '#/components/securitySchemes/oauth'\n27\n28  serverVariables:\n29    stage:\n30      default: demo\n31      description: This value is assigned by the service provider in this example of `mycompany.com`\n32\n33  channels:\n34    user:\n35      address: 'users.{userId}'\n36      title: Users channel\n37      description: This channel is used to exchange messages about user events.\n38      messages:\n39        userSignedUp:\n40          $ref: '#/components/messages/userSignUp'\n41      parameters:\n42        userId:\n43          $ref: '#/components/parameters/userId'\n44      servers:\n45        - $ref: '#/components/servers/development'\n46      bindings:\n47        $ref: '#/components/channelBindings/user'\n48      tags:\n49        - $ref: '#/components/tags/user'\n50      externalDocs:\n51        $ref: '#/components/externalDocs/infoDocs'\n52\n53  messages:\n54    userSignUp:\n55      summary: Action to sign a user up.\n56      traits:\n57        - $ref: '#/components/messageTraits/commonHeaders'\n58      payload:\n59        $ref: '#/components/schemas/Category'\n60      correlationId:\n61          $ref: '#/components/correlationIds/default'\n62      bindings:\n63        $ref: '#/components/messageBindings/user'\n64\n65  parameters:\n66    userId:\n67      description: Id of the user.\n68\n69  correlationIds:\n70    default:\n71      description: Default Correlation ID\n72      location: $message.header#/correlationId\n73\n74  operations:\n75    sendUserSignUp:\n76      action: send\n77      title: User sign up\n78      bindings:\n79        $ref: '#/components/operationBindings/sendUser'\n80      traits:\n81        - $ref: '#/components/operationTraits/binding'\n82      reply:\n83        $ref: '#/components/replies/signupReply'\n84\n85  replies:\n86    signupReply:\n87      address:\n88        $ref: '#/components/replyAddresses/signupReply'\n89      channel:\n90        $ref: '#/channels/userSignupReply'\n91\n92  replyAddresses:\n93    signupReply:\n94      location: '$message.header#/replyTo'\n95\n96\n97  securitySchemes:\n98    oauth:\n99      type: oauth2\n100      description: The oauth security descriptions\n101      flows:\n102        clientCredentials:\n103          tokenUrl: 'https://example.com/api/oauth/dialog'\n104          availableScopes:\n105            'subscribe:auth_revocations': Scope required for authorization revocation topic\n106      scopes:\n107        - 'subscribe:auth_revocations'\n108\n109  operationTraits:\n110    binding:\n111      bindings:\n112        amqp:\n113          ack: false\n114\n115  messageTraits:\n116    commonHeaders:\n117      headers:\n118        type: object\n119        properties:\n120          my-app-header:\n121            type: integer\n122            minimum: 0\n123            maximum: 100\n124\n125  tags:\n126    user:\n127      name: user\n128      description: User-related messages\n129\n130  externalDocs:\n131    infoDocs:\n132      url: https://example.com/docs\n133      description: 'Find more info here'\n134\n135  serverBindings:\n136    devAmqp:\n137      amqp:\n138        exchange: my-exchange\n139        queue: my-queue\n140\n141  channelBindings:\n142    user:\n143      amqp:\n144        is: queue\n145        queue:\n146          exclusive: true\n147\n148  operationBindings:\n149    sendUser:\n150      amqp:\n151        ack: false\n152\n153  messageBindings:\n154    user:\n155      amqp:\n156        contentEncoding: gzip\n157        messageType: 'user.signup'\n158        bindingVersion: '0.2.0'\n```\n Go Back Introduction Up Next Tags Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1info:\n2  title: My Event-Driven API\n3  version: 1.0.0\n4  description: This API provides real-time event streaming capabilities.\n5  termsOfService: https://example.com/terms-of-service\n6  contact:\n7    name: Rohit\n8    email: rohitwashere@asyncapi.com\n9  license:\n10    name: Apache 2.0\n11    url: https://www.apache.org/licenses/LICENSE-2.0.html\n12  tags:\n13    - name: Events\n14      description: APIs related to event streaming\n15    - name: Authentication\n16      description: APIs for authentication and authorization\n17  externalDocs:\n18    description: Additional documentation \n19    url: https://example.com/docs",
      "1servers:\n2  production:\n3    host: rabbitmq.in.mycompany.com:5672\n4    pathname: /v1\n5    protocol: amqp\n6    protocolVersion: \"1.0\"\n7    description: Production RabbitMQ broker (uses the `production` vhost).\n8    title: Production Server\n9    summary: Production environment server\n10    security:\n11      - type: http\n12        scheme: bearer\n13    tags:\n14      - name: production\n15        description: Production environment\n16    externalDocs:\n17      description: Additional documentation for the production server\n18      url: https://example.com/docs/production\n19    bindings:\n20      amqp:\n21        exchange: my-exchange\n22        queue: my-queue\n23  staging:\n24    host: rabbitmq.in.mycompany.com:5672\n25    pathname: /v1\n26    protocol: amqp\n27    protocolVersion: \"1.0\"\n28    description: Staging RabbitMQ broker (uses the `staging` vhost).\n29    title: Staging Server\n30    summary: Staging environment server\n31    security:\n32      - type: apiKey\n33        in: user\n34        description: Provide your API key as the user and leave the password empty.\n35    tags:\n36      - name: staging\n37        description: Staging environment\n38    externalDocs:\n39      description: Additional documentation for the staging server\n40      url: https://example.com/docs/staging\n41    bindings:\n42      amqp:\n43        exchange: my-exchange\n44        queue: my-queue",
      "1channels:\n2  user:\n3    address: 'users.{userId}'\n4    title: Users channel\n5    description: This channel is used to exchange messages about user events.\n6    messages:\n7      userSignedUp:\n8        $ref: '#/components/messages/userSignedUp'\n9      userCompletedOrder:\n10        $ref: '#/components/messages/userCompletedOrder'\n11    parameters:\n12      userId:\n13        $ref: '#/components/parameters/userId'\n14    servers:\n15      - $ref: '#/servers/production'\n16    bindings:\n17      amqp:\n18        is: queue\n19        queue:\n20          exclusive: true\n21    tags:\n22      - name: user\n23        description: User-related messages\n24    externalDocs:\n25      description: 'Find more info here'\n26      url: 'https://example.com'",
      "1operations:\n2  sendUserSignUp:\n3    action: send\n4    title: User sign up\n5    summary: Action to sign a user up.\n6    description: A longer description\n7    channel:\n8      $ref: '#/channels/user'\n9    security:\n10      - type: oauth2\n11        description: The oauth security descriptions\n12        flows:\n13          clientCredentials:\n14            tokenUrl: 'https://example.com/api/oauth/dialog'\n15            availableScopes:\n16              'subscribe:auth_revocations': Scope required for authorization revocation topic\n17        scopes:\n18          - 'subscribe:auth_revocations'\n19    tags:\n20      - name: user\n21      - name: signup\n22      - name: register\n23    bindings:\n24      amqp:\n25        ack: false\n26    traits:\n27      - $ref: \"#/components/operationTraits/kafka\"\n28    messages:\n29      - $ref: '#/components/messages/userSignedUp'\n30    reply:\n31      address:\n32        location: '$message.header#/replyTo'\n33      channel:\n34        $ref: '#/channels/userSignupReply'\n35      messages:\n36        - $ref: '#/channels/userSignupReply/messages/userSignedUpReply'",
      "1components:\n2\n3  schemas:\n4    Category:\n5      type: object\n6      properties:\n7        id:\n8          type: integer\n9          format: int64\n10    AvroExample:\n11      schemaFormat: application/vnd.apache.avro+json;version=1.9.0\n12      schema:\n13        $ref: 'path/to/user-create.avsc/#UserCreate'\n14\n15  servers:\n16    development:\n17      host: '{stage}.in.mycompany.com'\n18      protocol: amqp\n19      description: RabbitMQ broker\n20      bindings:\n21        $ref: '#/components/serverBindings/devAmqp'\n22      variables:\n23        stage:\n24          $ref: '#/components/serverVariables/stage'\n25      security:\n26        - $ref: '#/components/securitySchemes/oauth'\n27\n28  serverVariables:\n29    stage:\n30      default: demo\n31      description: This value is assigned by the service provider in this example of `mycompany.com`\n32\n33  channels:\n34    user:\n35      address: 'users.{userId}'\n36      title: Users channel\n37      description: This channel is used to exchange messages about user events.\n38      messages:\n39        userSignedUp:\n40          $ref: '#/components/messages/userSignUp'\n41      parameters:\n42        userId:\n43          $ref: '#/components/parameters/userId'\n44      servers:\n45        - $ref: '#/components/servers/development'\n46      bindings:\n47        $ref: '#/components/channelBindings/user'\n48      tags:\n49        - $ref: '#/components/tags/user'\n50      externalDocs:\n51        $ref: '#/components/externalDocs/infoDocs'\n52\n53  messages:\n54    userSignUp:\n55      summary: Action to sign a user up.\n56      traits:\n57        - $ref: '#/components/messageTraits/commonHeaders'\n58      payload:\n59        $ref: '#/components/schemas/Category'\n60      correlationId:\n61          $ref: '#/components/correlationIds/default'\n62      bindings:\n63        $ref: '#/components/messageBindings/user'\n64\n65  parameters:\n66    userId:\n67      description: Id of the user.\n68\n69  correlationIds:\n70    default:\n71      description: Default Correlation ID\n72      location: $message.header#/correlationId\n73\n74  operations:\n75    sendUserSignUp:\n76      action: send\n77      title: User sign up\n78      bindings:\n79        $ref: '#/components/operationBindings/sendUser'\n80      traits:\n81        - $ref: '#/components/operationTraits/binding'\n82      reply:\n83        $ref: '#/components/replies/signupReply'\n84\n85  replies:\n86    signupReply:\n87      address:\n88        $ref: '#/components/replyAddresses/signupReply'\n89      channel:\n90        $ref: '#/channels/userSignupReply'\n91\n92  replyAddresses:\n93    signupReply:\n94      location: '$message.header#/replyTo'\n95\n96\n97  securitySchemes:\n98    oauth:\n99      type: oauth2\n100      description: The oauth security descriptions\n101      flows:\n102        clientCredentials:\n103          tokenUrl: 'https://example.com/api/oauth/dialog'\n104          availableScopes:\n105            'subscribe:auth_revocations': Scope required for authorization revocation topic\n106      scopes:\n107        - 'subscribe:auth_revocations'\n108\n109  operationTraits:\n110    binding:\n111      bindings:\n112        amqp:\n113          ack: false\n114\n115  messageTraits:\n116    commonHeaders:\n117      headers:\n118        type: object\n119        properties:\n120          my-app-header:\n121            type: integer\n122            minimum: 0\n123            maximum: 100\n124\n125  tags:\n126    user:\n127      name: user\n128      description: User-related messages\n129\n130  externalDocs:\n131    infoDocs:\n132      url: https://example.com/docs\n133      description: 'Find more info here'\n134\n135  serverBindings:\n136    devAmqp:\n137      amqp:\n138        exchange: my-exchange\n139        queue: my-queue\n140\n141  channelBindings:\n142    user:\n143      amqp:\n144        is: queue\n145        queue:\n146          exclusive: true\n147\n148  operationBindings:\n149    sendUser:\n150      amqp:\n151        ack: false\n152\n153  messageBindings:\n154    user:\n155      amqp:\n156        contentEncoding: gzip\n157        messageType: 'user.signup'\n158        bindingVersion: '0.2.0'"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "845cc321",
    "title": "Tags | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/concepts/asyncapi-document/tags.html",
    "content": "Tags | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page tags in AsyncAPI document tags in info object tags in servers object tags in channels object tags in operations object tags in message object Tags Found an error? Have a suggestion? Edit this page on GitHub A tag functions as a label or category for logically grouping related entities like channels or servers in an event-driven system. The tag object facilitates the organization of channels, operations, or other components, categorizing them based on functionality, purpose, or other relevant criteria. In AsyncAPI, the tags object is a list of individual tag objects. Each tag within this collection can be defined with a specific name, accompanied by an optional description that offers additional insight into the tag's intended purpose or usage. You can define tags in the components object of an AsyncAPI document, which enables the reusability of the tags. If you include tags in the components object, they can be re-used by using reference objects . Additionally, within AsyncAPI, you can create a list of tags in the tags object at the info level, specifying the tags you intend to use throughout the document. These predefined tags can then be applied to individual components like servers or channels , facilitating logical grouping and organization of these components. tags in AsyncAPI document The tags object consists of a list of tag objects, which can be referenced using the reference object . The tags object is a list of tags and individual tag objects, each containing specific fields. In an AsyncAPI document, the function of tags within the tags object differs depending on context. For example, the tags object can be employed for consistent usage of tags across the document and logical grouping of components. Alternatively, tags can be applied to individual components such as servers or channels , serving more specific purposes within those contexts. The tags object fields include: name : The name of the tag. description : A short description for the tag. externalDocs : Additional external documentation for the tag. tags in info object When specified in the tags property of the info object, tags offer a comprehensive categorization for the entire AsyncAPI document. These globally defined tags under the info object impart an overarching context, representing key themes or functional areas within the event-driven system. They effectively group elements like channels or servers by their broader relevance, providing a holistic understanding of the application's structure. Here's a visual representation of the tags object inside an info object in an AsyncAPI document: Below is an example of the tags object inside the info object in an AsyncAPI document: \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: AsyncAPI Documentation\n4  version: 1.0.0\n5  description: |\n6    This AsyncAPI document provides an overview\n7    of the event-driven system.\n8  tags:\n9    - name: Applications\n10      description: All applications related topics. \n11      externalDocs:\n12        description: More info about applications\n13        url: https://applications.example.com/docs\n14    - name: Time\n15      description: All time related topics.\n16      externalDocs:\n17        description: More info about time\n18        url: https://time.example.com/docs\n```\n tags in servers object When tags are utilized within the servers object's tags property, they specifically pertain to server configurations and characteristics. These tags enable server categorization by various criteria, including geographical location, environment type (i.e., production or development), or unique server features. Using tags in the servers object allows for the categorization and organization of servers based on specific tags or labels. Using the tags object under the servers object is optional. Here's a visual representation of the tags object inside a servers object in an AsyncAPI document: Below is an example of the tags object inside the servers object in an AsyncAPI document: \n```javascript\n1asyncapi: 3.0.0\n2\n3info:\n4  title: AsyncAPI Documentation\n5  version: 1.0.0\n6\n7servers:\n8  development:\n9    host: localhost:5672\n10    description: Development AMQP broker.\n11    protocol: amqp\n12    protocolVersion: 0-9-1\n13    tags:\n14      - name: \"env:development\"\n15        description: \"This environment is meant for developers to run their tests.\"\n16  production:\n17    host: rabbitmq.in.mycompany.com:5672\n18    description: RabbitMQ broker for the production environment.\n19    protocol: amqp\n20    protocolVersion: 0-9-1\n21    tags:\n22      - name: \"env:production\"\n23        description: \"This environment is the live environment available for final users.\"\n```\n tags in channels object Tags linked with individual channels enable logical grouping and categorization based on specific functionalities or business domains. When the tags object is used within a channels object in an AsyncAPI document, its context is either confined to the channels object, impacting only that section, or it can be employed for consistent tagging across the document for cohesive grouping. Using the tags object under the channels object is optional. Here's a visual representation of the tags object inside a channels object in an AsyncAPI document: Below is an example of the tags object inside the channels object in an AsyncAPI document: \n```javascript\n1asyncapi: 3.0.0\n2\n3info:\n4  title: AsyncAPI Documentation\n5  version: 1.0.0\n6\n7channels:\n8  SignedUp:\n9    address: 'user.signedup'\n10    messages:\n11      userSignedUp:\n12        payload:\n13          type: object\n14    tags:\n15      - name: user\n16        description: User-related messages\n```\n tags in operations object Within an AsyncAPI document, the tags object in the operations object facilitates logical grouping and categorization of operation objects by operation type, functionality, and more. When used in an operations object, the tags can either serve a specific purpose within that object or be employed for consistent, logical grouping of components across the document. Using the tags object in the operations object is optional. Here's a visual representation of the tags object inside a operations object in an AsyncAPI document: Below is an example of the tags object inside the operations object in an AsyncAPI document: \n```javascript\n1operations:\n2  onUserSignUp:\n3    title: User sign up\n4    summary: Action to sign a user up.\n5    description: A longer description\n6    channel:\n7      $ref: '#/channels/userSignup'\n8    action: send\n9    tags:\n10      - name: user\n11        description: operation related to user\n12      - name: signup\n13        description: operation related to a user's signUp\n14      - name: register\n15        description: operation related to a new registration\n16    bindings:\n17      amqp:\n18        ack: false\n19    traits:\n20      - $ref: '#/components/operationTraits/kafka'\n```\n tags in message object Tags linked to individual message objects in an AsyncAPI document enable logical grouping and categorization of messages based on specific criteria, requirements, channels, and operations. When implemented within a message object, the context of the tags object can be confined to that specific message or integrated as the strategy for consistent tagging and logical organization across the entire document. Here's a visual representation of a tags object inside a message object in an AsyncAPI document: Below is an example of the tags object inside the message object in an AsyncAPI document: \n```javascript\n1 name: SimpleSignup\n2summary: A simple UserSignup example message\n3tags: \n4    - name: userSignUp\n5      description: some message related to user signup\n6headers:\n7  correlationId: my-correlation-id\n8  applicationInstanceId: myInstanceId\n9payload:\n10  user:\n11    someUserKey: someUserValue\n12  signup:\n13    someSignupKey: someSignupValue\n```\n Here's an example illustrating all the tags being defined in the components object and then referenced in other components such as servers , channels , and more: \n```javascript\n1asyncapi: 3.0.0\n2\n3components:\n4  tags:\n5    speech:\n6      name: Speech\n7      description: All speech related topics.\n8    video:\n9      name: Video\n10      description: All video related topics.\n11      \n12info:\n13  title: AsyncAPI Documentation\n14  version: 1.0.0\n15  description: |\n16    This AsyncAPI document provides an overview\n17    of the event-driven system.\n18  tags:\n19    - $ref: '#/components/tags/speech'\n20    - $ref: '#/components/tags/video'\n21\n22servers:\n23  speech:\n24    host: localhost:5672\n25    description: RabbitMQ broker for sending speech data.\n26    protocol: amqp\n27    tags:\n28      - $ref: '#/components/tags/speech'\n29  video:\n30    host: localhost:5673\n31    description: RabbitMQ broker for video information.\n32    protocol: amqp\n33    tags:\n34       - $ref: '#/components/tags/video'\n35\n36channels:\n37  getSpeech:\n38      address: 'application/speech/get'\n39      servers: \n40        - $ref: '#/servers/speech'\n41      messages:\n42        voice:\n43          name: Voice\n44          summary: Add info about the voice stream data.\n45          tags:\n46            - $ref: '#/components/tags/speech'\n47  getVideo:\n48      address: 'application/video/get'\n49      servers: \n50        - $ref: '#/servers/video'\n51      messages:\n52        voice:\n53          name: Video\n54          summary: Add info about the video data live bitrate and others.\n55          tags: \n56            - $ref: '#/components/tags/video'\n57\n58operations:\n59  onVoiceStreamed:\n60    title: Get speech data\n61    channel:\n62      $ref: '#/channels/getSpeech'\n63    action: receive\n64    tags:\n65      - $ref: '#/components/tags/speech'\n66\n67  onVideoStreamed:\n68    title: Get video data\n69    channel:\n70      $ref: '#/channels/getVideo'\n71    action: receive\n72    tags:\n73      - $ref: '#/components/tags/video'\n```\n Go Back AsyncAPI document structure Up Next Adding channels Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1asyncapi: 3.0.0\n2info:\n3  title: AsyncAPI Documentation\n4  version: 1.0.0\n5  description: |\n6    This AsyncAPI document provides an overview\n7    of the event-driven system.\n8  tags:\n9    - name: Applications\n10      description: All applications related topics. \n11      externalDocs:\n12        description: More info about applications\n13        url: https://applications.example.com/docs\n14    - name: Time\n15      description: All time related topics.\n16      externalDocs:\n17        description: More info about time\n18        url: https://time.example.com/docs",
      "1asyncapi: 3.0.0\n2\n3info:\n4  title: AsyncAPI Documentation\n5  version: 1.0.0\n6\n7servers:\n8  development:\n9    host: localhost:5672\n10    description: Development AMQP broker.\n11    protocol: amqp\n12    protocolVersion: 0-9-1\n13    tags:\n14      - name: \"env:development\"\n15        description: \"This environment is meant for developers to run their tests.\"\n16  production:\n17    host: rabbitmq.in.mycompany.com:5672\n18    description: RabbitMQ broker for the production environment.\n19    protocol: amqp\n20    protocolVersion: 0-9-1\n21    tags:\n22      - name: \"env:production\"\n23        description: \"This environment is the live environment available for final users.\"",
      "1asyncapi: 3.0.0\n2\n3info:\n4  title: AsyncAPI Documentation\n5  version: 1.0.0\n6\n7channels:\n8  SignedUp:\n9    address: 'user.signedup'\n10    messages:\n11      userSignedUp:\n12        payload:\n13          type: object\n14    tags:\n15      - name: user\n16        description: User-related messages",
      "1operations:\n2  onUserSignUp:\n3    title: User sign up\n4    summary: Action to sign a user up.\n5    description: A longer description\n6    channel:\n7      $ref: '#/channels/userSignup'\n8    action: send\n9    tags:\n10      - name: user\n11        description: operation related to user\n12      - name: signup\n13        description: operation related to a user's signUp\n14      - name: register\n15        description: operation related to a new registration\n16    bindings:\n17      amqp:\n18        ack: false\n19    traits:\n20      - $ref: '#/components/operationTraits/kafka'",
      "1 name: SimpleSignup\n2summary: A simple UserSignup example message\n3tags: \n4    - name: userSignUp\n5      description: some message related to user signup\n6headers:\n7  correlationId: my-correlation-id\n8  applicationInstanceId: myInstanceId\n9payload:\n10  user:\n11    someUserKey: someUserValue\n12  signup:\n13    someSignupKey: someSignupValue",
      "1asyncapi: 3.0.0\n2\n3components:\n4  tags:\n5    speech:\n6      name: Speech\n7      description: All speech related topics.\n8    video:\n9      name: Video\n10      description: All video related topics.\n11      \n12info:\n13  title: AsyncAPI Documentation\n14  version: 1.0.0\n15  description: |\n16    This AsyncAPI document provides an overview\n17    of the event-driven system.\n18  tags:\n19    - $ref: '#/components/tags/speech'\n20    - $ref: '#/components/tags/video'\n21\n22servers:\n23  speech:\n24    host: localhost:5672\n25    description: RabbitMQ broker for sending speech data.\n26    protocol: amqp\n27    tags:\n28      - $ref: '#/components/tags/speech'\n29  video:\n30    host: localhost:5673\n31    description: RabbitMQ broker for video information.\n32    protocol: amqp\n33    tags:\n34       - $ref: '#/components/tags/video'\n35\n36channels:\n37  getSpeech:\n38      address: 'application/speech/get'\n39      servers: \n40        - $ref: '#/servers/speech'\n41      messages:\n42        voice:\n43          name: Voice\n44          summary: Add info about the voice stream data.\n45          tags:\n46            - $ref: '#/components/tags/speech'\n47  getVideo:\n48      address: 'application/video/get'\n49      servers: \n50        - $ref: '#/servers/video'\n51      messages:\n52        voice:\n53          name: Video\n54          summary: Add info about the video data live bitrate and others.\n55          tags: \n56            - $ref: '#/components/tags/video'\n57\n58operations:\n59  onVoiceStreamed:\n60    title: Get speech data\n61    channel:\n62      $ref: '#/channels/getSpeech'\n63    action: receive\n64    tags:\n65      - $ref: '#/components/tags/speech'\n66\n67  onVideoStreamed:\n68    title: Get video data\n69    channel:\n70      $ref: '#/channels/getVideo'\n71    action: receive\n72    tags:\n73      - $ref: '#/components/tags/video'"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "f24d45e6",
    "title": "Server variables | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/concepts/asyncapi-document/variable-url.html",
    "content": "Server variables | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Add variables Servers section serverVariables section Define domain and port variables Server variables Found an error? Have a suggestion? Edit this page on GitHub The server's URL consists of the host and pathname fields. These values are not always known when you design your system. AsyncAPI enables you to construct dynamic URLs while enhancing the flexibility and maintainability of your AsyncAPI documents. These dynamic values (variables) are placeholders for values you can replace during runtime. You can easily manage multiple endpoints, handling various server configurations and environments. Add variables You can add variables to server.host and server.pathname by adding a variable between curly braces like {braces} . Next, you use server.variables to provide definitions of your variables. Finally, leverage components.serverVariables to enable reusable variable definitions across multiple servers. The diagram below describes how to use reusable variables in AsyncAPI. First, configure the variables in host and/or pathname . Next, define reusable variables in components.serverVariables . Finally, ensure that your server.variables from the server reference definitions in the components.serverVariables uses $ref . Servers section Define the servers section in your AsyncAPI document, including the host and pathname for your API servers. Use placeholders enclosed in curly braces to represent the variables in the server. For example: \n```javascript\n1servers:\n2  production:\n3    host: '{subdomain}.example.com:{port}'\n4    pathname: '/{version}\n5    variables:\n6      subdomain:\n7        enum:\n8          - development\n9          - staging\n10          - production\n11      port:\n12        default: '8080'\n13      version:\n14        enum:\n15          - v1\n16          - v2\n```\n serverVariables section Define the components.serverVariables section in your AsyncAPI document. For each variable used in the server host or pathname , provide a default value and an optional description to avoid repeating the variable definitions. For example: \n```javascript\n1components:\n2  serverVariables:\n3    subdomain:\n4      enum:\n5        - development\n6        - staging\n7        - production\n8      default: development\n9    port:\n10      default: '8080'\n11    version:\n12      enum:\n13        - v1\n14        - v2\n```\n Define domain and port variables Use components.serverVariables in your server using the Reference Object to avoid repeating information: \n```javascript\n1    variables:\n2      subdomain:\n3        $ref: '#/components/serverVariables/subdomain'\n```\n Here's the complete AsyncAPI document with the servers' variables for the host field: \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: Example API\n4  version: '1.0.0'\n5servers:\n6  production:\n7    host: '{subdomain}.example.com:{port}'\n8    pathname: '/{version}'\n9    protocol: amqp\n10    variables:\n11      subdomain:\n12        $ref: '#/components/serverVariables/subdomain'\n13      port:\n14        $ref: '#/components/serverVariables/port'\n15      version:\n16        $ref: '#/components/serverVariables/version'\n17  development:\n18    host: '{subdomain}.dev.example.com:{port}'\n19    pathname: /v1\n20    protocol: amqp\n21    variables:\n22      subdomain:\n23        $ref: '#/components/serverVariables/subdomain'\n24      port:\n25        $ref: '#/components/serverVariables/port'\n26      version:\n27        $ref: '#/components/serverVariables/version'\n28components:\n29  serverVariables:\n30    subdomain:\n31      enum:\n32        - development\n33        - staging\n34        - production\n35      default: development\n36    port:\n37      default: '8080'\n38    version:\n39      enum:\n40        - v1\n41        - v2\n```\n Go Back Payload schema Up Next Reusable parts Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1servers:\n2  production:\n3    host: '{subdomain}.example.com:{port}'\n4    pathname: '/{version}\n5    variables:\n6      subdomain:\n7        enum:\n8          - development\n9          - staging\n10          - production\n11      port:\n12        default: '8080'\n13      version:\n14        enum:\n15          - v1\n16          - v2",
      "1components:\n2  serverVariables:\n3    subdomain:\n4      enum:\n5        - development\n6        - staging\n7        - production\n8      default: development\n9    port:\n10      default: '8080'\n11    version:\n12      enum:\n13        - v1\n14        - v2",
      "1    variables:\n2      subdomain:\n3        $ref: '#/components/serverVariables/subdomain'",
      "1asyncapi: 3.0.0\n2info:\n3  title: Example API\n4  version: '1.0.0'\n5servers:\n6  production:\n7    host: '{subdomain}.example.com:{port}'\n8    pathname: '/{version}'\n9    protocol: amqp\n10    variables:\n11      subdomain:\n12        $ref: '#/components/serverVariables/subdomain'\n13      port:\n14        $ref: '#/components/serverVariables/port'\n15      version:\n16        $ref: '#/components/serverVariables/version'\n17  development:\n18    host: '{subdomain}.dev.example.com:{port}'\n19    pathname: /v1\n20    protocol: amqp\n21    variables:\n22      subdomain:\n23        $ref: '#/components/serverVariables/subdomain'\n24      port:\n25        $ref: '#/components/serverVariables/port'\n26      version:\n27        $ref: '#/components/serverVariables/version'\n28components:\n29  serverVariables:\n30    subdomain:\n31      enum:\n32        - development\n33        - staging\n34        - production\n35      default: development\n36    port:\n37      default: '8080'\n38    version:\n39      enum:\n40        - v1\n41        - v2"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "08d1ae17",
    "title": "Hello world | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/getting-started/hello-world.html",
    "content": "Hello world | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets Hello world Found an error? Have a suggestion? Edit this page on GitHub Let's define an application that's capable of receiving a \"hello {name}\" message: \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: Hello world application\n4  version: '0.1.0'\n5channels:\n6  hello:\n7    address: 'hello'\n8    messages:\n9      sayHelloMessage:\n10        payload:\n11          type: string\n12          pattern: '^hello .+$'\n13operations:\n14  receiveHello:\n15    action: 'receive'\n16    channel:\n17      $ref: '#/channels/hello'\n```\n Let's get into the details of this sample AsyncAPI document: \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: Hello world application\n4  version: '0.1.0'\n5channels:\n6  hello:\n7    address: 'hello'\n8    messages:\n9      sayHelloMessage:\n10        payload:\n11          type: string\n12          pattern: '^hello .+$'\n13operations:\n14  receiveHello:\n15    action: 'receive'\n16    channel:\n17      $ref: '#/channels/hello'\n```\n The first line of the specification starts with the document type asyncapi and the version (3.0.0). That line doesn't have to be the first one, but it's a best practice. \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: Hello world application\n4  version: '0.1.0'\n5channels:\n6  hello:\n7    address: 'hello'\n8    messages:\n9      sayHelloMessage:\n10        payload:\n11          type: string\n12          pattern: '^hello .+$'\n13operations:\n14  receiveHello:\n15    action: 'receive'\n16    channel:\n17      $ref: '#/channels/hello'\n```\n The info object contains the minimum required information about the application. It contains the title , which is a memorable name for the API, and the version . While it's not mandatory, it's strongly recommended to change the version whenever you make changes to the API. \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: Hello world application\n4  version: '0.1.0'\n5channels:\n6  hello:\n7    address: 'hello'\n8    messages:\n9      sayHelloMessage:\n10        payload:\n11          type: string\n12          pattern: '^hello .+$'\n13operations:\n14  receiveHello:\n15    action: 'receive'\n16    channel:\n17      $ref: '#/channels/hello'\n```\n The channels section of the specification houses all of the mediums where messages flow through. For example, some systems use topic , event name or routing key . Different kinds of information flow through each channel similar to the analogy of TV channels. You only have one channel called hello , and you see what message is available in this channel and how it must be structured. The payload object defines that the message must be a string and match the given regular expression in a string format such as hello {name} . \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: Hello world application\n4  version: '0.1.0'\n5channels:\n6  hello:\n7    address: 'hello'\n8    messages:\n9      sayHelloMessage:\n10        payload:\n11          type: string\n12          pattern: '^hello .+$'\n13operations:\n14  receiveHello:\n15    action: 'receive'\n16    channel:\n17      $ref: '#/channels/hello'\n```\n The operations section is where you describe what the application is doing. Each operation has a unique identifier for example, receiveHello . In the above example, you see that the Hello world application is a consumer listening to the sayHelloMessage message from the hello channel. In other words, you can say that the Hello world application subscribes to the hello topic to receive the sayHelloMessage message. That AsyncAPI document describes what the Hello world application is doing, not what others can do with it. Go Back Coming from OpenAPI Up Next Request/reply pattern Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1asyncapi: 3.0.0\n2info:\n3  title: Hello world application\n4  version: '0.1.0'\n5channels:\n6  hello:\n7    address: 'hello'\n8    messages:\n9      sayHelloMessage:\n10        payload:\n11          type: string\n12          pattern: '^hello .+$'\n13operations:\n14  receiveHello:\n15    action: 'receive'\n16    channel:\n17      $ref: '#/channels/hello'",
      "1asyncapi: 3.0.0\n2info:\n3  title: Hello world application\n4  version: '0.1.0'\n5channels:\n6  hello:\n7    address: 'hello'\n8    messages:\n9      sayHelloMessage:\n10        payload:\n11          type: string\n12          pattern: '^hello .+$'\n13operations:\n14  receiveHello:\n15    action: 'receive'\n16    channel:\n17      $ref: '#/channels/hello'",
      "1asyncapi: 3.0.0\n2info:\n3  title: Hello world application\n4  version: '0.1.0'\n5channels:\n6  hello:\n7    address: 'hello'\n8    messages:\n9      sayHelloMessage:\n10        payload:\n11          type: string\n12          pattern: '^hello .+$'\n13operations:\n14  receiveHello:\n15    action: 'receive'\n16    channel:\n17      $ref: '#/channels/hello'",
      "1asyncapi: 3.0.0\n2info:\n3  title: Hello world application\n4  version: '0.1.0'\n5channels:\n6  hello:\n7    address: 'hello'\n8    messages:\n9      sayHelloMessage:\n10        payload:\n11          type: string\n12          pattern: '^hello .+$'\n13operations:\n14  receiveHello:\n15    action: 'receive'\n16    channel:\n17      $ref: '#/channels/hello'",
      "1asyncapi: 3.0.0\n2info:\n3  title: Hello world application\n4  version: '0.1.0'\n5channels:\n6  hello:\n7    address: 'hello'\n8    messages:\n9      sayHelloMessage:\n10        payload:\n11          type: string\n12          pattern: '^hello .+$'\n13operations:\n14  receiveHello:\n15    action: 'receive'\n16    channel:\n17      $ref: '#/channels/hello'"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "96b97570",
    "title": "Coming from OpenAPI | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/getting-started/coming-from-openapi/index.html",
    "content": "Coming from OpenAPI | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Conclusion Coming from OpenAPI Found an error? Have a suggestion? Edit this page on GitHub If you're coming from OpenAPI, you must know that AsyncAPI started as an adaptation of the OpenAPI specification . AsyncAPI wanted to be as compatible as possible with OpenAPI so that the users could reuse parts in both. Before AsyncAPI 3.0.0 , you could find many similarities between OpenAPI and AsyncAPI. Remember that in the world of Event-Driven Architectures, you have more than one protocol; therefore, some things are different. Check out the following comparison chart, inspired by Darrel Miller's blog post : OpenAPI 3.0 Info Servers Security Paths Path Item Summary and description Operation (GET, PUT, POST, etc.) Request Responses Tags External Docs Components Schemas Responses Parameters Examples Request Bodies Headers Security Schemes Links Callbacks AsyncAPI 2.0 Info Servers (hosts + security) Channel Channel Item Operation (Publish and Subscribe) Summary, description, tags, etc. Message Headers Payload Id (application identifier) Tags External Docs Components Schemas Messages Security Schemes Parameters Correlation Ids Operation Traits Message Traits Server Bindings Channel Bindings Operation Bindings Message Bindings To enable more flexibility, the AsyncAPI 3.0.0 specification changes more and is less similar to OpenAPI starting with this version. The biggest change is in the channel structure, where operations are separated from it. It is like detaching operations from paths in OpenAPI. OpenAPI 3.0 Info Servers Security Paths Path Item Summary and description Operation GET, PUT, POST, etc. Request Responses Tags External Docs Components Definitions Responses Parameters Response Headers Security Definitions Callbacks Links AsyncAPI 3.0 Info Servers (hosts + security) Channels Channel Summary, description Messages Headers Payload Operations Operation action (send or receive) Channel reference Messages reference Id (application identifier) Tags External Docs Components Schemas Messages Security Schemes Parameters Correlation Ids Operation Traits Message Traits Server Bindings Channel Bindings Operation Bindings Message Bindings Aside from structural differences, you should know: AsyncAPI is compatible with OpenAPI schemas. The message payload in AsyncAPI can be any value, not just an AsyncAPI/OpenAPI schema. For instance, it could be an Avro schema. The AsyncAPI server object is almost identical to its OpenAPI counterpart, with the exception that scheme has been renamed to protocol and AsyncAPI introduces a new property called protocolVersion . AsyncAPI supports multiple protocols, not only HTTP, like in the case of OpenAPI. OpenAPI path parameters and AsyncAPI channel parameters are a bit different since AsyncAPI doesn't have the notion of \"query\" and \"cookie\", and header parameters can be defined in the message object . Therefore, AsyncAPI channel parameters are the equivalent of OpenAPI path parameters. Conclusion As you have seen above, OpenAPI and AsyncAPI are similar, but the specification's evolution will bring more differences in the future. In a real-world environment, systems don't have just REST APIs or events, but a mix of both. Most of the time, the information flowing in the events is very similar to the one the REST APIs have to handle in requests and responses; thus, being able to reuse schemas is a huge win. Let's learn how to create an AsyncAPI document that defines a \"Hello world\" application. Go Back Event-Driven Architectures Up Next Hello world Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "9f7f4de4",
    "title": "Event-Driven Architectures | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/getting-started/event-driven-architectures/index.html",
    "content": "Event-Driven Architectures | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Core concepts Message broker Publisher/Subscriber Message Channels Why \"event-driven\" and not \"message-driven\"? Conclusion Event-Driven Architectures Found an error? Have a suggestion? Edit this page on GitHub Many developers, architects, and product managers have used REST APIs and are familiar with the synchronous communication paradigm. You make a request and wait for the response. This is exactly how the world wide web works. You enter a URL (e.g., www.google.com ) in the browser's address bar and it sends a request to the server. The server then sends the response with the website content. The web is the greatest implementation of a REST API. However, there are certain situations where you don't need a response from the server. In most cases, it's only important to have some confirmation that the request was received. This is also called \"fire and forget\" , and it's very useful when you just want to communicate or inform that \"something happened.\" You're not requesting or asking for anything, thus you don't need a response. Some examples of this can be: A user just signed up. You have a new follower. Your fridge is almost empty. Along with the event, you may also want to send extra information . For instance: A user just signed up: here's the user information (e.g., name, email, age, etc.) You have a new follower: here are the follower details (e.g., username, name, picture, etc.) Your fridge is almost empty: here's the percentage of \"emptiness\" or available volume (e.g. 23%) This extra information is often referred to as the event payload or message payload . An Event-Driven Architecture (EDA) uses events to trigger and communicate between services and is common in modern applications built with microservices. An event is a state change, or an update, like adding a shopping item to a cart on an e-commerce website. Core concepts \n![](/img/diagrams/simple-event-driven.png)\n In most cases, EDAs are broker-centric, as seen in the diagram above. There are some new concepts in that diagram, so let's go through them now. Message broker A message broker (or \"broker\" ) is a piece of infrastructure in charge of receiving messages and delivering them to those who have shown interest. They often store messages until they are delivered, which makes EDAs very resilient to failures. Examples of brokers are RabbitMQ , Apache Kafka , Solace , etc. Publisher/Subscriber A publisher (a.k.a. producer ) is an application that sends messages to the broker . A subscriber (a.k.a. consumer ) is an application that connects to the broker , manifests an interest in a certain type of message, and leaves the connection open so the broker can push messages to them. Message A message is a piece of information that is sent by publishers to the broker, and received by all interested subscribers. Messages can contain anything and are frequently cataloged as events and commands . As you saw above, events communicate a fact that occurred. On the other hand, commands are very similar to requests in REST APIs. They instruct the subscribers to \"do this.\" To be precise, events and commands share the same structure but differ conceptually. Channels One detail that might pass unnoticed from the diagram above is the existence of channels . All brokers support communication through multiple channels. The industry doesn't have a common term for them, so you may see them referred to as topics , routing keys , event types , etc. A channel is usually assigned a name or identifier (e.g., user_signed_up ) and it is often good practice to send a single type of message through a particular channel. Think about TV or radio channels; the BBC only broadcasts its information through an assigned channel. If the broadcasters (publishers) didn't respect that rule, you (the subscriber) would only see and hear interference. Why \"event-driven\" and not \"message-driven\"? You will find both used interchangeably, although they are not the same. You will even find \"message-based\" and \"event-based\" . In practice, chances are they all refer to the same thing. Theoretically, \"message-driven\" is the most generic term -meaning you may use events and commands- while event-driven means that it's purely about events. However, that's not always the case, as Martin Fowler explains in his talk \"the many meanings of Event-Driven Architecture\" . Conclusion We've seen what an Event-Driven Architecture is, how it works, and explained its components. AsyncAPI defines and documents each of these components. We'll cover each of the components during the rest of this guide. To continue, choose your next step: Go Back Introduction Up Next Coming from OpenAPI Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/diagrams/simple-event-driven.png",
        "alt": ""
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "0fdc270f",
    "title": "Message validation | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/guides/message-validation.html",
    "content": "Message validation | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Introduction Message validation Runtime validation Gateway validation Schema Registry validation Message validation Found an error? Have a suggestion? Edit this page on GitHub Introduction This guide explains different concepts of validating messages in event-driven communication. You will also learn what role AsyncAPI documents play in validation. Message validation To understand message validation in event-driven communication, we must first understand the basic components involved. Producer: responsible for producing messages. Consumer: responsible for getting the producer's messages. Broker: acts as a bridge between the consumer and the producer because messages travel through the broker. Message validation can occur in different places in your system. This guide highlights three of those: Both producers and consumers can do validation internally during runtime. API Gateway can handle message validation. Validation of messages can be a native solution implemented by the Schema Registry. Because consumers and producers cannot communicate directly, the AsyncAPI file dictates what should be included in the payload when a service produces a message. The AsyncAPI document also tells the consumer about the message's properties. Let's further break down how validation works for all. Runtime validation Messages produced and consumed are both required for runtime message validation. The AsyncAPI document should include descriptions of payload schemas so that you can read them in your application and validate messages that are consumed and produced by the application. Before messages reach the consumer, runtime validation ensures that any errors are resolved and valid messages are sent to your application. An example implementation of message validation in runtime is the asyncapi-validator library that enables you to validate messages produced/consumed in your application against schemas provided in your AsyncAPI document. Check out the message validation in the runtime tutorial if you want to get your hands dirty with message validation. Gateway validation A gateway intercepts all incoming messages and routes them through the middleware and handler pipelines. The gateway sits between the producer and the broker. First, the messages are routed through the gateway, and then the gateway determines whether the message is valid. If the message is invalid, it displays an error and is not forwarded to the broker. An example implementation of message validation in a gateway is the AsyncAPI gateway . It intercepts all incoming messages moving them into a pipeline of middlewares and handlers such as message validation. You can use a Kafka consumer/producer (kcat) , a broker, and a simple WebSocket to run the AsyncAPI gateway in your machine. Check out an AsyncAPI file demo with Studio to learn more about how an AsyncAPI file can be used in gateway validation. Remember Currently, only the Kafka protocol is supported. The AsyncAPI document is important because payload schemas are taken from it, and messages are validated against it in your application. You can spin up the AsyncAPI gateway using an AsyncAPI file. All the messages are forwarded to a WebSocket endpoint; if the message/payload is invalid, it includes a validation error message. Schema Registry validation Producers and consumers do not communicate with each other directly; rather, information transfer happens via Kafka. At the same time, the consumer still needs to know the type of data the producer is sending. Imagine if the producer starts sending bad data to Kafka or if the data type of your data gets changed. We need a way to have a common data type that must be agreed upon. This is where Schema Registry comes into play. It is an application that runs outside your Kafka protocol and handles schema distribution to producers and consumers by storing a copy of the schema in its local cache and validating them in Kafka. With the Schema Registry in place, the producer first talks to the Schema Registry and checks if the schema of the message it wants to send is available before sending it to the broker. If it cannot locate the schema, it registers it in the Schema Registry. Then the producer sends a message to the broker prefixed with a unique schema ID. When the consumer processes this message, it will communicate with the Schema Registry using the schema ID obtained from the producer. If there is a schema mismatch, the Schema Registry will throw an error, informing the producer that it violates the schema agreement. AsyncAPI is not directly involved in validation based on the Schema Registry. The good thing is that you do not have to duplicate schemas in your AsyncAPI document stored in Schema Registry. You can reference schemas from Schema Registry in your AsyncAPI documents. Here's an example of an AsyncAPI document where you can see both schemaFormat and payload referenced from the Schema Registry: \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: Example with Avro\n4  version: 0.1.0\n5\n6channels:\n7  example:\n8    address: 'example'\n9    messages:\n10      avroMessage:\n11        payload:\n12          schemaFormat: 'application/vnd.apache.avro;version=1.9.0'\n13          schema:\n14            $ref: 'https://raw.githubusercontent.com/asyncapi/website/20a31a0396b41dd24b1bac877ab7ce3f58037c28/public/resources/casestudies/adeo/CostingRequestPayload.avsc'\n15\n16operations:\n17  onMessage:\n18    action: receive\n19    channel:\n20      $ref: '#/channels/example'\n```\n Go Back Validate AsyncAPI documents Up Next Reference - Overview Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1asyncapi: 3.0.0\n2info:\n3  title: Example with Avro\n4  version: 0.1.0\n5\n6channels:\n7  example:\n8    address: 'example'\n9    messages:\n10      avroMessage:\n11        payload:\n12          schemaFormat: 'application/vnd.apache.avro;version=1.9.0'\n13          schema:\n14            $ref: 'https://raw.githubusercontent.com/asyncapi/website/20a31a0396b41dd24b1bac877ab7ce3f58037c28/public/resources/casestudies/adeo/CostingRequestPayload.avsc'\n15\n16operations:\n17  onMessage:\n18    action: receive\n19    channel:\n20      $ref: '#/channels/example'"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "07b353a2",
    "title": "Validate AsyncAPI documents | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/guides/validate.html",
    "content": "Validate AsyncAPI documents | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Introduction Validate AsyncAPI documents Validate against specification AsyncAPI Studio validation AsyncAPI CLI validation Parsers (code) validation Validation against best practices or company governance rules Additional resources Validate AsyncAPI documents Found an error? Have a suggestion? Edit this page on GitHub Introduction In this guide, you'll learn multiple ways to validate AsyncAPI documents. Validate AsyncAPI documents Validating an AsyncAPI document can mean one of two things: Validation against the specification. Validation against the best practices or company governance rules also known as linting. Validate against specification Validating against the specification ensures that every content of the document is written in accordance with the AsyncAPI specification. Several tool options exist for validating against the specification: AsyncAPI Studio , AsyncAPI CLI , and Parsers . AsyncAPI Studio validation AsyncAPI Studio provides a visual and easy way to validate your AsyncAPI documents against the specification. (It uses the AsyncAPI JavaScript parser behind the scenes to perform syntax checks and validate documents.) Errors in your document are highlighted with a red underline, showing which lines are invalid. The Diagnostics section also provides feedback, allowing you to further troubleshoot with detailed error messages. When a document is invalid, it provides the following error: Empty or invalid document please fix errors / define AsyncAPI document . AsyncAPI CLI validation The following AsyncAPI CLI command validates AsyncAPI documents in your local computer or in CI/CD automation: asyncapi validate asyncapi.yaml Remember You can also open AsyncAPI Studio from the CLI by running the command asyncapi start studio . Parsers (code) validation AsyncAPI provides official JavaScript and Go parsers for validating AsyncAPI documents. Remember Official parsers use JSON Schema created for AsyncAPI specification. JSON Schema is not enough to fully validate AsyncAPI documents. Learn more about custom JSON Schemas validation needs . Official JavaScript parser supports and validates these special needs. Take it into account if you're thinking about writing your own parser using official JSON Schema. Validation against best practices or company governance rules Now let's discuss options for validating against best practices or company governance rules, also known as linting . When various teams use AsyncAPI, you want to ensure they follow the same rules and are consistent across the organization. It is not enough to validate AsyncAPI documents against official specification rules. Remember Let's discuss an example. While the summary property is optional in an AsyncAPI document, you could choose to require it for your organization. You would then implement a solution that enables you to enforce internal rules on AsyncAPI documents' providers. One way to do this is to use the Spectral open-source tool. It enables you to define company-specific rules that you can use internally. To get started: Install Spectral . Create a file named .spectral.yaml to begin writing your API description and document rules. Example: \n```javascript\n1{\n2  \"rules\": {\n3    // add your own rules here\n4  }\n5}\n```\n Create and add your own custom ruleset: \n```javascript\n1 {\n2     \"rules\": {\n3         \"valid-document-version\": {\n4             \"message\": \"Application title must start with upper case\",\n5             \"severity\": \"error\",\n6             \"given\": \"$.info\",\n7             \"then\": [\n8                 {\n9                     \"field\": \"title\",\n10                     \"function\": \"pattern\",\n11                     \"functionOptions\": {\n12                         \"match\": \"^[A-Z]\"\n13                     }\n14                 }\n15             ]\n16         }\n17     }\n18 }\n```\n After setting up Spectral and creating custom rules following steps 1 - 3, validate your AsyncAPI document using this Spectral CLI command: spectral lint asyncapi.yaml Additional resources AsyncAPI Studio READme AsyncAPI CLI READme AsyncAPI JavaScript Parsers READme AsyncAPI Go Parsers READme Go Back Overview Up Next Message validation Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1{\n2  \"rules\": {\n3    // add your own rules here\n4  }\n5}",
      "1 {\n2     \"rules\": {\n3         \"valid-document-version\": {\n4             \"message\": \"Application title must start with upper case\",\n5             \"severity\": \"error\",\n6             \"given\": \"$.info\",\n7             \"then\": [\n8                 {\n9                     \"field\": \"title\",\n10                     \"function\": \"pattern\",\n11                     \"functionOptions\": {\n12                         \"match\": \"^[A-Z]\"\n13                     }\n14                 }\n15             ]\n16         }\n17     }\n18 }"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "8dc20a3d",
    "title": "Migrating to v3 | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/migration/migrating-to-v3.html",
    "content": "Migrating to v3 | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Moved metadata Server URL splitting up Operation, channel, and message decoupling Channel address and channel key Operation keywords Messages instead of message Unifying explicit and implicit references New trait behavior Schema format and schemas Optional channels Restricted parameters object Migrating to v3 Found an error? Have a suggestion? Edit this page on GitHub Migration to a new major version is always difficult, and AsyncAPI is no exception. To provide as smooth a transition as possible, this document shows the breaking changes between AsyncAPI v2 and v3 in an interactive manner. If you want to update your AsyncAPI document, use the AsyncAPI converter directly in the CLI with the following command: \n```javascript\nasyncapi convert asyncapi.json --output=asyncapi_v3.json --target-version=3.0.0\n```\n For a detailed read-through about all the changes (non-breaking as well), read all the v3 release notes first to acquire additional context about the changes introduced in v3. Moved metadata In v2, two properties of tags and externalDocs were placed outside of the Info Object . For consistency, info has been moved in v3. AsyncAPI 2.x Info Tags External Docs AsyncAPI 3.0 Info Tags External Docs \n```javascript\n1asyncapi: 2.6.0\n2info: \n3  ...\n4externalDocs:\n5  description: Find more info here\n6  url: https://www.asyncapi.com\n7tags:\n8  - name: e-commerce\n```\n \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  externalDocs:\n4    description: Find more info here\n5    url: https://www.asyncapi.com\n6  tags:\n7    - name: e-commerce\n```\n Server URL splitting up There was occasional confusion regarding what the URL of a Server Object should include. AsyncAPI 2.x Servers Server Url AsyncAPI 3.0 Servers Server Host Pathname In v2, the URL was often a lengthy string, sometimes redundantly including details like the protocol. In v3, the url property has been divided into host , pathname , and protocol \u2014as was the case in v2\u2014making the information more explicit. \n```javascript\n1asyncapi: 2.6.0\n2servers:\n3  production:\n4    url: \"amqp://rabbitmq.in.mycompany.com:5672/production\"\n5    protocol: \"amqp\"\n```\n \n```javascript\n1asyncapi: 3.0.0\n2servers:\n3  production:\n4    host: \"rabbitmq.in.mycompany.com:5672\",\n5    pathname: \"/production\",\n6    protocol: \"amqp\",\n```\n Operation, channel, and message decoupling The decoupling of operations, channels, and messages is the most significant breaking change in v3, fundamentally altering how they relate to each other. AsyncAPI 2.x Channels Channel Item Operation (Publish and Subscribe) Messages Message Headers Payload AsyncAPI 3.0 Channels Channel Messages Message Headers Payload Operations Operation action (send or receive) channel messages In v2, reusing channels and having multiple operations per channel, such as operation variants, was impossible. In v3, this has become possible, emphasizing that a channel and message should be independent of the operations performed. For message brokers like Kafka, this is akin to defining topics and their associated messages. In REST interfaces, it pertains to the path and request type (e.g., POST, GET), along with the corresponding request and response messages. For WebSocket, it encompasses all messages transmitted through the WebSocket server. For Socket.IO, it delineates all the rooms and their messages. Channels are now reusable across multiple AsyncAPI documents, each facilitating a slightly different action. \n```javascript\n1asyncapi: 2.6.0\n2...\n3channels: \n4  user/signedup:\n5    publish:\n6      message:\n7        payload:\n8          type: object\n9          properties:\n10            displayName:\n11              type: string\n12              description: Name of the user\n```\n \n```javascript\n1asyncapi: 3.0.0\n2...\n3channels:\n4  UserSignup:\n5    address: \"user/signedup\"\n6    messages: \n7      UserMessage: \n8        payload:\n9          type: object\n10          properties:\n11            displayName:\n12              type: string\n13              description: Name of the user\n14operations:\n15  ConsumeUserSignups:\n16    action: receive\n17    channel: \n18      $ref: \"#/channels/UserSignup\"\n```\n Read more about the confusion between publishing and subscribing in the Operation keywords section. Channel address and channel key Another breaking change is that the channel key no longer represents the channel path. Instead, it's now an arbitrary unique ID. The channel paths are now defined using the address property within the Channel Object . AsyncAPI 2.x Channels Channel Item AsyncAPI 3.0 Channels Channel address In v2, the channel's address/topic/path doubled as its ID, hindering reusability and preventing the definition of scenarios where the same address was used in different contexts. In v3, the address/topic/path has been shifted to an address property, allowing the channel ID to be distinct and arbitrary. \n```javascript\n1asyncapi: 2.6.0\n2...\n3channels: \n4  test/path:\n5    ...\n```\n \n```javascript\n1asyncapi: 3.0.0\n2channels:\n3  testPathChannel:\n4    address: \"test/path\"\n```\n Operation keywords Another significant change is the shift away from defining operations using publish and subscribe , which had inverse meanings for your application. Now, you directly specify your application's behavior using send and receive via the action property in the Operation Object . AsyncAPI 2.x Channels Channel Item Operation (Publish and Subscribe) AsyncAPI 3.0 Operations Operation action (send or receive) In v2, the publish and subscribe operations consistently caused confusion, even among those familiar with the intricacies. When you specified publish , it implied that others could publish to this channel since your application subscribed to it. Conversely, subscribe meant that others could subscribe because your application was the one publishing. In v3, these operations have been entirely replaced with an action property that clearly indicates what your application does. That eliminates ambiguities related to other parties or differing perspectives. Read more information about the confusion between publishing and subscribing: Fran M\u00e9ndez's Proposal to solve publish/subscribe confusion Nic Townsend's blog post Demystifying the Semantics of Publish and Subscribe Here is an example where the application both consumes and produces messages to the test channel: \n```javascript\n1asyncapi: 2.6.0\n2...\n3channels: \n4  test/path:\n5    subscribe:\n6      ...\n7    publish:\n8      ...\n```\n \n```javascript\n1asyncapi: 3.0.0\n2channels:\n3  testPathChannel:\n4    address: \"test/path\"\n5    ...\n6operations: \n7  publishToTestPath:\n8    action: send\n9    channel: \n10      $ref: \"#/channels/testPathChannel\"\n11  consumeFromTestPath:\n12    action: receive\n13    channel: \n14      $ref: \"#/channels/testPathChannel\"\n```\n Messages instead of message In v2, channels were defined with one or more messages using the oneOf property. In v3, messages are defined using the Messages Object . For a channel with multiple messages, you specify multiple key-value pairs. For a channel with just one message, you use a single key-value pair. \n```javascript\n1asyncapi: 2.6.0\n2...\n3channels:\n4  user/signedup:\n5    message: \n6      oneOf:\n7        - messageId: UserMessage\n8          ...\n9        - messageId: UserMessage2\n10          ...\n11\n12asyncapi: 2.6.0\n13...\n14channels:\n15  user/signedup:\n16    message: \n17      messageId: UserMessage\n18      ...\n```\n \n```javascript\n1asyncapi: 3.0.0\n2...\n3channels:\n4  UserSignup:\n5    address: user/signedup\n6    messages: \n7      UserMessage: \n8        ...\n9      UserMessage2:\n10        ...\n11\n12asyncapi: 3.0.0\n13...\n14channels:\n15  UserSignup:\n16    address: user/signedup\n17    messages: \n18      UserMessage: \n19        ...\n```\n We have updated the structure of the Message Object by eliminating the messageId property. We now use the ID of the Message Object itself as the key in the key/value pairing, rendering a separate messageId property redundant. Unifying explicit and implicit references In v2, implicit references were allowed in certain instances. For instance, the server security configuration was identified by name, linking to a Security Schema Object within the components. Similarly, a channel could reference global servers by name. In v3, all such references MUST be explicit. As a result, we made a minor modification to the Server Object security property, transforming it from an object to an array. The details regarding required scopes for OAuth and OpenID Connect were then relocated to the Security Scheme Object . \n```javascript\n1asyncapi: 2.6.0\n2servers:\n3  production:\n4    ...\n5    security:\n6      oauth_test: [\"write:pets\"]\n7...\n8channels: \n9  test/path:\n10    servers:\n11      - production\n12components:\n13  securitySchemes:\n14    oauth_test: \n15      type: oauth2\n16      flows:\n17        implicit:\n18          authorizationUrl: https://example.com/api/oauth/dialog\n19          availableScopes:\n20            write:pets: modify pets in your account\n21            read:pets: read your pets\n22      scopes:\n23        - 'write:pets'\n```\n \n```javascript\n1asyncapi: 3.0.0\n2servers:\n3  production:\n4    ...\n5    security:\n6      - $ref: \"#/components/securitySchemes/oauth_test\"\n7...\n8channels: \n9  test/path:\n10    servers:\n11      - $ref: \"#/servers/production\"\n12components:\n13  securitySchemes:\n14    oauth_test:\n15      type: oauth2\n16      flows:\n17        implicit:\n18          authorizationUrl: https://example.com/api/oauth/dialog\n19          availableScopes:\n20            write:pets: modify pets in your account\n21            read:pets: read your pets\n22      scopes:\n23        - \"write:pets\"\n```\n New trait behavior In v2, traits invariably overwrote any duplicate properties specified both in the traits and the corresponding object. For instance, if both message traits and the message object defined headers, only the headers from the message traits would be recognized, effectively overriding those in the Message Object. In v3, this behavior has been revised. The primary objects now take precedence over any definitions in the traits. Such an adjustment is consistent for traits in both operation and message objects. Here is a message object and associated traits: \n```javascript\n1messageId: userSignup\n2description: A longer description.\n3payload:\n4  $ref: '#/components/schemas/userSignupPayload'\n5traits:\n6  - summary: Action to sign a user up.\n7    description: Description from trait.\n```\n In v2, after applying the traits, the complete message object appeared as follows. Note how the description was overridden: \n```javascript\n1messageId: userSignup\n2summary: Action to sign a user up.\n3description: Description from trait.\n4payload:\n5  $ref: '#/components/schemas/userSignupPayload'\n```\n That is the default behavior of the JSON Merge Patch algorithm we use. In v3, we've instituted a guideline stating, A property on a trait MUST NOT override the same property on the target object . Consequently, after applying the traits in v3, the complete message object appears as follows: \n```javascript\n1messageId: userSignup\n2summary: Action to sign a user up.\n3description: A longer description. # it's still description from \"main\" object\n4payload:\n5  $ref: '#/components/schemas/userSignupPayload'\n```\n Notice how the description is no longer overwritten. Schema format and schemas One limitation with schemas has always been the inability to reuse them across different schema formats. AsyncAPI 2.x components | channels messages message schemaFormat payload schema AsyncAPI 3.0 components | channels messages message payload schemaFormat schema In v2, the details about which schema format the payload uses are found within the message object, rather than being directly linked to the schema itself. Such separation hampers reusability, as the two data points aren't directly correlated. To address this in v3, we've introduced a multi-format schema object that consolidates this information. Consequently, whenever you utilize schemaFormat , you'll need to modify the schema as follows: \n```javascript\n1asyncapi: 2.6.0\n2...\n3channels:\n4  user/signedup:\n5    publish:\n6      message: \n7        schemaFormat: 'application/vnd.apache.avro;version=1.9.0'\n8        payload:\n9          type: record\n10          name: User\n11          namespace: com.company\n12          doc: User information\n13          fields:\n14            - name: displayName\n15              type: string\n```\n \n```javascript\n1asyncapi: 3.0.0\n2...\n3channels:\n4  UserSignup:\n5    address: user/signedup\n6    messages: \n7      userSignup: \n8        payload:\n9          schemaFormat: 'application/vnd.apache.avro;version=1.9.0'\n10          schema:\n11            type: record\n12            name: User\n13            namespace: com.company\n14            doc: User information\n15            fields:\n16              - name: displayName\n17                type: string\n```\n Optional channels In v3, defining channels has become entirely optional, eliminating the need to specify channels as an empty object (required in v2). \n```javascript\n1asyncapi: 2.6.0\n2...\n3channels: {}\n```\n \n```javascript\n1asyncapi: 3.0.0\n2...\n```\n Restricted parameters object Parameters have often prioritized convenience over accurately reflecting real-world use cases. AsyncAPI 2.x components | channels parameters parameter location description schema type enum examples default description pattern multipleOf And all other properties AsyncAPI 3.0 components | channels parameters parameter location description enum examples default In v2, we significantly streamlined the Schema Object. While the previous version offered full capability with numerous, often underutilized options, it posed challenges in serializing objects or booleans in the channel path. The new v3 simplifies this by consistently using the string type and limiting available properties. Now, you can only access enum , default , description , examples , and location , ensuring a more focused and practical approach. \n```javascript\n1asyncapi: 2.6.0\n2...\n3channels: \n4  user/{user_id}/signedup:\n5    parameters:\n6      location: \"$message.payload\"\n7      description: Just a test description\n8      schema:\n9        type: string\n10        enum: [\"test\"]\n11        default: \"test\"\n12        examples: [\"test\"]\n13    ...\n```\n \n```javascript\n1asyncapi: 3.0.0\n2...\n3channels: \n4  userSignedUp:\n5    address: user/{user_id}/signedup\n6    parameters:\n7      user_id: \n8        enum: [\"test\"]\n9        default: \"test\"\n10        description: Just a test description\n11        examples: [\"test\"]\n12        location: \"$message.payload\"\n```\n Go Back Overview Up Next Community - Overview Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "asyncapi convert asyncapi.json --output=asyncapi_v3.json --target-version=3.0.0",
      "1asyncapi: 2.6.0\n2info: \n3  ...\n4externalDocs:\n5  description: Find more info here\n6  url: https://www.asyncapi.com\n7tags:\n8  - name: e-commerce",
      "1asyncapi: 3.0.0\n2info:\n3  externalDocs:\n4    description: Find more info here\n5    url: https://www.asyncapi.com\n6  tags:\n7    - name: e-commerce",
      "1asyncapi: 2.6.0\n2servers:\n3  production:\n4    url: \"amqp://rabbitmq.in.mycompany.com:5672/production\"\n5    protocol: \"amqp\"",
      "1asyncapi: 3.0.0\n2servers:\n3  production:\n4    host: \"rabbitmq.in.mycompany.com:5672\",\n5    pathname: \"/production\",\n6    protocol: \"amqp\",",
      "1asyncapi: 2.6.0\n2...\n3channels: \n4  user/signedup:\n5    publish:\n6      message:\n7        payload:\n8          type: object\n9          properties:\n10            displayName:\n11              type: string\n12              description: Name of the user",
      "1asyncapi: 3.0.0\n2...\n3channels:\n4  UserSignup:\n5    address: \"user/signedup\"\n6    messages: \n7      UserMessage: \n8        payload:\n9          type: object\n10          properties:\n11            displayName:\n12              type: string\n13              description: Name of the user\n14operations:\n15  ConsumeUserSignups:\n16    action: receive\n17    channel: \n18      $ref: \"#/channels/UserSignup\"",
      "1asyncapi: 2.6.0\n2...\n3channels: \n4  test/path:\n5    ...",
      "1asyncapi: 3.0.0\n2channels:\n3  testPathChannel:\n4    address: \"test/path\"",
      "1asyncapi: 2.6.0\n2...\n3channels: \n4  test/path:\n5    subscribe:\n6      ...\n7    publish:\n8      ...",
      "1asyncapi: 3.0.0\n2channels:\n3  testPathChannel:\n4    address: \"test/path\"\n5    ...\n6operations: \n7  publishToTestPath:\n8    action: send\n9    channel: \n10      $ref: \"#/channels/testPathChannel\"\n11  consumeFromTestPath:\n12    action: receive\n13    channel: \n14      $ref: \"#/channels/testPathChannel\"",
      "1asyncapi: 2.6.0\n2...\n3channels:\n4  user/signedup:\n5    message: \n6      oneOf:\n7        - messageId: UserMessage\n8          ...\n9        - messageId: UserMessage2\n10          ...\n11\n12asyncapi: 2.6.0\n13...\n14channels:\n15  user/signedup:\n16    message: \n17      messageId: UserMessage\n18      ...",
      "1asyncapi: 3.0.0\n2...\n3channels:\n4  UserSignup:\n5    address: user/signedup\n6    messages: \n7      UserMessage: \n8        ...\n9      UserMessage2:\n10        ...\n11\n12asyncapi: 3.0.0\n13...\n14channels:\n15  UserSignup:\n16    address: user/signedup\n17    messages: \n18      UserMessage: \n19        ...",
      "1asyncapi: 2.6.0\n2servers:\n3  production:\n4    ...\n5    security:\n6      oauth_test: [\"write:pets\"]\n7...\n8channels: \n9  test/path:\n10    servers:\n11      - production\n12components:\n13  securitySchemes:\n14    oauth_test: \n15      type: oauth2\n16      flows:\n17        implicit:\n18          authorizationUrl: https://example.com/api/oauth/dialog\n19          availableScopes:\n20            write:pets: modify pets in your account\n21            read:pets: read your pets\n22      scopes:\n23        - 'write:pets'",
      "1asyncapi: 3.0.0\n2servers:\n3  production:\n4    ...\n5    security:\n6      - $ref: \"#/components/securitySchemes/oauth_test\"\n7...\n8channels: \n9  test/path:\n10    servers:\n11      - $ref: \"#/servers/production\"\n12components:\n13  securitySchemes:\n14    oauth_test:\n15      type: oauth2\n16      flows:\n17        implicit:\n18          authorizationUrl: https://example.com/api/oauth/dialog\n19          availableScopes:\n20            write:pets: modify pets in your account\n21            read:pets: read your pets\n22      scopes:\n23        - \"write:pets\"",
      "1messageId: userSignup\n2description: A longer description.\n3payload:\n4  $ref: '#/components/schemas/userSignupPayload'\n5traits:\n6  - summary: Action to sign a user up.\n7    description: Description from trait.",
      "1messageId: userSignup\n2summary: Action to sign a user up.\n3description: Description from trait.\n4payload:\n5  $ref: '#/components/schemas/userSignupPayload'",
      "1messageId: userSignup\n2summary: Action to sign a user up.\n3description: A longer description. # it's still description from \"main\" object\n4payload:\n5  $ref: '#/components/schemas/userSignupPayload'",
      "1asyncapi: 2.6.0\n2...\n3channels:\n4  user/signedup:\n5    publish:\n6      message: \n7        schemaFormat: 'application/vnd.apache.avro;version=1.9.0'\n8        payload:\n9          type: record\n10          name: User\n11          namespace: com.company\n12          doc: User information\n13          fields:\n14            - name: displayName\n15              type: string",
      "1asyncapi: 3.0.0\n2...\n3channels:\n4  UserSignup:\n5    address: user/signedup\n6    messages: \n7      userSignup: \n8        payload:\n9          schemaFormat: 'application/vnd.apache.avro;version=1.9.0'\n10          schema:\n11            type: record\n12            name: User\n13            namespace: com.company\n14            doc: User information\n15            fields:\n16              - name: displayName\n17                type: string",
      "1asyncapi: 2.6.0\n2...\n3channels: {}",
      "1asyncapi: 3.0.0\n2...",
      "1asyncapi: 2.6.0\n2...\n3channels: \n4  user/{user_id}/signedup:\n5    parameters:\n6      location: \"$message.payload\"\n7      description: Just a test description\n8      schema:\n9        type: string\n10        enum: [\"test\"]\n11        default: \"test\"\n12        examples: [\"test\"]\n13    ...",
      "1asyncapi: 3.0.0\n2...\n3channels: \n4  userSignedUp:\n5    address: user/{user_id}/signedup\n6    parameters:\n7      user_id: \n8        enum: [\"test\"]\n9        default: \"test\"\n10        description: Just a test description\n11        examples: [\"test\"]\n12        location: \"$message.payload\""
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "d1784f84",
    "title": "Overview | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/reference/bindings.html",
    "content": "Overview | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Overview Usage in an AsyncAPI document Contributing to bindings Overview Found an error? Have a suggestion? Edit this page on GitHub Overview Bindings in AsyncAPI provide a way to add protocol-specific information to the AsyncAPI documentation. They can be added to different document parts, such as servers, channels, or messages; they specify standard details specific to a particular protocol. The purpose of bindings is to enhance the API's understanding and usage by providing additional context and configuration options for different protocols. Usage in an AsyncAPI document To learn how to add bindings to your AsyncAPI document, read Adding bindings concept document, or read the guide about using Kafka bindings . Contributing to bindings Bindings are maintained by different community members that know and use given protocol and technology in production. If something can be improved, or some new binding is needed, open an issue in bindings repository . Go Back Reference - x Up Next Migrations - Overview Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "68d737eb",
    "title": "Overview | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/reference/extensions.html",
    "content": "Overview | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page What's an extension? Usage in an AsyncAPI document Adding your extension to the catalog Overview Found an error? Have a suggestion? Edit this page on GitHub What's an extension? Extension is a mechanism in AsyncAPI that enables you to add custom fields to an AsyncAPI document. You can define your own extensions or use them only for your use case inside your company. You can also share your extensions with others. This way an extension that is adopted by others can one day become a core part of the AsyncAPI specification. Usage in an AsyncAPI document AsyncAPI extensions are those that are preceded by x- . (Example: x-linkedin ) They can be placed in the AsyncAPI document in locations specified by the documentation of a given extension. Adding your extension to the catalog If you'd like to add your extension to the catalog, please submit a pull request to the Extensions Catalog repository. Make sure the extension doesn't exist already; otherwise, it's better to improve the existing one. Go Back Reference - Specification Visualizer Up Next linkedin Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "b544ae8b",
    "title": "linkedin | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/reference/extensions/linkedin.html",
    "content": "linkedin | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Linkedin Extension Overview Version Extension Definition Type: String Extension Location Example linkedin Found an error? Have a suggestion? Edit this page on GitHub Linkedin Extension This document defines how to use linkedin extension in AsyncAPI documents. Overview This extension allows you to provide the Linkedin username of the account representing the team/company of the API. Version Current version is 0.1.0 . Extension Definition Type: String URL of the Linkedin Profile of the user or company. Extension Location This extension can be used in the following locations: Info Object Example \n```javascript\n1asyncapi: '3.0.0'\n2info\n3  title: AsyncAPI Initiative Example\n4  version: '1.0.0'\n5  x-linkedin: https://www.linkedin.com/company/asyncapi\n```\n Go Back Overview Up Next x Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1asyncapi: '3.0.0'\n2info\n3  title: AsyncAPI Initiative Example\n4  version: '1.0.0'\n5  x-linkedin: https://www.linkedin.com/company/asyncapi"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "d37dace5",
    "title": "x | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/reference/extensions/x.html",
    "content": "x | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Twitter/X Extension Overview Version Extension Definition Type: String Extension Location Example x Found an error? Have a suggestion? Edit this page on GitHub Twitter/X Extension This document defines how to use x extension in AsyncAPI documents. Overview This extension allows you to provide the Twitter/X username of the account representing the team/company of the API. Version Current version is 0.1.0 . Extension Definition Type: String Name of the Twitter/X username. Extension Location This extension can be used in the following locations: Info Object Example \n```javascript\n1asyncapi: '3.0.0'\n2info\n3  title: Strretlights Kafka API\n4  version: '1.0.0'\n5  x-x: StreetLightData\n```\n Go Back linkedin Up Next Bindings - Overview Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1asyncapi: '3.0.0'\n2info\n3  title: Strretlights Kafka API\n4  version: '1.0.0'\n5  x-x: StreetLightData"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "7854e945",
    "title": "3.0.0 | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/reference/specification/latest.html",
    "content": "3.0.0 | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page AsyncAPI Specification Attribution Version 3.0.0 Introduction Definitions Server Application Sender Receiver Message Channel Protocol Bindings Specification Format File Structure Absolute URLs Schema AsyncAPI Object AsyncAPI Version String Identifier Info Object Contact Object License Object Servers Object Server Object Server Variable Object Default Content Type Channels Object Channel Object Channel Address Expressions Messages Object Operations Object Operation Object Operation Trait Object Operation Reply Object Operation Reply Address Object Parameters Object Parameter Object Server Bindings Object Channel Bindings Object Operation Bindings Object Message Bindings Object Message Object Message Trait Object Message Example Object Tags Object Tag Object External Documentation Object Reference Object Components Object Multi Format Schema Object Schema Object Security Scheme Object OAuth Flows Object OAuth Flow Object Correlation ID Object Fixed Fields Runtime Expression Examples Traits Merge Mechanism Example Specification Extensions Data Type Formats 3.0.0 Found an error? Have a suggestion? Edit this page on GitHub What is new in v3.0.0? Have a look at the release notes . Interested in release notes of other versions of the specification? Check list of release notes . AsyncAPI Specification Attribution Part of this content has been taken from the great work done by the folks at the OpenAPI Initiative . Version 3.0.0 The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 . The AsyncAPI Specification is licensed under The Apache License, Version 2.0 . Introduction The AsyncAPI Specification is a project used to describe message-driven APIs in a machine-readable format. It\u2019s protocol-agnostic, so you can use it for APIs that work over any protocol (e.g., AMQP, MQTT, WebSockets, Kafka, STOMP, HTTP, Mercure, etc). The AsyncAPI Specification defines a set of fields that can be used in an AsyncAPI document to describe an application 's API. The document may reference other files for additional details or shared fields, but it is typically a single, primary document that encapsulates the API description. The AsyncAPI document SHOULD describe the operations an application performs. For instance, consider the following AsyncAPI definition snippet: \n```javascript\n1channels:\n2  userSignedUp:\n3    # ...(redacted for brevity)\n4operations:\n5  onUserSignedUp:\n6    action: receive\n7    channel:\n8      $ref: \"#/channels/userSignedUp\"\n```\n It means that the application will receive messages from the userSignedUp channel . The AsyncAPI specification does not assume any kind of software topology, architecture or pattern. Therefore, a server MAY be a message broker, a web server or any other kind of computer program capable of sending and/or receiving data. However, AsyncAPI offers a mechanism called \"bindings\" that aims to help with more specific information about the protocol. It's NOT RECOMMENDED to derive a receiver AsyncAPI document from a sender one or vice versa. There are no guarantees that the channel used by an application to receive messages will be the same channel where another application is sending them. Also, certain fields in the document like summary , description , and the id of the operation might stop making sense. For instance, given the following receiver snippet: \n```javascript\n1operations:\n2  onUserSignedUp:\n3    summary: On user signed up.\n4    description: Event received when a user signed up on the product.\n5    action: receive\n6    channel:\n7      $ref: \"#/channels/userSignedUp\"\n```\n We can't automatically assume that an opposite application exists by simply replacing receive with send : \n```javascript\n1operations:\n2  onUserSignedUp: # <-- This doesn't make sense now. Should be something like sendUserSignedUp.\n3    summary: On user signed up. # <-- This doesn't make sense now. Should say something like \"Sends a user signed up event\".\n4    description: Event received when a user signed up on the product. # <-- This doesn't make sense now. Should speak about sending an event, not receiving it.\n5    action: send\n6    channel:\n7      $ref: \"#/channels/userSignedUp\"\n```\n Aside from the issues mentioned above, there may also be infrastructure configuration that is not represented here. For instance, a system may use a read-only channel for receiving messages, a different one for sending them, and an intermediary process that will forward messages from one channel to the other. Definitions Server A server MAY be a message broker that is capable of sending and/or receiving between a sender and receiver . A server MAY be a service with WebSocket API that enables message-driven communication between browser-to-server or server-to-server. Application An application is any kind of computer program or a group of them. It MUST be a sender , a receiver , or both. An application MAY be a microservice, IoT device (sensor), mainframe process, message broker, etc. An application MAY be written in any number of different programming languages as long as they support the selected protocol . An application MUST also use a protocol supported by the server in order to connect and exchange messages . Sender A sender is a type of application, that is sending messages to channels . A sender MAY send to multiple channels depending on the server , protocol, and use-case pattern. Receiver A receiver is a type of application that is receiving messages from channels . A receiver MAY receive from multiple channels depending on the server , protocol, and the use-case pattern. A receiver MAY forward a received message further without changing it. A receiver MAY act as a consumer and react to the message. A receiver MAY act as a processor that, for example, aggregates multiple messages in one and forwards them. Message A message is the mechanism by which information is exchanged via a channel between servers and applications. A message MAY contain a payload and MAY also contain headers. The headers MAY be subdivided into protocol -defined headers and header properties defined by the application which can act as supporting metadata. The payload contains the data, defined by the application, which MUST be serialized into a format (JSON, XML, Avro, binary, etc.). Since a message is a generic mechanism, it can support multiple interaction patterns such as event, command, request, or response. Channel A channel is an addressable component, made available by the server , for the organization of messages . Sender applications send messages to channels and receiver applications receive messages from channels. Servers MAY support many channel instances, allowing messages with different content to be addressed to different channels. Depending on the server implementation, the channel MAY be included in the message via protocol-defined headers. Protocol A protocol is the mechanism (wireline protocol or API) by which messages are exchanged between the application and the channel . Example protocols include, but are not limited to, AMQP, HTTP, JMS, Kafka, Anypoint MQ, MQTT, Solace, STOMP, Mercure, WebSocket, Google Pub/Sub, Pulsar. Bindings A \"binding\" (or \"protocol binding\") is a mechanism to define protocol-specific information. Therefore, a protocol binding MUST define protocol-specific information only. Specification Format The files describing the message-driven API in accordance with the AsyncAPI Specification are represented as JSON objects and conform to the JSON standards. YAML, being a superset of JSON, can be used as well to represent a A2S (AsyncAPI Specification) file. For example, if a field is said to have an array value, the JSON array representation will be used: \n```javascript\n1{\n2   \"field\" : [...]\n3}\n```\n While the API is described using JSON it does not impose a JSON input/output to the API itself. All field names in the specification are case sensitive . The schema exposes two types of fields. Fixed fields, which have a declared name, and Patterned fields, which declare a regex pattern for the field name. Patterned fields can have multiple occurrences as long as each has a unique name. In order to preserve the ability to round-trip between YAML and JSON formats, YAML version 1.2 is recommended along with some additional constraints: Tags MUST be limited to those allowed by the JSON Schema ruleset Keys used in YAML maps MUST be limited to a scalar string, as defined by the YAML Failsafe schema ruleset File Structure An AsyncAPI document MAY be made up of a single document or be divided into multiple, connected parts at the discretion of the author. In the latter case, Reference Objects are used. It is important to note that everything that is defined in an AsyncAPI document MUST be used by the implemented Application , with the exception of the Components Object . Everything that is defined inside the Components Object represents a resource that MAY or MAY NOT be used by the implemented Application . By convention, the AsyncAPI Specification (A2S) file is named asyncapi.json or asyncapi.yaml . Absolute URLs Unless specified otherwise, all properties that are absolute URLs are defined by RFC3986, section 4.3 . Schema AsyncAPI Object This is the root document object for the API specification. It combines resource listing and API declaration together into one document. Fixed Fields Field Name Type Description asyncapi AsyncAPI Version String REQUIRED. Specifies the AsyncAPI Specification version being used. It can be used by tooling Specifications and clients to interpret the version. The structure shall be major . minor . patch , where patch versions must be compatible with the existing major . minor tooling. Typically patch versions will be introduced to address errors in the documentation, and tooling should typically be compatible with the corresponding major . minor (1.0.*). Patch versions will correspond to patches of this document. id Identifier Identifier of the application the AsyncAPI document is defining. info Info Object REQUIRED. Provides metadata about the API. The metadata can be used by the clients if needed. servers Servers Object Provides connection details of servers. defaultContentType Default Content Type Default content type to use when encoding/decoding a message's payload. channels Channels Object The channels used by this application . operations Operations Object The operations this application MUST implement. components Components Object An element to hold various reusable objects for the specification. Everything that is defined inside this object represents a resource that MAY or MAY NOT be used in the rest of the document and MAY or MAY NOT be used by the implemented Application . This object MAY be extended with Specification Extensions . AsyncAPI Version String The version string signifies the version of the AsyncAPI Specification that the document complies to. The format for this string must be major . minor . patch . The patch may be suffixed by a hyphen and extra alphanumeric characters. A major . minor shall be used to designate the AsyncAPI Specification version, and will be considered compatible with the AsyncAPI Specification specified by that major . minor version. The patch version will not be considered by tooling, making no distinction between 1.0.0 and 1.0.1 . In subsequent versions of the AsyncAPI Specification, care will be given such that increments of the minor version should not interfere with operations of tooling developed to a lower minor version. Thus a hypothetical 1.1.0 specification should be usable with tooling designed for 1.0.0 . Identifier This field represents a unique universal identifier of the application the AsyncAPI document is defining. It must conform to the URI format, according to RFC3986 . It is RECOMMENDED to use a URN to globally and uniquely identify the application during long periods of time, even after it becomes unavailable or ceases to exist. Examples \n```javascript\n1{\n2  \"id\": \"urn:example:com:smartylighting:streetlights:server\"\n3}\n```\n \n```yaml\nid: 'urn:example:com:smartylighting:streetlights:server'\n```\n \n```javascript\n1{\n2  \"id\": \"https://github.com/smartylighting/streetlights-server\"\n3}\n```\n \n```yaml\nid: 'https://github.com/smartylighting/streetlights-server'\n```\n Info Object The object provides metadata about the API. The metadata can be used by the clients if needed. Fixed Fields Field Name Type Description title string REQUIRED. The title of the application. version string REQUIRED Provides the version of the application API (not to be confused with the specification version). description string A short description of the application. CommonMark syntax can be used for rich text representation. termsOfService string A URL to the Terms of Service for the API. This MUST be in the form of an absolute URL. contact Contact Object The contact information for the exposed API. license License Object The license information for the exposed API. tags Tags Object A list of tags for application API documentation control. Tags can be used for logical grouping of applications. externalDocs External Documentation Object | Reference Object Additional external documentation of the exposed API. This object MAY be extended with Specification Extensions . Info Object Example \n```javascript\n1{\n2  \"title\": \"AsyncAPI Sample App\",\n3  \"version\": \"1.0.1\",\n4  \"description\": \"This is a sample app.\",\n5  \"termsOfService\": \"https://asyncapi.org/terms/\",\n6  \"contact\": {\n7    \"name\": \"API Support\",\n8    \"url\": \"https://www.asyncapi.org/support\",\n9    \"email\": \"support@asyncapi.org\"\n10  },\n11  \"license\": {\n12    \"name\": \"Apache 2.0\",\n13    \"url\": \"https://www.apache.org/licenses/LICENSE-2.0.html\"\n14  },\n15  \"externalDocs\": {\n16    \"description\": \"Find more info here\",\n17    \"url\": \"https://www.asyncapi.org\"\n18  },\n19  \"tags\": [\n20    {\n21      \"name\": \"e-commerce\"\n22    }\n23  ]\n24}\n```\n \n```javascript\n1title: AsyncAPI Sample App\n2version: 1.0.1\n3description: This is a sample app.\n4termsOfService: https://asyncapi.org/terms/\n5contact:\n6  name: API Support\n7  url: https://www.asyncapi.org/support\n8  email: support@asyncapi.org\n9license:\n10  name: Apache 2.0\n11  url: https://www.apache.org/licenses/LICENSE-2.0.html\n12externalDocs:\n13  description: Find more info here\n14  url: https://www.asyncapi.org\n15tags:\n16  - name: e-commerce\n```\n Contact Object Contact information for the exposed API. Fixed Fields Field Name Type Description name string The identifying name of the contact person/organization. url string The URL pointing to the contact information. This MUST be in the form of an absolute URL. email string The email address of the contact person/organization. MUST be in the format of an email address. This object MAY be extended with Specification Extensions . Contact Object Example \n```javascript\n1{\n2  \"name\": \"API Support\",\n3  \"url\": \"https://www.example.com/support\",\n4  \"email\": \"support@example.com\"\n5}\n```\n \n```javascript\n1name: API Support\n2url: https://www.example.com/support\n3email: support@example.com\n```\n License Object License information for the exposed API. Fixed Fields Field Name Type Description name string REQUIRED. The license name used for the API. url string A URL to the license used for the API. This MUST be in the form of an absolute URL. This object MAY be extended with Specification Extensions . License Object Example \n```javascript\n1{\n2  \"name\": \"Apache 2.0\",\n3  \"url\": \"https://www.apache.org/licenses/LICENSE-2.0.html\"\n4}\n```\n \n```javascript\n1name: Apache 2.0\n2url: https://www.apache.org/licenses/LICENSE-2.0.html\n```\n Servers Object The Servers Object is a map of Server Objects . Patterned Fields Field Pattern Type Description ^[A-Za-z0-9_\\-]+$ Server Object | Reference Object The definition of a server this application MAY connect to. Servers Object Example \n```javascript\n1{\n2  \"development\": {\n3    \"host\": \"localhost:5672\",\n4    \"description\": \"Development AMQP broker.\",\n5    \"protocol\": \"amqp\",\n6    \"protocolVersion\": \"0-9-1\",\n7    \"tags\": [\n8      { \n9        \"name\": \"env:development\",\n10        \"description\": \"This environment is meant for developers to run their own tests.\"\n11      }\n12    ]\n13  },\n14  \"staging\": {\n15    \"host\": \"rabbitmq-staging.in.mycompany.com:5672\",\n16    \"description\": \"RabbitMQ broker for the staging environment.\",\n17    \"protocol\": \"amqp\",\n18    \"protocolVersion\": \"0-9-1\",\n19    \"tags\": [\n20      { \n21        \"name\": \"env:staging\",\n22        \"description\": \"This environment is a replica of the production environment.\"\n23      }\n24    ]\n25  },\n26  \"production\": {\n27    \"host\": \"rabbitmq.in.mycompany.com:5672\",\n28    \"description\": \"RabbitMQ broker for the production environment.\",\n29    \"protocol\": \"amqp\",\n30    \"protocolVersion\": \"0-9-1\",\n31    \"tags\": [\n32      { \n33        \"name\": \"env:production\",\n34        \"description\": \"This environment is the live environment available for final users.\"\n35      }\n36    ]\n37  }\n38}\n```\n \n```javascript\n1development:\n2  host: localhost:5672\n3  description: Development AMQP broker.\n4  protocol: amqp\n5  protocolVersion: 0-9-1\n6  tags:\n7    - name: \"env:development\"\n8      description: \"This environment is meant for developers to run their own tests.\"\n9staging:\n10  host: rabbitmq-staging.in.mycompany.com:5672\n11  description: RabbitMQ broker for the staging environment.\n12  protocol: amqp\n13  protocolVersion: 0-9-1\n14  tags:\n15    - name: \"env:staging\"\n16      description: \"This environment is a replica of the production environment.\"\n17production:\n18  host: rabbitmq.in.mycompany.com:5672\n19  description: RabbitMQ broker for the production environment.\n20  protocol: amqp\n21  protocolVersion: 0-9-1\n22  tags:\n23    - name: \"env:production\"\n24      description: \"This environment is the live environment available for final users.\"\n```\n Server Object An object representing a message broker, a server or any other kind of computer program capable of sending and/or receiving data. This object is used to capture details such as URIs, protocols and security configuration. Variable substitution can be used so that some details, for example usernames and passwords, can be injected by code generation tools. Fixed Fields Field Name Type Description host string REQUIRED . The server host name. It MAY include the port. This field supports Server Variables . Variable substitutions will be made when a variable is named in { braces } . protocol string REQUIRED . The protocol this server supports for connection. protocolVersion string The version of the protocol used for connection. For instance: AMQP 0.9.1 , HTTP 2.0 , Kafka 1.0.0 , etc. pathname string The path to a resource in the host. This field supports Server Variables . Variable substitutions will be made when a variable is named in { braces } . description string An optional string describing the server. CommonMark syntax MAY be used for rich text representation. title string A human-friendly title for the server. summary string A short summary of the server. variables Map[ string , Server Variable Object | Reference Object ]] A map between a variable name and its value. The value is used for substitution in the server's host and pathname template. security [ Security Scheme Object | Reference Object ] A declaration of which security schemes can be used with this server. The list of values includes alternative security scheme objects that can be used. Only one of the security scheme objects need to be satisfied to authorize a connection or operation. tags Tags Object A list of tags for logical grouping and categorization of servers. externalDocs External Documentation Object | Reference Object Additional external documentation for this server. bindings Server Bindings Object | Reference Object A map where the keys describe the name of the protocol and the values describe protocol-specific definitions for the server. Server Object Example A single server would be described as: \n```javascript\n1{\n2  \"host\": \"kafka.in.mycompany.com:9092\",\n3  \"description\": \"Production Kafka broker.\",\n4  \"protocol\": \"kafka\",\n5  \"protocolVersion\": \"3.2\"\n6}\n```\n \n```javascript\n1host: kafka.in.mycompany.com:9092\n2description: Production Kafka broker.\n3protocol: kafka\n4protocolVersion: '3.2'\n```\n An example of a server that has a pathname : \n```javascript\n1{\n2  \"host\": \"rabbitmq.in.mycompany.com:5672\",\n3  \"pathname\": \"/production\",\n4  \"protocol\": \"amqp\",\n5  \"description\": \"Production RabbitMQ broker (uses the `production` vhost).\"\n6}\n```\n \n```javascript\n1host: rabbitmq.in.mycompany.com:5672\n2pathname: /production\n3protocol: amqp\n4description: Production RabbitMQ broker (uses the `production` vhost).\n```\n Server Variable Object An object representing a Server Variable for server URL template substitution. Fixed Fields Field Name Type Description enum [ string ] An enumeration of string values to be used if the substitution options are from a limited set. default string The default value to use for substitution, and to send, if an alternate value is not supplied. description string An optional description for the server variable. CommonMark syntax MAY be used for rich text representation. examples [ string ] An array of examples of the server variable. This object MAY be extended with Specification Extensions . Server Variable Object Example \n```javascript\n1{\n2  \"host\": \"rabbitmq.in.mycompany.com:5672\",\n3  \"pathname\": \"/{env}\",\n4  \"protocol\": \"amqp\",\n5  \"description\": \"RabbitMQ broker. Use the `env` variable to point to either `production` or `staging`.\",\n6  \"variables\": {\n7    \"env\": {\n8      \"description\": \"Environment to connect to. It can be either `production` or `staging`.\",\n9      \"enum\": [\n10        \"production\",\n11        \"staging\"\n12      ]\n13    }\n14  }\n15}\n```\n \n```javascript\n1host: 'rabbitmq.in.mycompany.com:5672'\n2pathname: '/{env}'\n3protocol: amqp\n4description: RabbitMQ broker. Use the `env` variable to point to either `production` or `staging`.\n5variables:\n6  env:\n7    description: Environment to connect to. It can be either `production` or `staging`.\n8    enum:\n9      - production\n10      - staging\n```\n Default Content Type A string representing the default content type to use when encoding/decoding a message's payload. The value MUST be a specific media type (e.g. application/json ). This value MUST be used by schema parsers when the contentType property is omitted. In case a message can't be encoded/decoded using this value, schema parsers MUST use their default content type. Default Content Type Example \n```javascript\n1{\n2  \"defaultContentType\": \"application/json\"\n3}\n```\n defaultContentType: application/json Channels Object An object containing all the Channel Object definitions the Application MUST use during runtime. Patterned Fields Field Pattern Type Description {channelId} Channel Object | Reference Object An identifier for the described channel. The channelId value is case-sensitive . Tools and libraries MAY use the channelId to uniquely identify a channel, therefore, it is RECOMMENDED to follow common programming naming conventions. Channels Object Example \n```javascript\n1{\n2  \"userSignedUp\": {\n3    \"address\": \"user.signedup\",\n4    \"messages\": {\n5      \"userSignedUp\": {\n6        \"$ref\": \"#/components/messages/userSignedUp\"\n7      }\n8    }\n9  }\n10}\n```\n \n```javascript\n1userSignedUp:\n2  address: 'user.signedup'\n3  messages:\n4    userSignedUp:\n5      $ref: '#/components/messages/userSignedUp'\n```\n Channel Object Describes a shared communication channel. Fixed Fields Field Name Type Description address string | null An optional string representation of this channel's address. The address is typically the \"topic name\", \"routing key\", \"event type\", or \"path\". When null or absent, it MUST be interpreted as unknown. This is useful when the address is generated dynamically at runtime or can't be known upfront. It MAY contain Channel Address Expressions . Query parameters and fragments SHALL NOT be used, instead use bindings to define them. messages Messages Object A map of the messages that will be sent to this channel by any application at any time. Every message sent to this channel MUST be valid against one, and only one, of the message objects defined in this map. title string A human-friendly title for the channel. summary string A short summary of the channel. description string An optional description of this channel. CommonMark syntax can be used for rich text representation. servers [ Reference Object ] An array of $ref pointers to the definition of the servers in which this channel is available. If the channel is located in the root Channels Object , it MUST point to a subset of server definitions located in the root Servers Object , and MUST NOT point to a subset of server definitions located in the Components Object or anywhere else. If the channel is located in the Components Object , it MAY point to a Server Objects in any location. If servers is absent or empty, this channel MUST be available on all the servers defined in the Servers Object . Please note the servers property value MUST be an array of Reference Objects and, therefore, MUST NOT contain an array of Server Objects . However, it is RECOMMENDED that parsers (or other software) dereference this property for a better development experience. parameters Parameters Object A map of the parameters included in the channel address. It MUST be present only when the address contains Channel Address Expressions . tags Tags Object A list of tags for logical grouping of channels. externalDocs External Documentation Object | Reference Object Additional external documentation for this channel. bindings Channel Bindings Object | Reference Object A map where the keys describe the name of the protocol and the values describe protocol-specific definitions for the channel. This object MAY be extended with Specification Extensions . Channel Object Example \n```javascript\n1{\n2  \"address\": \"users.{userId}\",\n3  \"title\": \"Users channel\",\n4  \"description\": \"This channel is used to exchange messages about user events.\",\n5  \"messages\": {\n6    \"userSignedUp\": {\n7      \"$ref\": \"#/components/messages/userSignedUp\"\n8    },\n9    \"userCompletedOrder\": {\n10      \"$ref\": \"#/components/messages/userCompletedOrder\"\n11    }\n12  },\n13  \"parameters\": {\n14    \"userId\": {\n15      \"$ref\": \"#/components/parameters/userId\"\n16    }\n17  },\n18  \"servers\": [\n19    { \"$ref\": \"#/servers/rabbitmqInProd\" },\n20    { \"$ref\": \"#/servers/rabbitmqInStaging\" }\n21  ],\n22  \"bindings\": {\n23    \"amqp\": {\n24      \"is\": \"queue\",\n25      \"queue\": {\n26        \"exclusive\": true\n27      }\n28    }\n29  },\n30  \"tags\": [{\n31    \"name\": \"user\",\n32    \"description\": \"User-related messages\"\n33  }],\n34  \"externalDocs\": {\n35    \"description\": \"Find more info here\",\n36    \"url\": \"https://example.com\"\n37  }\n38}\n```\n \n```javascript\n1address: 'users.{userId}'\n2title: Users channel\n3description: This channel is used to exchange messages about user events.\n4messages:\n5  userSignedUp:\n6    $ref: '#/components/messages/userSignedUp'\n7  userCompletedOrder:\n8    $ref: '#/components/messages/userCompletedOrder'\n9parameters:\n10  userId:\n11    $ref: '#/components/parameters/userId'\n12servers:\n13  - $ref: '#/servers/rabbitmqInProd'\n14  - $ref: '#/servers/rabbitmqInStaging'\n15bindings:\n16  amqp:\n17    is: queue\n18    queue:\n19      exclusive: true\n20tags:\n21  - name: user\n22    description: User-related messages\n23externalDocs:\n24  description: 'Find more info here'\n25  url: 'https://example.com'\n```\n Channel Address Expressions Channel addresses MAY contain expressions that can be used to define dynamic values. Expressions MUST be composed by a name enclosed in curly braces ( { and } ). E.g., {userId} . Messages Object Describes a map of messages included in a channel. Patterned Fields Field Pattern Type Description {messageId} Message Object | Reference Object The key represents the message identifier. The messageId value is case-sensitive . Tools and libraries MAY use the messageId value to uniquely identify a message, therefore, it is RECOMMENDED to follow common programming naming conventions. Messages Object Example \n```javascript\n1{\n2  \"userSignedUp\": {\n3    \"$ref\": \"#/components/messages/userSignedUp\"\n4  },\n5  \"userCompletedOrder\": {\n6    \"$ref\": \"#/components/messages/userCompletedOrder\"\n7  }\n8}\n```\n \n```javascript\n1userSignedUp:\n2  $ref: '#/components/messages/userSignedUp'\n3userCompletedOrder:\n4  $ref: '#/components/messages/userCompletedOrder'\n```\n Operations Object Holds a dictionary with all the operations this application MUST implement. If you're looking for a place to define operations that MAY or MAY NOT be implemented by the application, consider defining them in components/operations . Patterned Fields Field Pattern Type Description {operationId} Operation Object | Reference Object The operation this application MUST implement. The field name ( operationId ) MUST be a string used to identify the operation in the document where it is defined, and its value is case-sensitive . Tools and libraries MAY use the operationId to uniquely identify an operation, therefore, it is RECOMMENDED to follow common programming naming conventions. Operations Object Example \n```javascript\n1{\n2  \"onUserSignUp\": {\n3    \"title\": \"User sign up\",\n4    \"summary\": \"Action to sign a user up.\",\n5    \"description\": \"A longer description\",\n6    \"channel\": {\n7      \"$ref\": \"#/channels/userSignup\"\n8    },\n9    \"action\": \"send\",\n10    \"tags\": [\n11      { \"name\": \"user\" },\n12      { \"name\": \"signup\" },\n13      { \"name\": \"register\" }\n14    ],\n15    \"bindings\": {\n16      \"amqp\": {\n17        \"ack\": false\n18      }\n19    },\n20    \"traits\": [\n21      { \"$ref\": \"#/components/operationTraits/kafka\" }\n22    ]\n23  }\n24}\n```\n \n```javascript\n1onUserSignUp:\n2  title: User sign up\n3  summary: Action to sign a user up.\n4  description: A longer description\n5  channel:\n6    $ref: '#/channels/userSignup'\n7  action: send\n8  tags:\n9    - name: user\n10    - name: signup\n11    - name: register\n12  bindings:\n13    amqp:\n14      ack: false\n15  traits:\n16    - $ref: '#/components/operationTraits/kafka'\n```\n Operation Object Describes a specific operation. Fixed Fields Field Name Type Description action \"send\" | \"receive\" Required . Use send when it's expected that the application will send a message to the given channel , and receive when the application should expect receiving messages from the given channel . channel Reference Object Required . A $ref pointer to the definition of the channel in which this operation is performed. If the operation is located in the root Operations Object , it MUST point to a channel definition located in the root Channels Object , and MUST NOT point to a channel definition located in the Components Object or anywhere else. If the operation is located in the Components Object , it MAY point to a Channel Object in any location. Please note the channel property value MUST be a Reference Object and, therefore, MUST NOT contain a Channel Object . However, it is RECOMMENDED that parsers (or other software) dereference this property for a better development experience. title string A human-friendly title for the operation. summary string A short summary of what the operation is about. description string A verbose explanation of the operation. CommonMark syntax can be used for rich text representation. security [ Security Scheme Object | Reference Object ] A declaration of which security schemes are associated with this operation. Only one of the security scheme objects MUST be satisfied to authorize an operation. In cases where Server Security also applies, it MUST also be satisfied. tags Tags Object A list of tags for logical grouping and categorization of operations. externalDocs External Documentation Object | Reference Object Additional external documentation for this operation. bindings Operation Bindings Object | Reference Object A map where the keys describe the name of the protocol and the values describe protocol-specific definitions for the operation. traits [ Operation Trait Object | Reference Object ] A list of traits to apply to the operation object. Traits MUST be merged using traits merge mechanism . The resulting object MUST be a valid Operation Object . messages [ Reference Object ] A list of $ref pointers pointing to the supported Message Objects that can be processed by this operation. It MUST contain a subset of the messages defined in the channel referenced in this operation , and MUST NOT point to a subset of message definitions located in the Messages Object in the Components Object or anywhere else. Every message processed by this operation MUST be valid against one, and only one, of the message objects referenced in this list. Please note the messages property value MUST be a list of Reference Objects and, therefore, MUST NOT contain Message Objects . However, it is RECOMMENDED that parsers (or other software) dereference this property for a better development experience. reply Operation Reply Object | Reference Object The definition of the reply in a request-reply operation. This object MAY be extended with Specification Extensions . Operation Object Example \n```javascript\n1{\n2  \"title\": \"User sign up\",\n3  \"summary\": \"Action to sign a user up.\",\n4  \"description\": \"A longer description\",\n5  \"channel\": {\n6    \"$ref\": \"#/channels/userSignup\"\n7  },\n8  \"action\": \"send\",\n9  \"security\": [\n10    {\n11     \"petstore_auth\": [\n12       \"write:pets\",\n13       \"read:pets\"\n14     ]\n15    }\n16  ],\n17  \"tags\": [\n18    { \"name\": \"user\" },\n19    { \"name\": \"signup\" },\n20    { \"name\": \"register\" }\n21  ],\n22  \"bindings\": {\n23    \"amqp\": {\n24      \"ack\": false\n25    }\n26  },\n27  \"traits\": [\n28    { \"$ref\": \"#/components/operationTraits/kafka\" }\n29  ],\n30  \"messages\": [\n31    { \"$ref\": \"/components/messages/userSignedUp\" }\n32  ],\n33  \"reply\": {\n34    \"address\": {\n35      \"location\": \"$message.header#/replyTo\"\n36    },\n37    \"channel\": {\n38      \"$ref\": \"#/channels/userSignupReply\"\n39    },\n40    \"messages\": [\n41      { \"$ref\": \"/components/messages/userSignedUpReply\" }\n42    ],\n43  }\n44}\n```\n \n```javascript\n1title: User sign up\n2summary: Action to sign a user up.\n3description: A longer description\n4channel:\n5  $ref: '#/channels/userSignup'\n6action: send\n7security:\n8  - petstore_auth:\n9    - write:pets\n10    - read:pets\n11tags:\n12  - name: user\n13  - name: signup\n14  - name: register\n15bindings:\n16  amqp:\n17    ack: false\n18traits:\n19  - $ref: \"#/components/operationTraits/kafka\"\n20messages:\n21  - $ref: '#/components/messages/userSignedUp'\n22reply:\n23  address:\n24    location: '$message.header#/replyTo'\n25  channel:\n26    $ref: '#/channels/userSignupReply'\n27  messages:\n28    - $ref: '#/components/messages/userSignedUpReply'\n```\n Operation Trait Object Describes a trait that MAY be applied to an Operation Object . This object MAY contain any property from the Operation Object , except the action , channel , messages and traits ones. If you're looking to apply traits to a message, see the Message Trait Object . Fixed Fields Field Name Type Description title string A human-friendly title for the operation. summary string A short summary of what the operation is about. description string A verbose explanation of the operation. CommonMark syntax can be used for rich text representation. security [ Security Scheme Object | Reference Object ] A declaration of which security schemes are associated with this operation. Only one of the security scheme objects MUST be satisfied to authorize an operation. In cases where Server Security also applies, it MUST also be satisfied. tags Tags Object A list of tags for logical grouping and categorization of operations. externalDocs External Documentation Object | Reference Object Additional external documentation for this operation. bindings Operation Bindings Object | Reference Object A map where the keys describe the name of the protocol and the values describe protocol-specific definitions for the operation. This object MAY be extended with Specification Extensions . Operation Trait Object Example \n```javascript\n1{\n2  \"bindings\": {\n3    \"amqp\": {\n4      \"ack\": false\n5    }\n6  }\n7}\n```\n \n```javascript\n1bindings:\n2  amqp:\n3    ack: false\n```\n Operation Reply Object Describes the reply part that MAY be applied to an Operation Object. If an operation implements the request/reply pattern, the reply object represents the response message. Fixed Fields Field Name Type Description address Operation Reply Address Object | Reference Object Definition of the address that implementations MUST use for the reply. channel Reference Object A $ref pointer to the definition of the channel in which this operation is performed. When address is specified, the address property of the channel referenced by this property MUST be either null or not defined. If the operation reply is located inside a root Operation Object , it MUST point to a channel definition located in the root Channels Object , and MUST NOT point to a channel definition located in the Components Object or anywhere else. If the operation reply is located inside an [Operation Object] in the Components Object or in the Replies Object in the Components Object , it MAY point to a Channel Object in any location. Please note the channel property value MUST be a Reference Object and, therefore, MUST NOT contain a Channel Object . However, it is RECOMMENDED that parsers (or other software) dereference this property for a better development experience. messages [ Reference Object ] A list of $ref pointers pointing to the supported Message Objects that can be processed by this operation as reply. It MUST contain a subset of the messages defined in the channel referenced in this operation reply , and MUST NOT point to a subset of message definitions located in the Components Object or anywhere else. Every message processed by this operation MUST be valid against one, and only one, of the message objects referenced in this list. Please note the messages property value MUST be a list of Reference Objects and, therefore, MUST NOT contain Message Objects . However, it is RECOMMENDED that parsers (or other software) dereference this property for a better development experience. This object MAY be extended with Specification Extensions . Operation Reply Address Object An object that specifies where an operation has to send the reply. For specifying and computing the location of a reply address, a runtime expression is used. Fixed Fields Field Name Type Description description string An optional description of the address. CommonMark syntax can be used for rich text representation. location string REQUIRED. A runtime expression that specifies the location of the reply address. This object MAY be extended with Specification Extensions . Examples \n```javascript\n1{\n2  \"description\": \"Consumer inbox\",\n3  \"location\": \"$message.header#/replyTo\"\n4}\n```\n \n```javascript\n1description: Consumer Inbox\n2location: $message.header#/replyTo\n```\n Parameters Object Describes a map of parameters included in a channel address. This map MUST contain all the parameters used in the parent channel address. Patterned Fields Field Pattern Type Description ^[A-Za-z0-9_\\-]+$ Parameter Object | Reference Object The key represents the name of the parameter. It MUST match the parameter name used in the parent channel address. Parameters Object Example \n```javascript\n1{\n2  \"address\": \"user/{userId}/signedup\",\n3  \"parameters\": {\n4    \"userId\": {\n5      \"description\": \"Id of the user.\"\n6    }\n7  }\n8}\n```\n \n```javascript\n1address: user/{userId}/signedup\n2parameters:\n3  userId:\n4    description: Id of the user.\n```\n Parameter Object Describes a parameter included in a channel address. Fixed Fields Field Name Type Description enum [ string ] An enumeration of string values to be used if the substitution options are from a limited set. default string The default value to use for substitution, and to send, if an alternate value is not supplied. description string An optional description for the parameter. CommonMark syntax MAY be used for rich text representation. examples [ string ] An array of examples of the parameter value. location string A runtime expression that specifies the location of the parameter value. This object MAY be extended with Specification Extensions . Parameter Object Example \n```javascript\n1{\n2  \"address\": \"user/{userId}/signedup\",\n3  \"parameters\": {\n4    \"userId\": {\n5      \"description\": \"Id of the user.\",\n6      \"location\": \"$message.payload#/user/id\"\n7    }\n8  }\n9}\n```\n \n```javascript\n1address: user/{userId}/signedup\n2parameters:\n3  userId:\n4    description: Id of the user.\n5    location: $message.payload#/user/id\n```\n Server Bindings Object Map describing protocol-specific definitions for a server. Fixed Fields Field Name Type Description http HTTP Server Binding Protocol-specific information for an HTTP server. ws WebSockets Server Binding Protocol-specific information for a WebSockets server. kafka Kafka Server Binding Protocol-specific information for a Kafka server. anypointmq Anypoint MQ Server Binding Protocol-specific information for an Anypoint MQ server. amqp AMQP Server Binding Protocol-specific information for an AMQP 0-9-1 server. amqp1 AMQP 1.0 Server Binding Protocol-specific information for an AMQP 1.0 server. mqtt MQTT Server Binding Protocol-specific information for an MQTT server. mqtt5 MQTT 5 Server Binding Protocol-specific information for an MQTT 5 server. nats NATS Server Binding Protocol-specific information for a NATS server. jms JMS Server Binding Protocol-specific information for a JMS server. sns SNS Server Binding Protocol-specific information for an SNS server. solace Solace Server Binding Protocol-specific information for a Solace server. sqs SQS Server Binding Protocol-specific information for an SQS server. stomp STOMP Server Binding Protocol-specific information for a STOMP server. redis Redis Server Binding Protocol-specific information for a Redis server. mercure Mercure Server Binding Protocol-specific information for a Mercure server. ibmmq IBM MQ Server Binding Protocol-specific information for an IBM MQ server. googlepubsub Google Cloud Pub/Sub Server Binding Protocol-specific information for a Google Cloud Pub/Sub server. pulsar Pulsar Server Binding Protocol-specific information for a Pulsar server. This object MAY be extended with Specification Extensions . Channel Bindings Object Map describing protocol-specific definitions for a channel. Fixed Fields Field Name Type Description http HTTP Channel Binding Protocol-specific information for an HTTP channel. ws WebSockets Channel Binding Protocol-specific information for a WebSockets channel. kafka Kafka Channel Binding Protocol-specific information for a Kafka channel. anypointmq Anypoint MQ Channel Binding Protocol-specific information for an Anypoint MQ channel. amqp AMQP Channel Binding Protocol-specific information for an AMQP 0-9-1 channel. amqp1 AMQP 1.0 Channel Binding Protocol-specific information for an AMQP 1.0 channel. mqtt MQTT Channel Binding Protocol-specific information for an MQTT channel. mqtt5 MQTT 5 Channel Binding Protocol-specific information for an MQTT 5 channel. nats NATS Channel Binding Protocol-specific information for a NATS channel. jms JMS Channel Binding Protocol-specific information for a JMS channel. sns SNS Channel Binding Protocol-specific information for an SNS channel. solace Solace Channel Binding Protocol-specific information for a Solace channel. sqs SQS Channel Binding Protocol-specific information for an SQS channel. stomp STOMP Channel Binding Protocol-specific information for a STOMP channel. redis Redis Channel Binding Protocol-specific information for a Redis channel. mercure Mercure Channel Binding Protocol-specific information for a Mercure channel. ibmmq IBM MQ Channel Binding Protocol-specific information for an IBM MQ channel. googlepubsub Google Cloud Pub/Sub Channel Binding Protocol-specific information for a Google Cloud Pub/Sub channel. pulsar Pulsar Channel Binding Protocol-specific information for a Pulsar channel. This object MAY be extended with Specification Extensions . Operation Bindings Object Map describing protocol-specific definitions for an operation. Fixed Fields Field Name Type Description http HTTP Operation Binding Protocol-specific information for an HTTP operation. ws WebSockets Operation Binding Protocol-specific information for a WebSockets operation. kafka Kafka Operation Binding Protocol-specific information for a Kafka operation. anypointmq Anypoint MQ Operation Binding Protocol-specific information for an Anypoint MQ operation. amqp AMQP Operation Binding Protocol-specific information for an AMQP 0-9-1 operation. amqp1 AMQP 1.0 Operation Binding Protocol-specific information for an AMQP 1.0 operation. mqtt MQTT Operation Binding Protocol-specific information for an MQTT operation. mqtt5 MQTT 5 Operation Binding Protocol-specific information for an MQTT 5 operation. nats NATS Operation Binding Protocol-specific information for a NATS operation. jms JMS Operation Binding Protocol-specific information for a JMS operation. sns SNS Operation Binding Protocol-specific information for an SNS operation. solace Solace Operation Binding Protocol-specific information for a Solace operation. sqs SQS Operation Binding Protocol-specific information for an SQS operation. stomp STOMP Operation Binding Protocol-specific information for a STOMP operation. redis Redis Operation Binding Protocol-specific information for a Redis operation. mercure Mercure Operation Binding Protocol-specific information for a Mercure operation. googlepubsub Google Cloud Pub/Sub Operation Binding Protocol-specific information for a Google Cloud Pub/Sub operation. ibmmq IBM MQ Operation Binding Protocol-specific information for an IBM MQ operation. pulsar Pulsar Operation Binding Protocol-specific information for a Pulsar operation. This object MAY be extended with Specification Extensions . Message Bindings Object Map describing protocol-specific definitions for a message. Fixed Fields Field Name Type Description http HTTP Message Binding Protocol-specific information for an HTTP message, i.e., a request or a response. ws WebSockets Message Binding Protocol-specific information for a WebSockets message. kafka Kafka Message Binding Protocol-specific information for a Kafka message. anypointmq Anypoint MQ Message Binding Protocol-specific information for an Anypoint MQ message. amqp AMQP Message Binding Protocol-specific information for an AMQP 0-9-1 message. amqp1 AMQP 1.0 Message Binding Protocol-specific information for an AMQP 1.0 message. mqtt MQTT Message Binding Protocol-specific information for an MQTT message. mqtt5 MQTT 5 Message Binding Protocol-specific information for an MQTT 5 message. nats NATS Message Binding Protocol-specific information for a NATS message. jms JMS Message Binding Protocol-specific information for a JMS message. sns SNS Message Binding Protocol-specific information for an SNS message. solace Solace Server Binding Protocol-specific information for a Solace message. sqs SQS Message Binding Protocol-specific information for an SQS message. stomp STOMP Message Binding Protocol-specific information for a STOMP message. redis Redis Message Binding Protocol-specific information for a Redis message. mercure Mercure Message Binding Protocol-specific information for a Mercure message. ibmmq IBM MQ Message Binding Protocol-specific information for an IBM MQ message. googlepubsub Google Cloud Pub/Sub Message Binding Protocol-specific information for a Google Cloud Pub/Sub message. pulsar Pulsar Message Binding Protocol-specific information for a Pulsar message. This object MAY be extended with Specification Extensions . Message Object Describes a message received on a given channel and operation. Fixed Fields Field Name Type Description headers Multi Format Schema Object | Schema Object | Reference Object Schema definition of the application headers. Schema MUST be a map of key-value pairs. It MUST NOT define the protocol headers. If this is a Schema Object , then the schemaFormat will be assumed to be \"application/vnd.aai.asyncapi+json;version= asyncapi \" where the version is equal to the AsyncAPI Version String . payload Multi Format Schema Object | Schema Object | Reference Object Definition of the message payload. If this is a Schema Object , then the schemaFormat will be assumed to be \"application/vnd.aai.asyncapi+json;version= asyncapi \" where the version is equal to the AsyncAPI Version String . correlationId Correlation ID Object | Reference Object Definition of the correlation ID used for message tracing or matching. contentType string The content type to use when encoding/decoding a message's payload. The value MUST be a specific media type (e.g. application/json ). When omitted, the value MUST be the one specified on the defaultContentType field. name string A machine-friendly name for the message. title string A human-friendly title for the message. summary string A short summary of what the message is about. description string A verbose explanation of the message. CommonMark syntax can be used for rich text representation. tags Tags Object A list of tags for logical grouping and categorization of messages. externalDocs External Documentation Object | Reference Object Additional external documentation for this message. bindings Message Bindings Object | Reference Object A map where the keys describe the name of the protocol and the values describe protocol-specific definitions for the message. examples [ Message Example Object ] List of examples. traits [ Message Trait Object | Reference Object ] A list of traits to apply to the message object. Traits MUST be merged using traits merge mechanism . The resulting object MUST be a valid Message Object . This object MAY be extended with Specification Extensions . Message Object Example \n```javascript\n1{\n2  \"name\": \"UserSignup\",\n3  \"title\": \"User signup\",\n4  \"summary\": \"Action to sign a user up.\",\n5  \"description\": \"A longer description\",\n6  \"contentType\": \"application/json\",\n7  \"tags\": [\n8    { \"name\": \"user\" },\n9    { \"name\": \"signup\" },\n10    { \"name\": \"register\" }\n11  ],\n12  \"headers\": {\n13    \"type\": \"object\",\n14    \"properties\": {\n15      \"correlationId\": {\n16        \"description\": \"Correlation ID set by application\",\n17        \"type\": \"string\"\n18      },\n19      \"applicationInstanceId\": {\n20        \"description\": \"Unique identifier for a given instance of the publishing application\",\n21        \"type\": \"string\"\n22      }\n23    }\n24  },\n25  \"payload\": {\n26    \"type\": \"object\",\n27    \"properties\": {\n28      \"user\": {\n29        \"$ref\": \"#/components/schemas/userCreate\"\n30      },\n31      \"signup\": {\n32        \"$ref\": \"#/components/schemas/signup\"\n33      }\n34    }\n35  },\n36  \"correlationId\": {\n37    \"description\": \"Default Correlation ID\",\n38    \"location\": \"$message.header#/correlationId\"\n39  },\n40  \"traits\": [\n41    { \"$ref\": \"#/components/messageTraits/commonHeaders\" }\n42  ],\n43  \"examples\": [\n44    {\n45      \"name\": \"SimpleSignup\",\n46      \"summary\": \"A simple UserSignup example message\",\n47      \"headers\": {\n48        \"correlationId\": \"my-correlation-id\",\n49        \"applicationInstanceId\": \"myInstanceId\"\n50      },\n51      \"payload\": {\n52        \"user\": {\n53          \"someUserKey\": \"someUserValue\"\n54        },\n55        \"signup\": {\n56          \"someSignupKey\": \"someSignupValue\"\n57        }\n58      }\n59    }\n60  ]\n61}\n```\n \n```javascript\n1name: UserSignup\n2title: User signup\n3summary: Action to sign a user up.\n4description: A longer description\n5contentType: application/json\n6tags:\n7  - name: user\n8  - name: signup\n9  - name: register\n10headers:\n11  type: object\n12  properties:\n13    correlationId:\n14      description: Correlation ID set by application\n15      type: string\n16    applicationInstanceId:\n17      description: Unique identifier for a given instance of the publishing application\n18      type: string\n19payload:\n20  type: object\n21  properties:\n22    user:\n23      $ref: \"#/components/schemas/userCreate\"\n24    signup:\n25      $ref: \"#/components/schemas/signup\"\n26correlationId:\n27  description: Default Correlation ID\n28  location: $message.header#/correlationId\n29traits:\n30  - $ref: \"#/components/messageTraits/commonHeaders\"\n31examples:\n32  - name: SimpleSignup\n33    summary: A simple UserSignup example message\n34    headers:\n35      correlationId: my-correlation-id\n36      applicationInstanceId: myInstanceId\n37    payload:\n38      user:\n39        someUserKey: someUserValue\n40      signup:\n41        someSignupKey: someSignupValue\n```\n Example using Avro to define the payload: \n```javascript\n1{\n2  \"name\": \"UserSignup\",\n3  \"title\": \"User signup\",\n4  \"summary\": \"Action to sign a user up.\",\n5  \"description\": \"A longer description\",\n6  \"tags\": [\n7    { \"name\": \"user\" },\n8    { \"name\": \"signup\" },\n9    { \"name\": \"register\" }\n10  ],\n11  \"payload\": {\n12    \"schemaFormat\": \"application/vnd.apache.avro+json;version=1.9.0\",\n13    \"schema\": {\n14      \"$ref\": \"path/to/user-create.avsc#/UserCreate\"\n15    }\n16  }\n17}\n```\n \n```javascript\n1name: UserSignup\n2title: User signup\n3summary: Action to sign a user up.\n4description: A longer description\n5tags:\n6  - name: user\n7  - name: signup\n8  - name: register\n9payload:\n10  schemaFormat: 'application/vnd.apache.avro+yaml;version=1.9.0'\n11  schema:\n12    $ref: 'path/to/user-create.avsc/#UserCreate'\n```\n Message Trait Object Describes a trait that MAY be applied to a Message Object . This object MAY contain any property from the Message Object , except payload and traits . If you're looking to apply traits to an operation, see the Operation Trait Object . Fixed Fields Field Name Type Description headers Multi Format Schema Object | Schema Object | Reference Object Schema definition of the application headers. Schema MUST be a map of key-value pairs. It MUST NOT define the protocol headers. If this is a Schema Object , then the schemaFormat will be assumed to be \"application/vnd.aai.asyncapi+json;version= asyncapi \" where the version is equal to the AsyncAPI Version String . correlationId Correlation ID Object | Reference Object Definition of the correlation ID used for message tracing or matching. contentType string The content type to use when encoding/decoding a message's payload. The value MUST be a specific media type (e.g. application/json ). When omitted, the value MUST be the one specified on the defaultContentType field. name string A machine-friendly name for the message. title string A human-friendly title for the message. summary string A short summary of what the message is about. description string A verbose explanation of the message. CommonMark syntax can be used for rich text representation. tags Tags Object A list of tags for logical grouping and categorization of messages. externalDocs External Documentation Object | Reference Object Additional external documentation for this message. bindings Message Bindings Object | Reference Object A map where the keys describe the name of the protocol and the values describe protocol-specific definitions for the message. examples [ Message Example Object ] List of examples. This object MAY be extended with Specification Extensions . Message Trait Object Example \n```javascript\n1{\n2  \"contentType\": \"application/json\"\n3}\n```\n contentType: application/json Message Example Object Message Example Object represents an example of a Message Object and MUST contain either headers and/or payload fields. Fixed Fields Field Name Type Description headers Map[string, any] The value of this field MUST validate against the Message Object's headers field. payload Map[string, any] The value of this field MUST validate against the Message Object's payload field. name string A machine-friendly name. summary string A short summary of what the example is about. This object MAY be extended with Specification Extensions . Message Example Object Example \n```javascript\n1{\n2  \"name\": \"SimpleSignup\",\n3  \"summary\": \"A simple UserSignup example message\",\n4  \"headers\": {\n5    \"correlationId\": \"my-correlation-id\",\n6    \"applicationInstanceId\": \"myInstanceId\"\n7  },\n8  \"payload\": {\n9    \"user\": {\n10      \"someUserKey\": \"someUserValue\"\n11    },\n12    \"signup\": {\n13      \"someSignupKey\": \"someSignupValue\"\n14    }\n15  }\n16}\n```\n \n```javascript\n1name: SimpleSignup\n2summary: A simple UserSignup example message\n3headers:\n4  correlationId: my-correlation-id\n5  applicationInstanceId: myInstanceId\n6payload:\n7  user:\n8    someUserKey: someUserValue\n9  signup:\n10    someSignupKey: someSignupValue\n```\n Tags Object A Tags object is a list of Tag Objects . An Tag Object in a list can be referenced by Reference Object . Tag Object Allows adding meta data to a single tag. Fixed Fields Field Name Type Description name string REQUIRED. The name of the tag. description string A short description for the tag. CommonMark syntax can be used for rich text representation. externalDocs External Documentation Object | Reference Object Additional external documentation for this tag. This object MAY be extended with Specification Extensions . Tag Object Example \n```javascript\n1{\n2 \"name\": \"user\",\n3 \"description\": \"User-related messages\"\n4}\n```\n \n```javascript\n1name: user\n2description: User-related messages\n```\n External Documentation Object Allows referencing an external resource for extended documentation. Fixed Fields Field Name Type Description description string A short description of the target documentation. CommonMark syntax can be used for rich text representation. url string REQUIRED. The URL for the target documentation. This MUST be in the form of an absolute URL. This object MAY be extended with Specification Extensions . External Documentation Object Example \n```javascript\n1{\n2  \"description\": \"Find more info here\",\n3  \"url\": \"https://example.com\"\n4}\n```\n \n```javascript\n1description: Find more info here\n2url: https://example.com\n```\n Reference Object A simple object to allow referencing other components in the specification, internally and externally. The Reference Object is defined by JSON Reference and follows the same structure, behavior and rules. A JSON Reference SHALL only be used to refer to a schema that is formatted in either JSON or YAML. In the case of a YAML-formatted Schema, the JSON Reference SHALL be applied to the JSON representation of that schema. The JSON representation SHALL be made by applying the conversion described here . For this specification, reference resolution is done as defined by the JSON Reference specification and not by the JSON Schema specification. Fixed Fields Field Name Type Description $ref string REQUIRED. The reference string. This object cannot be extended with additional properties and any properties added SHALL be ignored. Reference Object Example \n```javascript\n1{\n2  \"$ref\": \"#/components/schemas/Pet\"\n3}\n```\n $ref: '#/components/schemas/Pet' Components Object Holds a set of reusable objects for different aspects of the AsyncAPI specification. All objects defined within the components object will have no effect on the API unless they are explicitly referenced from properties outside the components object. Fixed Fields Field Name Type Description schemas Map[ string , Multi Format Schema Object | Schema Object | Reference Object ] An object to hold reusable Schema Object . If this is a Schema Object , then the schemaFormat will be assumed to be \"application/vnd.aai.asyncapi+json;version= asyncapi \" where the version is equal to the AsyncAPI Version String . servers Map[ string , Server Object | Reference Object ] An object to hold reusable Server Objects . channels Map[ string , Channel Object | Reference Object ] An object to hold reusable Channel Objects . operations Map[ string , Operation Object | Reference Object ] An object to hold reusable Operation Objects . messages Map[ string , Message Object | Reference Object ] An object to hold reusable Message Objects . securitySchemes Map[ string , Security Scheme Object | Reference Object ] An object to hold reusable Security Scheme Objects . serverVariables Map[ string , Server Variable Object | Reference Object ] An object to hold reusable Server Variable Objects . parameters Map[ string , Parameter Object | Reference Object ] An object to hold reusable Parameter Objects . correlationIds Map[ string , Correlation ID Object | Reference Object ] An object to hold reusable Correlation ID Objects . replies Map[ string , Operation Reply Object | Reference Object ] An object to hold reusable Operation Reply Objects . replyAddresses Map[ string , Operation Reply Address Object | Reference Object ] An object to hold reusable Operation Reply Address Objects . externalDocs Map[ string , External Documentation Object | Reference Object ] An object to hold reusable External Documentation Objects . tags Map[ string , Tag Object | Reference Object ] An object to hold reusable Tag Objects . operationTraits Map[ string , Operation Trait Object | Reference Object ] An object to hold reusable Operation Trait Objects . messageTraits Map[ string , Message Trait Object | Reference Object ] An object to hold reusable Message Trait Objects . serverBindings Map[ string , Server Bindings Object | Reference Object ] An object to hold reusable Server Bindings Objects . channelBindings Map[ string , Channel Bindings Object | Reference Object ] An object to hold reusable Channel Bindings Objects . operationBindings Map[ string , Operation Bindings Object | Reference Object ] An object to hold reusable Operation Bindings Objects . messageBindings Map[ string , Message Bindings Object | Reference Object ] An object to hold reusable Message Bindings Objects . This object MAY be extended with Specification Extensions . All the fixed fields declared above are objects that MUST use keys that match the regular expression: ^[a-zA-Z0-9\\.\\-_]+$ . Field Name Examples: \n```javascript\n1User\n2User_1\n3User_Name\n4user-name\n5my.org.User\n```\n Components Object Example \n```javascript\n1{\n2  \"components\": {\n3    \"schemas\": {\n4      \"Category\": {\n5        \"type\": \"object\",\n6        \"properties\": {\n7          \"id\": {\n8            \"type\": \"integer\",\n9            \"format\": \"int64\"\n10          },\n11          \"name\": {\n12            \"type\": \"string\"\n13          }\n14        }\n15      },\n16      \"Tag\": {\n17        \"type\": \"object\",\n18        \"properties\": {\n19          \"id\": {\n20            \"type\": \"integer\",\n21            \"format\": \"int64\"\n22          },\n23          \"name\": {\n24            \"type\": \"string\"\n25          }\n26        }\n27      },\n28      \"AvroExample\": {\n29        \"schemaFormat\": \"application/vnd.apache.avro+json;version=1.9.0\",\n30        \"schema\": {\n31          \"$ref\": \"path/to/user-create.avsc#/UserCreate\"\n32        }\n33      }\n34    },\n35    \"servers\": {\n36      \"development\": {\n37        \"host\": \"{stage}.in.mycompany.com:{port}\",\n38        \"description\": \"RabbitMQ broker\",\n39        \"protocol\": \"amqp\",\n40        \"protocolVersion\": \"0-9-1\",\n41        \"variables\": {\n42          \"stage\": {\n43            \"$ref\": \"#/components/serverVariables/stage\"\n44          },\n45          \"port\": {\n46            \"$ref\": \"#/components/serverVariables/port\"\n47          }\n48        }\n49      }\n50    },\n51    \"serverVariables\": {\n52      \"stage\": {\n53        \"default\": \"demo\",\n54        \"description\": \"This value is assigned by the service provider, in this example `mycompany.com`\"\n55      },\n56      \"port\": {\n57        \"enum\": [\"5671\", \"5672\"],\n58        \"default\": \"5672\"\n59      }\n60    },\n61    \"channels\": {\n62      \"user/signedup\": {\n63        \"subscribe\": {\n64          \"message\": {\n65            \"$ref\": \"#/components/messages/userSignUp\"\n66          }\n67        }\n68      }\n69    },\n70    \"messages\": {\n71      \"userSignUp\": {\n72        \"summary\": \"Action to sign a user up.\",\n73        \"description\": \"Multiline description of what this action does.\\nHere you have another line.\\n\",\n74        \"tags\": [\n75          {\n76            \"name\": \"user\"\n77          },\n78          {\n79            \"name\": \"signup\"\n80          }\n81        ],\n82        \"headers\": {\n83          \"type\": \"object\",\n84          \"properties\": {\n85            \"applicationInstanceId\": {\n86              \"description\": \"Unique identifier for a given instance of the publishing application\",\n87              \"type\": \"string\"\n88            }\n89          }\n90        },\n91        \"payload\": {\n92          \"type\": \"object\",\n93          \"properties\": {\n94            \"user\": {\n95              \"$ref\": \"#/components/schemas/userCreate\"\n96            },\n97            \"signup\": {\n98              \"$ref\": \"#/components/schemas/signup\"\n99            }\n100          }\n101        }\n102      }\n103    },\n104    \"parameters\": {\n105      \"userId\": {\n106        \"description\": \"Id of the user.\"\n107      }\n108    },\n109    \"correlationIds\": {\n110      \"default\": {\n111        \"description\": \"Default Correlation ID\",\n112        \"location\": \"$message.header#/correlationId\"\n113      }\n114    },\n115    \"messageTraits\": {\n116      \"commonHeaders\": {\n117        \"headers\": {\n118          \"type\": \"object\",\n119          \"properties\": {\n120            \"my-app-header\": {\n121              \"type\": \"integer\",\n122              \"minimum\": 0,\n123              \"maximum\": 100\n124            }\n125          }\n126        }\n127      }\n128    }\n129  }\n130}\n```\n \n```javascript\n1components:\n2  schemas:\n3    Category:\n4      type: object\n5      properties:\n6        id:\n7          type: integer\n8          format: int64\n9        name:\n10          type: string\n11    Tag:\n12      type: object\n13      properties:\n14        id:\n15          type: integer\n16          format: int64\n17        name:\n18          type: string\n19    AvroExample:\n20      schemaFormat: application/vnd.apache.avro+json;version=1.9.0\n21      schema:\n22        $ref: 'path/to/user-create.avsc/#UserCreate'\n23  servers:\n24    development:\n25      host: \"{stage}.in.mycompany.com:{port}\"\n26      description: RabbitMQ broker\n27      protocol: amqp\n28      protocolVersion: 0-9-1\n29      variables:\n30        stage:\n31          $ref: \"#/components/serverVariables/stage\"\n32        port:\n33          $ref: \"#/components/serverVariables/port\"\n34  serverVariables:\n35    stage:\n36      default: demo\n37      description: This value is assigned by the service provider, in this example `mycompany.com`\n38    port:\n39      enum: [\"5671\", \"5672\"]\n40      default: \"5672\"\n41  channels:\n42    user/signedup:\n43      subscribe:\n44        message:\n45          $ref: \"#/components/messages/userSignUp\"\n46  messages:\n47    userSignUp:\n48      summary: Action to sign a user up.\n49      description: |\n50        Multiline description of what this action does.\n51        Here you have another line.\n52      tags:\n53        - name: user\n54        - name: signup\n55      headers:\n56        type: object\n57        properties:\n58          applicationInstanceId:\n59            description: Unique identifier for a given instance of the publishing application\n60            type: string\n61      payload:\n62        type: object\n63        properties:\n64          user:\n65            $ref: \"#/components/schemas/userCreate\"\n66          signup:\n67            $ref: \"#/components/schemas/signup\"\n68  parameters:\n69    userId:\n70      description: Id of the user.\n71  correlationIds:\n72    default:\n73      description: Default Correlation ID\n74      location: $message.header#/correlationId\n75  messageTraits:\n76    commonHeaders:\n77      headers:\n78        type: object\n79        properties:\n80          my-app-header:\n81            type: integer\n82            minimum: 0\n83            maximum: 100\n```\n Multi Format Schema Object The Multi Format Schema Object represents a schema definition. It differs from the Schema Object in that it supports multiple schema formats or languages (e.g., JSON Schema, Avro, etc.). Fixed Fields Field Name Type Description schemaFormat string Required . A string containing the name of the schema format that is used to define the information. If schemaFormat is missing, it MUST default to application/vnd.aai.asyncapi+json;version={{asyncapi}} where {{asyncapi}} matches the AsyncAPI Version String . In such a case, this would make the Multi Format Schema Object equivalent to the Schema Object . When using Reference Object within the schema, the schemaFormat of the resource being referenced MUST match the schemaFormat of the schema that contains the initial reference. For example, if you reference Avro schema , then schemaFormat of referencing resource and the resource being reference MUST match. Check out the supported schema formats table for more information. Custom values are allowed but their implementation is OPTIONAL. A custom value MUST NOT refer to one of the schema formats listed in the table . When using Reference Objects within the schema, the schemaFormat of the referenced resource MUST match the schemaFormat of the schema containing the reference. schema any Required . Definition of the message payload. It can be of any type but defaults to Schema Object . It MUST match the schema format defined in schemaFormat , including the encoding type. E.g., Avro should be inlined as either a YAML or JSON object instead of as a string to be parsed as YAML or JSON. Non-JSON-based schemas (e.g., Protobuf or XSD) MUST be inlined as a string. This object MAY be extended with Specification Extensions . Schema formats table The following table contains a set of values that every implementation MUST support. Name Allowed values Notes AsyncAPI 3.0.0 Schema Object application/vnd.aai.asyncapi;version=3.0.0 , application/vnd.aai.asyncapi+json;version=3.0.0 , application/vnd.aai.asyncapi+yaml;version=3.0.0 This is the default when a schemaFormat is not provided. JSON Schema Draft 07 application/schema+json;version=draft-07 , application/schema+yaml;version=draft-07 The following table contains a set of values that every implementation is RECOMMENDED to support. Name Allowed values Notes Avro 1.9.0 schema application/vnd.apache.avro;version=1.9.0 , application/vnd.apache.avro+json;version=1.9.0 , application/vnd.apache.avro+yaml;version=1.9.0 OpenAPI 3.0.0 Schema Object application/vnd.oai.openapi;version=3.0.0 , application/vnd.oai.openapi+json;version=3.0.0 , application/vnd.oai.openapi+yaml;version=3.0.0 RAML 1.0 data type application/raml+yaml;version=1.0 Protocol Buffers application/vnd.google.protobuf;version=2 , application/vnd.google.protobuf;version=3 Multi Format Schema Object Examples Multi Format Schema Object Example with Avro \n```javascript\n1channels:\n2  example:\n3    messages:\n4      myMessage:\n5        payload:\n6          schemaFormat: 'application/vnd.apache.avro;version=1.9.0'\n7          schema:\n8            type: record\n9            name: User\n10            namespace: com.company\n11            doc: User information\n12            fields:\n13              - name: displayName\n14                type: string\n15              - name: age\n16                type: int\n```\n Schema Object The Schema Object allows the definition of input and output data types. These types can be objects, but also primitives and arrays. This object is a superset of the JSON Schema Specification Draft 07 . The empty schema (which allows any instance to validate) MAY be represented by the boolean value true and a schema which allows no instance to validate MAY be represented by the boolean value false . Further information about the properties can be found in JSON Schema Core and JSON Schema Validation . Unless stated otherwise, the property definitions follow the JSON Schema specification as referenced here. For other formats (e.g., Avro, RAML, etc) see Multi Format Schema Object . Properties The AsyncAPI Schema Object is a JSON Schema vocabulary which extends JSON Schema Core and Validation vocabularies. As such, any keyword available for those vocabularies is by definition available in AsyncAPI, and will work the exact same way, including but not limited to: title type required multipleOf maximum exclusiveMaximum minimum exclusiveMinimum maxLength minLength pattern (This string SHOULD be a valid regular expression, according to the ECMA 262 regular expression dialect) maxItems minItems uniqueItems maxProperties minProperties enum const examples if / then / else readOnly writeOnly properties patternProperties additionalProperties additionalItems items propertyNames contains allOf oneOf anyOf not The following properties are taken from the JSON Schema definition but their definitions were adjusted to the AsyncAPI Specification. description - CommonMark syntax can be used for rich text representation. format - See Data Type Formats for further details. While relying on JSON Schema's defined formats, the AsyncAPI Specification offers a few additional predefined formats. default - Use it to specify that property has a predefined value if no other value is present. Unlike JSON Schema, the value MUST conform to the defined type for the Schema Object defined at the same level. For example, of type is string , then default can be \"foo\" but cannot be 1 . Alternatively, any time a Schema Object can be used, a Reference Object can be used in its place. This allows referencing definitions in place of defining them inline. It is appropriate to clarify that the $ref keyword MUST follow the behavior described by Reference Object instead of the one in JSON Schema definition . In addition to the JSON Schema fields, the following AsyncAPI vocabulary fields MAY be used for further schema documentation: Fixed Fields Field Name Type Description discriminator string Adds support for polymorphism. The discriminator is the schema property name that is used to differentiate between other schema that inherit this schema. The property name used MUST be defined at this schema and it MUST be in the required property list. When used, the value MUST be the name of this schema or any schema that inherits it. See Composition and Inheritance for more details. externalDocs External Documentation Object | Reference Object Additional external documentation for this schema. deprecated boolean Specifies that a schema is deprecated and SHOULD be transitioned out of usage. Default value is false . This object MAY be extended with Specification Extensions . Composition and Inheritance (Polymorphism) The AsyncAPI Specification allows combining and extending model definitions using the allOf property of JSON Schema, in effect offering model composition. allOf takes in an array of object definitions that are validated independently but together compose a single object. While composition offers model extensibility, it does not imply a hierarchy between the models. To support polymorphism, AsyncAPI Specification adds the support of the discriminator field. When used, the discriminator will be the name of the property used to decide which schema definition is used to validate the structure of the model. As such, the discriminator field MUST be a required field. There are two ways to define the value of a discriminator for an inheriting instance. Use the schema's name. Override the schema's name by overriding the property with a new value. If exists, this takes precedence over the schema's name. As such, inline schema definitions, which do not have a given id, cannot be used in polymorphism. Schema Object Examples Primitive Sample \n```javascript\n1{\n2  \"type\": \"string\",\n3  \"format\": \"email\"\n4}\n```\n \n```javascript\n1type: string\n2format: email\n```\n Simple Model \n```javascript\n1{\n2  \"type\": \"object\",\n3  \"required\": [\n4    \"name\"\n5  ],\n6  \"properties\": {\n7    \"name\": {\n8      \"type\": \"string\"\n9    },\n10    \"address\": {\n11      \"$ref\": \"#/components/schemas/Address\"\n12    },\n13    \"age\": {\n14      \"type\": \"integer\",\n15      \"format\": \"int32\",\n16      \"minimum\": 0\n17    }\n18  }\n19}\n```\n \n```javascript\n1type: object\n2required:\n3- name\n4properties:\n5  name:\n6    type: string\n7  address:\n8    $ref: '#/components/schemas/Address'\n9  age:\n10    type: integer\n11    format: int32\n12    minimum: 0\n```\n Model with Map/Dictionary Properties For a simple string to string mapping: \n```javascript\n1{\n2  \"type\": \"object\",\n3  \"additionalProperties\": {\n4    \"type\": \"string\"\n5  }\n6}\n```\n \n```javascript\n1type: object\n2additionalProperties:\n3  type: string\n```\n For a string to model mapping: \n```javascript\n1{\n2  \"type\": \"object\",\n3  \"additionalProperties\": {\n4    \"$ref\": \"#/components/schemas/ComplexModel\"\n5  }\n6}\n```\n \n```javascript\n1type: object\n2additionalProperties:\n3  $ref: '#/components/schemas/ComplexModel'\n```\n Model with Example \n```javascript\n1{\n2  \"type\": \"object\",\n3  \"properties\": {\n4    \"id\": {\n5      \"type\": \"integer\",\n6      \"format\": \"int64\"\n7    },\n8    \"name\": {\n9      \"type\": \"string\"\n10    }\n11  },\n12  \"required\": [\n13    \"name\"\n14  ],\n15  \"examples\": [\n16    {\n17      \"name\": \"Puma\",\n18      \"id\": 1\n19    }\n20  ]\n21}\n```\n \n```javascript\n1type: object\n2properties:\n3  id:\n4    type: integer\n5    format: int64\n6  name:\n7    type: string\n8required:\n9- name\n10examples:\n11- name: Puma\n12  id: 1\n```\n Model with Boolean Schemas \n```javascript\n1{\n2  \"type\": \"object\",\n3  \"required\": [\n4    \"anySchema\"\n5  ],\n6  \"properties\": {\n7    \"anySchema\": true,\n8    \"cannotBeDefined\": false\n9  }\n10}\n```\n \n```javascript\n1type: object\n2required:\n3- anySchema\n4properties:\n5  anySchema: true\n6  cannotBeDefined: false\n```\n Models with Composition \n```javascript\n1{\n2  \"schemas\": {\n3    \"ErrorModel\": {\n4      \"type\": \"object\",\n5      \"required\": [\n6        \"message\",\n7        \"code\"\n8      ],\n9      \"properties\": {\n10        \"message\": {\n11          \"type\": \"string\"\n12        },\n13        \"code\": {\n14          \"type\": \"integer\",\n15          \"minimum\": 100,\n16          \"maximum\": 600\n17        }\n18      }\n19    },\n20    \"ExtendedErrorModel\": {\n21      \"allOf\": [\n22        {\n23          \"$ref\": \"#/components/schemas/ErrorModel\"\n24        },\n25        {\n26          \"type\": \"object\",\n27          \"required\": [\n28            \"rootCause\"\n29          ],\n30          \"properties\": {\n31            \"rootCause\": {\n32              \"type\": \"string\"\n33            }\n34          }\n35        }\n36      ]\n37    }\n38  }\n39}\n```\n \n```javascript\n1schemas:\n2  ErrorModel:\n3    type: object\n4    required:\n5    - message\n6    - code\n7    properties:\n8      message:\n9        type: string\n10      code:\n11        type: integer\n12        minimum: 100\n13        maximum: 600\n14  ExtendedErrorModel:\n15    allOf:\n16    - $ref: '#/components/schemas/ErrorModel'\n17    - type: object\n18      required:\n19      - rootCause\n20      properties:\n21        rootCause:\n22          type: string\n```\n Models with Polymorphism Support \n```javascript\n1{\n2  \"schemas\": {\n3    \"Pet\": {\n4      \"type\": \"object\",\n5      \"discriminator\": \"petType\",\n6      \"properties\": {\n7        \"name\": {\n8          \"type\": \"string\"\n9        },\n10        \"petType\": {\n11          \"type\": \"string\"\n12        }\n13      },\n14      \"required\": [\n15        \"name\",\n16        \"petType\"\n17      ]\n18    },\n19    \"Cat\": {\n20      \"description\": \"A representation of a cat. Note that `Cat` will be used as the discriminator value.\",\n21      \"allOf\": [\n22        {\n23          \"$ref\": \"#/components/schemas/Pet\"\n24        },\n25        {\n26          \"type\": \"object\",\n27          \"properties\": {\n28            \"huntingSkill\": {\n29              \"type\": \"string\",\n30              \"description\": \"The measured skill for hunting\",\n31              \"enum\": [\n32                \"clueless\",\n33                \"lazy\",\n34                \"adventurous\",\n35                \"aggressive\"\n36              ]\n37            }\n38          },\n39          \"required\": [\n40            \"huntingSkill\"\n41          ]\n42        }\n43      ]\n44    },\n45    \"Dog\": {\n46      \"description\": \"A representation of a dog. Note that `Dog` will be used as the discriminator value.\",\n47      \"allOf\": [\n48        {\n49          \"$ref\": \"#/components/schemas/Pet\"\n50        },\n51        {\n52          \"type\": \"object\",\n53          \"properties\": {\n54            \"packSize\": {\n55              \"type\": \"integer\",\n56              \"format\": \"int32\",\n57              \"description\": \"the size of the pack the dog is from\",\n58              \"minimum\": 0\n59            }\n60          },\n61          \"required\": [\n62            \"packSize\"\n63          ]\n64        }\n65      ]\n66    },\n67    \"StickInsect\": {\n68      \"description\": \"A representation of an Australian walking stick. Note that `StickBug` will be used as the discriminator value.\",\n69      \"allOf\": [\n70        {\n71          \"$ref\": \"#/components/schemas/Pet\"\n72        },\n73        {\n74          \"type\": \"object\",\n75          \"properties\": {\n76            \"petType\": {\n77              \"const\": \"StickBug\"\n78            },\n79            \"color\": {\n80              \"type\": \"string\"\n81            }\n82          },\n83          \"required\": [\n84            \"color\"\n85          ]\n86        }\n87      ]\n88    }\n89  }\n90}\n```\n \n```javascript\n1schemas:\n2  Pet:\n3    type: object\n4    discriminator: petType\n5    properties:\n6      name:\n7        type: string\n8      petType:\n9        type: string\n10    required:\n11    - name\n12    - petType\n13  ## applies to instances with `petType: \"Cat\"`\n14  ## because that is the schema name\n15  Cat:\n16    description: A representation of a cat\n17    allOf:\n18    - $ref: '#/components/schemas/Pet'\n19    - type: object\n20      properties:\n21        huntingSkill:\n22          type: string\n23          description: The measured skill for hunting\n24          enum:\n25          - clueless\n26          - lazy\n27          - adventurous\n28          - aggressive\n29      required:\n30      - huntingSkill\n31  ## applies to instances with `petType: \"Dog\"`\n32  ## because that is the schema name\n33  Dog:\n34    description: A representation of a dog\n35    allOf:\n36    - $ref: '#/components/schemas/Pet'\n37    - type: object\n38      properties:\n39        packSize:\n40          type: integer\n41          format: int32\n42          description: the size of the pack the dog is from\n43          minimum: 0\n44      required:\n45      - packSize\n46  ## applies to instances with `petType: \"StickBug\"`\n47  ## because that is the required value of the discriminator field,\n48  ## overriding the schema name\n49  StickInsect:\n50    description: A representation of an Australian walking stick\n51    allOf:\n52    - $ref: '#/components/schemas/Pet'\n53    - type: object\n54      properties:\n55        petType:\n56          const: StickBug\n57        color:\n58          type: string\n59      required:\n60      - color\n```\n Security Scheme Object Defines a security scheme that can be used by the operations. Supported schemes are: User/Password. API key (either as user or as password). X.509 certificate. End-to-end encryption (either symmetric or asymmetric). HTTP authentication. HTTP API key. OAuth2's common flows (Implicit, Resource Owner Protected Credentials, Client Credentials and Authorization Code) as defined in RFC6749 . OpenID Connect Discovery . SASL (Simple Authentication and Security Layer) as defined in RFC4422 . Fixed Fields Field Name Type Applies To Description type string Any REQUIRED . The type of the security scheme. Valid values are \"userPassword\" , \"apiKey\" , \"X509\" , \"symmetricEncryption\" , \"asymmetricEncryption\" , \"httpApiKey\" , \"http\" , \"oauth2\" , \"openIdConnect\" , \"plain\" , \"scramSha256\" , \"scramSha512\" , and \"gssapi\" . description string Any A short description for security scheme. CommonMark syntax MAY be used for rich text representation. name string httpApiKey REQUIRED . The name of the header, query or cookie parameter to be used. in string apiKey | httpApiKey REQUIRED . The location of the API key. Valid values are \"user\" and \"password\" for apiKey and \"query\" , \"header\" or \"cookie\" for httpApiKey . scheme string http REQUIRED . The name of the HTTP Authorization scheme to be used in the Authorization header as defined in RFC7235 . bearerFormat string http ( \"bearer\" ) A hint to the client to identify how the bearer token is formatted. Bearer tokens are usually generated by an authorization server, so this information is primarily for documentation purposes. flows OAuth Flows Object oauth2 REQUIRED . An object containing configuration information for the flow types supported. openIdConnectUrl string openIdConnect REQUIRED . OpenId Connect URL to discover OAuth2 configuration values. This MUST be in the form of an absolute URL. scopes [ string ] oauth2 | openIdConnect List of the needed scope names. An empty array means no scopes are needed. This object MAY be extended with Specification Extensions . Security Scheme Object Example User/Password Authentication Sample \n```javascript\n1{\n2  \"type\": \"userPassword\"\n3}\n```\n type: userPassword API Key Authentication Sample \n```javascript\n1{\n2  \"type\": \"apiKey\",\n3  \"in\": \"user\"\n4}\n```\n \n```javascript\n1type: apiKey\n2in: user\n```\n X.509 Authentication Sample \n```javascript\n1{\n2  \"type\": \"X509\"\n3}\n```\n type: X509 End-to-end Encryption Authentication Sample \n```javascript\n1{\n2  \"type\": \"symmetricEncryption\"\n3}\n```\n type: symmetricEncryption Basic Authentication Sample \n```javascript\n1{\n2  \"type\": \"http\",\n3  \"scheme\": \"basic\"\n4}\n```\n \n```javascript\n1type: http\n2scheme: basic\n```\n API Key Sample \n```javascript\n1{\n2  \"type\": \"httpApiKey\",\n3  \"name\": \"api_key\",\n4  \"in\": \"header\"\n5}\n```\n \n```javascript\n1type: httpApiKey\n2name: api_key\n3in: header\n```\n JWT Bearer Sample \n```javascript\n1{\n2  \"type\": \"http\",\n3  \"scheme\": \"bearer\",\n4  \"bearerFormat\": \"JWT\"\n5}\n```\n \n```javascript\n1type: http\n2scheme: bearer\n3bearerFormat: JWT\n```\n Implicit OAuth2 Sample \n```javascript\n1{\n2  \"type\": \"oauth2\",\n3  \"flows\": {\n4    \"implicit\": {\n5      \"authorizationUrl\": \"https://example.com/api/oauth/dialog\",\n6      \"availableScopes\": {\n7        \"write:pets\": \"modify pets in your account\",\n8        \"read:pets\": \"read your pets\"\n9      }\n10    }\n11  },\n12  \"scopes\": [\n13    \"write:pets\"\n14  ]\n15}\n```\n \n```javascript\n1type: oauth2\n2flows:\n3  implicit:\n4    authorizationUrl: https://example.com/api/oauth/dialog\n5    availableScopes:\n6      write:pets: modify pets in your account\n7      read:pets: read your pets\n8scopes:\n9  - 'write:pets'\n```\n SASL Sample \n```javascript\n1{\n2  \"type\": \"scramSha512\"\n3}\n```\n type: scramSha512 OAuth Flows Object Allows configuration of the supported OAuth Flows. Fixed Fields Field Name Type Description implicit OAuth Flow Object Configuration for the OAuth Implicit flow. password OAuth Flow Object Configuration for the OAuth Resource Owner Protected Credentials flow. clientCredentials OAuth Flow Object Configuration for the OAuth Client Credentials flow. authorizationCode OAuth Flow Object Configuration for the OAuth Authorization Code flow. This object MAY be extended with Specification Extensions . OAuth Flow Object Configuration details for a supported OAuth Flow Fixed Fields Field Name Type Applies To Description authorizationUrl string oauth2 ( \"implicit\" , \"authorizationCode\" ) REQUIRED . The authorization URL to be used for this flow. This MUST be in the form of an absolute URL. tokenUrl string oauth2 ( \"password\" , \"clientCredentials\" , \"authorizationCode\" ) REQUIRED . The token URL to be used for this flow. This MUST be in the form of an absolute URL. refreshUrl string oauth2 The URL to be used for obtaining refresh tokens. This MUST be in the form of an absolute URL. availableScopes Map[ string , string ] oauth2 REQUIRED . The available scopes for the OAuth2 security scheme. A map between the scope name and a short description for it. This object MAY be extended with Specification Extensions . OAuth Flow Object Examples \n```javascript\n1{\n2  \"authorizationUrl\": \"https://example.com/api/oauth/dialog\",\n3  \"tokenUrl\": \"https://example.com/api/oauth/token\",\n4  \"availableScopes\": {\n5    \"write:pets\": \"modify pets in your account\",\n6    \"read:pets\": \"read your pets\"\n7  }\n8}\n```\n \n```javascript\n1authorizationUrl: https://example.com/api/oauth/dialog\n2tokenUrl: https://example.com/api/oauth/token\n3availableScopes:\n4  write:pets: modify pets in your account\n5  read:pets: read your pets\n```\n Correlation ID Object An object that specifies an identifier at design time that can used for message tracing and correlation. For specifying and computing the location of a Correlation ID, a runtime expression is used. Fixed Fields Field Name Type Description description string An optional description of the identifier. CommonMark syntax can be used for rich text representation. location string REQUIRED. A runtime expression that specifies the location of the correlation ID. This object MAY be extended with Specification Extensions . Examples \n```javascript\n1{\n2  \"description\": \"Default Correlation ID\",\n3  \"location\": \"$message.header#/correlationId\"\n4}\n```\n \n```javascript\n1description: Default Correlation ID\n2location: $message.header#/correlationId\n```\n Runtime Expression A runtime expression allows values to be defined based on information that will be available within the message. This mechanism is used by Correlation ID Object and Operation Reply Address Object . The runtime expression is defined by the following ABNF syntax: \n```javascript\n1      expression = ( \"$message\" \".\" source )\n2      source = ( header-reference | payload-reference )\n3      header-reference = \"header\" [\"#\" fragment]\n4      payload-reference = \"payload\" [\"#\" fragment]\n5      fragment = a JSON Pointer [RFC 6901](https://tools.ietf.org/html/rfc6901)\n```\n The table below provides examples of runtime expressions and examples of their use in a value: Examples Source Location Example expression Notes Message Header Property $message.header#/MQMD/CorrelId Correlation ID is set using the CorrelId value from the MQMD header. Message Payload Property $message.payload#/messageId Correlation ID is set using the messageId value from the message payload. Runtime expressions preserve the type of the referenced value. Traits Merge Mechanism Traits MUST be merged with the target object using the JSON Merge Patch algorithm in the same order they are defined. A property on a trait MUST NOT override the same property on the target object. Example An object like the following: \n```javascript\n1description: A longer description.\n2traits:\n3  - name: UserSignup\n4    description: Description from trait.\n5  - tags:\n6      - name: user\n```\n Would look like the following after applying traits: \n```javascript\n1name: UserSignup\n2description: A longer description.\n3tags:\n4  - name: user\n```\n Specification Extensions While the AsyncAPI Specification tries to accommodate most use cases, additional data can be added to extend the specification at certain points. The extensions properties are implemented as patterned fields that are always prefixed by \"x-\" . Field Pattern Type Description ^x-[\\w\\d\\.\\x2d_]+$ Any Allows extensions to the AsyncAPI Schema. The field name MUST begin with x- , for example, x-internal-id . The value can be null , a primitive, an array or an object. Can have any valid JSON format value. The extensions may or may not be supported by the available tooling, but those may be extended as well to add requested support (if tools are internal or open-sourced). Data Type Formats Primitives have an optional modifier property: format . The AsyncAPI specification uses several known formats to more finely define the data type being used. However, the format property is an open string -valued property, and can have any value to support documentation needs. Formats such as \"email\" , \"uuid\" , etc., can be used even though they are not defined by this specification. Types that are not accompanied by a format property follow their definition from the JSON Schema. Tools that do not recognize a specific format MAY default back to the type alone, as if the format was not specified. The formats defined by the AsyncAPI Specification are: Common Name type format Comments integer integer int32 signed 32 bits long integer int64 signed 64 bits float number float double number double string string byte string byte base64 encoded characters binary string binary any sequence of octets boolean boolean date string date As defined by full-date - RFC3339 dateTime string date-time As defined by date-time - RFC3339 password string password Used to hint UIs the input needs to be obscured. Go Back Reference - Overview Up Next 2.x Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1channels:\n2  userSignedUp:\n3    # ...(redacted for brevity)\n4operations:\n5  onUserSignedUp:\n6    action: receive\n7    channel:\n8      $ref: \"#/channels/userSignedUp\"",
      "1operations:\n2  onUserSignedUp:\n3    summary: On user signed up.\n4    description: Event received when a user signed up on the product.\n5    action: receive\n6    channel:\n7      $ref: \"#/channels/userSignedUp\"",
      "1operations:\n2  onUserSignedUp: # <-- This doesn't make sense now. Should be something like sendUserSignedUp.\n3    summary: On user signed up. # <-- This doesn't make sense now. Should say something like \"Sends a user signed up event\".\n4    description: Event received when a user signed up on the product. # <-- This doesn't make sense now. Should speak about sending an event, not receiving it.\n5    action: send\n6    channel:\n7      $ref: \"#/channels/userSignedUp\"",
      "1{\n2   \"field\" : [...]\n3}",
      "1{\n2  \"id\": \"urn:example:com:smartylighting:streetlights:server\"\n3}",
      "1{\n2  \"id\": \"https://github.com/smartylighting/streetlights-server\"\n3}",
      "1{\n2  \"title\": \"AsyncAPI Sample App\",\n3  \"version\": \"1.0.1\",\n4  \"description\": \"This is a sample app.\",\n5  \"termsOfService\": \"https://asyncapi.org/terms/\",\n6  \"contact\": {\n7    \"name\": \"API Support\",\n8    \"url\": \"https://www.asyncapi.org/support\",\n9    \"email\": \"support@asyncapi.org\"\n10  },\n11  \"license\": {\n12    \"name\": \"Apache 2.0\",\n13    \"url\": \"https://www.apache.org/licenses/LICENSE-2.0.html\"\n14  },\n15  \"externalDocs\": {\n16    \"description\": \"Find more info here\",\n17    \"url\": \"https://www.asyncapi.org\"\n18  },\n19  \"tags\": [\n20    {\n21      \"name\": \"e-commerce\"\n22    }\n23  ]\n24}",
      "1title: AsyncAPI Sample App\n2version: 1.0.1\n3description: This is a sample app.\n4termsOfService: https://asyncapi.org/terms/\n5contact:\n6  name: API Support\n7  url: https://www.asyncapi.org/support\n8  email: support@asyncapi.org\n9license:\n10  name: Apache 2.0\n11  url: https://www.apache.org/licenses/LICENSE-2.0.html\n12externalDocs:\n13  description: Find more info here\n14  url: https://www.asyncapi.org\n15tags:\n16  - name: e-commerce",
      "1{\n2  \"name\": \"API Support\",\n3  \"url\": \"https://www.example.com/support\",\n4  \"email\": \"support@example.com\"\n5}",
      "1name: API Support\n2url: https://www.example.com/support\n3email: support@example.com",
      "1{\n2  \"name\": \"Apache 2.0\",\n3  \"url\": \"https://www.apache.org/licenses/LICENSE-2.0.html\"\n4}",
      "1name: Apache 2.0\n2url: https://www.apache.org/licenses/LICENSE-2.0.html",
      "1{\n2  \"development\": {\n3    \"host\": \"localhost:5672\",\n4    \"description\": \"Development AMQP broker.\",\n5    \"protocol\": \"amqp\",\n6    \"protocolVersion\": \"0-9-1\",\n7    \"tags\": [\n8      { \n9        \"name\": \"env:development\",\n10        \"description\": \"This environment is meant for developers to run their own tests.\"\n11      }\n12    ]\n13  },\n14  \"staging\": {\n15    \"host\": \"rabbitmq-staging.in.mycompany.com:5672\",\n16    \"description\": \"RabbitMQ broker for the staging environment.\",\n17    \"protocol\": \"amqp\",\n18    \"protocolVersion\": \"0-9-1\",\n19    \"tags\": [\n20      { \n21        \"name\": \"env:staging\",\n22        \"description\": \"This environment is a replica of the production environment.\"\n23      }\n24    ]\n25  },\n26  \"production\": {\n27    \"host\": \"rabbitmq.in.mycompany.com:5672\",\n28    \"description\": \"RabbitMQ broker for the production environment.\",\n29    \"protocol\": \"amqp\",\n30    \"protocolVersion\": \"0-9-1\",\n31    \"tags\": [\n32      { \n33        \"name\": \"env:production\",\n34        \"description\": \"This environment is the live environment available for final users.\"\n35      }\n36    ]\n37  }\n38}",
      "1development:\n2  host: localhost:5672\n3  description: Development AMQP broker.\n4  protocol: amqp\n5  protocolVersion: 0-9-1\n6  tags:\n7    - name: \"env:development\"\n8      description: \"This environment is meant for developers to run their own tests.\"\n9staging:\n10  host: rabbitmq-staging.in.mycompany.com:5672\n11  description: RabbitMQ broker for the staging environment.\n12  protocol: amqp\n13  protocolVersion: 0-9-1\n14  tags:\n15    - name: \"env:staging\"\n16      description: \"This environment is a replica of the production environment.\"\n17production:\n18  host: rabbitmq.in.mycompany.com:5672\n19  description: RabbitMQ broker for the production environment.\n20  protocol: amqp\n21  protocolVersion: 0-9-1\n22  tags:\n23    - name: \"env:production\"\n24      description: \"This environment is the live environment available for final users.\"",
      "1{\n2  \"host\": \"kafka.in.mycompany.com:9092\",\n3  \"description\": \"Production Kafka broker.\",\n4  \"protocol\": \"kafka\",\n5  \"protocolVersion\": \"3.2\"\n6}",
      "1host: kafka.in.mycompany.com:9092\n2description: Production Kafka broker.\n3protocol: kafka\n4protocolVersion: '3.2'",
      "1{\n2  \"host\": \"rabbitmq.in.mycompany.com:5672\",\n3  \"pathname\": \"/production\",\n4  \"protocol\": \"amqp\",\n5  \"description\": \"Production RabbitMQ broker (uses the `production` vhost).\"\n6}",
      "1host: rabbitmq.in.mycompany.com:5672\n2pathname: /production\n3protocol: amqp\n4description: Production RabbitMQ broker (uses the `production` vhost).",
      "1{\n2  \"host\": \"rabbitmq.in.mycompany.com:5672\",\n3  \"pathname\": \"/{env}\",\n4  \"protocol\": \"amqp\",\n5  \"description\": \"RabbitMQ broker. Use the `env` variable to point to either `production` or `staging`.\",\n6  \"variables\": {\n7    \"env\": {\n8      \"description\": \"Environment to connect to. It can be either `production` or `staging`.\",\n9      \"enum\": [\n10        \"production\",\n11        \"staging\"\n12      ]\n13    }\n14  }\n15}",
      "1host: 'rabbitmq.in.mycompany.com:5672'\n2pathname: '/{env}'\n3protocol: amqp\n4description: RabbitMQ broker. Use the `env` variable to point to either `production` or `staging`.\n5variables:\n6  env:\n7    description: Environment to connect to. It can be either `production` or `staging`.\n8    enum:\n9      - production\n10      - staging",
      "1{\n2  \"defaultContentType\": \"application/json\"\n3}",
      "1{\n2  \"userSignedUp\": {\n3    \"address\": \"user.signedup\",\n4    \"messages\": {\n5      \"userSignedUp\": {\n6        \"$ref\": \"#/components/messages/userSignedUp\"\n7      }\n8    }\n9  }\n10}",
      "1userSignedUp:\n2  address: 'user.signedup'\n3  messages:\n4    userSignedUp:\n5      $ref: '#/components/messages/userSignedUp'",
      "1{\n2  \"address\": \"users.{userId}\",\n3  \"title\": \"Users channel\",\n4  \"description\": \"This channel is used to exchange messages about user events.\",\n5  \"messages\": {\n6    \"userSignedUp\": {\n7      \"$ref\": \"#/components/messages/userSignedUp\"\n8    },\n9    \"userCompletedOrder\": {\n10      \"$ref\": \"#/components/messages/userCompletedOrder\"\n11    }\n12  },\n13  \"parameters\": {\n14    \"userId\": {\n15      \"$ref\": \"#/components/parameters/userId\"\n16    }\n17  },\n18  \"servers\": [\n19    { \"$ref\": \"#/servers/rabbitmqInProd\" },\n20    { \"$ref\": \"#/servers/rabbitmqInStaging\" }\n21  ],\n22  \"bindings\": {\n23    \"amqp\": {\n24      \"is\": \"queue\",\n25      \"queue\": {\n26        \"exclusive\": true\n27      }\n28    }\n29  },\n30  \"tags\": [{\n31    \"name\": \"user\",\n32    \"description\": \"User-related messages\"\n33  }],\n34  \"externalDocs\": {\n35    \"description\": \"Find more info here\",\n36    \"url\": \"https://example.com\"\n37  }\n38}",
      "1address: 'users.{userId}'\n2title: Users channel\n3description: This channel is used to exchange messages about user events.\n4messages:\n5  userSignedUp:\n6    $ref: '#/components/messages/userSignedUp'\n7  userCompletedOrder:\n8    $ref: '#/components/messages/userCompletedOrder'\n9parameters:\n10  userId:\n11    $ref: '#/components/parameters/userId'\n12servers:\n13  - $ref: '#/servers/rabbitmqInProd'\n14  - $ref: '#/servers/rabbitmqInStaging'\n15bindings:\n16  amqp:\n17    is: queue\n18    queue:\n19      exclusive: true\n20tags:\n21  - name: user\n22    description: User-related messages\n23externalDocs:\n24  description: 'Find more info here'\n25  url: 'https://example.com'",
      "1{\n2  \"userSignedUp\": {\n3    \"$ref\": \"#/components/messages/userSignedUp\"\n4  },\n5  \"userCompletedOrder\": {\n6    \"$ref\": \"#/components/messages/userCompletedOrder\"\n7  }\n8}",
      "1userSignedUp:\n2  $ref: '#/components/messages/userSignedUp'\n3userCompletedOrder:\n4  $ref: '#/components/messages/userCompletedOrder'",
      "1{\n2  \"onUserSignUp\": {\n3    \"title\": \"User sign up\",\n4    \"summary\": \"Action to sign a user up.\",\n5    \"description\": \"A longer description\",\n6    \"channel\": {\n7      \"$ref\": \"#/channels/userSignup\"\n8    },\n9    \"action\": \"send\",\n10    \"tags\": [\n11      { \"name\": \"user\" },\n12      { \"name\": \"signup\" },\n13      { \"name\": \"register\" }\n14    ],\n15    \"bindings\": {\n16      \"amqp\": {\n17        \"ack\": false\n18      }\n19    },\n20    \"traits\": [\n21      { \"$ref\": \"#/components/operationTraits/kafka\" }\n22    ]\n23  }\n24}",
      "1onUserSignUp:\n2  title: User sign up\n3  summary: Action to sign a user up.\n4  description: A longer description\n5  channel:\n6    $ref: '#/channels/userSignup'\n7  action: send\n8  tags:\n9    - name: user\n10    - name: signup\n11    - name: register\n12  bindings:\n13    amqp:\n14      ack: false\n15  traits:\n16    - $ref: '#/components/operationTraits/kafka'",
      "1{\n2  \"title\": \"User sign up\",\n3  \"summary\": \"Action to sign a user up.\",\n4  \"description\": \"A longer description\",\n5  \"channel\": {\n6    \"$ref\": \"#/channels/userSignup\"\n7  },\n8  \"action\": \"send\",\n9  \"security\": [\n10    {\n11     \"petstore_auth\": [\n12       \"write:pets\",\n13       \"read:pets\"\n14     ]\n15    }\n16  ],\n17  \"tags\": [\n18    { \"name\": \"user\" },\n19    { \"name\": \"signup\" },\n20    { \"name\": \"register\" }\n21  ],\n22  \"bindings\": {\n23    \"amqp\": {\n24      \"ack\": false\n25    }\n26  },\n27  \"traits\": [\n28    { \"$ref\": \"#/components/operationTraits/kafka\" }\n29  ],\n30  \"messages\": [\n31    { \"$ref\": \"/components/messages/userSignedUp\" }\n32  ],\n33  \"reply\": {\n34    \"address\": {\n35      \"location\": \"$message.header#/replyTo\"\n36    },\n37    \"channel\": {\n38      \"$ref\": \"#/channels/userSignupReply\"\n39    },\n40    \"messages\": [\n41      { \"$ref\": \"/components/messages/userSignedUpReply\" }\n42    ],\n43  }\n44}",
      "1title: User sign up\n2summary: Action to sign a user up.\n3description: A longer description\n4channel:\n5  $ref: '#/channels/userSignup'\n6action: send\n7security:\n8  - petstore_auth:\n9    - write:pets\n10    - read:pets\n11tags:\n12  - name: user\n13  - name: signup\n14  - name: register\n15bindings:\n16  amqp:\n17    ack: false\n18traits:\n19  - $ref: \"#/components/operationTraits/kafka\"\n20messages:\n21  - $ref: '#/components/messages/userSignedUp'\n22reply:\n23  address:\n24    location: '$message.header#/replyTo'\n25  channel:\n26    $ref: '#/channels/userSignupReply'\n27  messages:\n28    - $ref: '#/components/messages/userSignedUpReply'",
      "1{\n2  \"bindings\": {\n3    \"amqp\": {\n4      \"ack\": false\n5    }\n6  }\n7}",
      "1bindings:\n2  amqp:\n3    ack: false",
      "1{\n2  \"description\": \"Consumer inbox\",\n3  \"location\": \"$message.header#/replyTo\"\n4}",
      "1description: Consumer Inbox\n2location: $message.header#/replyTo",
      "1{\n2  \"address\": \"user/{userId}/signedup\",\n3  \"parameters\": {\n4    \"userId\": {\n5      \"description\": \"Id of the user.\"\n6    }\n7  }\n8}",
      "1address: user/{userId}/signedup\n2parameters:\n3  userId:\n4    description: Id of the user.",
      "1{\n2  \"address\": \"user/{userId}/signedup\",\n3  \"parameters\": {\n4    \"userId\": {\n5      \"description\": \"Id of the user.\",\n6      \"location\": \"$message.payload#/user/id\"\n7    }\n8  }\n9}",
      "1address: user/{userId}/signedup\n2parameters:\n3  userId:\n4    description: Id of the user.\n5    location: $message.payload#/user/id",
      "1{\n2  \"name\": \"UserSignup\",\n3  \"title\": \"User signup\",\n4  \"summary\": \"Action to sign a user up.\",\n5  \"description\": \"A longer description\",\n6  \"contentType\": \"application/json\",\n7  \"tags\": [\n8    { \"name\": \"user\" },\n9    { \"name\": \"signup\" },\n10    { \"name\": \"register\" }\n11  ],\n12  \"headers\": {\n13    \"type\": \"object\",\n14    \"properties\": {\n15      \"correlationId\": {\n16        \"description\": \"Correlation ID set by application\",\n17        \"type\": \"string\"\n18      },\n19      \"applicationInstanceId\": {\n20        \"description\": \"Unique identifier for a given instance of the publishing application\",\n21        \"type\": \"string\"\n22      }\n23    }\n24  },\n25  \"payload\": {\n26    \"type\": \"object\",\n27    \"properties\": {\n28      \"user\": {\n29        \"$ref\": \"#/components/schemas/userCreate\"\n30      },\n31      \"signup\": {\n32        \"$ref\": \"#/components/schemas/signup\"\n33      }\n34    }\n35  },\n36  \"correlationId\": {\n37    \"description\": \"Default Correlation ID\",\n38    \"location\": \"$message.header#/correlationId\"\n39  },\n40  \"traits\": [\n41    { \"$ref\": \"#/components/messageTraits/commonHeaders\" }\n42  ],\n43  \"examples\": [\n44    {\n45      \"name\": \"SimpleSignup\",\n46      \"summary\": \"A simple UserSignup example message\",\n47      \"headers\": {\n48        \"correlationId\": \"my-correlation-id\",\n49        \"applicationInstanceId\": \"myInstanceId\"\n50      },\n51      \"payload\": {\n52        \"user\": {\n53          \"someUserKey\": \"someUserValue\"\n54        },\n55        \"signup\": {\n56          \"someSignupKey\": \"someSignupValue\"\n57        }\n58      }\n59    }\n60  ]\n61}",
      "1name: UserSignup\n2title: User signup\n3summary: Action to sign a user up.\n4description: A longer description\n5contentType: application/json\n6tags:\n7  - name: user\n8  - name: signup\n9  - name: register\n10headers:\n11  type: object\n12  properties:\n13    correlationId:\n14      description: Correlation ID set by application\n15      type: string\n16    applicationInstanceId:\n17      description: Unique identifier for a given instance of the publishing application\n18      type: string\n19payload:\n20  type: object\n21  properties:\n22    user:\n23      $ref: \"#/components/schemas/userCreate\"\n24    signup:\n25      $ref: \"#/components/schemas/signup\"\n26correlationId:\n27  description: Default Correlation ID\n28  location: $message.header#/correlationId\n29traits:\n30  - $ref: \"#/components/messageTraits/commonHeaders\"\n31examples:\n32  - name: SimpleSignup\n33    summary: A simple UserSignup example message\n34    headers:\n35      correlationId: my-correlation-id\n36      applicationInstanceId: myInstanceId\n37    payload:\n38      user:\n39        someUserKey: someUserValue\n40      signup:\n41        someSignupKey: someSignupValue",
      "1{\n2  \"name\": \"UserSignup\",\n3  \"title\": \"User signup\",\n4  \"summary\": \"Action to sign a user up.\",\n5  \"description\": \"A longer description\",\n6  \"tags\": [\n7    { \"name\": \"user\" },\n8    { \"name\": \"signup\" },\n9    { \"name\": \"register\" }\n10  ],\n11  \"payload\": {\n12    \"schemaFormat\": \"application/vnd.apache.avro+json;version=1.9.0\",\n13    \"schema\": {\n14      \"$ref\": \"path/to/user-create.avsc#/UserCreate\"\n15    }\n16  }\n17}",
      "1name: UserSignup\n2title: User signup\n3summary: Action to sign a user up.\n4description: A longer description\n5tags:\n6  - name: user\n7  - name: signup\n8  - name: register\n9payload:\n10  schemaFormat: 'application/vnd.apache.avro+yaml;version=1.9.0'\n11  schema:\n12    $ref: 'path/to/user-create.avsc/#UserCreate'",
      "1{\n2  \"contentType\": \"application/json\"\n3}",
      "1{\n2  \"name\": \"SimpleSignup\",\n3  \"summary\": \"A simple UserSignup example message\",\n4  \"headers\": {\n5    \"correlationId\": \"my-correlation-id\",\n6    \"applicationInstanceId\": \"myInstanceId\"\n7  },\n8  \"payload\": {\n9    \"user\": {\n10      \"someUserKey\": \"someUserValue\"\n11    },\n12    \"signup\": {\n13      \"someSignupKey\": \"someSignupValue\"\n14    }\n15  }\n16}",
      "1name: SimpleSignup\n2summary: A simple UserSignup example message\n3headers:\n4  correlationId: my-correlation-id\n5  applicationInstanceId: myInstanceId\n6payload:\n7  user:\n8    someUserKey: someUserValue\n9  signup:\n10    someSignupKey: someSignupValue",
      "1{\n2 \"name\": \"user\",\n3 \"description\": \"User-related messages\"\n4}",
      "1name: user\n2description: User-related messages",
      "1{\n2  \"description\": \"Find more info here\",\n3  \"url\": \"https://example.com\"\n4}",
      "1description: Find more info here\n2url: https://example.com",
      "1{\n2  \"$ref\": \"#/components/schemas/Pet\"\n3}",
      "1User\n2User_1\n3User_Name\n4user-name\n5my.org.User",
      "1{\n2  \"components\": {\n3    \"schemas\": {\n4      \"Category\": {\n5        \"type\": \"object\",\n6        \"properties\": {\n7          \"id\": {\n8            \"type\": \"integer\",\n9            \"format\": \"int64\"\n10          },\n11          \"name\": {\n12            \"type\": \"string\"\n13          }\n14        }\n15      },\n16      \"Tag\": {\n17        \"type\": \"object\",\n18        \"properties\": {\n19          \"id\": {\n20            \"type\": \"integer\",\n21            \"format\": \"int64\"\n22          },\n23          \"name\": {\n24            \"type\": \"string\"\n25          }\n26        }\n27      },\n28      \"AvroExample\": {\n29        \"schemaFormat\": \"application/vnd.apache.avro+json;version=1.9.0\",\n30        \"schema\": {\n31          \"$ref\": \"path/to/user-create.avsc#/UserCreate\"\n32        }\n33      }\n34    },\n35    \"servers\": {\n36      \"development\": {\n37        \"host\": \"{stage}.in.mycompany.com:{port}\",\n38        \"description\": \"RabbitMQ broker\",\n39        \"protocol\": \"amqp\",\n40        \"protocolVersion\": \"0-9-1\",\n41        \"variables\": {\n42          \"stage\": {\n43            \"$ref\": \"#/components/serverVariables/stage\"\n44          },\n45          \"port\": {\n46            \"$ref\": \"#/components/serverVariables/port\"\n47          }\n48        }\n49      }\n50    },\n51    \"serverVariables\": {\n52      \"stage\": {\n53        \"default\": \"demo\",\n54        \"description\": \"This value is assigned by the service provider, in this example `mycompany.com`\"\n55      },\n56      \"port\": {\n57        \"enum\": [\"5671\", \"5672\"],\n58        \"default\": \"5672\"\n59      }\n60    },\n61    \"channels\": {\n62      \"user/signedup\": {\n63        \"subscribe\": {\n64          \"message\": {\n65            \"$ref\": \"#/components/messages/userSignUp\"\n66          }\n67        }\n68      }\n69    },\n70    \"messages\": {\n71      \"userSignUp\": {\n72        \"summary\": \"Action to sign a user up.\",\n73        \"description\": \"Multiline description of what this action does.\\nHere you have another line.\\n\",\n74        \"tags\": [\n75          {\n76            \"name\": \"user\"\n77          },\n78          {\n79            \"name\": \"signup\"\n80          }\n81        ],\n82        \"headers\": {\n83          \"type\": \"object\",\n84          \"properties\": {\n85            \"applicationInstanceId\": {\n86              \"description\": \"Unique identifier for a given instance of the publishing application\",\n87              \"type\": \"string\"\n88            }\n89          }\n90        },\n91        \"payload\": {\n92          \"type\": \"object\",\n93          \"properties\": {\n94            \"user\": {\n95              \"$ref\": \"#/components/schemas/userCreate\"\n96            },\n97            \"signup\": {\n98              \"$ref\": \"#/components/schemas/signup\"\n99            }\n100          }\n101        }\n102      }\n103    },\n104    \"parameters\": {\n105      \"userId\": {\n106        \"description\": \"Id of the user.\"\n107      }\n108    },\n109    \"correlationIds\": {\n110      \"default\": {\n111        \"description\": \"Default Correlation ID\",\n112        \"location\": \"$message.header#/correlationId\"\n113      }\n114    },\n115    \"messageTraits\": {\n116      \"commonHeaders\": {\n117        \"headers\": {\n118          \"type\": \"object\",\n119          \"properties\": {\n120            \"my-app-header\": {\n121              \"type\": \"integer\",\n122              \"minimum\": 0,\n123              \"maximum\": 100\n124            }\n125          }\n126        }\n127      }\n128    }\n129  }\n130}",
      "1components:\n2  schemas:\n3    Category:\n4      type: object\n5      properties:\n6        id:\n7          type: integer\n8          format: int64\n9        name:\n10          type: string\n11    Tag:\n12      type: object\n13      properties:\n14        id:\n15          type: integer\n16          format: int64\n17        name:\n18          type: string\n19    AvroExample:\n20      schemaFormat: application/vnd.apache.avro+json;version=1.9.0\n21      schema:\n22        $ref: 'path/to/user-create.avsc/#UserCreate'\n23  servers:\n24    development:\n25      host: \"{stage}.in.mycompany.com:{port}\"\n26      description: RabbitMQ broker\n27      protocol: amqp\n28      protocolVersion: 0-9-1\n29      variables:\n30        stage:\n31          $ref: \"#/components/serverVariables/stage\"\n32        port:\n33          $ref: \"#/components/serverVariables/port\"\n34  serverVariables:\n35    stage:\n36      default: demo\n37      description: This value is assigned by the service provider, in this example `mycompany.com`\n38    port:\n39      enum: [\"5671\", \"5672\"]\n40      default: \"5672\"\n41  channels:\n42    user/signedup:\n43      subscribe:\n44        message:\n45          $ref: \"#/components/messages/userSignUp\"\n46  messages:\n47    userSignUp:\n48      summary: Action to sign a user up.\n49      description: |\n50        Multiline description of what this action does.\n51        Here you have another line.\n52      tags:\n53        - name: user\n54        - name: signup\n55      headers:\n56        type: object\n57        properties:\n58          applicationInstanceId:\n59            description: Unique identifier for a given instance of the publishing application\n60            type: string\n61      payload:\n62        type: object\n63        properties:\n64          user:\n65            $ref: \"#/components/schemas/userCreate\"\n66          signup:\n67            $ref: \"#/components/schemas/signup\"\n68  parameters:\n69    userId:\n70      description: Id of the user.\n71  correlationIds:\n72    default:\n73      description: Default Correlation ID\n74      location: $message.header#/correlationId\n75  messageTraits:\n76    commonHeaders:\n77      headers:\n78        type: object\n79        properties:\n80          my-app-header:\n81            type: integer\n82            minimum: 0\n83            maximum: 100",
      "1channels:\n2  example:\n3    messages:\n4      myMessage:\n5        payload:\n6          schemaFormat: 'application/vnd.apache.avro;version=1.9.0'\n7          schema:\n8            type: record\n9            name: User\n10            namespace: com.company\n11            doc: User information\n12            fields:\n13              - name: displayName\n14                type: string\n15              - name: age\n16                type: int",
      "1{\n2  \"type\": \"string\",\n3  \"format\": \"email\"\n4}",
      "1type: string\n2format: email",
      "1{\n2  \"type\": \"object\",\n3  \"required\": [\n4    \"name\"\n5  ],\n6  \"properties\": {\n7    \"name\": {\n8      \"type\": \"string\"\n9    },\n10    \"address\": {\n11      \"$ref\": \"#/components/schemas/Address\"\n12    },\n13    \"age\": {\n14      \"type\": \"integer\",\n15      \"format\": \"int32\",\n16      \"minimum\": 0\n17    }\n18  }\n19}",
      "1type: object\n2required:\n3- name\n4properties:\n5  name:\n6    type: string\n7  address:\n8    $ref: '#/components/schemas/Address'\n9  age:\n10    type: integer\n11    format: int32\n12    minimum: 0",
      "1{\n2  \"type\": \"object\",\n3  \"additionalProperties\": {\n4    \"type\": \"string\"\n5  }\n6}",
      "1type: object\n2additionalProperties:\n3  type: string",
      "1{\n2  \"type\": \"object\",\n3  \"additionalProperties\": {\n4    \"$ref\": \"#/components/schemas/ComplexModel\"\n5  }\n6}",
      "1type: object\n2additionalProperties:\n3  $ref: '#/components/schemas/ComplexModel'",
      "1{\n2  \"type\": \"object\",\n3  \"properties\": {\n4    \"id\": {\n5      \"type\": \"integer\",\n6      \"format\": \"int64\"\n7    },\n8    \"name\": {\n9      \"type\": \"string\"\n10    }\n11  },\n12  \"required\": [\n13    \"name\"\n14  ],\n15  \"examples\": [\n16    {\n17      \"name\": \"Puma\",\n18      \"id\": 1\n19    }\n20  ]\n21}",
      "1type: object\n2properties:\n3  id:\n4    type: integer\n5    format: int64\n6  name:\n7    type: string\n8required:\n9- name\n10examples:\n11- name: Puma\n12  id: 1",
      "1{\n2  \"type\": \"object\",\n3  \"required\": [\n4    \"anySchema\"\n5  ],\n6  \"properties\": {\n7    \"anySchema\": true,\n8    \"cannotBeDefined\": false\n9  }\n10}",
      "1type: object\n2required:\n3- anySchema\n4properties:\n5  anySchema: true\n6  cannotBeDefined: false",
      "1{\n2  \"schemas\": {\n3    \"ErrorModel\": {\n4      \"type\": \"object\",\n5      \"required\": [\n6        \"message\",\n7        \"code\"\n8      ],\n9      \"properties\": {\n10        \"message\": {\n11          \"type\": \"string\"\n12        },\n13        \"code\": {\n14          \"type\": \"integer\",\n15          \"minimum\": 100,\n16          \"maximum\": 600\n17        }\n18      }\n19    },\n20    \"ExtendedErrorModel\": {\n21      \"allOf\": [\n22        {\n23          \"$ref\": \"#/components/schemas/ErrorModel\"\n24        },\n25        {\n26          \"type\": \"object\",\n27          \"required\": [\n28            \"rootCause\"\n29          ],\n30          \"properties\": {\n31            \"rootCause\": {\n32              \"type\": \"string\"\n33            }\n34          }\n35        }\n36      ]\n37    }\n38  }\n39}",
      "1schemas:\n2  ErrorModel:\n3    type: object\n4    required:\n5    - message\n6    - code\n7    properties:\n8      message:\n9        type: string\n10      code:\n11        type: integer\n12        minimum: 100\n13        maximum: 600\n14  ExtendedErrorModel:\n15    allOf:\n16    - $ref: '#/components/schemas/ErrorModel'\n17    - type: object\n18      required:\n19      - rootCause\n20      properties:\n21        rootCause:\n22          type: string",
      "1{\n2  \"schemas\": {\n3    \"Pet\": {\n4      \"type\": \"object\",\n5      \"discriminator\": \"petType\",\n6      \"properties\": {\n7        \"name\": {\n8          \"type\": \"string\"\n9        },\n10        \"petType\": {\n11          \"type\": \"string\"\n12        }\n13      },\n14      \"required\": [\n15        \"name\",\n16        \"petType\"\n17      ]\n18    },\n19    \"Cat\": {\n20      \"description\": \"A representation of a cat. Note that `Cat` will be used as the discriminator value.\",\n21      \"allOf\": [\n22        {\n23          \"$ref\": \"#/components/schemas/Pet\"\n24        },\n25        {\n26          \"type\": \"object\",\n27          \"properties\": {\n28            \"huntingSkill\": {\n29              \"type\": \"string\",\n30              \"description\": \"The measured skill for hunting\",\n31              \"enum\": [\n32                \"clueless\",\n33                \"lazy\",\n34                \"adventurous\",\n35                \"aggressive\"\n36              ]\n37            }\n38          },\n39          \"required\": [\n40            \"huntingSkill\"\n41          ]\n42        }\n43      ]\n44    },\n45    \"Dog\": {\n46      \"description\": \"A representation of a dog. Note that `Dog` will be used as the discriminator value.\",\n47      \"allOf\": [\n48        {\n49          \"$ref\": \"#/components/schemas/Pet\"\n50        },\n51        {\n52          \"type\": \"object\",\n53          \"properties\": {\n54            \"packSize\": {\n55              \"type\": \"integer\",\n56              \"format\": \"int32\",\n57              \"description\": \"the size of the pack the dog is from\",\n58              \"minimum\": 0\n59            }\n60          },\n61          \"required\": [\n62            \"packSize\"\n63          ]\n64        }\n65      ]\n66    },\n67    \"StickInsect\": {\n68      \"description\": \"A representation of an Australian walking stick. Note that `StickBug` will be used as the discriminator value.\",\n69      \"allOf\": [\n70        {\n71          \"$ref\": \"#/components/schemas/Pet\"\n72        },\n73        {\n74          \"type\": \"object\",\n75          \"properties\": {\n76            \"petType\": {\n77              \"const\": \"StickBug\"\n78            },\n79            \"color\": {\n80              \"type\": \"string\"\n81            }\n82          },\n83          \"required\": [\n84            \"color\"\n85          ]\n86        }\n87      ]\n88    }\n89  }\n90}",
      "1schemas:\n2  Pet:\n3    type: object\n4    discriminator: petType\n5    properties:\n6      name:\n7        type: string\n8      petType:\n9        type: string\n10    required:\n11    - name\n12    - petType\n13  ## applies to instances with `petType: \"Cat\"`\n14  ## because that is the schema name\n15  Cat:\n16    description: A representation of a cat\n17    allOf:\n18    - $ref: '#/components/schemas/Pet'\n19    - type: object\n20      properties:\n21        huntingSkill:\n22          type: string\n23          description: The measured skill for hunting\n24          enum:\n25          - clueless\n26          - lazy\n27          - adventurous\n28          - aggressive\n29      required:\n30      - huntingSkill\n31  ## applies to instances with `petType: \"Dog\"`\n32  ## because that is the schema name\n33  Dog:\n34    description: A representation of a dog\n35    allOf:\n36    - $ref: '#/components/schemas/Pet'\n37    - type: object\n38      properties:\n39        packSize:\n40          type: integer\n41          format: int32\n42          description: the size of the pack the dog is from\n43          minimum: 0\n44      required:\n45      - packSize\n46  ## applies to instances with `petType: \"StickBug\"`\n47  ## because that is the required value of the discriminator field,\n48  ## overriding the schema name\n49  StickInsect:\n50    description: A representation of an Australian walking stick\n51    allOf:\n52    - $ref: '#/components/schemas/Pet'\n53    - type: object\n54      properties:\n55        petType:\n56          const: StickBug\n57        color:\n58          type: string\n59      required:\n60      - color",
      "1{\n2  \"type\": \"userPassword\"\n3}",
      "1{\n2  \"type\": \"apiKey\",\n3  \"in\": \"user\"\n4}",
      "1type: apiKey\n2in: user",
      "1{\n2  \"type\": \"X509\"\n3}",
      "1{\n2  \"type\": \"symmetricEncryption\"\n3}",
      "1{\n2  \"type\": \"http\",\n3  \"scheme\": \"basic\"\n4}",
      "1type: http\n2scheme: basic",
      "1{\n2  \"type\": \"httpApiKey\",\n3  \"name\": \"api_key\",\n4  \"in\": \"header\"\n5}",
      "1type: httpApiKey\n2name: api_key\n3in: header",
      "1{\n2  \"type\": \"http\",\n3  \"scheme\": \"bearer\",\n4  \"bearerFormat\": \"JWT\"\n5}",
      "1type: http\n2scheme: bearer\n3bearerFormat: JWT",
      "1{\n2  \"type\": \"oauth2\",\n3  \"flows\": {\n4    \"implicit\": {\n5      \"authorizationUrl\": \"https://example.com/api/oauth/dialog\",\n6      \"availableScopes\": {\n7        \"write:pets\": \"modify pets in your account\",\n8        \"read:pets\": \"read your pets\"\n9      }\n10    }\n11  },\n12  \"scopes\": [\n13    \"write:pets\"\n14  ]\n15}",
      "1type: oauth2\n2flows:\n3  implicit:\n4    authorizationUrl: https://example.com/api/oauth/dialog\n5    availableScopes:\n6      write:pets: modify pets in your account\n7      read:pets: read your pets\n8scopes:\n9  - 'write:pets'",
      "1{\n2  \"type\": \"scramSha512\"\n3}",
      "1{\n2  \"authorizationUrl\": \"https://example.com/api/oauth/dialog\",\n3  \"tokenUrl\": \"https://example.com/api/oauth/token\",\n4  \"availableScopes\": {\n5    \"write:pets\": \"modify pets in your account\",\n6    \"read:pets\": \"read your pets\"\n7  }\n8}",
      "1authorizationUrl: https://example.com/api/oauth/dialog\n2tokenUrl: https://example.com/api/oauth/token\n3availableScopes:\n4  write:pets: modify pets in your account\n5  read:pets: read your pets",
      "1{\n2  \"description\": \"Default Correlation ID\",\n3  \"location\": \"$message.header#/correlationId\"\n4}",
      "1description: Default Correlation ID\n2location: $message.header#/correlationId",
      "1      expression = ( \"$message\" \".\" source )\n2      source = ( header-reference | payload-reference )\n3      header-reference = \"header\" [\"#\" fragment]\n4      payload-reference = \"payload\" [\"#\" fragment]\n5      fragment = a JSON Pointer [RFC 6901](https://tools.ietf.org/html/rfc6901)",
      "1description: A longer description.\n2traits:\n3  - name: UserSignup\n4    description: Description from trait.\n5  - tags:\n6      - name: user",
      "1name: UserSignup\n2description: A longer description.\n3tags:\n4  - name: user"
    ],
    "yaml_blocks": [
      "id: 'urn:example:com:smartylighting:streetlights:server'",
      "id: 'https://github.com/smartylighting/streetlights-server'"
    ],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "6ec9442a",
    "title": "v2.5.0.html",
    "path": "asyncapi-docs/www.asyncapi.com/docs/reference/specification/v2.5.0.html",
    "content": "",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "219702fd",
    "title": "v2.6.0.html",
    "path": "asyncapi-docs/www.asyncapi.com/docs/reference/specification/v2.6.0.html",
    "content": "",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "6cf102ff",
    "title": "2.x | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/reference/specification/v2.x.html",
    "content": "2.x | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets 2.x Found an error? Have a suggestion? Edit this page on GitHub To read about previous versions of AsyncAPI specification go to: https://v2.asyncapi.com/docs/reference Go Back 3.0.0 Up Next Specification Visualizer Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "d62b8308",
    "title": "AsyncAPI Logo",
    "path": "asyncapi-docs/www.asyncapi.com/docs/reference/specification/v3.0.0-explorer.html",
    "content": "AsyncAPI Logo loading",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "9bb78f9d",
    "title": "3.0.0 | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/reference/specification/v3.0.0.html",
    "content": "3.0.0 | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page AsyncAPI Specification Attribution Version 3.0.0 Introduction Definitions Server Application Sender Receiver Message Channel Protocol Bindings Specification Format File Structure Absolute URLs Schema AsyncAPI Object AsyncAPI Version String Identifier Info Object Contact Object License Object Servers Object Server Object Server Variable Object Default Content Type Channels Object Channel Object Channel Address Expressions Messages Object Operations Object Operation Object Operation Trait Object Operation Reply Object Operation Reply Address Object Parameters Object Parameter Object Server Bindings Object Channel Bindings Object Operation Bindings Object Message Bindings Object Message Object Message Trait Object Message Example Object Tags Object Tag Object External Documentation Object Reference Object Components Object Multi Format Schema Object Schema Object Security Scheme Object OAuth Flows Object OAuth Flow Object Correlation ID Object Fixed Fields Runtime Expression Examples Traits Merge Mechanism Example Specification Extensions Data Type Formats 3.0.0 Found an error? Have a suggestion? Edit this page on GitHub What is new in v3.0.0? Have a look at the release notes . Interested in release notes of other versions of the specification? Check list of release notes . AsyncAPI Specification Attribution Part of this content has been taken from the great work done by the folks at the OpenAPI Initiative . Version 3.0.0 The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 . The AsyncAPI Specification is licensed under The Apache License, Version 2.0 . Introduction The AsyncAPI Specification is a project used to describe message-driven APIs in a machine-readable format. It\u2019s protocol-agnostic, so you can use it for APIs that work over any protocol (e.g., AMQP, MQTT, WebSockets, Kafka, STOMP, HTTP, Mercure, etc). The AsyncAPI Specification defines a set of fields that can be used in an AsyncAPI document to describe an application 's API. The document may reference other files for additional details or shared fields, but it is typically a single, primary document that encapsulates the API description. The AsyncAPI document SHOULD describe the operations an application performs. For instance, consider the following AsyncAPI definition snippet: \n```javascript\n1channels:\n2  userSignedUp:\n3    # ...(redacted for brevity)\n4operations:\n5  onUserSignedUp:\n6    action: receive\n7    channel:\n8      $ref: \"#/channels/userSignedUp\"\n```\n It means that the application will receive messages from the userSignedUp channel . The AsyncAPI specification does not assume any kind of software topology, architecture or pattern. Therefore, a server MAY be a message broker, a web server or any other kind of computer program capable of sending and/or receiving data. However, AsyncAPI offers a mechanism called \"bindings\" that aims to help with more specific information about the protocol. It's NOT RECOMMENDED to derive a receiver AsyncAPI document from a sender one or vice versa. There are no guarantees that the channel used by an application to receive messages will be the same channel where another application is sending them. Also, certain fields in the document like summary , description , and the id of the operation might stop making sense. For instance, given the following receiver snippet: \n```javascript\n1operations:\n2  onUserSignedUp:\n3    summary: On user signed up.\n4    description: Event received when a user signed up on the product.\n5    action: receive\n6    channel:\n7      $ref: \"#/channels/userSignedUp\"\n```\n We can't automatically assume that an opposite application exists by simply replacing receive with send : \n```javascript\n1operations:\n2  onUserSignedUp: # <-- This doesn't make sense now. Should be something like sendUserSignedUp.\n3    summary: On user signed up. # <-- This doesn't make sense now. Should say something like \"Sends a user signed up event\".\n4    description: Event received when a user signed up on the product. # <-- This doesn't make sense now. Should speak about sending an event, not receiving it.\n5    action: send\n6    channel:\n7      $ref: \"#/channels/userSignedUp\"\n```\n Aside from the issues mentioned above, there may also be infrastructure configuration that is not represented here. For instance, a system may use a read-only channel for receiving messages, a different one for sending them, and an intermediary process that will forward messages from one channel to the other. Definitions Server A server MAY be a message broker that is capable of sending and/or receiving between a sender and receiver . A server MAY be a service with WebSocket API that enables message-driven communication between browser-to-server or server-to-server. Application An application is any kind of computer program or a group of them. It MUST be a sender , a receiver , or both. An application MAY be a microservice, IoT device (sensor), mainframe process, message broker, etc. An application MAY be written in any number of different programming languages as long as they support the selected protocol . An application MUST also use a protocol supported by the server in order to connect and exchange messages . Sender A sender is a type of application, that is sending messages to channels . A sender MAY send to multiple channels depending on the server , protocol, and use-case pattern. Receiver A receiver is a type of application that is receiving messages from channels . A receiver MAY receive from multiple channels depending on the server , protocol, and the use-case pattern. A receiver MAY forward a received message further without changing it. A receiver MAY act as a consumer and react to the message. A receiver MAY act as a processor that, for example, aggregates multiple messages in one and forwards them. Message A message is the mechanism by which information is exchanged via a channel between servers and applications. A message MAY contain a payload and MAY also contain headers. The headers MAY be subdivided into protocol -defined headers and header properties defined by the application which can act as supporting metadata. The payload contains the data, defined by the application, which MUST be serialized into a format (JSON, XML, Avro, binary, etc.). Since a message is a generic mechanism, it can support multiple interaction patterns such as event, command, request, or response. Channel A channel is an addressable component, made available by the server , for the organization of messages . Sender applications send messages to channels and receiver applications receive messages from channels. Servers MAY support many channel instances, allowing messages with different content to be addressed to different channels. Depending on the server implementation, the channel MAY be included in the message via protocol-defined headers. Protocol A protocol is the mechanism (wireline protocol or API) by which messages are exchanged between the application and the channel . Example protocols include, but are not limited to, AMQP, HTTP, JMS, Kafka, Anypoint MQ, MQTT, Solace, STOMP, Mercure, WebSocket, Google Pub/Sub, Pulsar. Bindings A \"binding\" (or \"protocol binding\") is a mechanism to define protocol-specific information. Therefore, a protocol binding MUST define protocol-specific information only. Specification Format The files describing the message-driven API in accordance with the AsyncAPI Specification are represented as JSON objects and conform to the JSON standards. YAML, being a superset of JSON, can be used as well to represent a A2S (AsyncAPI Specification) file. For example, if a field is said to have an array value, the JSON array representation will be used: \n```javascript\n1{\n2   \"field\" : [...]\n3}\n```\n While the API is described using JSON it does not impose a JSON input/output to the API itself. All field names in the specification are case sensitive . The schema exposes two types of fields. Fixed fields, which have a declared name, and Patterned fields, which declare a regex pattern for the field name. Patterned fields can have multiple occurrences as long as each has a unique name. In order to preserve the ability to round-trip between YAML and JSON formats, YAML version 1.2 is recommended along with some additional constraints: Tags MUST be limited to those allowed by the JSON Schema ruleset Keys used in YAML maps MUST be limited to a scalar string, as defined by the YAML Failsafe schema ruleset File Structure An AsyncAPI document MAY be made up of a single document or be divided into multiple, connected parts at the discretion of the author. In the latter case, Reference Objects are used. It is important to note that everything that is defined in an AsyncAPI document MUST be used by the implemented Application , with the exception of the Components Object . Everything that is defined inside the Components Object represents a resource that MAY or MAY NOT be used by the implemented Application . By convention, the AsyncAPI Specification (A2S) file is named asyncapi.json or asyncapi.yaml . Absolute URLs Unless specified otherwise, all properties that are absolute URLs are defined by RFC3986, section 4.3 . Schema AsyncAPI Object This is the root document object for the API specification. It combines resource listing and API declaration together into one document. Fixed Fields Field Name Type Description asyncapi AsyncAPI Version String REQUIRED. Specifies the AsyncAPI Specification version being used. It can be used by tooling Specifications and clients to interpret the version. The structure shall be major . minor . patch , where patch versions must be compatible with the existing major . minor tooling. Typically patch versions will be introduced to address errors in the documentation, and tooling should typically be compatible with the corresponding major . minor (1.0.*). Patch versions will correspond to patches of this document. id Identifier Identifier of the application the AsyncAPI document is defining. info Info Object REQUIRED. Provides metadata about the API. The metadata can be used by the clients if needed. servers Servers Object Provides connection details of servers. defaultContentType Default Content Type Default content type to use when encoding/decoding a message's payload. channels Channels Object The channels used by this application . operations Operations Object The operations this application MUST implement. components Components Object An element to hold various reusable objects for the specification. Everything that is defined inside this object represents a resource that MAY or MAY NOT be used in the rest of the document and MAY or MAY NOT be used by the implemented Application . This object MAY be extended with Specification Extensions . AsyncAPI Version String The version string signifies the version of the AsyncAPI Specification that the document complies to. The format for this string must be major . minor . patch . The patch may be suffixed by a hyphen and extra alphanumeric characters. A major . minor shall be used to designate the AsyncAPI Specification version, and will be considered compatible with the AsyncAPI Specification specified by that major . minor version. The patch version will not be considered by tooling, making no distinction between 1.0.0 and 1.0.1 . In subsequent versions of the AsyncAPI Specification, care will be given such that increments of the minor version should not interfere with operations of tooling developed to a lower minor version. Thus a hypothetical 1.1.0 specification should be usable with tooling designed for 1.0.0 . Identifier This field represents a unique universal identifier of the application the AsyncAPI document is defining. It must conform to the URI format, according to RFC3986 . It is RECOMMENDED to use a URN to globally and uniquely identify the application during long periods of time, even after it becomes unavailable or ceases to exist. Examples \n```javascript\n1{\n2  \"id\": \"urn:example:com:smartylighting:streetlights:server\"\n3}\n```\n \n```yaml\nid: 'urn:example:com:smartylighting:streetlights:server'\n```\n \n```javascript\n1{\n2  \"id\": \"https://github.com/smartylighting/streetlights-server\"\n3}\n```\n \n```yaml\nid: 'https://github.com/smartylighting/streetlights-server'\n```\n Info Object The object provides metadata about the API. The metadata can be used by the clients if needed. Fixed Fields Field Name Type Description title string REQUIRED. The title of the application. version string REQUIRED Provides the version of the application API (not to be confused with the specification version). description string A short description of the application. CommonMark syntax can be used for rich text representation. termsOfService string A URL to the Terms of Service for the API. This MUST be in the form of an absolute URL. contact Contact Object The contact information for the exposed API. license License Object The license information for the exposed API. tags Tags Object A list of tags for application API documentation control. Tags can be used for logical grouping of applications. externalDocs External Documentation Object | Reference Object Additional external documentation of the exposed API. This object MAY be extended with Specification Extensions . Info Object Example \n```javascript\n1{\n2  \"title\": \"AsyncAPI Sample App\",\n3  \"version\": \"1.0.1\",\n4  \"description\": \"This is a sample app.\",\n5  \"termsOfService\": \"https://asyncapi.org/terms/\",\n6  \"contact\": {\n7    \"name\": \"API Support\",\n8    \"url\": \"https://www.asyncapi.org/support\",\n9    \"email\": \"support@asyncapi.org\"\n10  },\n11  \"license\": {\n12    \"name\": \"Apache 2.0\",\n13    \"url\": \"https://www.apache.org/licenses/LICENSE-2.0.html\"\n14  },\n15  \"externalDocs\": {\n16    \"description\": \"Find more info here\",\n17    \"url\": \"https://www.asyncapi.org\"\n18  },\n19  \"tags\": [\n20    {\n21      \"name\": \"e-commerce\"\n22    }\n23  ]\n24}\n```\n \n```javascript\n1title: AsyncAPI Sample App\n2version: 1.0.1\n3description: This is a sample app.\n4termsOfService: https://asyncapi.org/terms/\n5contact:\n6  name: API Support\n7  url: https://www.asyncapi.org/support\n8  email: support@asyncapi.org\n9license:\n10  name: Apache 2.0\n11  url: https://www.apache.org/licenses/LICENSE-2.0.html\n12externalDocs:\n13  description: Find more info here\n14  url: https://www.asyncapi.org\n15tags:\n16  - name: e-commerce\n```\n Contact Object Contact information for the exposed API. Fixed Fields Field Name Type Description name string The identifying name of the contact person/organization. url string The URL pointing to the contact information. This MUST be in the form of an absolute URL. email string The email address of the contact person/organization. MUST be in the format of an email address. This object MAY be extended with Specification Extensions . Contact Object Example \n```javascript\n1{\n2  \"name\": \"API Support\",\n3  \"url\": \"https://www.example.com/support\",\n4  \"email\": \"support@example.com\"\n5}\n```\n \n```javascript\n1name: API Support\n2url: https://www.example.com/support\n3email: support@example.com\n```\n License Object License information for the exposed API. Fixed Fields Field Name Type Description name string REQUIRED. The license name used for the API. url string A URL to the license used for the API. This MUST be in the form of an absolute URL. This object MAY be extended with Specification Extensions . License Object Example \n```javascript\n1{\n2  \"name\": \"Apache 2.0\",\n3  \"url\": \"https://www.apache.org/licenses/LICENSE-2.0.html\"\n4}\n```\n \n```javascript\n1name: Apache 2.0\n2url: https://www.apache.org/licenses/LICENSE-2.0.html\n```\n Servers Object The Servers Object is a map of Server Objects . Patterned Fields Field Pattern Type Description ^[A-Za-z0-9_\\-]+$ Server Object | Reference Object The definition of a server this application MAY connect to. Servers Object Example \n```javascript\n1{\n2  \"development\": {\n3    \"host\": \"localhost:5672\",\n4    \"description\": \"Development AMQP broker.\",\n5    \"protocol\": \"amqp\",\n6    \"protocolVersion\": \"0-9-1\",\n7    \"tags\": [\n8      { \n9        \"name\": \"env:development\",\n10        \"description\": \"This environment is meant for developers to run their own tests.\"\n11      }\n12    ]\n13  },\n14  \"staging\": {\n15    \"host\": \"rabbitmq-staging.in.mycompany.com:5672\",\n16    \"description\": \"RabbitMQ broker for the staging environment.\",\n17    \"protocol\": \"amqp\",\n18    \"protocolVersion\": \"0-9-1\",\n19    \"tags\": [\n20      { \n21        \"name\": \"env:staging\",\n22        \"description\": \"This environment is a replica of the production environment.\"\n23      }\n24    ]\n25  },\n26  \"production\": {\n27    \"host\": \"rabbitmq.in.mycompany.com:5672\",\n28    \"description\": \"RabbitMQ broker for the production environment.\",\n29    \"protocol\": \"amqp\",\n30    \"protocolVersion\": \"0-9-1\",\n31    \"tags\": [\n32      { \n33        \"name\": \"env:production\",\n34        \"description\": \"This environment is the live environment available for final users.\"\n35      }\n36    ]\n37  }\n38}\n```\n \n```javascript\n1development:\n2  host: localhost:5672\n3  description: Development AMQP broker.\n4  protocol: amqp\n5  protocolVersion: 0-9-1\n6  tags:\n7    - name: \"env:development\"\n8      description: \"This environment is meant for developers to run their own tests.\"\n9staging:\n10  host: rabbitmq-staging.in.mycompany.com:5672\n11  description: RabbitMQ broker for the staging environment.\n12  protocol: amqp\n13  protocolVersion: 0-9-1\n14  tags:\n15    - name: \"env:staging\"\n16      description: \"This environment is a replica of the production environment.\"\n17production:\n18  host: rabbitmq.in.mycompany.com:5672\n19  description: RabbitMQ broker for the production environment.\n20  protocol: amqp\n21  protocolVersion: 0-9-1\n22  tags:\n23    - name: \"env:production\"\n24      description: \"This environment is the live environment available for final users.\"\n```\n Server Object An object representing a message broker, a server or any other kind of computer program capable of sending and/or receiving data. This object is used to capture details such as URIs, protocols and security configuration. Variable substitution can be used so that some details, for example usernames and passwords, can be injected by code generation tools. Fixed Fields Field Name Type Description host string REQUIRED . The server host name. It MAY include the port. This field supports Server Variables . Variable substitutions will be made when a variable is named in { braces } . protocol string REQUIRED . The protocol this server supports for connection. protocolVersion string The version of the protocol used for connection. For instance: AMQP 0.9.1 , HTTP 2.0 , Kafka 1.0.0 , etc. pathname string The path to a resource in the host. This field supports Server Variables . Variable substitutions will be made when a variable is named in { braces } . description string An optional string describing the server. CommonMark syntax MAY be used for rich text representation. title string A human-friendly title for the server. summary string A short summary of the server. variables Map[ string , Server Variable Object | Reference Object ]] A map between a variable name and its value. The value is used for substitution in the server's host and pathname template. security [ Security Scheme Object | Reference Object ] A declaration of which security schemes can be used with this server. The list of values includes alternative security scheme objects that can be used. Only one of the security scheme objects need to be satisfied to authorize a connection or operation. tags Tags Object A list of tags for logical grouping and categorization of servers. externalDocs External Documentation Object | Reference Object Additional external documentation for this server. bindings Server Bindings Object | Reference Object A map where the keys describe the name of the protocol and the values describe protocol-specific definitions for the server. Server Object Example A single server would be described as: \n```javascript\n1{\n2  \"host\": \"kafka.in.mycompany.com:9092\",\n3  \"description\": \"Production Kafka broker.\",\n4  \"protocol\": \"kafka\",\n5  \"protocolVersion\": \"3.2\"\n6}\n```\n \n```javascript\n1host: kafka.in.mycompany.com:9092\n2description: Production Kafka broker.\n3protocol: kafka\n4protocolVersion: '3.2'\n```\n An example of a server that has a pathname : \n```javascript\n1{\n2  \"host\": \"rabbitmq.in.mycompany.com:5672\",\n3  \"pathname\": \"/production\",\n4  \"protocol\": \"amqp\",\n5  \"description\": \"Production RabbitMQ broker (uses the `production` vhost).\"\n6}\n```\n \n```javascript\n1host: rabbitmq.in.mycompany.com:5672\n2pathname: /production\n3protocol: amqp\n4description: Production RabbitMQ broker (uses the `production` vhost).\n```\n Server Variable Object An object representing a Server Variable for server URL template substitution. Fixed Fields Field Name Type Description enum [ string ] An enumeration of string values to be used if the substitution options are from a limited set. default string The default value to use for substitution, and to send, if an alternate value is not supplied. description string An optional description for the server variable. CommonMark syntax MAY be used for rich text representation. examples [ string ] An array of examples of the server variable. This object MAY be extended with Specification Extensions . Server Variable Object Example \n```javascript\n1{\n2  \"host\": \"rabbitmq.in.mycompany.com:5672\",\n3  \"pathname\": \"/{env}\",\n4  \"protocol\": \"amqp\",\n5  \"description\": \"RabbitMQ broker. Use the `env` variable to point to either `production` or `staging`.\",\n6  \"variables\": {\n7    \"env\": {\n8      \"description\": \"Environment to connect to. It can be either `production` or `staging`.\",\n9      \"enum\": [\n10        \"production\",\n11        \"staging\"\n12      ]\n13    }\n14  }\n15}\n```\n \n```javascript\n1host: 'rabbitmq.in.mycompany.com:5672'\n2pathname: '/{env}'\n3protocol: amqp\n4description: RabbitMQ broker. Use the `env` variable to point to either `production` or `staging`.\n5variables:\n6  env:\n7    description: Environment to connect to. It can be either `production` or `staging`.\n8    enum:\n9      - production\n10      - staging\n```\n Default Content Type A string representing the default content type to use when encoding/decoding a message's payload. The value MUST be a specific media type (e.g. application/json ). This value MUST be used by schema parsers when the contentType property is omitted. In case a message can't be encoded/decoded using this value, schema parsers MUST use their default content type. Default Content Type Example \n```javascript\n1{\n2  \"defaultContentType\": \"application/json\"\n3}\n```\n defaultContentType: application/json Channels Object An object containing all the Channel Object definitions the Application MUST use during runtime. Patterned Fields Field Pattern Type Description {channelId} Channel Object | Reference Object An identifier for the described channel. The channelId value is case-sensitive . Tools and libraries MAY use the channelId to uniquely identify a channel, therefore, it is RECOMMENDED to follow common programming naming conventions. Channels Object Example \n```javascript\n1{\n2  \"userSignedUp\": {\n3    \"address\": \"user.signedup\",\n4    \"messages\": {\n5      \"userSignedUp\": {\n6        \"$ref\": \"#/components/messages/userSignedUp\"\n7      }\n8    }\n9  }\n10}\n```\n \n```javascript\n1userSignedUp:\n2  address: 'user.signedup'\n3  messages:\n4    userSignedUp:\n5      $ref: '#/components/messages/userSignedUp'\n```\n Channel Object Describes a shared communication channel. Fixed Fields Field Name Type Description address string | null An optional string representation of this channel's address. The address is typically the \"topic name\", \"routing key\", \"event type\", or \"path\". When null or absent, it MUST be interpreted as unknown. This is useful when the address is generated dynamically at runtime or can't be known upfront. It MAY contain Channel Address Expressions . Query parameters and fragments SHALL NOT be used, instead use bindings to define them. messages Messages Object A map of the messages that will be sent to this channel by any application at any time. Every message sent to this channel MUST be valid against one, and only one, of the message objects defined in this map. title string A human-friendly title for the channel. summary string A short summary of the channel. description string An optional description of this channel. CommonMark syntax can be used for rich text representation. servers [ Reference Object ] An array of $ref pointers to the definition of the servers in which this channel is available. If the channel is located in the root Channels Object , it MUST point to a subset of server definitions located in the root Servers Object , and MUST NOT point to a subset of server definitions located in the Components Object or anywhere else. If the channel is located in the Components Object , it MAY point to a Server Objects in any location. If servers is absent or empty, this channel MUST be available on all the servers defined in the Servers Object . Please note the servers property value MUST be an array of Reference Objects and, therefore, MUST NOT contain an array of Server Objects . However, it is RECOMMENDED that parsers (or other software) dereference this property for a better development experience. parameters Parameters Object A map of the parameters included in the channel address. It MUST be present only when the address contains Channel Address Expressions . tags Tags Object A list of tags for logical grouping of channels. externalDocs External Documentation Object | Reference Object Additional external documentation for this channel. bindings Channel Bindings Object | Reference Object A map where the keys describe the name of the protocol and the values describe protocol-specific definitions for the channel. This object MAY be extended with Specification Extensions . Channel Object Example \n```javascript\n1{\n2  \"address\": \"users.{userId}\",\n3  \"title\": \"Users channel\",\n4  \"description\": \"This channel is used to exchange messages about user events.\",\n5  \"messages\": {\n6    \"userSignedUp\": {\n7      \"$ref\": \"#/components/messages/userSignedUp\"\n8    },\n9    \"userCompletedOrder\": {\n10      \"$ref\": \"#/components/messages/userCompletedOrder\"\n11    }\n12  },\n13  \"parameters\": {\n14    \"userId\": {\n15      \"$ref\": \"#/components/parameters/userId\"\n16    }\n17  },\n18  \"servers\": [\n19    { \"$ref\": \"#/servers/rabbitmqInProd\" },\n20    { \"$ref\": \"#/servers/rabbitmqInStaging\" }\n21  ],\n22  \"bindings\": {\n23    \"amqp\": {\n24      \"is\": \"queue\",\n25      \"queue\": {\n26        \"exclusive\": true\n27      }\n28    }\n29  },\n30  \"tags\": [{\n31    \"name\": \"user\",\n32    \"description\": \"User-related messages\"\n33  }],\n34  \"externalDocs\": {\n35    \"description\": \"Find more info here\",\n36    \"url\": \"https://example.com\"\n37  }\n38}\n```\n \n```javascript\n1address: 'users.{userId}'\n2title: Users channel\n3description: This channel is used to exchange messages about user events.\n4messages:\n5  userSignedUp:\n6    $ref: '#/components/messages/userSignedUp'\n7  userCompletedOrder:\n8    $ref: '#/components/messages/userCompletedOrder'\n9parameters:\n10  userId:\n11    $ref: '#/components/parameters/userId'\n12servers:\n13  - $ref: '#/servers/rabbitmqInProd'\n14  - $ref: '#/servers/rabbitmqInStaging'\n15bindings:\n16  amqp:\n17    is: queue\n18    queue:\n19      exclusive: true\n20tags:\n21  - name: user\n22    description: User-related messages\n23externalDocs:\n24  description: 'Find more info here'\n25  url: 'https://example.com'\n```\n Channel Address Expressions Channel addresses MAY contain expressions that can be used to define dynamic values. Expressions MUST be composed by a name enclosed in curly braces ( { and } ). E.g., {userId} . Messages Object Describes a map of messages included in a channel. Patterned Fields Field Pattern Type Description {messageId} Message Object | Reference Object The key represents the message identifier. The messageId value is case-sensitive . Tools and libraries MAY use the messageId value to uniquely identify a message, therefore, it is RECOMMENDED to follow common programming naming conventions. Messages Object Example \n```javascript\n1{\n2  \"userSignedUp\": {\n3    \"$ref\": \"#/components/messages/userSignedUp\"\n4  },\n5  \"userCompletedOrder\": {\n6    \"$ref\": \"#/components/messages/userCompletedOrder\"\n7  }\n8}\n```\n \n```javascript\n1userSignedUp:\n2  $ref: '#/components/messages/userSignedUp'\n3userCompletedOrder:\n4  $ref: '#/components/messages/userCompletedOrder'\n```\n Operations Object Holds a dictionary with all the operations this application MUST implement. If you're looking for a place to define operations that MAY or MAY NOT be implemented by the application, consider defining them in components/operations . Patterned Fields Field Pattern Type Description {operationId} Operation Object | Reference Object The operation this application MUST implement. The field name ( operationId ) MUST be a string used to identify the operation in the document where it is defined, and its value is case-sensitive . Tools and libraries MAY use the operationId to uniquely identify an operation, therefore, it is RECOMMENDED to follow common programming naming conventions. Operations Object Example \n```javascript\n1{\n2  \"onUserSignUp\": {\n3    \"title\": \"User sign up\",\n4    \"summary\": \"Action to sign a user up.\",\n5    \"description\": \"A longer description\",\n6    \"channel\": {\n7      \"$ref\": \"#/channels/userSignup\"\n8    },\n9    \"action\": \"send\",\n10    \"tags\": [\n11      { \"name\": \"user\" },\n12      { \"name\": \"signup\" },\n13      { \"name\": \"register\" }\n14    ],\n15    \"bindings\": {\n16      \"amqp\": {\n17        \"ack\": false\n18      }\n19    },\n20    \"traits\": [\n21      { \"$ref\": \"#/components/operationTraits/kafka\" }\n22    ]\n23  }\n24}\n```\n \n```javascript\n1onUserSignUp:\n2  title: User sign up\n3  summary: Action to sign a user up.\n4  description: A longer description\n5  channel:\n6    $ref: '#/channels/userSignup'\n7  action: send\n8  tags:\n9    - name: user\n10    - name: signup\n11    - name: register\n12  bindings:\n13    amqp:\n14      ack: false\n15  traits:\n16    - $ref: '#/components/operationTraits/kafka'\n```\n Operation Object Describes a specific operation. Fixed Fields Field Name Type Description action \"send\" | \"receive\" Required . Use send when it's expected that the application will send a message to the given channel , and receive when the application should expect receiving messages from the given channel . channel Reference Object Required . A $ref pointer to the definition of the channel in which this operation is performed. If the operation is located in the root Operations Object , it MUST point to a channel definition located in the root Channels Object , and MUST NOT point to a channel definition located in the Components Object or anywhere else. If the operation is located in the Components Object , it MAY point to a Channel Object in any location. Please note the channel property value MUST be a Reference Object and, therefore, MUST NOT contain a Channel Object . However, it is RECOMMENDED that parsers (or other software) dereference this property for a better development experience. title string A human-friendly title for the operation. summary string A short summary of what the operation is about. description string A verbose explanation of the operation. CommonMark syntax can be used for rich text representation. security [ Security Scheme Object | Reference Object ] A declaration of which security schemes are associated with this operation. Only one of the security scheme objects MUST be satisfied to authorize an operation. In cases where Server Security also applies, it MUST also be satisfied. tags Tags Object A list of tags for logical grouping and categorization of operations. externalDocs External Documentation Object | Reference Object Additional external documentation for this operation. bindings Operation Bindings Object | Reference Object A map where the keys describe the name of the protocol and the values describe protocol-specific definitions for the operation. traits [ Operation Trait Object | Reference Object ] A list of traits to apply to the operation object. Traits MUST be merged using traits merge mechanism . The resulting object MUST be a valid Operation Object . messages [ Reference Object ] A list of $ref pointers pointing to the supported Message Objects that can be processed by this operation. It MUST contain a subset of the messages defined in the channel referenced in this operation , and MUST NOT point to a subset of message definitions located in the Messages Object in the Components Object or anywhere else. Every message processed by this operation MUST be valid against one, and only one, of the message objects referenced in this list. Please note the messages property value MUST be a list of Reference Objects and, therefore, MUST NOT contain Message Objects . However, it is RECOMMENDED that parsers (or other software) dereference this property for a better development experience. reply Operation Reply Object | Reference Object The definition of the reply in a request-reply operation. This object MAY be extended with Specification Extensions . Operation Object Example \n```javascript\n1{\n2  \"title\": \"User sign up\",\n3  \"summary\": \"Action to sign a user up.\",\n4  \"description\": \"A longer description\",\n5  \"channel\": {\n6    \"$ref\": \"#/channels/userSignup\"\n7  },\n8  \"action\": \"send\",\n9  \"security\": [\n10    {\n11     \"petstore_auth\": [\n12       \"write:pets\",\n13       \"read:pets\"\n14     ]\n15    }\n16  ],\n17  \"tags\": [\n18    { \"name\": \"user\" },\n19    { \"name\": \"signup\" },\n20    { \"name\": \"register\" }\n21  ],\n22  \"bindings\": {\n23    \"amqp\": {\n24      \"ack\": false\n25    }\n26  },\n27  \"traits\": [\n28    { \"$ref\": \"#/components/operationTraits/kafka\" }\n29  ],\n30  \"messages\": [\n31    { \"$ref\": \"/components/messages/userSignedUp\" }\n32  ],\n33  \"reply\": {\n34    \"address\": {\n35      \"location\": \"$message.header#/replyTo\"\n36    },\n37    \"channel\": {\n38      \"$ref\": \"#/channels/userSignupReply\"\n39    },\n40    \"messages\": [\n41      { \"$ref\": \"/components/messages/userSignedUpReply\" }\n42    ],\n43  }\n44}\n```\n \n```javascript\n1title: User sign up\n2summary: Action to sign a user up.\n3description: A longer description\n4channel:\n5  $ref: '#/channels/userSignup'\n6action: send\n7security:\n8  - petstore_auth:\n9    - write:pets\n10    - read:pets\n11tags:\n12  - name: user\n13  - name: signup\n14  - name: register\n15bindings:\n16  amqp:\n17    ack: false\n18traits:\n19  - $ref: \"#/components/operationTraits/kafka\"\n20messages:\n21  - $ref: '#/components/messages/userSignedUp'\n22reply:\n23  address:\n24    location: '$message.header#/replyTo'\n25  channel:\n26    $ref: '#/channels/userSignupReply'\n27  messages:\n28    - $ref: '#/components/messages/userSignedUpReply'\n```\n Operation Trait Object Describes a trait that MAY be applied to an Operation Object . This object MAY contain any property from the Operation Object , except the action , channel , messages and traits ones. If you're looking to apply traits to a message, see the Message Trait Object . Fixed Fields Field Name Type Description title string A human-friendly title for the operation. summary string A short summary of what the operation is about. description string A verbose explanation of the operation. CommonMark syntax can be used for rich text representation. security [ Security Scheme Object | Reference Object ] A declaration of which security schemes are associated with this operation. Only one of the security scheme objects MUST be satisfied to authorize an operation. In cases where Server Security also applies, it MUST also be satisfied. tags Tags Object A list of tags for logical grouping and categorization of operations. externalDocs External Documentation Object | Reference Object Additional external documentation for this operation. bindings Operation Bindings Object | Reference Object A map where the keys describe the name of the protocol and the values describe protocol-specific definitions for the operation. This object MAY be extended with Specification Extensions . Operation Trait Object Example \n```javascript\n1{\n2  \"bindings\": {\n3    \"amqp\": {\n4      \"ack\": false\n5    }\n6  }\n7}\n```\n \n```javascript\n1bindings:\n2  amqp:\n3    ack: false\n```\n Operation Reply Object Describes the reply part that MAY be applied to an Operation Object. If an operation implements the request/reply pattern, the reply object represents the response message. Fixed Fields Field Name Type Description address Operation Reply Address Object | Reference Object Definition of the address that implementations MUST use for the reply. channel Reference Object A $ref pointer to the definition of the channel in which this operation is performed. When address is specified, the address property of the channel referenced by this property MUST be either null or not defined. If the operation reply is located inside a root Operation Object , it MUST point to a channel definition located in the root Channels Object , and MUST NOT point to a channel definition located in the Components Object or anywhere else. If the operation reply is located inside an [Operation Object] in the Components Object or in the Replies Object in the Components Object , it MAY point to a Channel Object in any location. Please note the channel property value MUST be a Reference Object and, therefore, MUST NOT contain a Channel Object . However, it is RECOMMENDED that parsers (or other software) dereference this property for a better development experience. messages [ Reference Object ] A list of $ref pointers pointing to the supported Message Objects that can be processed by this operation as reply. It MUST contain a subset of the messages defined in the channel referenced in this operation reply , and MUST NOT point to a subset of message definitions located in the Components Object or anywhere else. Every message processed by this operation MUST be valid against one, and only one, of the message objects referenced in this list. Please note the messages property value MUST be a list of Reference Objects and, therefore, MUST NOT contain Message Objects . However, it is RECOMMENDED that parsers (or other software) dereference this property for a better development experience. This object MAY be extended with Specification Extensions . Operation Reply Address Object An object that specifies where an operation has to send the reply. For specifying and computing the location of a reply address, a runtime expression is used. Fixed Fields Field Name Type Description description string An optional description of the address. CommonMark syntax can be used for rich text representation. location string REQUIRED. A runtime expression that specifies the location of the reply address. This object MAY be extended with Specification Extensions . Examples \n```javascript\n1{\n2  \"description\": \"Consumer inbox\",\n3  \"location\": \"$message.header#/replyTo\"\n4}\n```\n \n```javascript\n1description: Consumer Inbox\n2location: $message.header#/replyTo\n```\n Parameters Object Describes a map of parameters included in a channel address. This map MUST contain all the parameters used in the parent channel address. Patterned Fields Field Pattern Type Description ^[A-Za-z0-9_\\-]+$ Parameter Object | Reference Object The key represents the name of the parameter. It MUST match the parameter name used in the parent channel address. Parameters Object Example \n```javascript\n1{\n2  \"address\": \"user/{userId}/signedup\",\n3  \"parameters\": {\n4    \"userId\": {\n5      \"description\": \"Id of the user.\"\n6    }\n7  }\n8}\n```\n \n```javascript\n1address: user/{userId}/signedup\n2parameters:\n3  userId:\n4    description: Id of the user.\n```\n Parameter Object Describes a parameter included in a channel address. Fixed Fields Field Name Type Description enum [ string ] An enumeration of string values to be used if the substitution options are from a limited set. default string The default value to use for substitution, and to send, if an alternate value is not supplied. description string An optional description for the parameter. CommonMark syntax MAY be used for rich text representation. examples [ string ] An array of examples of the parameter value. location string A runtime expression that specifies the location of the parameter value. This object MAY be extended with Specification Extensions . Parameter Object Example \n```javascript\n1{\n2  \"address\": \"user/{userId}/signedup\",\n3  \"parameters\": {\n4    \"userId\": {\n5      \"description\": \"Id of the user.\",\n6      \"location\": \"$message.payload#/user/id\"\n7    }\n8  }\n9}\n```\n \n```javascript\n1address: user/{userId}/signedup\n2parameters:\n3  userId:\n4    description: Id of the user.\n5    location: $message.payload#/user/id\n```\n Server Bindings Object Map describing protocol-specific definitions for a server. Fixed Fields Field Name Type Description http HTTP Server Binding Protocol-specific information for an HTTP server. ws WebSockets Server Binding Protocol-specific information for a WebSockets server. kafka Kafka Server Binding Protocol-specific information for a Kafka server. anypointmq Anypoint MQ Server Binding Protocol-specific information for an Anypoint MQ server. amqp AMQP Server Binding Protocol-specific information for an AMQP 0-9-1 server. amqp1 AMQP 1.0 Server Binding Protocol-specific information for an AMQP 1.0 server. mqtt MQTT Server Binding Protocol-specific information for an MQTT server. mqtt5 MQTT 5 Server Binding Protocol-specific information for an MQTT 5 server. nats NATS Server Binding Protocol-specific information for a NATS server. jms JMS Server Binding Protocol-specific information for a JMS server. sns SNS Server Binding Protocol-specific information for an SNS server. solace Solace Server Binding Protocol-specific information for a Solace server. sqs SQS Server Binding Protocol-specific information for an SQS server. stomp STOMP Server Binding Protocol-specific information for a STOMP server. redis Redis Server Binding Protocol-specific information for a Redis server. mercure Mercure Server Binding Protocol-specific information for a Mercure server. ibmmq IBM MQ Server Binding Protocol-specific information for an IBM MQ server. googlepubsub Google Cloud Pub/Sub Server Binding Protocol-specific information for a Google Cloud Pub/Sub server. pulsar Pulsar Server Binding Protocol-specific information for a Pulsar server. This object MAY be extended with Specification Extensions . Channel Bindings Object Map describing protocol-specific definitions for a channel. Fixed Fields Field Name Type Description http HTTP Channel Binding Protocol-specific information for an HTTP channel. ws WebSockets Channel Binding Protocol-specific information for a WebSockets channel. kafka Kafka Channel Binding Protocol-specific information for a Kafka channel. anypointmq Anypoint MQ Channel Binding Protocol-specific information for an Anypoint MQ channel. amqp AMQP Channel Binding Protocol-specific information for an AMQP 0-9-1 channel. amqp1 AMQP 1.0 Channel Binding Protocol-specific information for an AMQP 1.0 channel. mqtt MQTT Channel Binding Protocol-specific information for an MQTT channel. mqtt5 MQTT 5 Channel Binding Protocol-specific information for an MQTT 5 channel. nats NATS Channel Binding Protocol-specific information for a NATS channel. jms JMS Channel Binding Protocol-specific information for a JMS channel. sns SNS Channel Binding Protocol-specific information for an SNS channel. solace Solace Channel Binding Protocol-specific information for a Solace channel. sqs SQS Channel Binding Protocol-specific information for an SQS channel. stomp STOMP Channel Binding Protocol-specific information for a STOMP channel. redis Redis Channel Binding Protocol-specific information for a Redis channel. mercure Mercure Channel Binding Protocol-specific information for a Mercure channel. ibmmq IBM MQ Channel Binding Protocol-specific information for an IBM MQ channel. googlepubsub Google Cloud Pub/Sub Channel Binding Protocol-specific information for a Google Cloud Pub/Sub channel. pulsar Pulsar Channel Binding Protocol-specific information for a Pulsar channel. This object MAY be extended with Specification Extensions . Operation Bindings Object Map describing protocol-specific definitions for an operation. Fixed Fields Field Name Type Description http HTTP Operation Binding Protocol-specific information for an HTTP operation. ws WebSockets Operation Binding Protocol-specific information for a WebSockets operation. kafka Kafka Operation Binding Protocol-specific information for a Kafka operation. anypointmq Anypoint MQ Operation Binding Protocol-specific information for an Anypoint MQ operation. amqp AMQP Operation Binding Protocol-specific information for an AMQP 0-9-1 operation. amqp1 AMQP 1.0 Operation Binding Protocol-specific information for an AMQP 1.0 operation. mqtt MQTT Operation Binding Protocol-specific information for an MQTT operation. mqtt5 MQTT 5 Operation Binding Protocol-specific information for an MQTT 5 operation. nats NATS Operation Binding Protocol-specific information for a NATS operation. jms JMS Operation Binding Protocol-specific information for a JMS operation. sns SNS Operation Binding Protocol-specific information for an SNS operation. solace Solace Operation Binding Protocol-specific information for a Solace operation. sqs SQS Operation Binding Protocol-specific information for an SQS operation. stomp STOMP Operation Binding Protocol-specific information for a STOMP operation. redis Redis Operation Binding Protocol-specific information for a Redis operation. mercure Mercure Operation Binding Protocol-specific information for a Mercure operation. googlepubsub Google Cloud Pub/Sub Operation Binding Protocol-specific information for a Google Cloud Pub/Sub operation. ibmmq IBM MQ Operation Binding Protocol-specific information for an IBM MQ operation. pulsar Pulsar Operation Binding Protocol-specific information for a Pulsar operation. This object MAY be extended with Specification Extensions . Message Bindings Object Map describing protocol-specific definitions for a message. Fixed Fields Field Name Type Description http HTTP Message Binding Protocol-specific information for an HTTP message, i.e., a request or a response. ws WebSockets Message Binding Protocol-specific information for a WebSockets message. kafka Kafka Message Binding Protocol-specific information for a Kafka message. anypointmq Anypoint MQ Message Binding Protocol-specific information for an Anypoint MQ message. amqp AMQP Message Binding Protocol-specific information for an AMQP 0-9-1 message. amqp1 AMQP 1.0 Message Binding Protocol-specific information for an AMQP 1.0 message. mqtt MQTT Message Binding Protocol-specific information for an MQTT message. mqtt5 MQTT 5 Message Binding Protocol-specific information for an MQTT 5 message. nats NATS Message Binding Protocol-specific information for a NATS message. jms JMS Message Binding Protocol-specific information for a JMS message. sns SNS Message Binding Protocol-specific information for an SNS message. solace Solace Server Binding Protocol-specific information for a Solace message. sqs SQS Message Binding Protocol-specific information for an SQS message. stomp STOMP Message Binding Protocol-specific information for a STOMP message. redis Redis Message Binding Protocol-specific information for a Redis message. mercure Mercure Message Binding Protocol-specific information for a Mercure message. ibmmq IBM MQ Message Binding Protocol-specific information for an IBM MQ message. googlepubsub Google Cloud Pub/Sub Message Binding Protocol-specific information for a Google Cloud Pub/Sub message. pulsar Pulsar Message Binding Protocol-specific information for a Pulsar message. This object MAY be extended with Specification Extensions . Message Object Describes a message received on a given channel and operation. Fixed Fields Field Name Type Description headers Multi Format Schema Object | Schema Object | Reference Object Schema definition of the application headers. Schema MUST be a map of key-value pairs. It MUST NOT define the protocol headers. If this is a Schema Object , then the schemaFormat will be assumed to be \"application/vnd.aai.asyncapi+json;version= asyncapi \" where the version is equal to the AsyncAPI Version String . payload Multi Format Schema Object | Schema Object | Reference Object Definition of the message payload. If this is a Schema Object , then the schemaFormat will be assumed to be \"application/vnd.aai.asyncapi+json;version= asyncapi \" where the version is equal to the AsyncAPI Version String . correlationId Correlation ID Object | Reference Object Definition of the correlation ID used for message tracing or matching. contentType string The content type to use when encoding/decoding a message's payload. The value MUST be a specific media type (e.g. application/json ). When omitted, the value MUST be the one specified on the defaultContentType field. name string A machine-friendly name for the message. title string A human-friendly title for the message. summary string A short summary of what the message is about. description string A verbose explanation of the message. CommonMark syntax can be used for rich text representation. tags Tags Object A list of tags for logical grouping and categorization of messages. externalDocs External Documentation Object | Reference Object Additional external documentation for this message. bindings Message Bindings Object | Reference Object A map where the keys describe the name of the protocol and the values describe protocol-specific definitions for the message. examples [ Message Example Object ] List of examples. traits [ Message Trait Object | Reference Object ] A list of traits to apply to the message object. Traits MUST be merged using traits merge mechanism . The resulting object MUST be a valid Message Object . This object MAY be extended with Specification Extensions . Message Object Example \n```javascript\n1{\n2  \"name\": \"UserSignup\",\n3  \"title\": \"User signup\",\n4  \"summary\": \"Action to sign a user up.\",\n5  \"description\": \"A longer description\",\n6  \"contentType\": \"application/json\",\n7  \"tags\": [\n8    { \"name\": \"user\" },\n9    { \"name\": \"signup\" },\n10    { \"name\": \"register\" }\n11  ],\n12  \"headers\": {\n13    \"type\": \"object\",\n14    \"properties\": {\n15      \"correlationId\": {\n16        \"description\": \"Correlation ID set by application\",\n17        \"type\": \"string\"\n18      },\n19      \"applicationInstanceId\": {\n20        \"description\": \"Unique identifier for a given instance of the publishing application\",\n21        \"type\": \"string\"\n22      }\n23    }\n24  },\n25  \"payload\": {\n26    \"type\": \"object\",\n27    \"properties\": {\n28      \"user\": {\n29        \"$ref\": \"#/components/schemas/userCreate\"\n30      },\n31      \"signup\": {\n32        \"$ref\": \"#/components/schemas/signup\"\n33      }\n34    }\n35  },\n36  \"correlationId\": {\n37    \"description\": \"Default Correlation ID\",\n38    \"location\": \"$message.header#/correlationId\"\n39  },\n40  \"traits\": [\n41    { \"$ref\": \"#/components/messageTraits/commonHeaders\" }\n42  ],\n43  \"examples\": [\n44    {\n45      \"name\": \"SimpleSignup\",\n46      \"summary\": \"A simple UserSignup example message\",\n47      \"headers\": {\n48        \"correlationId\": \"my-correlation-id\",\n49        \"applicationInstanceId\": \"myInstanceId\"\n50      },\n51      \"payload\": {\n52        \"user\": {\n53          \"someUserKey\": \"someUserValue\"\n54        },\n55        \"signup\": {\n56          \"someSignupKey\": \"someSignupValue\"\n57        }\n58      }\n59    }\n60  ]\n61}\n```\n \n```javascript\n1name: UserSignup\n2title: User signup\n3summary: Action to sign a user up.\n4description: A longer description\n5contentType: application/json\n6tags:\n7  - name: user\n8  - name: signup\n9  - name: register\n10headers:\n11  type: object\n12  properties:\n13    correlationId:\n14      description: Correlation ID set by application\n15      type: string\n16    applicationInstanceId:\n17      description: Unique identifier for a given instance of the publishing application\n18      type: string\n19payload:\n20  type: object\n21  properties:\n22    user:\n23      $ref: \"#/components/schemas/userCreate\"\n24    signup:\n25      $ref: \"#/components/schemas/signup\"\n26correlationId:\n27  description: Default Correlation ID\n28  location: $message.header#/correlationId\n29traits:\n30  - $ref: \"#/components/messageTraits/commonHeaders\"\n31examples:\n32  - name: SimpleSignup\n33    summary: A simple UserSignup example message\n34    headers:\n35      correlationId: my-correlation-id\n36      applicationInstanceId: myInstanceId\n37    payload:\n38      user:\n39        someUserKey: someUserValue\n40      signup:\n41        someSignupKey: someSignupValue\n```\n Example using Avro to define the payload: \n```javascript\n1{\n2  \"name\": \"UserSignup\",\n3  \"title\": \"User signup\",\n4  \"summary\": \"Action to sign a user up.\",\n5  \"description\": \"A longer description\",\n6  \"tags\": [\n7    { \"name\": \"user\" },\n8    { \"name\": \"signup\" },\n9    { \"name\": \"register\" }\n10  ],\n11  \"payload\": {\n12    \"schemaFormat\": \"application/vnd.apache.avro+json;version=1.9.0\",\n13    \"schema\": {\n14      \"$ref\": \"path/to/user-create.avsc#/UserCreate\"\n15    }\n16  }\n17}\n```\n \n```javascript\n1name: UserSignup\n2title: User signup\n3summary: Action to sign a user up.\n4description: A longer description\n5tags:\n6  - name: user\n7  - name: signup\n8  - name: register\n9payload:\n10  schemaFormat: 'application/vnd.apache.avro+yaml;version=1.9.0'\n11  schema:\n12    $ref: 'path/to/user-create.avsc/#UserCreate'\n```\n Message Trait Object Describes a trait that MAY be applied to a Message Object . This object MAY contain any property from the Message Object , except payload and traits . If you're looking to apply traits to an operation, see the Operation Trait Object . Fixed Fields Field Name Type Description headers Multi Format Schema Object | Schema Object | Reference Object Schema definition of the application headers. Schema MUST be a map of key-value pairs. It MUST NOT define the protocol headers. If this is a Schema Object , then the schemaFormat will be assumed to be \"application/vnd.aai.asyncapi+json;version= asyncapi \" where the version is equal to the AsyncAPI Version String . correlationId Correlation ID Object | Reference Object Definition of the correlation ID used for message tracing or matching. contentType string The content type to use when encoding/decoding a message's payload. The value MUST be a specific media type (e.g. application/json ). When omitted, the value MUST be the one specified on the defaultContentType field. name string A machine-friendly name for the message. title string A human-friendly title for the message. summary string A short summary of what the message is about. description string A verbose explanation of the message. CommonMark syntax can be used for rich text representation. tags Tags Object A list of tags for logical grouping and categorization of messages. externalDocs External Documentation Object | Reference Object Additional external documentation for this message. bindings Message Bindings Object | Reference Object A map where the keys describe the name of the protocol and the values describe protocol-specific definitions for the message. examples [ Message Example Object ] List of examples. This object MAY be extended with Specification Extensions . Message Trait Object Example \n```javascript\n1{\n2  \"contentType\": \"application/json\"\n3}\n```\n contentType: application/json Message Example Object Message Example Object represents an example of a Message Object and MUST contain either headers and/or payload fields. Fixed Fields Field Name Type Description headers Map[string, any] The value of this field MUST validate against the Message Object's headers field. payload Map[string, any] The value of this field MUST validate against the Message Object's payload field. name string A machine-friendly name. summary string A short summary of what the example is about. This object MAY be extended with Specification Extensions . Message Example Object Example \n```javascript\n1{\n2  \"name\": \"SimpleSignup\",\n3  \"summary\": \"A simple UserSignup example message\",\n4  \"headers\": {\n5    \"correlationId\": \"my-correlation-id\",\n6    \"applicationInstanceId\": \"myInstanceId\"\n7  },\n8  \"payload\": {\n9    \"user\": {\n10      \"someUserKey\": \"someUserValue\"\n11    },\n12    \"signup\": {\n13      \"someSignupKey\": \"someSignupValue\"\n14    }\n15  }\n16}\n```\n \n```javascript\n1name: SimpleSignup\n2summary: A simple UserSignup example message\n3headers:\n4  correlationId: my-correlation-id\n5  applicationInstanceId: myInstanceId\n6payload:\n7  user:\n8    someUserKey: someUserValue\n9  signup:\n10    someSignupKey: someSignupValue\n```\n Tags Object A Tags object is a list of Tag Objects . An Tag Object in a list can be referenced by Reference Object . Tag Object Allows adding meta data to a single tag. Fixed Fields Field Name Type Description name string REQUIRED. The name of the tag. description string A short description for the tag. CommonMark syntax can be used for rich text representation. externalDocs External Documentation Object | Reference Object Additional external documentation for this tag. This object MAY be extended with Specification Extensions . Tag Object Example \n```javascript\n1{\n2 \"name\": \"user\",\n3 \"description\": \"User-related messages\"\n4}\n```\n \n```javascript\n1name: user\n2description: User-related messages\n```\n External Documentation Object Allows referencing an external resource for extended documentation. Fixed Fields Field Name Type Description description string A short description of the target documentation. CommonMark syntax can be used for rich text representation. url string REQUIRED. The URL for the target documentation. This MUST be in the form of an absolute URL. This object MAY be extended with Specification Extensions . External Documentation Object Example \n```javascript\n1{\n2  \"description\": \"Find more info here\",\n3  \"url\": \"https://example.com\"\n4}\n```\n \n```javascript\n1description: Find more info here\n2url: https://example.com\n```\n Reference Object A simple object to allow referencing other components in the specification, internally and externally. The Reference Object is defined by JSON Reference and follows the same structure, behavior and rules. A JSON Reference SHALL only be used to refer to a schema that is formatted in either JSON or YAML. In the case of a YAML-formatted Schema, the JSON Reference SHALL be applied to the JSON representation of that schema. The JSON representation SHALL be made by applying the conversion described here . For this specification, reference resolution is done as defined by the JSON Reference specification and not by the JSON Schema specification. Fixed Fields Field Name Type Description $ref string REQUIRED. The reference string. This object cannot be extended with additional properties and any properties added SHALL be ignored. Reference Object Example \n```javascript\n1{\n2  \"$ref\": \"#/components/schemas/Pet\"\n3}\n```\n $ref: '#/components/schemas/Pet' Components Object Holds a set of reusable objects for different aspects of the AsyncAPI specification. All objects defined within the components object will have no effect on the API unless they are explicitly referenced from properties outside the components object. Fixed Fields Field Name Type Description schemas Map[ string , Multi Format Schema Object | Schema Object | Reference Object ] An object to hold reusable Schema Object . If this is a Schema Object , then the schemaFormat will be assumed to be \"application/vnd.aai.asyncapi+json;version= asyncapi \" where the version is equal to the AsyncAPI Version String . servers Map[ string , Server Object | Reference Object ] An object to hold reusable Server Objects . channels Map[ string , Channel Object | Reference Object ] An object to hold reusable Channel Objects . operations Map[ string , Operation Object | Reference Object ] An object to hold reusable Operation Objects . messages Map[ string , Message Object | Reference Object ] An object to hold reusable Message Objects . securitySchemes Map[ string , Security Scheme Object | Reference Object ] An object to hold reusable Security Scheme Objects . serverVariables Map[ string , Server Variable Object | Reference Object ] An object to hold reusable Server Variable Objects . parameters Map[ string , Parameter Object | Reference Object ] An object to hold reusable Parameter Objects . correlationIds Map[ string , Correlation ID Object | Reference Object ] An object to hold reusable Correlation ID Objects . replies Map[ string , Operation Reply Object | Reference Object ] An object to hold reusable Operation Reply Objects . replyAddresses Map[ string , Operation Reply Address Object | Reference Object ] An object to hold reusable Operation Reply Address Objects . externalDocs Map[ string , External Documentation Object | Reference Object ] An object to hold reusable External Documentation Objects . tags Map[ string , Tag Object | Reference Object ] An object to hold reusable Tag Objects . operationTraits Map[ string , Operation Trait Object | Reference Object ] An object to hold reusable Operation Trait Objects . messageTraits Map[ string , Message Trait Object | Reference Object ] An object to hold reusable Message Trait Objects . serverBindings Map[ string , Server Bindings Object | Reference Object ] An object to hold reusable Server Bindings Objects . channelBindings Map[ string , Channel Bindings Object | Reference Object ] An object to hold reusable Channel Bindings Objects . operationBindings Map[ string , Operation Bindings Object | Reference Object ] An object to hold reusable Operation Bindings Objects . messageBindings Map[ string , Message Bindings Object | Reference Object ] An object to hold reusable Message Bindings Objects . This object MAY be extended with Specification Extensions . All the fixed fields declared above are objects that MUST use keys that match the regular expression: ^[a-zA-Z0-9\\.\\-_]+$ . Field Name Examples: \n```javascript\n1User\n2User_1\n3User_Name\n4user-name\n5my.org.User\n```\n Components Object Example \n```javascript\n1{\n2  \"components\": {\n3    \"schemas\": {\n4      \"Category\": {\n5        \"type\": \"object\",\n6        \"properties\": {\n7          \"id\": {\n8            \"type\": \"integer\",\n9            \"format\": \"int64\"\n10          },\n11          \"name\": {\n12            \"type\": \"string\"\n13          }\n14        }\n15      },\n16      \"Tag\": {\n17        \"type\": \"object\",\n18        \"properties\": {\n19          \"id\": {\n20            \"type\": \"integer\",\n21            \"format\": \"int64\"\n22          },\n23          \"name\": {\n24            \"type\": \"string\"\n25          }\n26        }\n27      },\n28      \"AvroExample\": {\n29        \"schemaFormat\": \"application/vnd.apache.avro+json;version=1.9.0\",\n30        \"schema\": {\n31          \"$ref\": \"path/to/user-create.avsc#/UserCreate\"\n32        }\n33      }\n34    },\n35    \"servers\": {\n36      \"development\": {\n37        \"host\": \"{stage}.in.mycompany.com:{port}\",\n38        \"description\": \"RabbitMQ broker\",\n39        \"protocol\": \"amqp\",\n40        \"protocolVersion\": \"0-9-1\",\n41        \"variables\": {\n42          \"stage\": {\n43            \"$ref\": \"#/components/serverVariables/stage\"\n44          },\n45          \"port\": {\n46            \"$ref\": \"#/components/serverVariables/port\"\n47          }\n48        }\n49      }\n50    },\n51    \"serverVariables\": {\n52      \"stage\": {\n53        \"default\": \"demo\",\n54        \"description\": \"This value is assigned by the service provider, in this example `mycompany.com`\"\n55      },\n56      \"port\": {\n57        \"enum\": [\"5671\", \"5672\"],\n58        \"default\": \"5672\"\n59      }\n60    },\n61    \"channels\": {\n62      \"user/signedup\": {\n63        \"subscribe\": {\n64          \"message\": {\n65            \"$ref\": \"#/components/messages/userSignUp\"\n66          }\n67        }\n68      }\n69    },\n70    \"messages\": {\n71      \"userSignUp\": {\n72        \"summary\": \"Action to sign a user up.\",\n73        \"description\": \"Multiline description of what this action does.\\nHere you have another line.\\n\",\n74        \"tags\": [\n75          {\n76            \"name\": \"user\"\n77          },\n78          {\n79            \"name\": \"signup\"\n80          }\n81        ],\n82        \"headers\": {\n83          \"type\": \"object\",\n84          \"properties\": {\n85            \"applicationInstanceId\": {\n86              \"description\": \"Unique identifier for a given instance of the publishing application\",\n87              \"type\": \"string\"\n88            }\n89          }\n90        },\n91        \"payload\": {\n92          \"type\": \"object\",\n93          \"properties\": {\n94            \"user\": {\n95              \"$ref\": \"#/components/schemas/userCreate\"\n96            },\n97            \"signup\": {\n98              \"$ref\": \"#/components/schemas/signup\"\n99            }\n100          }\n101        }\n102      }\n103    },\n104    \"parameters\": {\n105      \"userId\": {\n106        \"description\": \"Id of the user.\"\n107      }\n108    },\n109    \"correlationIds\": {\n110      \"default\": {\n111        \"description\": \"Default Correlation ID\",\n112        \"location\": \"$message.header#/correlationId\"\n113      }\n114    },\n115    \"messageTraits\": {\n116      \"commonHeaders\": {\n117        \"headers\": {\n118          \"type\": \"object\",\n119          \"properties\": {\n120            \"my-app-header\": {\n121              \"type\": \"integer\",\n122              \"minimum\": 0,\n123              \"maximum\": 100\n124            }\n125          }\n126        }\n127      }\n128    }\n129  }\n130}\n```\n \n```javascript\n1components:\n2  schemas:\n3    Category:\n4      type: object\n5      properties:\n6        id:\n7          type: integer\n8          format: int64\n9        name:\n10          type: string\n11    Tag:\n12      type: object\n13      properties:\n14        id:\n15          type: integer\n16          format: int64\n17        name:\n18          type: string\n19    AvroExample:\n20      schemaFormat: application/vnd.apache.avro+json;version=1.9.0\n21      schema:\n22        $ref: 'path/to/user-create.avsc/#UserCreate'\n23  servers:\n24    development:\n25      host: \"{stage}.in.mycompany.com:{port}\"\n26      description: RabbitMQ broker\n27      protocol: amqp\n28      protocolVersion: 0-9-1\n29      variables:\n30        stage:\n31          $ref: \"#/components/serverVariables/stage\"\n32        port:\n33          $ref: \"#/components/serverVariables/port\"\n34  serverVariables:\n35    stage:\n36      default: demo\n37      description: This value is assigned by the service provider, in this example `mycompany.com`\n38    port:\n39      enum: [\"5671\", \"5672\"]\n40      default: \"5672\"\n41  channels:\n42    user/signedup:\n43      subscribe:\n44        message:\n45          $ref: \"#/components/messages/userSignUp\"\n46  messages:\n47    userSignUp:\n48      summary: Action to sign a user up.\n49      description: |\n50        Multiline description of what this action does.\n51        Here you have another line.\n52      tags:\n53        - name: user\n54        - name: signup\n55      headers:\n56        type: object\n57        properties:\n58          applicationInstanceId:\n59            description: Unique identifier for a given instance of the publishing application\n60            type: string\n61      payload:\n62        type: object\n63        properties:\n64          user:\n65            $ref: \"#/components/schemas/userCreate\"\n66          signup:\n67            $ref: \"#/components/schemas/signup\"\n68  parameters:\n69    userId:\n70      description: Id of the user.\n71  correlationIds:\n72    default:\n73      description: Default Correlation ID\n74      location: $message.header#/correlationId\n75  messageTraits:\n76    commonHeaders:\n77      headers:\n78        type: object\n79        properties:\n80          my-app-header:\n81            type: integer\n82            minimum: 0\n83            maximum: 100\n```\n Multi Format Schema Object The Multi Format Schema Object represents a schema definition. It differs from the Schema Object in that it supports multiple schema formats or languages (e.g., JSON Schema, Avro, etc.). Fixed Fields Field Name Type Description schemaFormat string Required . A string containing the name of the schema format that is used to define the information. If schemaFormat is missing, it MUST default to application/vnd.aai.asyncapi+json;version={{asyncapi}} where {{asyncapi}} matches the AsyncAPI Version String . In such a case, this would make the Multi Format Schema Object equivalent to the Schema Object . When using Reference Object within the schema, the schemaFormat of the resource being referenced MUST match the schemaFormat of the schema that contains the initial reference. For example, if you reference Avro schema , then schemaFormat of referencing resource and the resource being reference MUST match. Check out the supported schema formats table for more information. Custom values are allowed but their implementation is OPTIONAL. A custom value MUST NOT refer to one of the schema formats listed in the table . When using Reference Objects within the schema, the schemaFormat of the referenced resource MUST match the schemaFormat of the schema containing the reference. schema any Required . Definition of the message payload. It can be of any type but defaults to Schema Object . It MUST match the schema format defined in schemaFormat , including the encoding type. E.g., Avro should be inlined as either a YAML or JSON object instead of as a string to be parsed as YAML or JSON. Non-JSON-based schemas (e.g., Protobuf or XSD) MUST be inlined as a string. This object MAY be extended with Specification Extensions . Schema formats table The following table contains a set of values that every implementation MUST support. Name Allowed values Notes AsyncAPI 3.0.0 Schema Object application/vnd.aai.asyncapi;version=3.0.0 , application/vnd.aai.asyncapi+json;version=3.0.0 , application/vnd.aai.asyncapi+yaml;version=3.0.0 This is the default when a schemaFormat is not provided. JSON Schema Draft 07 application/schema+json;version=draft-07 , application/schema+yaml;version=draft-07 The following table contains a set of values that every implementation is RECOMMENDED to support. Name Allowed values Notes Avro 1.9.0 schema application/vnd.apache.avro;version=1.9.0 , application/vnd.apache.avro+json;version=1.9.0 , application/vnd.apache.avro+yaml;version=1.9.0 OpenAPI 3.0.0 Schema Object application/vnd.oai.openapi;version=3.0.0 , application/vnd.oai.openapi+json;version=3.0.0 , application/vnd.oai.openapi+yaml;version=3.0.0 RAML 1.0 data type application/raml+yaml;version=1.0 Protocol Buffers application/vnd.google.protobuf;version=2 , application/vnd.google.protobuf;version=3 Multi Format Schema Object Examples Multi Format Schema Object Example with Avro \n```javascript\n1channels:\n2  example:\n3    messages:\n4      myMessage:\n5        payload:\n6          schemaFormat: 'application/vnd.apache.avro;version=1.9.0'\n7          schema:\n8            type: record\n9            name: User\n10            namespace: com.company\n11            doc: User information\n12            fields:\n13              - name: displayName\n14                type: string\n15              - name: age\n16                type: int\n```\n Schema Object The Schema Object allows the definition of input and output data types. These types can be objects, but also primitives and arrays. This object is a superset of the JSON Schema Specification Draft 07 . The empty schema (which allows any instance to validate) MAY be represented by the boolean value true and a schema which allows no instance to validate MAY be represented by the boolean value false . Further information about the properties can be found in JSON Schema Core and JSON Schema Validation . Unless stated otherwise, the property definitions follow the JSON Schema specification as referenced here. For other formats (e.g., Avro, RAML, etc) see Multi Format Schema Object . Properties The AsyncAPI Schema Object is a JSON Schema vocabulary which extends JSON Schema Core and Validation vocabularies. As such, any keyword available for those vocabularies is by definition available in AsyncAPI, and will work the exact same way, including but not limited to: title type required multipleOf maximum exclusiveMaximum minimum exclusiveMinimum maxLength minLength pattern (This string SHOULD be a valid regular expression, according to the ECMA 262 regular expression dialect) maxItems minItems uniqueItems maxProperties minProperties enum const examples if / then / else readOnly writeOnly properties patternProperties additionalProperties additionalItems items propertyNames contains allOf oneOf anyOf not The following properties are taken from the JSON Schema definition but their definitions were adjusted to the AsyncAPI Specification. description - CommonMark syntax can be used for rich text representation. format - See Data Type Formats for further details. While relying on JSON Schema's defined formats, the AsyncAPI Specification offers a few additional predefined formats. default - Use it to specify that property has a predefined value if no other value is present. Unlike JSON Schema, the value MUST conform to the defined type for the Schema Object defined at the same level. For example, of type is string , then default can be \"foo\" but cannot be 1 . Alternatively, any time a Schema Object can be used, a Reference Object can be used in its place. This allows referencing definitions in place of defining them inline. It is appropriate to clarify that the $ref keyword MUST follow the behavior described by Reference Object instead of the one in JSON Schema definition . In addition to the JSON Schema fields, the following AsyncAPI vocabulary fields MAY be used for further schema documentation: Fixed Fields Field Name Type Description discriminator string Adds support for polymorphism. The discriminator is the schema property name that is used to differentiate between other schema that inherit this schema. The property name used MUST be defined at this schema and it MUST be in the required property list. When used, the value MUST be the name of this schema or any schema that inherits it. See Composition and Inheritance for more details. externalDocs External Documentation Object | Reference Object Additional external documentation for this schema. deprecated boolean Specifies that a schema is deprecated and SHOULD be transitioned out of usage. Default value is false . This object MAY be extended with Specification Extensions . Composition and Inheritance (Polymorphism) The AsyncAPI Specification allows combining and extending model definitions using the allOf property of JSON Schema, in effect offering model composition. allOf takes in an array of object definitions that are validated independently but together compose a single object. While composition offers model extensibility, it does not imply a hierarchy between the models. To support polymorphism, AsyncAPI Specification adds the support of the discriminator field. When used, the discriminator will be the name of the property used to decide which schema definition is used to validate the structure of the model. As such, the discriminator field MUST be a required field. There are two ways to define the value of a discriminator for an inheriting instance. Use the schema's name. Override the schema's name by overriding the property with a new value. If exists, this takes precedence over the schema's name. As such, inline schema definitions, which do not have a given id, cannot be used in polymorphism. Schema Object Examples Primitive Sample \n```javascript\n1{\n2  \"type\": \"string\",\n3  \"format\": \"email\"\n4}\n```\n \n```javascript\n1type: string\n2format: email\n```\n Simple Model \n```javascript\n1{\n2  \"type\": \"object\",\n3  \"required\": [\n4    \"name\"\n5  ],\n6  \"properties\": {\n7    \"name\": {\n8      \"type\": \"string\"\n9    },\n10    \"address\": {\n11      \"$ref\": \"#/components/schemas/Address\"\n12    },\n13    \"age\": {\n14      \"type\": \"integer\",\n15      \"format\": \"int32\",\n16      \"minimum\": 0\n17    }\n18  }\n19}\n```\n \n```javascript\n1type: object\n2required:\n3- name\n4properties:\n5  name:\n6    type: string\n7  address:\n8    $ref: '#/components/schemas/Address'\n9  age:\n10    type: integer\n11    format: int32\n12    minimum: 0\n```\n Model with Map/Dictionary Properties For a simple string to string mapping: \n```javascript\n1{\n2  \"type\": \"object\",\n3  \"additionalProperties\": {\n4    \"type\": \"string\"\n5  }\n6}\n```\n \n```javascript\n1type: object\n2additionalProperties:\n3  type: string\n```\n For a string to model mapping: \n```javascript\n1{\n2  \"type\": \"object\",\n3  \"additionalProperties\": {\n4    \"$ref\": \"#/components/schemas/ComplexModel\"\n5  }\n6}\n```\n \n```javascript\n1type: object\n2additionalProperties:\n3  $ref: '#/components/schemas/ComplexModel'\n```\n Model with Example \n```javascript\n1{\n2  \"type\": \"object\",\n3  \"properties\": {\n4    \"id\": {\n5      \"type\": \"integer\",\n6      \"format\": \"int64\"\n7    },\n8    \"name\": {\n9      \"type\": \"string\"\n10    }\n11  },\n12  \"required\": [\n13    \"name\"\n14  ],\n15  \"examples\": [\n16    {\n17      \"name\": \"Puma\",\n18      \"id\": 1\n19    }\n20  ]\n21}\n```\n \n```javascript\n1type: object\n2properties:\n3  id:\n4    type: integer\n5    format: int64\n6  name:\n7    type: string\n8required:\n9- name\n10examples:\n11- name: Puma\n12  id: 1\n```\n Model with Boolean Schemas \n```javascript\n1{\n2  \"type\": \"object\",\n3  \"required\": [\n4    \"anySchema\"\n5  ],\n6  \"properties\": {\n7    \"anySchema\": true,\n8    \"cannotBeDefined\": false\n9  }\n10}\n```\n \n```javascript\n1type: object\n2required:\n3- anySchema\n4properties:\n5  anySchema: true\n6  cannotBeDefined: false\n```\n Models with Composition \n```javascript\n1{\n2  \"schemas\": {\n3    \"ErrorModel\": {\n4      \"type\": \"object\",\n5      \"required\": [\n6        \"message\",\n7        \"code\"\n8      ],\n9      \"properties\": {\n10        \"message\": {\n11          \"type\": \"string\"\n12        },\n13        \"code\": {\n14          \"type\": \"integer\",\n15          \"minimum\": 100,\n16          \"maximum\": 600\n17        }\n18      }\n19    },\n20    \"ExtendedErrorModel\": {\n21      \"allOf\": [\n22        {\n23          \"$ref\": \"#/components/schemas/ErrorModel\"\n24        },\n25        {\n26          \"type\": \"object\",\n27          \"required\": [\n28            \"rootCause\"\n29          ],\n30          \"properties\": {\n31            \"rootCause\": {\n32              \"type\": \"string\"\n33            }\n34          }\n35        }\n36      ]\n37    }\n38  }\n39}\n```\n \n```javascript\n1schemas:\n2  ErrorModel:\n3    type: object\n4    required:\n5    - message\n6    - code\n7    properties:\n8      message:\n9        type: string\n10      code:\n11        type: integer\n12        minimum: 100\n13        maximum: 600\n14  ExtendedErrorModel:\n15    allOf:\n16    - $ref: '#/components/schemas/ErrorModel'\n17    - type: object\n18      required:\n19      - rootCause\n20      properties:\n21        rootCause:\n22          type: string\n```\n Models with Polymorphism Support \n```javascript\n1{\n2  \"schemas\": {\n3    \"Pet\": {\n4      \"type\": \"object\",\n5      \"discriminator\": \"petType\",\n6      \"properties\": {\n7        \"name\": {\n8          \"type\": \"string\"\n9        },\n10        \"petType\": {\n11          \"type\": \"string\"\n12        }\n13      },\n14      \"required\": [\n15        \"name\",\n16        \"petType\"\n17      ]\n18    },\n19    \"Cat\": {\n20      \"description\": \"A representation of a cat. Note that `Cat` will be used as the discriminator value.\",\n21      \"allOf\": [\n22        {\n23          \"$ref\": \"#/components/schemas/Pet\"\n24        },\n25        {\n26          \"type\": \"object\",\n27          \"properties\": {\n28            \"huntingSkill\": {\n29              \"type\": \"string\",\n30              \"description\": \"The measured skill for hunting\",\n31              \"enum\": [\n32                \"clueless\",\n33                \"lazy\",\n34                \"adventurous\",\n35                \"aggressive\"\n36              ]\n37            }\n38          },\n39          \"required\": [\n40            \"huntingSkill\"\n41          ]\n42        }\n43      ]\n44    },\n45    \"Dog\": {\n46      \"description\": \"A representation of a dog. Note that `Dog` will be used as the discriminator value.\",\n47      \"allOf\": [\n48        {\n49          \"$ref\": \"#/components/schemas/Pet\"\n50        },\n51        {\n52          \"type\": \"object\",\n53          \"properties\": {\n54            \"packSize\": {\n55              \"type\": \"integer\",\n56              \"format\": \"int32\",\n57              \"description\": \"the size of the pack the dog is from\",\n58              \"minimum\": 0\n59            }\n60          },\n61          \"required\": [\n62            \"packSize\"\n63          ]\n64        }\n65      ]\n66    },\n67    \"StickInsect\": {\n68      \"description\": \"A representation of an Australian walking stick. Note that `StickBug` will be used as the discriminator value.\",\n69      \"allOf\": [\n70        {\n71          \"$ref\": \"#/components/schemas/Pet\"\n72        },\n73        {\n74          \"type\": \"object\",\n75          \"properties\": {\n76            \"petType\": {\n77              \"const\": \"StickBug\"\n78            },\n79            \"color\": {\n80              \"type\": \"string\"\n81            }\n82          },\n83          \"required\": [\n84            \"color\"\n85          ]\n86        }\n87      ]\n88    }\n89  }\n90}\n```\n \n```javascript\n1schemas:\n2  Pet:\n3    type: object\n4    discriminator: petType\n5    properties:\n6      name:\n7        type: string\n8      petType:\n9        type: string\n10    required:\n11    - name\n12    - petType\n13  ## applies to instances with `petType: \"Cat\"`\n14  ## because that is the schema name\n15  Cat:\n16    description: A representation of a cat\n17    allOf:\n18    - $ref: '#/components/schemas/Pet'\n19    - type: object\n20      properties:\n21        huntingSkill:\n22          type: string\n23          description: The measured skill for hunting\n24          enum:\n25          - clueless\n26          - lazy\n27          - adventurous\n28          - aggressive\n29      required:\n30      - huntingSkill\n31  ## applies to instances with `petType: \"Dog\"`\n32  ## because that is the schema name\n33  Dog:\n34    description: A representation of a dog\n35    allOf:\n36    - $ref: '#/components/schemas/Pet'\n37    - type: object\n38      properties:\n39        packSize:\n40          type: integer\n41          format: int32\n42          description: the size of the pack the dog is from\n43          minimum: 0\n44      required:\n45      - packSize\n46  ## applies to instances with `petType: \"StickBug\"`\n47  ## because that is the required value of the discriminator field,\n48  ## overriding the schema name\n49  StickInsect:\n50    description: A representation of an Australian walking stick\n51    allOf:\n52    - $ref: '#/components/schemas/Pet'\n53    - type: object\n54      properties:\n55        petType:\n56          const: StickBug\n57        color:\n58          type: string\n59      required:\n60      - color\n```\n Security Scheme Object Defines a security scheme that can be used by the operations. Supported schemes are: User/Password. API key (either as user or as password). X.509 certificate. End-to-end encryption (either symmetric or asymmetric). HTTP authentication. HTTP API key. OAuth2's common flows (Implicit, Resource Owner Protected Credentials, Client Credentials and Authorization Code) as defined in RFC6749 . OpenID Connect Discovery . SASL (Simple Authentication and Security Layer) as defined in RFC4422 . Fixed Fields Field Name Type Applies To Description type string Any REQUIRED . The type of the security scheme. Valid values are \"userPassword\" , \"apiKey\" , \"X509\" , \"symmetricEncryption\" , \"asymmetricEncryption\" , \"httpApiKey\" , \"http\" , \"oauth2\" , \"openIdConnect\" , \"plain\" , \"scramSha256\" , \"scramSha512\" , and \"gssapi\" . description string Any A short description for security scheme. CommonMark syntax MAY be used for rich text representation. name string httpApiKey REQUIRED . The name of the header, query or cookie parameter to be used. in string apiKey | httpApiKey REQUIRED . The location of the API key. Valid values are \"user\" and \"password\" for apiKey and \"query\" , \"header\" or \"cookie\" for httpApiKey . scheme string http REQUIRED . The name of the HTTP Authorization scheme to be used in the Authorization header as defined in RFC7235 . bearerFormat string http ( \"bearer\" ) A hint to the client to identify how the bearer token is formatted. Bearer tokens are usually generated by an authorization server, so this information is primarily for documentation purposes. flows OAuth Flows Object oauth2 REQUIRED . An object containing configuration information for the flow types supported. openIdConnectUrl string openIdConnect REQUIRED . OpenId Connect URL to discover OAuth2 configuration values. This MUST be in the form of an absolute URL. scopes [ string ] oauth2 | openIdConnect List of the needed scope names. An empty array means no scopes are needed. This object MAY be extended with Specification Extensions . Security Scheme Object Example User/Password Authentication Sample \n```javascript\n1{\n2  \"type\": \"userPassword\"\n3}\n```\n type: userPassword API Key Authentication Sample \n```javascript\n1{\n2  \"type\": \"apiKey\",\n3  \"in\": \"user\"\n4}\n```\n \n```javascript\n1type: apiKey\n2in: user\n```\n X.509 Authentication Sample \n```javascript\n1{\n2  \"type\": \"X509\"\n3}\n```\n type: X509 End-to-end Encryption Authentication Sample \n```javascript\n1{\n2  \"type\": \"symmetricEncryption\"\n3}\n```\n type: symmetricEncryption Basic Authentication Sample \n```javascript\n1{\n2  \"type\": \"http\",\n3  \"scheme\": \"basic\"\n4}\n```\n \n```javascript\n1type: http\n2scheme: basic\n```\n API Key Sample \n```javascript\n1{\n2  \"type\": \"httpApiKey\",\n3  \"name\": \"api_key\",\n4  \"in\": \"header\"\n5}\n```\n \n```javascript\n1type: httpApiKey\n2name: api_key\n3in: header\n```\n JWT Bearer Sample \n```javascript\n1{\n2  \"type\": \"http\",\n3  \"scheme\": \"bearer\",\n4  \"bearerFormat\": \"JWT\"\n5}\n```\n \n```javascript\n1type: http\n2scheme: bearer\n3bearerFormat: JWT\n```\n Implicit OAuth2 Sample \n```javascript\n1{\n2  \"type\": \"oauth2\",\n3  \"flows\": {\n4    \"implicit\": {\n5      \"authorizationUrl\": \"https://example.com/api/oauth/dialog\",\n6      \"availableScopes\": {\n7        \"write:pets\": \"modify pets in your account\",\n8        \"read:pets\": \"read your pets\"\n9      }\n10    }\n11  },\n12  \"scopes\": [\n13    \"write:pets\"\n14  ]\n15}\n```\n \n```javascript\n1type: oauth2\n2flows:\n3  implicit:\n4    authorizationUrl: https://example.com/api/oauth/dialog\n5    availableScopes:\n6      write:pets: modify pets in your account\n7      read:pets: read your pets\n8scopes:\n9  - 'write:pets'\n```\n SASL Sample \n```javascript\n1{\n2  \"type\": \"scramSha512\"\n3}\n```\n type: scramSha512 OAuth Flows Object Allows configuration of the supported OAuth Flows. Fixed Fields Field Name Type Description implicit OAuth Flow Object Configuration for the OAuth Implicit flow. password OAuth Flow Object Configuration for the OAuth Resource Owner Protected Credentials flow. clientCredentials OAuth Flow Object Configuration for the OAuth Client Credentials flow. authorizationCode OAuth Flow Object Configuration for the OAuth Authorization Code flow. This object MAY be extended with Specification Extensions . OAuth Flow Object Configuration details for a supported OAuth Flow Fixed Fields Field Name Type Applies To Description authorizationUrl string oauth2 ( \"implicit\" , \"authorizationCode\" ) REQUIRED . The authorization URL to be used for this flow. This MUST be in the form of an absolute URL. tokenUrl string oauth2 ( \"password\" , \"clientCredentials\" , \"authorizationCode\" ) REQUIRED . The token URL to be used for this flow. This MUST be in the form of an absolute URL. refreshUrl string oauth2 The URL to be used for obtaining refresh tokens. This MUST be in the form of an absolute URL. availableScopes Map[ string , string ] oauth2 REQUIRED . The available scopes for the OAuth2 security scheme. A map between the scope name and a short description for it. This object MAY be extended with Specification Extensions . OAuth Flow Object Examples \n```javascript\n1{\n2  \"authorizationUrl\": \"https://example.com/api/oauth/dialog\",\n3  \"tokenUrl\": \"https://example.com/api/oauth/token\",\n4  \"availableScopes\": {\n5    \"write:pets\": \"modify pets in your account\",\n6    \"read:pets\": \"read your pets\"\n7  }\n8}\n```\n \n```javascript\n1authorizationUrl: https://example.com/api/oauth/dialog\n2tokenUrl: https://example.com/api/oauth/token\n3availableScopes:\n4  write:pets: modify pets in your account\n5  read:pets: read your pets\n```\n Correlation ID Object An object that specifies an identifier at design time that can used for message tracing and correlation. For specifying and computing the location of a Correlation ID, a runtime expression is used. Fixed Fields Field Name Type Description description string An optional description of the identifier. CommonMark syntax can be used for rich text representation. location string REQUIRED. A runtime expression that specifies the location of the correlation ID. This object MAY be extended with Specification Extensions . Examples \n```javascript\n1{\n2  \"description\": \"Default Correlation ID\",\n3  \"location\": \"$message.header#/correlationId\"\n4}\n```\n \n```javascript\n1description: Default Correlation ID\n2location: $message.header#/correlationId\n```\n Runtime Expression A runtime expression allows values to be defined based on information that will be available within the message. This mechanism is used by Correlation ID Object and Operation Reply Address Object . The runtime expression is defined by the following ABNF syntax: \n```javascript\n1      expression = ( \"$message\" \".\" source )\n2      source = ( header-reference | payload-reference )\n3      header-reference = \"header\" [\"#\" fragment]\n4      payload-reference = \"payload\" [\"#\" fragment]\n5      fragment = a JSON Pointer [RFC 6901](https://tools.ietf.org/html/rfc6901)\n```\n The table below provides examples of runtime expressions and examples of their use in a value: Examples Source Location Example expression Notes Message Header Property $message.header#/MQMD/CorrelId Correlation ID is set using the CorrelId value from the MQMD header. Message Payload Property $message.payload#/messageId Correlation ID is set using the messageId value from the message payload. Runtime expressions preserve the type of the referenced value. Traits Merge Mechanism Traits MUST be merged with the target object using the JSON Merge Patch algorithm in the same order they are defined. A property on a trait MUST NOT override the same property on the target object. Example An object like the following: \n```javascript\n1description: A longer description.\n2traits:\n3  - name: UserSignup\n4    description: Description from trait.\n5  - tags:\n6      - name: user\n```\n Would look like the following after applying traits: \n```javascript\n1name: UserSignup\n2description: A longer description.\n3tags:\n4  - name: user\n```\n Specification Extensions While the AsyncAPI Specification tries to accommodate most use cases, additional data can be added to extend the specification at certain points. The extensions properties are implemented as patterned fields that are always prefixed by \"x-\" . Field Pattern Type Description ^x-[\\w\\d\\.\\x2d_]+$ Any Allows extensions to the AsyncAPI Schema. The field name MUST begin with x- , for example, x-internal-id . The value can be null , a primitive, an array or an object. Can have any valid JSON format value. The extensions may or may not be supported by the available tooling, but those may be extended as well to add requested support (if tools are internal or open-sourced). Data Type Formats Primitives have an optional modifier property: format . The AsyncAPI specification uses several known formats to more finely define the data type being used. However, the format property is an open string -valued property, and can have any value to support documentation needs. Formats such as \"email\" , \"uuid\" , etc., can be used even though they are not defined by this specification. Types that are not accompanied by a format property follow their definition from the JSON Schema. Tools that do not recognize a specific format MAY default back to the type alone, as if the format was not specified. The formats defined by the AsyncAPI Specification are: Common Name type format Comments integer integer int32 signed 32 bits long integer int64 signed 64 bits float number float double number double string string byte string byte base64 encoded characters binary string binary any sequence of octets boolean boolean date string date As defined by full-date - RFC3339 dateTime string date-time As defined by date-time - RFC3339 password string password Used to hint UIs the input needs to be obscured. Go Back Reference - Overview Up Next 2.x Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1channels:\n2  userSignedUp:\n3    # ...(redacted for brevity)\n4operations:\n5  onUserSignedUp:\n6    action: receive\n7    channel:\n8      $ref: \"#/channels/userSignedUp\"",
      "1operations:\n2  onUserSignedUp:\n3    summary: On user signed up.\n4    description: Event received when a user signed up on the product.\n5    action: receive\n6    channel:\n7      $ref: \"#/channels/userSignedUp\"",
      "1operations:\n2  onUserSignedUp: # <-- This doesn't make sense now. Should be something like sendUserSignedUp.\n3    summary: On user signed up. # <-- This doesn't make sense now. Should say something like \"Sends a user signed up event\".\n4    description: Event received when a user signed up on the product. # <-- This doesn't make sense now. Should speak about sending an event, not receiving it.\n5    action: send\n6    channel:\n7      $ref: \"#/channels/userSignedUp\"",
      "1{\n2   \"field\" : [...]\n3}",
      "1{\n2  \"id\": \"urn:example:com:smartylighting:streetlights:server\"\n3}",
      "1{\n2  \"id\": \"https://github.com/smartylighting/streetlights-server\"\n3}",
      "1{\n2  \"title\": \"AsyncAPI Sample App\",\n3  \"version\": \"1.0.1\",\n4  \"description\": \"This is a sample app.\",\n5  \"termsOfService\": \"https://asyncapi.org/terms/\",\n6  \"contact\": {\n7    \"name\": \"API Support\",\n8    \"url\": \"https://www.asyncapi.org/support\",\n9    \"email\": \"support@asyncapi.org\"\n10  },\n11  \"license\": {\n12    \"name\": \"Apache 2.0\",\n13    \"url\": \"https://www.apache.org/licenses/LICENSE-2.0.html\"\n14  },\n15  \"externalDocs\": {\n16    \"description\": \"Find more info here\",\n17    \"url\": \"https://www.asyncapi.org\"\n18  },\n19  \"tags\": [\n20    {\n21      \"name\": \"e-commerce\"\n22    }\n23  ]\n24}",
      "1title: AsyncAPI Sample App\n2version: 1.0.1\n3description: This is a sample app.\n4termsOfService: https://asyncapi.org/terms/\n5contact:\n6  name: API Support\n7  url: https://www.asyncapi.org/support\n8  email: support@asyncapi.org\n9license:\n10  name: Apache 2.0\n11  url: https://www.apache.org/licenses/LICENSE-2.0.html\n12externalDocs:\n13  description: Find more info here\n14  url: https://www.asyncapi.org\n15tags:\n16  - name: e-commerce",
      "1{\n2  \"name\": \"API Support\",\n3  \"url\": \"https://www.example.com/support\",\n4  \"email\": \"support@example.com\"\n5}",
      "1name: API Support\n2url: https://www.example.com/support\n3email: support@example.com",
      "1{\n2  \"name\": \"Apache 2.0\",\n3  \"url\": \"https://www.apache.org/licenses/LICENSE-2.0.html\"\n4}",
      "1name: Apache 2.0\n2url: https://www.apache.org/licenses/LICENSE-2.0.html",
      "1{\n2  \"development\": {\n3    \"host\": \"localhost:5672\",\n4    \"description\": \"Development AMQP broker.\",\n5    \"protocol\": \"amqp\",\n6    \"protocolVersion\": \"0-9-1\",\n7    \"tags\": [\n8      { \n9        \"name\": \"env:development\",\n10        \"description\": \"This environment is meant for developers to run their own tests.\"\n11      }\n12    ]\n13  },\n14  \"staging\": {\n15    \"host\": \"rabbitmq-staging.in.mycompany.com:5672\",\n16    \"description\": \"RabbitMQ broker for the staging environment.\",\n17    \"protocol\": \"amqp\",\n18    \"protocolVersion\": \"0-9-1\",\n19    \"tags\": [\n20      { \n21        \"name\": \"env:staging\",\n22        \"description\": \"This environment is a replica of the production environment.\"\n23      }\n24    ]\n25  },\n26  \"production\": {\n27    \"host\": \"rabbitmq.in.mycompany.com:5672\",\n28    \"description\": \"RabbitMQ broker for the production environment.\",\n29    \"protocol\": \"amqp\",\n30    \"protocolVersion\": \"0-9-1\",\n31    \"tags\": [\n32      { \n33        \"name\": \"env:production\",\n34        \"description\": \"This environment is the live environment available for final users.\"\n35      }\n36    ]\n37  }\n38}",
      "1development:\n2  host: localhost:5672\n3  description: Development AMQP broker.\n4  protocol: amqp\n5  protocolVersion: 0-9-1\n6  tags:\n7    - name: \"env:development\"\n8      description: \"This environment is meant for developers to run their own tests.\"\n9staging:\n10  host: rabbitmq-staging.in.mycompany.com:5672\n11  description: RabbitMQ broker for the staging environment.\n12  protocol: amqp\n13  protocolVersion: 0-9-1\n14  tags:\n15    - name: \"env:staging\"\n16      description: \"This environment is a replica of the production environment.\"\n17production:\n18  host: rabbitmq.in.mycompany.com:5672\n19  description: RabbitMQ broker for the production environment.\n20  protocol: amqp\n21  protocolVersion: 0-9-1\n22  tags:\n23    - name: \"env:production\"\n24      description: \"This environment is the live environment available for final users.\"",
      "1{\n2  \"host\": \"kafka.in.mycompany.com:9092\",\n3  \"description\": \"Production Kafka broker.\",\n4  \"protocol\": \"kafka\",\n5  \"protocolVersion\": \"3.2\"\n6}",
      "1host: kafka.in.mycompany.com:9092\n2description: Production Kafka broker.\n3protocol: kafka\n4protocolVersion: '3.2'",
      "1{\n2  \"host\": \"rabbitmq.in.mycompany.com:5672\",\n3  \"pathname\": \"/production\",\n4  \"protocol\": \"amqp\",\n5  \"description\": \"Production RabbitMQ broker (uses the `production` vhost).\"\n6}",
      "1host: rabbitmq.in.mycompany.com:5672\n2pathname: /production\n3protocol: amqp\n4description: Production RabbitMQ broker (uses the `production` vhost).",
      "1{\n2  \"host\": \"rabbitmq.in.mycompany.com:5672\",\n3  \"pathname\": \"/{env}\",\n4  \"protocol\": \"amqp\",\n5  \"description\": \"RabbitMQ broker. Use the `env` variable to point to either `production` or `staging`.\",\n6  \"variables\": {\n7    \"env\": {\n8      \"description\": \"Environment to connect to. It can be either `production` or `staging`.\",\n9      \"enum\": [\n10        \"production\",\n11        \"staging\"\n12      ]\n13    }\n14  }\n15}",
      "1host: 'rabbitmq.in.mycompany.com:5672'\n2pathname: '/{env}'\n3protocol: amqp\n4description: RabbitMQ broker. Use the `env` variable to point to either `production` or `staging`.\n5variables:\n6  env:\n7    description: Environment to connect to. It can be either `production` or `staging`.\n8    enum:\n9      - production\n10      - staging",
      "1{\n2  \"defaultContentType\": \"application/json\"\n3}",
      "1{\n2  \"userSignedUp\": {\n3    \"address\": \"user.signedup\",\n4    \"messages\": {\n5      \"userSignedUp\": {\n6        \"$ref\": \"#/components/messages/userSignedUp\"\n7      }\n8    }\n9  }\n10}",
      "1userSignedUp:\n2  address: 'user.signedup'\n3  messages:\n4    userSignedUp:\n5      $ref: '#/components/messages/userSignedUp'",
      "1{\n2  \"address\": \"users.{userId}\",\n3  \"title\": \"Users channel\",\n4  \"description\": \"This channel is used to exchange messages about user events.\",\n5  \"messages\": {\n6    \"userSignedUp\": {\n7      \"$ref\": \"#/components/messages/userSignedUp\"\n8    },\n9    \"userCompletedOrder\": {\n10      \"$ref\": \"#/components/messages/userCompletedOrder\"\n11    }\n12  },\n13  \"parameters\": {\n14    \"userId\": {\n15      \"$ref\": \"#/components/parameters/userId\"\n16    }\n17  },\n18  \"servers\": [\n19    { \"$ref\": \"#/servers/rabbitmqInProd\" },\n20    { \"$ref\": \"#/servers/rabbitmqInStaging\" }\n21  ],\n22  \"bindings\": {\n23    \"amqp\": {\n24      \"is\": \"queue\",\n25      \"queue\": {\n26        \"exclusive\": true\n27      }\n28    }\n29  },\n30  \"tags\": [{\n31    \"name\": \"user\",\n32    \"description\": \"User-related messages\"\n33  }],\n34  \"externalDocs\": {\n35    \"description\": \"Find more info here\",\n36    \"url\": \"https://example.com\"\n37  }\n38}",
      "1address: 'users.{userId}'\n2title: Users channel\n3description: This channel is used to exchange messages about user events.\n4messages:\n5  userSignedUp:\n6    $ref: '#/components/messages/userSignedUp'\n7  userCompletedOrder:\n8    $ref: '#/components/messages/userCompletedOrder'\n9parameters:\n10  userId:\n11    $ref: '#/components/parameters/userId'\n12servers:\n13  - $ref: '#/servers/rabbitmqInProd'\n14  - $ref: '#/servers/rabbitmqInStaging'\n15bindings:\n16  amqp:\n17    is: queue\n18    queue:\n19      exclusive: true\n20tags:\n21  - name: user\n22    description: User-related messages\n23externalDocs:\n24  description: 'Find more info here'\n25  url: 'https://example.com'",
      "1{\n2  \"userSignedUp\": {\n3    \"$ref\": \"#/components/messages/userSignedUp\"\n4  },\n5  \"userCompletedOrder\": {\n6    \"$ref\": \"#/components/messages/userCompletedOrder\"\n7  }\n8}",
      "1userSignedUp:\n2  $ref: '#/components/messages/userSignedUp'\n3userCompletedOrder:\n4  $ref: '#/components/messages/userCompletedOrder'",
      "1{\n2  \"onUserSignUp\": {\n3    \"title\": \"User sign up\",\n4    \"summary\": \"Action to sign a user up.\",\n5    \"description\": \"A longer description\",\n6    \"channel\": {\n7      \"$ref\": \"#/channels/userSignup\"\n8    },\n9    \"action\": \"send\",\n10    \"tags\": [\n11      { \"name\": \"user\" },\n12      { \"name\": \"signup\" },\n13      { \"name\": \"register\" }\n14    ],\n15    \"bindings\": {\n16      \"amqp\": {\n17        \"ack\": false\n18      }\n19    },\n20    \"traits\": [\n21      { \"$ref\": \"#/components/operationTraits/kafka\" }\n22    ]\n23  }\n24}",
      "1onUserSignUp:\n2  title: User sign up\n3  summary: Action to sign a user up.\n4  description: A longer description\n5  channel:\n6    $ref: '#/channels/userSignup'\n7  action: send\n8  tags:\n9    - name: user\n10    - name: signup\n11    - name: register\n12  bindings:\n13    amqp:\n14      ack: false\n15  traits:\n16    - $ref: '#/components/operationTraits/kafka'",
      "1{\n2  \"title\": \"User sign up\",\n3  \"summary\": \"Action to sign a user up.\",\n4  \"description\": \"A longer description\",\n5  \"channel\": {\n6    \"$ref\": \"#/channels/userSignup\"\n7  },\n8  \"action\": \"send\",\n9  \"security\": [\n10    {\n11     \"petstore_auth\": [\n12       \"write:pets\",\n13       \"read:pets\"\n14     ]\n15    }\n16  ],\n17  \"tags\": [\n18    { \"name\": \"user\" },\n19    { \"name\": \"signup\" },\n20    { \"name\": \"register\" }\n21  ],\n22  \"bindings\": {\n23    \"amqp\": {\n24      \"ack\": false\n25    }\n26  },\n27  \"traits\": [\n28    { \"$ref\": \"#/components/operationTraits/kafka\" }\n29  ],\n30  \"messages\": [\n31    { \"$ref\": \"/components/messages/userSignedUp\" }\n32  ],\n33  \"reply\": {\n34    \"address\": {\n35      \"location\": \"$message.header#/replyTo\"\n36    },\n37    \"channel\": {\n38      \"$ref\": \"#/channels/userSignupReply\"\n39    },\n40    \"messages\": [\n41      { \"$ref\": \"/components/messages/userSignedUpReply\" }\n42    ],\n43  }\n44}",
      "1title: User sign up\n2summary: Action to sign a user up.\n3description: A longer description\n4channel:\n5  $ref: '#/channels/userSignup'\n6action: send\n7security:\n8  - petstore_auth:\n9    - write:pets\n10    - read:pets\n11tags:\n12  - name: user\n13  - name: signup\n14  - name: register\n15bindings:\n16  amqp:\n17    ack: false\n18traits:\n19  - $ref: \"#/components/operationTraits/kafka\"\n20messages:\n21  - $ref: '#/components/messages/userSignedUp'\n22reply:\n23  address:\n24    location: '$message.header#/replyTo'\n25  channel:\n26    $ref: '#/channels/userSignupReply'\n27  messages:\n28    - $ref: '#/components/messages/userSignedUpReply'",
      "1{\n2  \"bindings\": {\n3    \"amqp\": {\n4      \"ack\": false\n5    }\n6  }\n7}",
      "1bindings:\n2  amqp:\n3    ack: false",
      "1{\n2  \"description\": \"Consumer inbox\",\n3  \"location\": \"$message.header#/replyTo\"\n4}",
      "1description: Consumer Inbox\n2location: $message.header#/replyTo",
      "1{\n2  \"address\": \"user/{userId}/signedup\",\n3  \"parameters\": {\n4    \"userId\": {\n5      \"description\": \"Id of the user.\"\n6    }\n7  }\n8}",
      "1address: user/{userId}/signedup\n2parameters:\n3  userId:\n4    description: Id of the user.",
      "1{\n2  \"address\": \"user/{userId}/signedup\",\n3  \"parameters\": {\n4    \"userId\": {\n5      \"description\": \"Id of the user.\",\n6      \"location\": \"$message.payload#/user/id\"\n7    }\n8  }\n9}",
      "1address: user/{userId}/signedup\n2parameters:\n3  userId:\n4    description: Id of the user.\n5    location: $message.payload#/user/id",
      "1{\n2  \"name\": \"UserSignup\",\n3  \"title\": \"User signup\",\n4  \"summary\": \"Action to sign a user up.\",\n5  \"description\": \"A longer description\",\n6  \"contentType\": \"application/json\",\n7  \"tags\": [\n8    { \"name\": \"user\" },\n9    { \"name\": \"signup\" },\n10    { \"name\": \"register\" }\n11  ],\n12  \"headers\": {\n13    \"type\": \"object\",\n14    \"properties\": {\n15      \"correlationId\": {\n16        \"description\": \"Correlation ID set by application\",\n17        \"type\": \"string\"\n18      },\n19      \"applicationInstanceId\": {\n20        \"description\": \"Unique identifier for a given instance of the publishing application\",\n21        \"type\": \"string\"\n22      }\n23    }\n24  },\n25  \"payload\": {\n26    \"type\": \"object\",\n27    \"properties\": {\n28      \"user\": {\n29        \"$ref\": \"#/components/schemas/userCreate\"\n30      },\n31      \"signup\": {\n32        \"$ref\": \"#/components/schemas/signup\"\n33      }\n34    }\n35  },\n36  \"correlationId\": {\n37    \"description\": \"Default Correlation ID\",\n38    \"location\": \"$message.header#/correlationId\"\n39  },\n40  \"traits\": [\n41    { \"$ref\": \"#/components/messageTraits/commonHeaders\" }\n42  ],\n43  \"examples\": [\n44    {\n45      \"name\": \"SimpleSignup\",\n46      \"summary\": \"A simple UserSignup example message\",\n47      \"headers\": {\n48        \"correlationId\": \"my-correlation-id\",\n49        \"applicationInstanceId\": \"myInstanceId\"\n50      },\n51      \"payload\": {\n52        \"user\": {\n53          \"someUserKey\": \"someUserValue\"\n54        },\n55        \"signup\": {\n56          \"someSignupKey\": \"someSignupValue\"\n57        }\n58      }\n59    }\n60  ]\n61}",
      "1name: UserSignup\n2title: User signup\n3summary: Action to sign a user up.\n4description: A longer description\n5contentType: application/json\n6tags:\n7  - name: user\n8  - name: signup\n9  - name: register\n10headers:\n11  type: object\n12  properties:\n13    correlationId:\n14      description: Correlation ID set by application\n15      type: string\n16    applicationInstanceId:\n17      description: Unique identifier for a given instance of the publishing application\n18      type: string\n19payload:\n20  type: object\n21  properties:\n22    user:\n23      $ref: \"#/components/schemas/userCreate\"\n24    signup:\n25      $ref: \"#/components/schemas/signup\"\n26correlationId:\n27  description: Default Correlation ID\n28  location: $message.header#/correlationId\n29traits:\n30  - $ref: \"#/components/messageTraits/commonHeaders\"\n31examples:\n32  - name: SimpleSignup\n33    summary: A simple UserSignup example message\n34    headers:\n35      correlationId: my-correlation-id\n36      applicationInstanceId: myInstanceId\n37    payload:\n38      user:\n39        someUserKey: someUserValue\n40      signup:\n41        someSignupKey: someSignupValue",
      "1{\n2  \"name\": \"UserSignup\",\n3  \"title\": \"User signup\",\n4  \"summary\": \"Action to sign a user up.\",\n5  \"description\": \"A longer description\",\n6  \"tags\": [\n7    { \"name\": \"user\" },\n8    { \"name\": \"signup\" },\n9    { \"name\": \"register\" }\n10  ],\n11  \"payload\": {\n12    \"schemaFormat\": \"application/vnd.apache.avro+json;version=1.9.0\",\n13    \"schema\": {\n14      \"$ref\": \"path/to/user-create.avsc#/UserCreate\"\n15    }\n16  }\n17}",
      "1name: UserSignup\n2title: User signup\n3summary: Action to sign a user up.\n4description: A longer description\n5tags:\n6  - name: user\n7  - name: signup\n8  - name: register\n9payload:\n10  schemaFormat: 'application/vnd.apache.avro+yaml;version=1.9.0'\n11  schema:\n12    $ref: 'path/to/user-create.avsc/#UserCreate'",
      "1{\n2  \"contentType\": \"application/json\"\n3}",
      "1{\n2  \"name\": \"SimpleSignup\",\n3  \"summary\": \"A simple UserSignup example message\",\n4  \"headers\": {\n5    \"correlationId\": \"my-correlation-id\",\n6    \"applicationInstanceId\": \"myInstanceId\"\n7  },\n8  \"payload\": {\n9    \"user\": {\n10      \"someUserKey\": \"someUserValue\"\n11    },\n12    \"signup\": {\n13      \"someSignupKey\": \"someSignupValue\"\n14    }\n15  }\n16}",
      "1name: SimpleSignup\n2summary: A simple UserSignup example message\n3headers:\n4  correlationId: my-correlation-id\n5  applicationInstanceId: myInstanceId\n6payload:\n7  user:\n8    someUserKey: someUserValue\n9  signup:\n10    someSignupKey: someSignupValue",
      "1{\n2 \"name\": \"user\",\n3 \"description\": \"User-related messages\"\n4}",
      "1name: user\n2description: User-related messages",
      "1{\n2  \"description\": \"Find more info here\",\n3  \"url\": \"https://example.com\"\n4}",
      "1description: Find more info here\n2url: https://example.com",
      "1{\n2  \"$ref\": \"#/components/schemas/Pet\"\n3}",
      "1User\n2User_1\n3User_Name\n4user-name\n5my.org.User",
      "1{\n2  \"components\": {\n3    \"schemas\": {\n4      \"Category\": {\n5        \"type\": \"object\",\n6        \"properties\": {\n7          \"id\": {\n8            \"type\": \"integer\",\n9            \"format\": \"int64\"\n10          },\n11          \"name\": {\n12            \"type\": \"string\"\n13          }\n14        }\n15      },\n16      \"Tag\": {\n17        \"type\": \"object\",\n18        \"properties\": {\n19          \"id\": {\n20            \"type\": \"integer\",\n21            \"format\": \"int64\"\n22          },\n23          \"name\": {\n24            \"type\": \"string\"\n25          }\n26        }\n27      },\n28      \"AvroExample\": {\n29        \"schemaFormat\": \"application/vnd.apache.avro+json;version=1.9.0\",\n30        \"schema\": {\n31          \"$ref\": \"path/to/user-create.avsc#/UserCreate\"\n32        }\n33      }\n34    },\n35    \"servers\": {\n36      \"development\": {\n37        \"host\": \"{stage}.in.mycompany.com:{port}\",\n38        \"description\": \"RabbitMQ broker\",\n39        \"protocol\": \"amqp\",\n40        \"protocolVersion\": \"0-9-1\",\n41        \"variables\": {\n42          \"stage\": {\n43            \"$ref\": \"#/components/serverVariables/stage\"\n44          },\n45          \"port\": {\n46            \"$ref\": \"#/components/serverVariables/port\"\n47          }\n48        }\n49      }\n50    },\n51    \"serverVariables\": {\n52      \"stage\": {\n53        \"default\": \"demo\",\n54        \"description\": \"This value is assigned by the service provider, in this example `mycompany.com`\"\n55      },\n56      \"port\": {\n57        \"enum\": [\"5671\", \"5672\"],\n58        \"default\": \"5672\"\n59      }\n60    },\n61    \"channels\": {\n62      \"user/signedup\": {\n63        \"subscribe\": {\n64          \"message\": {\n65            \"$ref\": \"#/components/messages/userSignUp\"\n66          }\n67        }\n68      }\n69    },\n70    \"messages\": {\n71      \"userSignUp\": {\n72        \"summary\": \"Action to sign a user up.\",\n73        \"description\": \"Multiline description of what this action does.\\nHere you have another line.\\n\",\n74        \"tags\": [\n75          {\n76            \"name\": \"user\"\n77          },\n78          {\n79            \"name\": \"signup\"\n80          }\n81        ],\n82        \"headers\": {\n83          \"type\": \"object\",\n84          \"properties\": {\n85            \"applicationInstanceId\": {\n86              \"description\": \"Unique identifier for a given instance of the publishing application\",\n87              \"type\": \"string\"\n88            }\n89          }\n90        },\n91        \"payload\": {\n92          \"type\": \"object\",\n93          \"properties\": {\n94            \"user\": {\n95              \"$ref\": \"#/components/schemas/userCreate\"\n96            },\n97            \"signup\": {\n98              \"$ref\": \"#/components/schemas/signup\"\n99            }\n100          }\n101        }\n102      }\n103    },\n104    \"parameters\": {\n105      \"userId\": {\n106        \"description\": \"Id of the user.\"\n107      }\n108    },\n109    \"correlationIds\": {\n110      \"default\": {\n111        \"description\": \"Default Correlation ID\",\n112        \"location\": \"$message.header#/correlationId\"\n113      }\n114    },\n115    \"messageTraits\": {\n116      \"commonHeaders\": {\n117        \"headers\": {\n118          \"type\": \"object\",\n119          \"properties\": {\n120            \"my-app-header\": {\n121              \"type\": \"integer\",\n122              \"minimum\": 0,\n123              \"maximum\": 100\n124            }\n125          }\n126        }\n127      }\n128    }\n129  }\n130}",
      "1components:\n2  schemas:\n3    Category:\n4      type: object\n5      properties:\n6        id:\n7          type: integer\n8          format: int64\n9        name:\n10          type: string\n11    Tag:\n12      type: object\n13      properties:\n14        id:\n15          type: integer\n16          format: int64\n17        name:\n18          type: string\n19    AvroExample:\n20      schemaFormat: application/vnd.apache.avro+json;version=1.9.0\n21      schema:\n22        $ref: 'path/to/user-create.avsc/#UserCreate'\n23  servers:\n24    development:\n25      host: \"{stage}.in.mycompany.com:{port}\"\n26      description: RabbitMQ broker\n27      protocol: amqp\n28      protocolVersion: 0-9-1\n29      variables:\n30        stage:\n31          $ref: \"#/components/serverVariables/stage\"\n32        port:\n33          $ref: \"#/components/serverVariables/port\"\n34  serverVariables:\n35    stage:\n36      default: demo\n37      description: This value is assigned by the service provider, in this example `mycompany.com`\n38    port:\n39      enum: [\"5671\", \"5672\"]\n40      default: \"5672\"\n41  channels:\n42    user/signedup:\n43      subscribe:\n44        message:\n45          $ref: \"#/components/messages/userSignUp\"\n46  messages:\n47    userSignUp:\n48      summary: Action to sign a user up.\n49      description: |\n50        Multiline description of what this action does.\n51        Here you have another line.\n52      tags:\n53        - name: user\n54        - name: signup\n55      headers:\n56        type: object\n57        properties:\n58          applicationInstanceId:\n59            description: Unique identifier for a given instance of the publishing application\n60            type: string\n61      payload:\n62        type: object\n63        properties:\n64          user:\n65            $ref: \"#/components/schemas/userCreate\"\n66          signup:\n67            $ref: \"#/components/schemas/signup\"\n68  parameters:\n69    userId:\n70      description: Id of the user.\n71  correlationIds:\n72    default:\n73      description: Default Correlation ID\n74      location: $message.header#/correlationId\n75  messageTraits:\n76    commonHeaders:\n77      headers:\n78        type: object\n79        properties:\n80          my-app-header:\n81            type: integer\n82            minimum: 0\n83            maximum: 100",
      "1channels:\n2  example:\n3    messages:\n4      myMessage:\n5        payload:\n6          schemaFormat: 'application/vnd.apache.avro;version=1.9.0'\n7          schema:\n8            type: record\n9            name: User\n10            namespace: com.company\n11            doc: User information\n12            fields:\n13              - name: displayName\n14                type: string\n15              - name: age\n16                type: int",
      "1{\n2  \"type\": \"string\",\n3  \"format\": \"email\"\n4}",
      "1type: string\n2format: email",
      "1{\n2  \"type\": \"object\",\n3  \"required\": [\n4    \"name\"\n5  ],\n6  \"properties\": {\n7    \"name\": {\n8      \"type\": \"string\"\n9    },\n10    \"address\": {\n11      \"$ref\": \"#/components/schemas/Address\"\n12    },\n13    \"age\": {\n14      \"type\": \"integer\",\n15      \"format\": \"int32\",\n16      \"minimum\": 0\n17    }\n18  }\n19}",
      "1type: object\n2required:\n3- name\n4properties:\n5  name:\n6    type: string\n7  address:\n8    $ref: '#/components/schemas/Address'\n9  age:\n10    type: integer\n11    format: int32\n12    minimum: 0",
      "1{\n2  \"type\": \"object\",\n3  \"additionalProperties\": {\n4    \"type\": \"string\"\n5  }\n6}",
      "1type: object\n2additionalProperties:\n3  type: string",
      "1{\n2  \"type\": \"object\",\n3  \"additionalProperties\": {\n4    \"$ref\": \"#/components/schemas/ComplexModel\"\n5  }\n6}",
      "1type: object\n2additionalProperties:\n3  $ref: '#/components/schemas/ComplexModel'",
      "1{\n2  \"type\": \"object\",\n3  \"properties\": {\n4    \"id\": {\n5      \"type\": \"integer\",\n6      \"format\": \"int64\"\n7    },\n8    \"name\": {\n9      \"type\": \"string\"\n10    }\n11  },\n12  \"required\": [\n13    \"name\"\n14  ],\n15  \"examples\": [\n16    {\n17      \"name\": \"Puma\",\n18      \"id\": 1\n19    }\n20  ]\n21}",
      "1type: object\n2properties:\n3  id:\n4    type: integer\n5    format: int64\n6  name:\n7    type: string\n8required:\n9- name\n10examples:\n11- name: Puma\n12  id: 1",
      "1{\n2  \"type\": \"object\",\n3  \"required\": [\n4    \"anySchema\"\n5  ],\n6  \"properties\": {\n7    \"anySchema\": true,\n8    \"cannotBeDefined\": false\n9  }\n10}",
      "1type: object\n2required:\n3- anySchema\n4properties:\n5  anySchema: true\n6  cannotBeDefined: false",
      "1{\n2  \"schemas\": {\n3    \"ErrorModel\": {\n4      \"type\": \"object\",\n5      \"required\": [\n6        \"message\",\n7        \"code\"\n8      ],\n9      \"properties\": {\n10        \"message\": {\n11          \"type\": \"string\"\n12        },\n13        \"code\": {\n14          \"type\": \"integer\",\n15          \"minimum\": 100,\n16          \"maximum\": 600\n17        }\n18      }\n19    },\n20    \"ExtendedErrorModel\": {\n21      \"allOf\": [\n22        {\n23          \"$ref\": \"#/components/schemas/ErrorModel\"\n24        },\n25        {\n26          \"type\": \"object\",\n27          \"required\": [\n28            \"rootCause\"\n29          ],\n30          \"properties\": {\n31            \"rootCause\": {\n32              \"type\": \"string\"\n33            }\n34          }\n35        }\n36      ]\n37    }\n38  }\n39}",
      "1schemas:\n2  ErrorModel:\n3    type: object\n4    required:\n5    - message\n6    - code\n7    properties:\n8      message:\n9        type: string\n10      code:\n11        type: integer\n12        minimum: 100\n13        maximum: 600\n14  ExtendedErrorModel:\n15    allOf:\n16    - $ref: '#/components/schemas/ErrorModel'\n17    - type: object\n18      required:\n19      - rootCause\n20      properties:\n21        rootCause:\n22          type: string",
      "1{\n2  \"schemas\": {\n3    \"Pet\": {\n4      \"type\": \"object\",\n5      \"discriminator\": \"petType\",\n6      \"properties\": {\n7        \"name\": {\n8          \"type\": \"string\"\n9        },\n10        \"petType\": {\n11          \"type\": \"string\"\n12        }\n13      },\n14      \"required\": [\n15        \"name\",\n16        \"petType\"\n17      ]\n18    },\n19    \"Cat\": {\n20      \"description\": \"A representation of a cat. Note that `Cat` will be used as the discriminator value.\",\n21      \"allOf\": [\n22        {\n23          \"$ref\": \"#/components/schemas/Pet\"\n24        },\n25        {\n26          \"type\": \"object\",\n27          \"properties\": {\n28            \"huntingSkill\": {\n29              \"type\": \"string\",\n30              \"description\": \"The measured skill for hunting\",\n31              \"enum\": [\n32                \"clueless\",\n33                \"lazy\",\n34                \"adventurous\",\n35                \"aggressive\"\n36              ]\n37            }\n38          },\n39          \"required\": [\n40            \"huntingSkill\"\n41          ]\n42        }\n43      ]\n44    },\n45    \"Dog\": {\n46      \"description\": \"A representation of a dog. Note that `Dog` will be used as the discriminator value.\",\n47      \"allOf\": [\n48        {\n49          \"$ref\": \"#/components/schemas/Pet\"\n50        },\n51        {\n52          \"type\": \"object\",\n53          \"properties\": {\n54            \"packSize\": {\n55              \"type\": \"integer\",\n56              \"format\": \"int32\",\n57              \"description\": \"the size of the pack the dog is from\",\n58              \"minimum\": 0\n59            }\n60          },\n61          \"required\": [\n62            \"packSize\"\n63          ]\n64        }\n65      ]\n66    },\n67    \"StickInsect\": {\n68      \"description\": \"A representation of an Australian walking stick. Note that `StickBug` will be used as the discriminator value.\",\n69      \"allOf\": [\n70        {\n71          \"$ref\": \"#/components/schemas/Pet\"\n72        },\n73        {\n74          \"type\": \"object\",\n75          \"properties\": {\n76            \"petType\": {\n77              \"const\": \"StickBug\"\n78            },\n79            \"color\": {\n80              \"type\": \"string\"\n81            }\n82          },\n83          \"required\": [\n84            \"color\"\n85          ]\n86        }\n87      ]\n88    }\n89  }\n90}",
      "1schemas:\n2  Pet:\n3    type: object\n4    discriminator: petType\n5    properties:\n6      name:\n7        type: string\n8      petType:\n9        type: string\n10    required:\n11    - name\n12    - petType\n13  ## applies to instances with `petType: \"Cat\"`\n14  ## because that is the schema name\n15  Cat:\n16    description: A representation of a cat\n17    allOf:\n18    - $ref: '#/components/schemas/Pet'\n19    - type: object\n20      properties:\n21        huntingSkill:\n22          type: string\n23          description: The measured skill for hunting\n24          enum:\n25          - clueless\n26          - lazy\n27          - adventurous\n28          - aggressive\n29      required:\n30      - huntingSkill\n31  ## applies to instances with `petType: \"Dog\"`\n32  ## because that is the schema name\n33  Dog:\n34    description: A representation of a dog\n35    allOf:\n36    - $ref: '#/components/schemas/Pet'\n37    - type: object\n38      properties:\n39        packSize:\n40          type: integer\n41          format: int32\n42          description: the size of the pack the dog is from\n43          minimum: 0\n44      required:\n45      - packSize\n46  ## applies to instances with `petType: \"StickBug\"`\n47  ## because that is the required value of the discriminator field,\n48  ## overriding the schema name\n49  StickInsect:\n50    description: A representation of an Australian walking stick\n51    allOf:\n52    - $ref: '#/components/schemas/Pet'\n53    - type: object\n54      properties:\n55        petType:\n56          const: StickBug\n57        color:\n58          type: string\n59      required:\n60      - color",
      "1{\n2  \"type\": \"userPassword\"\n3}",
      "1{\n2  \"type\": \"apiKey\",\n3  \"in\": \"user\"\n4}",
      "1type: apiKey\n2in: user",
      "1{\n2  \"type\": \"X509\"\n3}",
      "1{\n2  \"type\": \"symmetricEncryption\"\n3}",
      "1{\n2  \"type\": \"http\",\n3  \"scheme\": \"basic\"\n4}",
      "1type: http\n2scheme: basic",
      "1{\n2  \"type\": \"httpApiKey\",\n3  \"name\": \"api_key\",\n4  \"in\": \"header\"\n5}",
      "1type: httpApiKey\n2name: api_key\n3in: header",
      "1{\n2  \"type\": \"http\",\n3  \"scheme\": \"bearer\",\n4  \"bearerFormat\": \"JWT\"\n5}",
      "1type: http\n2scheme: bearer\n3bearerFormat: JWT",
      "1{\n2  \"type\": \"oauth2\",\n3  \"flows\": {\n4    \"implicit\": {\n5      \"authorizationUrl\": \"https://example.com/api/oauth/dialog\",\n6      \"availableScopes\": {\n7        \"write:pets\": \"modify pets in your account\",\n8        \"read:pets\": \"read your pets\"\n9      }\n10    }\n11  },\n12  \"scopes\": [\n13    \"write:pets\"\n14  ]\n15}",
      "1type: oauth2\n2flows:\n3  implicit:\n4    authorizationUrl: https://example.com/api/oauth/dialog\n5    availableScopes:\n6      write:pets: modify pets in your account\n7      read:pets: read your pets\n8scopes:\n9  - 'write:pets'",
      "1{\n2  \"type\": \"scramSha512\"\n3}",
      "1{\n2  \"authorizationUrl\": \"https://example.com/api/oauth/dialog\",\n3  \"tokenUrl\": \"https://example.com/api/oauth/token\",\n4  \"availableScopes\": {\n5    \"write:pets\": \"modify pets in your account\",\n6    \"read:pets\": \"read your pets\"\n7  }\n8}",
      "1authorizationUrl: https://example.com/api/oauth/dialog\n2tokenUrl: https://example.com/api/oauth/token\n3availableScopes:\n4  write:pets: modify pets in your account\n5  read:pets: read your pets",
      "1{\n2  \"description\": \"Default Correlation ID\",\n3  \"location\": \"$message.header#/correlationId\"\n4}",
      "1description: Default Correlation ID\n2location: $message.header#/correlationId",
      "1      expression = ( \"$message\" \".\" source )\n2      source = ( header-reference | payload-reference )\n3      header-reference = \"header\" [\"#\" fragment]\n4      payload-reference = \"payload\" [\"#\" fragment]\n5      fragment = a JSON Pointer [RFC 6901](https://tools.ietf.org/html/rfc6901)",
      "1description: A longer description.\n2traits:\n3  - name: UserSignup\n4    description: Description from trait.\n5  - tags:\n6      - name: user",
      "1name: UserSignup\n2description: A longer description.\n3tags:\n4  - name: user"
    ],
    "yaml_blocks": [
      "id: 'urn:example:com:smartylighting:streetlights:server'",
      "id: 'https://github.com/smartylighting/streetlights-server'"
    ],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "fe9acc15",
    "title": "Introduction | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/cli.html",
    "content": "Introduction | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Features CLI flow Introduction Found an error? Have a suggestion? Edit this page on GitHub The AsyncAPI CLI is a command-line tool that provides a set of commands for working with AsyncAPI documents. AsyncAPI is a specification for describing asynchronous APIs, which allows developers to define the structure of messages exchanged between different parts of their applications. The AsyncAPI CLI simplifies creating, validating, bundling, and manipulating AsyncAPI documents, making it easier to work with asynchronous APIs. Features The AsyncAPI CLI offers the following key features: Creation: New AsyncAPI documents can be created from scratch using the CLI, which is useful when starting a new project or creating a new version of an existing API. Validation: AsyncAPI documents can be quickly and easily validated using the AsyncAPI Parser , which ensures that the documents conform to the AsyncAPI specification and catches errors early in the development process. Conversion: The AsyncAPI CLI can convert AsyncAPI documents from one version to another, which is helpful for migrating APIs to a newer version of the AsyncAPI specification. Difference: The AsyncAPI CLI can be used to find the differences between two AsyncAPI documents, which helps compare different versions of an API or identify changes made to an API. Generation: The AsyncAPI CLI leverages AsyncAPI libraries like Generator and Modelina , which allow you to generate various types of documentation, applications, and models in different programming languages. This feature can save significant time and effort when creating new APIs. Optimize: Using Optimizer , the AsyncAPI CLI can be used to optimize an AsyncAPI specification file which can optimize the structure of the AsyncAPI document to make it smaller and without repetition. Start: The AsyncAPI CLI can be used to start AsyncAPI Studio locally, which the user can use to view, edit, and test AsyncAPI documents. To summarize, the AsyncAPI CLI offers the following features and process flow, as shown in the diagram below: CLI flow The following flowchart illustrates the process flow of the AsyncAPI CLI: This flowchart shows the high-level process that occurs when using the AsyncAPI CLI. The user starts by running a command (such as validate , generate , or start ), which the CLI processes. The CLI then performs the corresponding operation (such as validating or generating an AsyncAPI document) and returns the results to the user. If an error occurs, the CLI displays an error message and suggests possible next steps for the user. Go Back Tools - Migrating from `ag` CLI to AsyncAPI CLI Up Next Installation guide Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "193e7536",
    "title": "Introduction | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/generator.html",
    "content": "Introduction | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Generator use cases Generator advantages Generation process Introduction Found an error? Have a suggestion? Edit this page on GitHub The AsyncAPI generator is a tool that generates anything you want using the AsyncAPI Document and Template that are supplied as inputs to the AsyncAPI CLI. The generator was built with extensibility in mind; you can use the generator to generate anything you want, provided that it can be defined in a template, such as code, diagrams, markdown files, microservices, and applications. A number of community-maintained templates are now available for immediate usage. Note: If your primary objective is to generate models/classes for your event-driven architecture apps, use AsyncAPI Modelina , which is supported in the AsyncAPI CLI, instead of using the AsyncAPI Generator. Modelina is specifically designed for model generation and provides utilities for working with the AsyncAPI document. Generator use cases Generation of interactive and understandable API documentation Generation of APIs' client libraries Generation of APIs' boilerplate code Generator advantages Quick to setup and easy to use on a regular basis Effortless generation of complex documents Number of community maintained AsyncAPI templates Generation process The Generator receives the Template and AsyncAPI Document as inputs. The Generator sends to the Parser the asyncapiString which is a stringified version of the original AsyncAPI Document . The Parser uses additional plugins such as the OpenAPI, RAML, or Avro schemas to validate custom schemas of message payloads defined in the AsyncAPI Document . If the Parser determines that the original AsyncAPI Document is valid, it manipulates the document and returns a set of helper functions and properties and bundles them together into an asyncapi variable that is an instance of AsyncAPIDocument . The asyncapi helper functions make it easier to access the contents of the AsyncAPI Document. At this point, the Generator passes the asyncapi , the originalAsyncAPI , and the params which collectively make up the Template Context to the Render Engine . AsyncAPI has two Render Engines ( react and nunjucks ). Depending on which one you've specified in your package.json , the Generator knows the right Render Engine to pass both the Template Files and the Template Context . Once the Render Engine receives the Template Files and the Template Context , it injects all the dynamic values in your react or nunjucks based Template Files using the Template Context . As a result, the Render Engine generates markdown , pdf , boilerplate code , and anything else you specified to be generated as output. You can generate anything you want using the generator as long as it can be defined in a Template . The diagram below depicts the entire process of passing the Template and AsyncAPI Document to the AsyncAPI generator tool, how the generator uses these inputs to generate the desired output, and example outputs you can get from the render engine. params are template-specific options passed to the asyncapi generate fromTemplate CLI command to customize the generated output. Go Back Tools - Overview Up Next Installation guide Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "32c4bab7",
    "title": "Kickstarting Your Journey with Glee | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/glee.html",
    "content": "Kickstarting Your Journey with Glee | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Welcome to Glee Application structure Kickstarting Your Journey with Glee Found an error? Have a suggestion? Edit this page on GitHub Welcome to Glee Glee introduces a refreshing approach to building server-side applications, emphasizing a spec-first methodology. This means your journey begins with defining the API specification (AsyncAPI) before writing a single line of application logic. Here's how Glee enhances your development experience: Always Updated Documentation : Glee aligns your codebase with the AsyncAPI definition, ensuring your API documentation is constantly updated and reflective of your application's current capabilities. Developer Centricity : With Glee, your focus remains on the business logic. Leave the concerns of performance, scalability, and resilience to Glee, as it equips your application to be production-ready from the get-go. Schema Validation : Glee rigorously checks incoming payloads against the schema outlined in your AsyncAPI document. Any discrepancies result in an error, maintaining the integrity and reliability of your server's data processing. Before you dive into Glee, let's explore its application structure and understand what makes Glee unique. Application structure Glee expects your project to have some files and folders with special names. When you run asyncapi new glee , AsyncAPI CLI generates a boilerplate application structure by creating a new folder and populating an initial set of files as shown below. You can continue working in this default structure, adding new components, as described throughout the documentation of asyncapi cli. \n```javascript\n1\u251c\u2500 functions          (required)\n2\u2502  \u251c\u2500 onHello.js\n3\u2502  \u2514\u2500 ...\n4\u251c\u2500 lifecycle          (optional)\n5\u2502  \u251c\u2500 onConnect.js\n6\u2502  \u2514\u2500 ...\n7\u251c\u2500 .env               (optional)\n8\u251c\u2500 asyncapi.(yaml | yml | json)      (required)\n9\u251c\u2500 glee.config.js     (optional)\n10\u251c\u2500 package.json       (required)\n```\n File/Directory Description functions Required. This directory contains all the functions that Glee must execute when it receives a message from the server. Each file must export a default async function. lifecycle This directory contains application lifecycle functions. These functions will be executed when certain events happen in the application. E.g., onConnect , onServerReady , onDisconnect , etc. .env The environment variables of your application. DO NOT PUT SECRETS HERE . asyncapi.(yaml or json or yml) Required. The AsyncAPI file defines your API. Make sure all the receive operations have a name that matches a file name (excluding the extension) in the functions directory. glee.config.js The Glee configuration file . package.json Required. The Node.js package definition file. Make sure you include @asyncapi/glee as a dependency and add two scripts: dev and start . They should be running glee dev and glee start respectively. To understand the structure in a broader way, please refer to the associated page's links. Go Back Tools - Metrics Collection Up Next Building Your First Glee Application Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1\u251c\u2500 functions          (required)\n2\u2502  \u251c\u2500 onHello.js\n3\u2502  \u2514\u2500 ...\n4\u251c\u2500 lifecycle          (optional)\n5\u2502  \u251c\u2500 onConnect.js\n6\u2502  \u2514\u2500 ...\n7\u251c\u2500 .env               (optional)\n8\u251c\u2500 asyncapi.(yaml | yml | json)      (required)\n9\u251c\u2500 glee.config.js     (optional)\n10\u251c\u2500 package.json       (required)"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "09699d01",
    "title": "CLI Architecture | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/cli/architecture.html",
    "content": "CLI Architecture | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Detailed Explanation of Key Directories in the CLI src/commands/ src/core/ test/ Use Cases CLI Architecture Found an error? Have a suggestion? Edit this page on GitHub The AsyncAPI CLI uses oclif (Open CLI Framework) as its core framework, which enables developers to build powerful and scalable command-line applications. Structure of the AsyncAPI CLI : The CLI is primarily divided into two components: commands and the core part. Command Component : The commands include all the necessary functionalities that help developers interact with features like creating new AsyncAPI projects, validating AsyncAPI files, formatting AsyncAPI files, and more. Core Component : The core part of the CLI contains various utilities that facilitate the efficient creation of new commands. Detailed Explanation of Key Directories in the CLI src/commands/ Purpose: Implements the CLI commands available to the user. Subdirectories: config/ : Stores configuration-related files for commands. generate/ : Generates typed models or other artifacts like clients, applications, or documentation using AsyncAPI Generator templates. Files: fromTemplate.ts : Contains logic for generating files using templates. models.ts : Defines the models used during generation. new/ : Create a new AsyncAPI project, specification files, or templates for clients and applications. Files: file.ts : Handles file creation logic. glee.ts : Related to Glee, a tool for event-driven microservices. template.ts : Manages templates for new projects. start/ : Implements starting functionalities like launching a local server or studio. Files: studio.ts : Integrates with the AsyncAPI Studio. Standalone Files: bundle.ts : Bundles one or multiple AsyncAPI documents and their references together. convert.ts : Converts AsyncAPI documents from older to newer versions or transforms OpenAPI/Postman-collection documents into AsyncAPI. diff.ts : Compares two AsyncAPI documents. format.ts : Converts AsyncAPI documents from any format to YAML, YML, or JSON. optimize.ts : Optimizes AsyncAPI documents for performance. pretty.ts : Beautifies the AsyncAPI spec file (indentation, styling) in place or outputs the formatted spec to a new file. validate.ts : Validates AsyncAPI documents for correctness. src/core/ Purpose: Provides foundational components and utilities for the CLI. Subdirectories: errors/ : Centralized error definitions. flags/ : Defines CLI flags and their behavior. hooks/ : Event hooks used for customization. models/ : Core data models used across the application. utils/ : Utility functions for common operations. Standalone Files: base.ts : Base class or logic for CLI commands. global.d.ts : Global TypeScript definitions. globals.ts : Stores global variables and configurations. parser.ts : Parses AsyncAPI documents. test/ Purpose: Implements the test suite for the CLI. Subdirectories: fixtures/ : Contains mock data or files for testing. hooks/ : Tests related to hooks. integration/ : Integration tests to verify end-to-end functionality. system/ : System-level tests. unit/ : Unit tests for individual modules or functions. Use Cases Generate AsyncAPI Artifacts: Use the generate command to create client/server code, documentation, or other artifacts based on AsyncAPI templates. Create New Projects: The new command helps users scaffold new AsyncAPI projects with predefined templates. Validate AsyncAPI Documents: The validate command ensures AsyncAPI documents conform to the specification. Optimize and Format Documents: The optimize and pretty commands provide tools for improving document readability and performance. Compare Documents: The diff command enables comparison between two AsyncAPI documents to track changes. Integration with AsyncAPI Studio: The start command integrates with the AsyncAPI Studio for editing and visualizing documents. Convert Between Formats: The convert command supports converting AsyncAPI documents between formats like YAML and JSON. This structure ensures the CLI is modular, scalable, and easy to maintain. Let me know if you need further clarification or additional details! Go Back Auto-complete setup Up Next Usage Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "0267018e",
    "title": "Auto-complete setup | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/cli/autocompleteEnabled.html",
    "content": "Auto-complete setup | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page AsyncAPI CLI Autocomplete Setup Automatic Setup (Post-Install Script) Steps: Manual Setup (For PowerShell and Troubleshooting) Steps: Auto-complete setup Found an error? Have a suggestion? Edit this page on GitHub AsyncAPI CLI Autocomplete Setup This guide provides steps to enable autocomplete for the AsyncAPI CLI. The setup supports zsh , bash , and PowerShell (manual setup only). Automatic Setup (Post-Install Script) The AsyncAPI CLI includes a post-install script that automatically configures autocomplete for supported shells ( zsh and bash ). No additional steps are required. Steps: Ensure that AsyncAPI CLI is installed. You can verify by running: asyncapi --version If the command fails, install it using: npm install -g @asyncapi/cli Apply the changes by running: \n```javascript\n1source ~/.bashrc   # For bash\n2source ~/.zshrc    # For zsh\n```\n Verify autocomplete by typing: asyncapi < TAB > You should see command suggestions. Manual Setup (For PowerShell and Troubleshooting) If the automatic setup does not work or if you need to enable autocomplete manually (especially for PowerShell), follow these steps. Steps: Build the AsyncAPI CLI manually: If you are working with the CLI project locally, you need to build it first: \n```javascript\n1npm install\n2npm run build\n```\n Run the autocomplete command manually: \n```javascript\n./bin/run autocomplete  # Run this from the project root folder\n```\n Locate the AsyncAPI CLI executable: Run the following command to find the executable path: \n```javascript\n1which asyncapi   # For bash/zsh\n2Get-Command asyncapi | Select-Object -ExpandProperty Definition   # For PowerShell\n```\n If the command does not return a path, ensure AsyncAPI CLI is installed. Generate and apply the autocomplete script: Run the following command based on your shell: \n```javascript\n1printf \"$(./bin/run autocomplete script bash)\" >> ~/.bashrc; source ~/.bashrc   # For bash\n2printf \"$(./bin/run autocomplete script zsh)\" >> ~/.zshrc; source ~/.zshrc       # For zsh\n3printf \"$(./bin/run autocomplete script powershell)\" >> $PROFILE; . $PROFILE    # For PowerShell\n```\n Test autocomplete: asyncapi < TAB > If it works, autocomplete is successfully enabled! If you encounter any issues, ensure that your shell configuration file is correctly updated and sourced. Restart your terminal if necessary. Go Back Installation guide Up Next CLI Architecture Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1source ~/.bashrc   # For bash\n2source ~/.zshrc    # For zsh",
      "1npm install\n2npm run build",
      "./bin/run autocomplete  # Run this from the project root folder",
      "1which asyncapi   # For bash/zsh\n2Get-Command asyncapi | Select-Object -ExpandProperty Definition   # For PowerShell",
      "1printf \"$(./bin/run autocomplete script bash)\" >> ~/.bashrc; source ~/.bashrc   # For bash\n2printf \"$(./bin/run autocomplete script zsh)\" >> ~/.zshrc; source ~/.zshrc       # For zsh\n3printf \"$(./bin/run autocomplete script powershell)\" >> $PROFILE; . $PROFILE    # For PowerShell"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "19e989b7",
    "title": "Context concept | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/cli/context.html",
    "content": "Context concept | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Overview Context File location How to add context to a project Manually Using CLI's init command Setup example in a real project Context File structure Fixed Fields Store Object Minimal Empty Context File Context File Example More context related CLI options Context concept Found an error? Have a suggestion? Edit this page on GitHub Overview AsyncAPI CLI provides functionality called context . It's purpose is to help to work with AsyncAPI CLI in large projects where you do not have just one service exposing AsyncAPI document, but multiple. Event driven architecture involves multiple actors, subscribers and publishers. One time you want to validate document A and the other time you want to generate models from document B . Every time you do it, you need to provide to AsyncAPI CLI the location of the AsyncAPI document, which might be time consuming. You can workaround it with aliases in bash profiles or with other solutions but it is better to use context feature, as you can then store it in your repository and share with other team members. In short it means that for example instead of writing asyncapi validate /some/folder/my-asyncapi.yml you can create a context called myasync that will be an alias for and point to /some/folder/my-asyncapi.yml . This way next time you use the CLI you can do asyncapi validate myasync . Context File location You can have a global context for your workstation, and a project specific context. If your use case is that you work with multiple repositories, you might want to use a global context. The .asyncapi-cli context file is then located in your home directory. You can also store your custom .asyncapi-cli file in your project with custom configuration. This way when you run asyncapi config context add inside your project, the new context is added to the context file under your project. How to add context to a project Manually Create file .asyncapi-cli containing minimal empty context file in: current directory root of current repository user's home directory Using CLI's init command asyncapi config context init [CONTEXT-FILE-PATH] Where [CONTEXT-FILE-PATH] instructs CLI what directory should the file .asyncapi-cli containing minimal empty context file be created in: current directory: asyncapi config context init . (default) root of current repository: asyncapi config context init ./ user's home directory: asyncapi config context init ~ (if [CONTEXT-FILE-PATH] is omitted, empty context file is created in current directory) Make use of newly created .asyncapi-cli by executing command: asyncapi config context add [CONTEXT-NAME] [SPEC-FILE-PATH] Setup example in a real project Below you can see an example of context setup for Event Driven Flight status notification service of the Amadeus Airline Platform , with multiple microservices and their AsyncAPI documents. \n```javascript\n1# One-time initialization of '.asyncapi-cli' file\n2(main)$ asyncapi config context init\n3Initialized context /amadeus-async-flight-status/.asyncapi-cli\n4\n5# Adding first context\n6(main)$ asyncapi config context add subscriber subscriber/asyncapi.yaml\n7Added context \"subscriber\".\n8You can set it as your current context: asyncapi config context use subscriber\n9You can use this context when needed by passing subscriber as a parameter: asyncapi validate subscriber\n10\n11# Adding more contexts\n12(main)$ asyncapi config context add notifier notifier/asyncapi.yaml\n13Added context \"notifier\".\n14You can set it as your current context: asyncapi config context use notifier\n15You can use this context when needed by passing notifier as a parameter: asyncapi validate notifier\n16\n17(main)$ asyncapi config context add monitor monitor/asyncapi.yaml\n18Added context \"monitor\".\n19You can set it as your current context: asyncapi config context use monitor\n20You can use this context when needed by passing monitor as a parameter: asyncapi validate monitor\n21\n22# Setting monitor as default context\n23(main)$ asyncapi config context use monitor\n24monitor is set as current\n25\n26# Now you do not even have to remember the context name, and default 'monitor/asyncapi.yaml' will be validated\n27(main)$ asyncapi validate\n28File monitor/asyncapi.yaml is valid but has (itself and/or referenced documents) governance issues.\n29monitor/asyncapi.yaml\n30  1:1       warning  asyncapi-defaultContentType      AsyncAPI document should have \"defaultContentType\" field.\n31  1:1       warning  asyncapi-id                      AsyncAPI document should have \"id\" field.\n32  1:1       warning  asyncapi2-tags                   AsyncAPI object should have non-empty \"tags\" array.\n33  1:11  information  asyncapi-latest-version          The latest version of AsyncAPi is not used. It is recommended update to the \"2.6.0\" version.  asyncapi\n34  2:6       warning  asyncapi-info-contact            Info object should have \"contact\" object.                                                     info\n35 19:15      warning  asyncapi2-operation-operationId  Operation should have an \"operationId\" field defined.                                         channels.flight/update.subscribe\n36 26:13      warning  asyncapi2-operation-operationId  Operation should have an \"operationId\" field defined.                                         channels.flight/queue.publish\n37\u2716 7 problems (0 errors, 6 warnings, 1 info, 0 hints)\n38\n39# You can now use context name when running AsyncAPI commands, no need to remember file location like 'notifier/asyncapi.yaml'\n40(main)$ asyncapi validate notifier\n41File notifier/asyncapi.yaml is valid but has (itself and/or referenced documents) governance issues.\n42notifier/asyncapi.yaml\n43  1:1       warning  asyncapi-defaultContentType      AsyncAPI document should have \"defaultContentType\" field.\n44  1:1       warning  asyncapi-id                      AsyncAPI document should have \"id\" field.\n45  1:1       warning  asyncapi2-tags                   AsyncAPI object should have non-empty \"tags\" array.\n46  1:11  information  asyncapi-latest-version          The latest version of AsyncAPi is not used. It is recommended update to the \"2.6.0\" version.  asyncapi\n47  2:6       warning  asyncapi-info-contact            Info object should have \"contact\" object.                                                     info\n48 18:13      warning  asyncapi2-operation-operationId  Operation should have an \"operationId\" field defined.                                         channels.flight/update.publish\n49\u2716 6 problems (0 errors, 5 warnings, 1 info, 0 hints)\n50\n51# Switch default context \n52(main)$ asyncapi config context use notifier\n53notifier is set as current\n54\n55# List all contexts\n56(main)$ asyncapi config context list\n57monitor: monitor/asyncapi.yaml\n58notifier: notifier/asyncapi.yaml\n59subscriber: subscriber/asyncapi.yaml\n```\n Context File structure Fixed Fields Field Name Type Description current string An optional string value representing one of context names, which is used as default in CLI. Default means you can run CLI commands without providing context name, like asyncapi validate , and it will run against the default - current - context. store Store Object REQUIRED . Map of filesystem paths to target AsyncAPI documents. Store Object Map of filesystem paths to target AsyncAPI documents. Patterned Fields Field Pattern Type Description {contextName} string An optional string value representing filesystem path to the target AsyncAPI document. Minimal Empty Context File Raw JSON: \n```javascript\n1{\n2  \"store\": {}\n3}\n```\n Stringified JSON: { \"store\" : {}} Context File Example Example of a context file for Event Driven Flight status notification service of the Amadeus Airline Platform , with multiple microservices and their AsyncAPI documents: \n```javascript\n1{\n2  \"current\": \"monitor\",\n3  \"store\": {\n4    \"monitor\": \"monitor/asyncapi.yaml\",\n5    \"notifier\": \"notifier/asyncapi.yaml\",\n6    \"subscriber\": \"subscriber/asyncapi.yaml\"\n7  }\n8}\n```\n More context related CLI options All commands for managing contexts are available under asyncapi config context CLI commands group . Go Back GitHub Action for CLI Up Next Metrics Collection Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1# One-time initialization of '.asyncapi-cli' file\n2(main)$ asyncapi config context init\n3Initialized context /amadeus-async-flight-status/.asyncapi-cli\n4\n5# Adding first context\n6(main)$ asyncapi config context add subscriber subscriber/asyncapi.yaml\n7Added context \"subscriber\".\n8You can set it as your current context: asyncapi config context use subscriber\n9You can use this context when needed by passing subscriber as a parameter: asyncapi validate subscriber\n10\n11# Adding more contexts\n12(main)$ asyncapi config context add notifier notifier/asyncapi.yaml\n13Added context \"notifier\".\n14You can set it as your current context: asyncapi config context use notifier\n15You can use this context when needed by passing notifier as a parameter: asyncapi validate notifier\n16\n17(main)$ asyncapi config context add monitor monitor/asyncapi.yaml\n18Added context \"monitor\".\n19You can set it as your current context: asyncapi config context use monitor\n20You can use this context when needed by passing monitor as a parameter: asyncapi validate monitor\n21\n22# Setting monitor as default context\n23(main)$ asyncapi config context use monitor\n24monitor is set as current\n25\n26# Now you do not even have to remember the context name, and default 'monitor/asyncapi.yaml' will be validated\n27(main)$ asyncapi validate\n28File monitor/asyncapi.yaml is valid but has (itself and/or referenced documents) governance issues.\n29monitor/asyncapi.yaml\n30  1:1       warning  asyncapi-defaultContentType      AsyncAPI document should have \"defaultContentType\" field.\n31  1:1       warning  asyncapi-id                      AsyncAPI document should have \"id\" field.\n32  1:1       warning  asyncapi2-tags                   AsyncAPI object should have non-empty \"tags\" array.\n33  1:11  information  asyncapi-latest-version          The latest version of AsyncAPi is not used. It is recommended update to the \"2.6.0\" version.  asyncapi\n34  2:6       warning  asyncapi-info-contact            Info object should have \"contact\" object.                                                     info\n35 19:15      warning  asyncapi2-operation-operationId  Operation should have an \"operationId\" field defined.                                         channels.flight/update.subscribe\n36 26:13      warning  asyncapi2-operation-operationId  Operation should have an \"operationId\" field defined.                                         channels.flight/queue.publish\n37\u2716 7 problems (0 errors, 6 warnings, 1 info, 0 hints)\n38\n39# You can now use context name when running AsyncAPI commands, no need to remember file location like 'notifier/asyncapi.yaml'\n40(main)$ asyncapi validate notifier\n41File notifier/asyncapi.yaml is valid but has (itself and/or referenced documents) governance issues.\n42notifier/asyncapi.yaml\n43  1:1       warning  asyncapi-defaultContentType      AsyncAPI document should have \"defaultContentType\" field.\n44  1:1       warning  asyncapi-id                      AsyncAPI document should have \"id\" field.\n45  1:1       warning  asyncapi2-tags                   AsyncAPI object should have non-empty \"tags\" array.\n46  1:11  information  asyncapi-latest-version          The latest version of AsyncAPi is not used. It is recommended update to the \"2.6.0\" version.  asyncapi\n47  2:6       warning  asyncapi-info-contact            Info object should have \"contact\" object.                                                     info\n48 18:13      warning  asyncapi2-operation-operationId  Operation should have an \"operationId\" field defined.                                         channels.flight/update.publish\n49\u2716 6 problems (0 errors, 5 warnings, 1 info, 0 hints)\n50\n51# Switch default context \n52(main)$ asyncapi config context use notifier\n53notifier is set as current\n54\n55# List all contexts\n56(main)$ asyncapi config context list\n57monitor: monitor/asyncapi.yaml\n58notifier: notifier/asyncapi.yaml\n59subscriber: subscriber/asyncapi.yaml",
      "1{\n2  \"store\": {}\n3}",
      "1{\n2  \"current\": \"monitor\",\n3  \"store\": {\n4    \"monitor\": \"monitor/asyncapi.yaml\",\n5    \"notifier\": \"notifier/asyncapi.yaml\",\n6    \"subscriber\": \"subscriber/asyncapi.yaml\"\n7  }\n8}"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "e9edec2a",
    "title": "GitHub Action for CLI | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/cli/github-action.html",
    "content": "GitHub Action for CLI | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Inputs cli_version command custom_command filepath template language output parameters Example usage Basic Using all possible inputs Example workflow with publishing generated HTML to GitHub Pages Example workflow for generating models Example workflow for validating AsyncAPI document changes Local dry run Troubleshooting GitHub Action for CLI Found an error? Have a suggestion? Edit this page on GitHub This action exposes the AsyncAPI CLI . It allows you to generate documentation, validate AsyncAPI documents, convert between different AsyncAPI versions and much more. The source code of the action can be found here Inputs cli_version Version of the AsyncAPI CLI you wish to use. You can find all available versions here . Recommended leave it out of the inputs and use the default value. Default points to the latest version. [!TIP] We recommend to default to latest version. This way there is no overhead with the script updating the CLI version. As it takes a lot of time to update the CLI version, we recommend to update it only when you need to use another one for compatibility reasons. command Command that you wish to run. You can find all available commands Available commands are: generate - generates documentation from AsyncAPI document validate - validates AsyncAPI document optimize - optimizes AsyncAPI document convert - converts AsyncAPI document to another version custom - allows you to run any command that is available in the AsyncAPI CLI. You can find all available commands here . Default points to generate command. [!IMPORTANT] In case you want to use custom command, you need to pass an array of commands to the custom_command input. Although passing command is not required, it is recommended to pass it to avoid any issues later on. For example, if you want to run asyncapi bundle ./asyncapi.yaml --output final-asyncapi.yaml you need to pass \"bundle ./asyncapi.yaml --output final-asyncapi.yaml\" to the custom_command` input. custom_command In case you want to use custom command you need to pass the command that you want to run in this input. You can find all available commands here . Default points to '' (empty string). Sample usage: \n```javascript\n1- name: Generating HTML from my AsyncAPI document\n2  uses: asyncapi/cli@v2.16.0# You can use any version you want\n3  with:\n4    custom_command: bundle ./asyncapi.yaml --output final-asyncapi.yaml\n```\n [!CAUTION] You have to pass the whole command as a string including the parameters and the command itself. It will run like this: asyncapi <custom_command> filepath Path to the AsyncAPI document that you want to process. Default expects the AsyncAPI document to be in the root of the repository and named asyncapi.yaml . template Template for the generator. Official templates are listed here https://github.com/asyncapi/generator#list-of-official-generator-templates . You can pass template as npm package, url to git repository, link to tar file or local template. Default points to @asyncapi/markdown-template@0.10.0 template. [!TIP] We recommend to always specify the version of the template to not encounter any issues with the action in case of release of the template that is not compatible with given version of the generator. language Specifies the language to be used for the generated models. The value must be a valid language name supported by modelina . Default is not set. [!WARNING] Either language or template must be set else an error will be thrown. The action will return an error if the language is not supported by modelina . output Path to the output directory. Can be used for generate and convert commands. Default points to output directory in the root of the repository. parameters The command that you use might support and even require specific parameters to be passed to the CLI for the generation. You can find all available parameters here . Default points to '' (empty string). [!NOTE] For template parameters, you need to pass them as -p <template_parameters> as can be seen in CLI documentation. Example usage [!WARNING] Using docker://asyncapi/github-action-for-cli will not work as expected. This is because the GitHub Actions runner does not pass params to the docker image correctly. This is why we recommend to use asyncapi/cli instead. However, you don't need to worry as it won't build the image every time. It will pull it from Docker Hub as it is already built there. Basic In case all defaults are fine for you, just add such step: \n```javascript\n1- name: Generating Markdown from my AsyncAPI document\n2  uses: asyncapi/cli@v2.16.0 # You can use any version you want\n```\n Using all possible inputs In case you do not want to use defaults, you for example want to use different template: \n```javascript\n1- name: Generating HTML from my AsyncAPI document\n2  uses: asyncapi/cli@v2.16.0 # You can use any version you want\n3  with:\n4    command: generate\n5    filepath: ./docs/api/asyncapi.yaml\n6    template: \"@asyncapi/html-template@0.9.0\" #In case of template from npm. Or can use a link.\n7    output: ./generated-html\n8    parameters: \"-p baseHref=/test-experiment/ sidebarOrganization=byTags\"\n```\n [!IMPORTANT] Note the usage of -p in parameters input. This is required for template parameters, unlike previous versions of this action as the action includes other commands than just generate . Example workflow with publishing generated HTML to GitHub Pages In case you want to validate your asyncapi file first, and also send generated HTML to GitHub Pages this is how full workflow could look like: \n```javascript\n1name: AsyncAPI documents processing\n2\n3on:\n4  push:\n5    branches: [ master ]\n6\n7jobs:\n8  generate:\n9    runs-on: ubuntu-latest\n10    steps:\n11    #\"standard step\" where repo needs to be checked-out first\n12    - name: Checkout repo\n13      uses: actions/checkout@v2\n14      \n15    #In case you do not want to use defaults, you for example want to use different template\n16    - name: Generating HTML from my AsyncAPI document\n17      uses: asyncapi/cli@v2.16.0 # You can use any version you want\n18      with:\n19        template: '@asyncapi/html-template@0.9.0'  #In case of template from npm, because of @ it must be in quotes\n20        filepath: docs/api/my-asyncapi.yml\n21        parameters: -p baseHref=/test-experiment/ sidebarOrganization=byTags #space separated list of key/values\n22        output: generated-html\n23      \n24    #Using another action that takes generated HTML and pushes it to GH Pages\n25    - name: Deploy GH page\n26      uses: JamesIves/github-pages-deploy-action@3.4.2\n27      with:\n28        ACCESS_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n29        BRANCH: gh-pages\n30        FOLDER: generated-html\n```\n Example workflow for generating models In case you want to use models generated from your AsyncAPI document, you can use this action to generate them and then use them in your workflow. This is how full workflow could look like: \n```javascript\n1\n2name: AsyncAPI documents processing\n3\n4on:\n5  push:\n6    branches: [ master ]\n7\n8jobs:\n9  generate-models:\n10    runs-on: ubuntu-latest\n11    steps:\n12    #\"standard step\" where repo needs to be checked-out first\n13    - name: Checkout repo\n14      uses: actions/checkout@v2\n15      \n16    - name: Generating models from my AsyncAPI document\n17      uses: asyncapi/cli@v2.16.0 # You can use any version you want\n18      with:\n19        command: generate\n20        filepath: docs/api/my-asyncapi.yml\n21        language: typescript\n22        output: generated-models\n```\n Example workflow for validating AsyncAPI document changes In case you want to validate your AsyncAPI document changes, you can use this action to validate them and then use them in your workflow. This is how full workflow could look like: \n```javascript\n1name: Validate AsyncAPI document\n2\n3on:\n4  pull_request:\n5    branches: [ master ]\n6\n7jobs:\n8  validate:\n9    runs-on: ubuntu-latest\n10    steps:\n11    #\"standard step\" where repo needs to be checked-out first\n12    - name: Checkout repo\n13      uses: actions/checkout@v2\n14      \n15    - name: Validating AsyncAPI document\n16      uses: asyncapi/cli@v2.16.0 # You can use any version you want\n17      with:\n18        command: validate\n19        filepath: docs/api/my-asyncapi.yml\n```\n Local dry run Use following commands to run and test github action locally: Build docker image of github action for cli npm run action:docker:build Execute docker image with proper arguments \n```javascript\ndocker run -e GITHUB_WORKSPACE=\"\" --workdir /action  -v \"/home/{user}/path/to/repo\":\"/action\" asyncapi/github-action-for-cli  \"\" \"generate\" \"github-action/test/asyncapi.yml\" \"@asyncapi/markdown-template@0.10.0\" \"\" \"output\" \"\" \"\"\n```\n Make sure to change the path of the repo and user in the command. Troubleshooting You can enable more log information in GitHub Action by adding ACTIONS_STEP_DEBUG secret to repository where you want to use this action. Set the value of this secret to true and you''ll notice more debug logs from this action. Go Back Usage Up Next Context concept Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1- name: Generating HTML from my AsyncAPI document\n2  uses: asyncapi/cli@v2.16.0# You can use any version you want\n3  with:\n4    custom_command: bundle ./asyncapi.yaml --output final-asyncapi.yaml",
      "1- name: Generating Markdown from my AsyncAPI document\n2  uses: asyncapi/cli@v2.16.0 # You can use any version you want",
      "1- name: Generating HTML from my AsyncAPI document\n2  uses: asyncapi/cli@v2.16.0 # You can use any version you want\n3  with:\n4    command: generate\n5    filepath: ./docs/api/asyncapi.yaml\n6    template: \"@asyncapi/html-template@0.9.0\" #In case of template from npm. Or can use a link.\n7    output: ./generated-html\n8    parameters: \"-p baseHref=/test-experiment/ sidebarOrganization=byTags\"",
      "1name: AsyncAPI documents processing\n2\n3on:\n4  push:\n5    branches: [ master ]\n6\n7jobs:\n8  generate:\n9    runs-on: ubuntu-latest\n10    steps:\n11    #\"standard step\" where repo needs to be checked-out first\n12    - name: Checkout repo\n13      uses: actions/checkout@v2\n14      \n15    #In case you do not want to use defaults, you for example want to use different template\n16    - name: Generating HTML from my AsyncAPI document\n17      uses: asyncapi/cli@v2.16.0 # You can use any version you want\n18      with:\n19        template: '@asyncapi/html-template@0.9.0'  #In case of template from npm, because of @ it must be in quotes\n20        filepath: docs/api/my-asyncapi.yml\n21        parameters: -p baseHref=/test-experiment/ sidebarOrganization=byTags #space separated list of key/values\n22        output: generated-html\n23      \n24    #Using another action that takes generated HTML and pushes it to GH Pages\n25    - name: Deploy GH page\n26      uses: JamesIves/github-pages-deploy-action@3.4.2\n27      with:\n28        ACCESS_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n29        BRANCH: gh-pages\n30        FOLDER: generated-html",
      "1\n2name: AsyncAPI documents processing\n3\n4on:\n5  push:\n6    branches: [ master ]\n7\n8jobs:\n9  generate-models:\n10    runs-on: ubuntu-latest\n11    steps:\n12    #\"standard step\" where repo needs to be checked-out first\n13    - name: Checkout repo\n14      uses: actions/checkout@v2\n15      \n16    - name: Generating models from my AsyncAPI document\n17      uses: asyncapi/cli@v2.16.0 # You can use any version you want\n18      with:\n19        command: generate\n20        filepath: docs/api/my-asyncapi.yml\n21        language: typescript\n22        output: generated-models",
      "1name: Validate AsyncAPI document\n2\n3on:\n4  pull_request:\n5    branches: [ master ]\n6\n7jobs:\n8  validate:\n9    runs-on: ubuntu-latest\n10    steps:\n11    #\"standard step\" where repo needs to be checked-out first\n12    - name: Checkout repo\n13      uses: actions/checkout@v2\n14      \n15    - name: Validating AsyncAPI document\n16      uses: asyncapi/cli@v2.16.0 # You can use any version you want\n17      with:\n18        command: validate\n19        filepath: docs/api/my-asyncapi.yml",
      "docker run -e GITHUB_WORKSPACE=\"\" --workdir /action  -v \"/home/{user}/path/to/repo\":\"/action\" asyncapi/github-action-for-cli  \"\" \"generate\" \"github-action/test/asyncapi.yml\" \"@asyncapi/markdown-template@0.10.0\" \"\" \"output\" \"\" \"\""
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "dbaeef97",
    "title": "Installation guide | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/cli/installation.html",
    "content": "Installation guide | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Node and npm Docker Mac brew pkg Windows Chocolatey Executable files Linux Debian based distros Other distros Installation guide Found an error? Have a suggestion? Edit this page on GitHub Node and npm To use the AsyncAPI CLI tool, you must install NPM and Node.js version 16 or higher. To check if you already have both installed, run the following commands in your terminal: \n```javascript\n1# check if node is installed\n2node -v\n3# or\n4node --version\n5\n6# check if NPM is installed\n7npm -v\n8# or\n9npm --version\n```\n If you don\u2019t have Node.js or NPM installed, you can install both with this Node.js package manager . After installing Node.js and NPM, run the following command to install the AsyncAPI ClI globally: npm install -g @asyncapi/cli To enable the autocomplete feature in the CLI for the shells bash and zshrc , there is a script that will run automatically and autocomplete is only support for bash and zshrc for the powershell refer to manually enabling autocomplete guide in ClI: After the ClI installation : if the configuration is not present logs will be: \u2705 Autocomplete configuration added to .zshrc. If the configuration is present for autocomplete logs: \n```javascript\n\u2705 Autocomplete is already configured. Skipping addition.\n```\n To refresh the variables: \n```javascript\n1 source ~/.bashrc   # For bash\n2 source ~/.zshrc    # For zsh\n```\n Docker Install Docker first, then use docker to build the image using the following command : docker build -t asyncapi/cli:latest . and run the image using the following command : \n```javascript\n1docker run --rm -it \\\n2--user=root \\\n3-v [ASYNCAPI SPEC FILE LOCATION]:/app/asyncapi.yml \\\n4-v [GENERATED FILES LOCATION]:/app/output \\\n5asyncapi/cli [COMMAND HERE]\n6\n7# Example that you can run inside the cli directory after cloning this repository. First, you specify the mount in the location of your AsyncAPI specification file and then you mount it in the directory where the generation result should be saved.\n8docker run --rm -it \\\n9   --user=root \\\n10   -v ${PWD}/test/integration/fixtures/asyncapi_v1.yml:/app/asyncapi.yml \\\n11   -v ${PWD}/output:/app/output \\\n12   asyncapi/cli generate fromTemplate -o /app/output /app/asyncapi.yml @asyncapi/html-template --force-write\n```\n Note: Use ` instead of \\ for Windows. Mac There are two ways to install the AsyncAPI CLI on your macOS: using the brew package manager or pkg files. brew To install the AsyncAPI CLI using the brew package manager, run the following commands in your terminal: \n```javascript\n1# Install brew\n2/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n3\n4# Install AsyncAPI CLI\n5brew install asyncapi\n```\n pkg Every release of the AsyncAPI CLI has two macOS dedicated pkg file that enables you to install the CLI tool as a macOS application for x64 as well as arm64 architecture. To download the latest CLI release, run this command in your terminal: \n```javascript\n1# For x64\n2curl -OL https://github.com/asyncapi/cli/releases/latest/download/asyncapi.x64.pkg\n3\n4# For arm64\n5curl -OL https://github.com/asyncapi/cli/releases/latest/download/asyncapi.arm64.pkg\n```\n To download a specific CLI release, run this command in your terminal: \n```javascript\ncurl -OL https://github.com/asyncapi/cli/releases/download/<replace this with the specific CLI version e.g v0.13.0>/asyncapi.pkg\n```\n Remember Follow this link for all AsyncAPI CLI releases . After downloading the AsyncAPI CLI, install it via the following command: sudo installer -pkg asyncapi.pkg - target / Windows There are two ways to install the AsyncAPI CLI on your Windows operating system: using the chocolatey package manager or executable files. Chocolatey Prerequisites: Chocolatey must be installed on your Windows operating system. The installation instructions can be found here . To install the AsyncAPI CLI using the chocolatey package manager, run the following command in your terminal with administrator privileges: \n```javascript\n1# Install AsyncAPI CLI\n2choco install asyncapi\n```\n To upgrade run this command:- \n```javascript\n1# Upgrade AsyncAPI CLI\n2choco upgrade asyncapi\n```\n To install a specific version run this command: \n```javascript\n1# Install AsyncAPI CLI version xx.xx.xx\n2choco install asyncapi --version xx.xx.xx\n```\n All the AsyncAPI CLI versions can be found here . Executable files Just install the appropriate installer and simply follow the default installation steps to complete the installation process. Download asyncapi.x64.exe for 64-bit Windows and download asyncapi.x86.exe for 32-bit Windows. Linux Selecting the appropriate AsyncAPI CLI installation method on a Linux operating system depends on your Linux distro. Debian based distros For Debian based distros, you can install the AsycAPI CLI using the dpkg package manager for Debian. \n```javascript\ncurl -OL https://github.com/asyncapi/cli/releases/latest/download/asyncapi.deb\n```\n To download a specific release of the CLI, run this command in your terminal: \n```javascript\ncurl -OL https://github.com/asyncapi/cli/releases/download/<replace this with the specific CLI version e.g v0.13.0>/asyncapi.deb\n```\n Other distros You can install the AsyncAPI CLI for other Linux distros using the archive tar.gz file. To download the latest release of the CLI, run this command in your terminal: \n```javascript\ncurl -OL https://github.com/asyncapi/cli/releases/latest/download/asyncapi.tar.gz\n```\n To download a specific release of the CLI, run this command in your terminal: \n```javascript\ncurl -OL https://github.com/asyncapi/cli/releases/download/<replace this with the specific CLI version e.g v0.13.0>/asyncapi.tar.gz\n```\n Once you have downloaded the archived file, untar it by running this command in your terminal: tar -xzf asyncapi .tar.gz The step above will create an AsyncAPI directory in the current path. To run the CLI from anywhere, you must create a symlink . If the current path you are on is /user/local/bin , for example, you must create the symlink in the /user/local/bin directory by following these steps: \n```javascript\n1# cd into the unarchived directory\n2cd asyncapi\n3\n4# get the absolute path\n5pwd\n6\n7# Create a symlink\n8ln -s <absolute-path>/bin/asyncapi /user/local/bin/asyncapi\n9\n10# The \"asyncapi\" command should be available to be used\n11asyncapi\n```\n Go Back Introduction Up Next Auto-complete setup Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1# check if node is installed\n2node -v\n3# or\n4node --version\n5\n6# check if NPM is installed\n7npm -v\n8# or\n9npm --version",
      "\u2705 Autocomplete is already configured. Skipping addition.",
      "1 source ~/.bashrc   # For bash\n2 source ~/.zshrc    # For zsh",
      "1docker run --rm -it \\\n2--user=root \\\n3-v [ASYNCAPI SPEC FILE LOCATION]:/app/asyncapi.yml \\\n4-v [GENERATED FILES LOCATION]:/app/output \\\n5asyncapi/cli [COMMAND HERE]\n6\n7# Example that you can run inside the cli directory after cloning this repository. First, you specify the mount in the location of your AsyncAPI specification file and then you mount it in the directory where the generation result should be saved.\n8docker run --rm -it \\\n9   --user=root \\\n10   -v ${PWD}/test/integration/fixtures/asyncapi_v1.yml:/app/asyncapi.yml \\\n11   -v ${PWD}/output:/app/output \\\n12   asyncapi/cli generate fromTemplate -o /app/output /app/asyncapi.yml @asyncapi/html-template --force-write",
      "1# Install brew\n2/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n3\n4# Install AsyncAPI CLI\n5brew install asyncapi",
      "1# For x64\n2curl -OL https://github.com/asyncapi/cli/releases/latest/download/asyncapi.x64.pkg\n3\n4# For arm64\n5curl -OL https://github.com/asyncapi/cli/releases/latest/download/asyncapi.arm64.pkg",
      "curl -OL https://github.com/asyncapi/cli/releases/download/<replace this with the specific CLI version e.g v0.13.0>/asyncapi.pkg",
      "1# Install AsyncAPI CLI\n2choco install asyncapi",
      "1# Upgrade AsyncAPI CLI\n2choco upgrade asyncapi",
      "1# Install AsyncAPI CLI version xx.xx.xx\n2choco install asyncapi --version xx.xx.xx",
      "curl -OL https://github.com/asyncapi/cli/releases/latest/download/asyncapi.deb",
      "curl -OL https://github.com/asyncapi/cli/releases/download/<replace this with the specific CLI version e.g v0.13.0>/asyncapi.deb",
      "curl -OL https://github.com/asyncapi/cli/releases/latest/download/asyncapi.tar.gz",
      "curl -OL https://github.com/asyncapi/cli/releases/download/<replace this with the specific CLI version e.g v0.13.0>/asyncapi.tar.gz",
      "1# cd into the unarchived directory\n2cd asyncapi\n3\n4# get the absolute path\n5pwd\n6\n7# Create a symlink\n8ln -s <absolute-path>/bin/asyncapi /user/local/bin/asyncapi\n9\n10# The \"asyncapi\" command should be available to be used\n11asyncapi"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "b69b0dc3",
    "title": "Metrics Collection | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/cli/metrics_collection.html",
    "content": "Metrics Collection | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Metrics collection guideline What we collect Where the data is stored How to disable tracking Metrics Collection Found an error? Have a suggestion? Edit this page on GitHub Metrics collection guideline AsyncAPI anonymously tracks command executions to improve the specification and tools, ensuring no sensitive data reaches our servers. It aids in comprehending how AsyncAPI tools are used and adopted, facilitating ongoing improvements to our specifications and tools. Even though metrics collection is enabled by default, you can always disable tracking if you want to. What we collect We are collecting the following metrics: asyncapi_adoption.action.invoked : With this metric we are tracking the command executed on the CLI as soon as the command is invoked, so it has already been executed but not finished yet. We just want to know which commands are used, regardless they have failed or succeeded. Example of the data collected by this metric when the validate command has been executed: \n```javascript\nasyncapi_adoption.action.invoked        COUNTER { action: 'validate' }  1\n```\n asyncapi_adoption.action.finished : This metric tracks the command executed once it has already finished, carrying the result of the execution and some metadata based on the AsyncAPI document in place. Example for validate command successfully executed and finished: \n```javascript\n1asyncapi_adoption.action.finished       COUNTER {\n2  validation_result: 'valid',\n3  success: true,\n4  asyncapi_version: '2.6.0',\n5  asyncapi_servers: 2,\n6  asyncapi_channels: 4,\n7  asyncapi_messages: 3,\n8  asyncapi_operations_send: 3,\n9  asyncapi_operations_receive: 1,\n10  asyncapi_schemas: 52,\n11  action: 'validate'\n12  }       1\n```\n Where the data is stored We are making use of New Relic API to send the metrics collected to New Relic servers, where they are stored, and finally visualized on the AsyncAPI website. Metrics won't be collected in CI environments, or when the \"CI\" env variable is set up to \"true\". The analytics config file will be store by default at your home directory. In case you prefer to change the file path then you should set the ASYNCAPI_METRICS_CONFIG_PATH env var to any specific path value when running any command. For instance: \n```javascript\nASYNCAPI_METRICS_CONFIG_PATH=/tmp/.asyncapi-analytics asyncapi config analytics --status\n```\n How to disable tracking To disable tracking, please run the following command: asyncapi config analytics --disable Once disabled, if you want to enable tracking back again then run: asyncapi config analytics --enable In case you do not know the current status of analytics, then you can append the \"--status\" flag to be aware of it: asyncapi config analytics --status Remember that keeping this tracking enabled will help AsyncAPI community to provide better specifications and tools in the future. Go Back Context concept Up Next Glee - Kickstarting Your Journey with Glee Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "asyncapi_adoption.action.invoked        COUNTER { action: 'validate' }  1",
      "1asyncapi_adoption.action.finished       COUNTER {\n2  validation_result: 'valid',\n3  success: true,\n4  asyncapi_version: '2.6.0',\n5  asyncapi_servers: 2,\n6  asyncapi_channels: 4,\n7  asyncapi_messages: 3,\n8  asyncapi_operations_send: 3,\n9  asyncapi_operations_receive: 1,\n10  asyncapi_schemas: 52,\n11  action: 'validate'\n12  }       1",
      "ASYNCAPI_METRICS_CONFIG_PATH=/tmp/.asyncapi-analytics asyncapi config analytics --status"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "757cee6b",
    "title": "Usage | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/cli/usage.html",
    "content": "Usage | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Usage Commands asyncapi bundle asyncapi config asyncapi config analytics asyncapi config context asyncapi config context add CONTEXT-NAME SPEC-FILE-PATH asyncapi config context current asyncapi config context edit CONTEXT-NAME NEW-SPEC-FILE-PATH asyncapi config context init [CONTEXT-FILE-PATH] asyncapi config context list asyncapi config context remove CONTEXT-NAME asyncapi config context use CONTEXT-NAME asyncapi config versions asyncapi convert [SPEC-FILE] asyncapi diff OLD NEW asyncapi format [SPEC-FILE] asyncapi generate asyncapi generate fromTemplate ASYNCAPI TEMPLATE asyncapi generate models LANGUAGE FILE asyncapi new asyncapi new file asyncapi new glee asyncapi new template asyncapi optimize [SPEC-FILE] asyncapi pretty SPEC-FILE asyncapi start asyncapi start studio [SPEC-FILE] asyncapi validate [SPEC-FILE] Usage Found an error? Have a suggestion? Edit this page on GitHub The AsyncAPI CLI makes it easier to work with AsyncAPI documents. Usage \n```javascript\n1$ npm install -g @asyncapi/cli\n2$ asyncapi COMMAND\n3running command...\n4$ asyncapi (--version|--v)\n5@asyncapi/cli/2.16.4 linux-x64 node-v18.20.6\n6$ asyncapi --help [COMMAND]\n7USAGE\n8  $ asyncapi COMMAND\n9...\n```\n Commands Usage Commands asyncapi bundle asyncapi config asyncapi config analytics asyncapi config context asyncapi config context add CONTEXT-NAME SPEC-FILE-PATH asyncapi config context current asyncapi config context edit CONTEXT-NAME NEW-SPEC-FILE-PATH asyncapi config context init [CONTEXT-FILE-PATH] asyncapi config context list asyncapi config context remove CONTEXT-NAME asyncapi config context use CONTEXT-NAME asyncapi config versions asyncapi convert [SPEC-FILE] asyncapi diff OLD NEW asyncapi format [SPEC-FILE] asyncapi generate asyncapi generate fromTemplate ASYNCAPI TEMPLATE asyncapi generate models LANGUAGE FILE asyncapi new asyncapi new file asyncapi new glee asyncapi new template asyncapi optimize [SPEC-FILE] asyncapi pretty SPEC-FILE asyncapi start asyncapi start studio [SPEC-FILE] asyncapi validate [SPEC-FILE] asyncapi bundle Bundle one or multiple AsyncAPI Documents and their references together. \n```javascript\n1USAGE\n2  $ asyncapi bundle [-h] [-o <value>] [-b <value>] [-d <value>] [-x]\n3\n4FLAGS\n5  -b, --base=<value>     Path to the file which will act as a base. This is required when some properties need to be\n6                         overwritten.\n7  -d, --baseDir=<value>  One relative/absolute path to directory relative to which paths to AsyncAPI Documents that\n8                         should be bundled will be resolved.\n9  -h, --help             Show CLI help.\n10  -o, --output=<value>   The output file name. Omitting this flag the result will be printed in the console.\n11  -x, --xOrigin          Pass this switch to generate properties \"x-origin\" that will contain historical values of\n12                         dereferenced \"$ref\"s.\n13\n14DESCRIPTION\n15  Bundle one or multiple AsyncAPI Documents and their references together.\n16\n17EXAMPLES\n18  $ asyncapi bundle ./asyncapi.yaml > final-asyncapi.yaml\n19\n20  $ asyncapi bundle ./asyncapi.yaml --output final-asyncapi.yaml\n21\n22  $ asyncapi bundle ./asyncapi.yaml ./features.yaml\n23\n24  $ asyncapi bundle ./asyncapi.yaml ./features.yaml --base ./main.yaml\n25\n26  $ asyncapi bundle ./asyncapi.yaml ./features.yaml --base ./main.yaml --xOrigin\n27\n28  $ asyncapi bundle ./asyncapi.yaml -o final-asyncapi.yaml --base ../public-api/main.yaml --baseDir ./social-media/comments-service\n```\n See code: src/commands/bundle.ts asyncapi config CLI config settings \n```javascript\n1USAGE\n2  $ asyncapi config\n3\n4DESCRIPTION\n5  CLI config settings\n```\n See code: src/commands/config/index.ts asyncapi config analytics Enable or disable analytics for metrics collection \n```javascript\n1USAGE\n2  $ asyncapi config analytics [-h] [-d] [-e] [-s]\n3\n4FLAGS\n5  -d, --disable  disable analytics\n6  -e, --enable   enable analytics\n7  -h, --help     Show CLI help.\n8  -s, --status   show current status of analytics\n9\n10DESCRIPTION\n11  Enable or disable analytics for metrics collection\n```\n See code: src/commands/config/analytics.ts asyncapi config context Manage short aliases for full paths to AsyncAPI documents \n```javascript\n1USAGE\n2  $ asyncapi config context\n3\n4DESCRIPTION\n5  Manage short aliases for full paths to AsyncAPI documents\n```\n See code: src/commands/config/context/index.ts asyncapi config context add CONTEXT-NAME SPEC-FILE-PATH Add a context to the store \n```javascript\n1USAGE\n2  $ asyncapi config context add CONTEXT-NAME SPEC-FILE-PATH [-h] [-s]\n3\n4ARGUMENTS\n5  CONTEXT-NAME    context name\n6  SPEC-FILE-PATH  file path of the spec file\n7\n8FLAGS\n9  -h, --help         Show CLI help.\n10  -s, --set-current  Set context being added as the current context\n11\n12DESCRIPTION\n13  Add a context to the store\n```\n See code: src/commands/config/context/add.ts asyncapi config context current Shows the current context that is being used \n```javascript\n1USAGE\n2  $ asyncapi config context current [-h]\n3\n4FLAGS\n5  -h, --help  Show CLI help.\n6\n7DESCRIPTION\n8  Shows the current context that is being used\n```\n See code: src/commands/config/context/current.ts asyncapi config context edit CONTEXT-NAME NEW-SPEC-FILE-PATH Edit a context in the store \n```javascript\n1USAGE\n2  $ asyncapi config context edit CONTEXT-NAME NEW-SPEC-FILE-PATH [-h]\n3\n4ARGUMENTS\n5  CONTEXT-NAME        context name\n6  NEW-SPEC-FILE-PATH  file path of the spec file\n7\n8FLAGS\n9  -h, --help  Show CLI help.\n10\n11DESCRIPTION\n12  Edit a context in the store\n```\n See code: src/commands/config/context/edit.ts asyncapi config context init [CONTEXT-FILE-PATH] Initialize context \n```javascript\n1USAGE\n2  $ asyncapi config context init [CONTEXT-FILE-PATH] [-h]\n3\n4ARGUMENTS\n5  CONTEXT-FILE-PATH  Specify directory in which context file should be created:\n6                     - current directory          : asyncapi config context init .(default)\n7                     - root of current repository : asyncapi config context init ./\n8                     - user's home directory      : asyncapi config context init ~`\n9\n10FLAGS\n11  -h, --help  Show CLI help.\n12\n13DESCRIPTION\n14  Initialize context\n```\n See code: src/commands/config/context/init.ts asyncapi config context list List all the stored contexts in the store \n```javascript\n1USAGE\n2  $ asyncapi config context list [-h]\n3\n4FLAGS\n5  -h, --help  Show CLI help.\n6\n7DESCRIPTION\n8  List all the stored contexts in the store\n```\n See code: src/commands/config/context/list.ts asyncapi config context remove CONTEXT-NAME Delete a context from the store \n```javascript\n1USAGE\n2  $ asyncapi config context remove CONTEXT-NAME [-h]\n3\n4ARGUMENTS\n5  CONTEXT-NAME  Name of the context to delete\n6\n7FLAGS\n8  -h, --help  Show CLI help.\n9\n10DESCRIPTION\n11  Delete a context from the store\n```\n See code: src/commands/config/context/remove.ts asyncapi config context use CONTEXT-NAME Set a context as current \n```javascript\n1USAGE\n2  $ asyncapi config context use CONTEXT-NAME [-h]\n3\n4ARGUMENTS\n5  CONTEXT-NAME  name of the saved context\n6\n7FLAGS\n8  -h, --help  Show CLI help.\n9\n10DESCRIPTION\n11  Set a context as current\n```\n See code: src/commands/config/context/use.ts asyncapi config versions Show versions of AsyncAPI tools used \n```javascript\n1USAGE\n2  $ asyncapi config versions [-h]\n3\n4FLAGS\n5  -h, --help  Show CLI help.\n6\n7DESCRIPTION\n8  Show versions of AsyncAPI tools used\n```\n See code: src/commands/config/versions.ts asyncapi convert [SPEC-FILE] Convert asyncapi documents older to newer versions or OpenAPI/postman-collection documents to AsyncAPI \n```javascript\n1USAGE\n2  $ asyncapi convert [SPEC-FILE] -f openapi|asyncapi|postman-collection [-h] [-o <value>] [-t <value>] [-p\n3    client|server] [--proxyHost <value>] [--proxyPort <value>]\n4\n5ARGUMENTS\n6  SPEC-FILE  spec path, url, or context-name\n7\n8FLAGS\n9  -f, --format=<option>         (required) [default: asyncapi] Specify the format to convert from (openapi or asyncapi)\n10                                <options: openapi|asyncapi|postman-collection>\n11  -h, --help                    Show CLI help.\n12  -o, --output=<value>          path to the file where the result is saved\n13  -p, --perspective=<option>    [default: server] Perspective to use when converting OpenAPI to AsyncAPI (client or\n14                                server). Note: This option is only applicable for OpenAPI to AsyncAPI conversions.\n15                                <options: client|server>\n16  -t, --target-version=<value>  [default: 3.0.0] asyncapi version to convert to\n17      --proxyHost=<value>       Name of the ProxyHost\n18      --proxyPort=<value>       Port number number for the proxyHost.\n19\n20DESCRIPTION\n21  Convert asyncapi documents older to newer versions or OpenAPI/postman-collection documents to AsyncAPI\n```\n See code: src/commands/convert.ts asyncapi diff OLD NEW Find diff between two asyncapi files \n```javascript\n1USAGE\n2  $ asyncapi diff OLD NEW [-h] [-f json|yaml|yml|md] [-t breaking|non-breaking|unclassified|all]\n3    [--markdownSubtype json|yaml|yml] [-o <value>] [--no-error] [-w] [--log-diagnostics] [--diagnostics-format\n4    json|stylish|junit|html|text|teamcity|pretty] [--fail-severity error|warn|info|hint] [-o <value>]\n5\n6ARGUMENTS\n7  OLD  old spec path, URL or context-name\n8  NEW  new spec path, URL or context-name\n9\n10FLAGS\n11  -f, --format=<option>              [default: yaml] format of the output\n12                                     <options: json|yaml|yml|md>\n13  -h, --help                         Show CLI help.\n14  -o, --output=<value>               The output file name. Omitting this flag the result will be printed in the console.\n15  -o, --overrides=<value>            path to JSON file containing the override properties\n16  -t, --type=<option>                [default: all] type of the output\n17                                     <options: breaking|non-breaking|unclassified|all>\n18  -w, --watch                        Enable watch mode\n19      --diagnostics-format=<option>  [default: stylish] format to use for validation diagnostics\n20                                     <options: json|stylish|junit|html|text|teamcity|pretty>\n21      --fail-severity=<option>       [default: error] diagnostics of this level or above will trigger a failure exit\n22                                     code\n23                                     <options: error|warn|info|hint>\n24      --[no-]log-diagnostics         log validation diagnostics or not\n25      --markdownSubtype=<option>     the format of changes made to AsyncAPI document. It works only when diff is\n26                                     generated using md type. For example, when you specify subtype as json, then diff\n27                                     information in markdown is dumped as json structure.\n28                                     <options: json|yaml|yml>\n29      --no-error                     don't show error on breaking changes\n30\n31DESCRIPTION\n32  Find diff between two asyncapi files\n```\n See code: src/commands/diff.ts asyncapi format [SPEC-FILE] Convert asyncapi documents from any format to yaml, yml or JSON \n```javascript\n1USAGE\n2  $ asyncapi format [SPEC-FILE] -f yaml|yml|json [-h] [-o <value>]\n3\n4ARGUMENTS\n5  SPEC-FILE  spec path, url, or context-name\n6\n7FLAGS\n8  -f, --format=<option>  (required) [default: json] Specify the format to convert to\n9                         <options: yaml|yml|json>\n10  -h, --help             Show CLI help.\n11  -o, --output=<value>   path to the file where the result is saved\n12\n13DESCRIPTION\n14  Convert asyncapi documents from any format to yaml, yml or JSON\n```\n See code: src/commands/format.ts asyncapi generate Generate typed models or other things like clients, applications or docs using AsyncAPI Generator templates. \n```javascript\n1USAGE\n2  $ asyncapi generate\n3\n4DESCRIPTION\n5  Generate typed models or other things like clients, applications or docs using AsyncAPI Generator templates.\n```\n See code: src/commands/generate/index.ts asyncapi generate fromTemplate ASYNCAPI TEMPLATE Generates whatever you want using templates compatible with AsyncAPI Generator. \n```javascript\n1USAGE\n2  $ asyncapi generate fromTemplate ASYNCAPI TEMPLATE [-h] [-d <value>...] [--no-interactive] [-i] [--debug] [-n <value>...]\n3    [-o <value>] [--force-write] [-w] [-p <value>...] [--map-base-url <value>] [--registry-url <value>] [--registry-auth\n4    <value>] [--registry-token <value>] [--use-new-generator] [--proxyHost <value>] [--proxyPort <value>]\n5\n6ARGUMENTS\n7  ASYNCAPI  - Local path, url or context-name pointing to AsyncAPI file\n8  TEMPLATE  - Name of the generator template like for example @asyncapi/html-template or\n9            https://github.com/asyncapi/html-template\n10\n11FLAGS\n12  -d, --disable-hook=<value>...  Disable a specific hook type or hooks from a given hook type\n13  -h, --help                     Show CLI help.\n14  -i, --install                  Installs the template and its dependencies (defaults to false)\n15  -n, --no-overwrite=<value>...  Glob or path of the file(s) to skip when regenerating\n16  -o, --output=<value>           Directory where to put the generated files (defaults to current directory)\n17  -p, --param=<value>...         Additional param to pass to templates\n18  -w, --watch                    Watches the template directory and the AsyncAPI document, and re-generate the files\n19                                 when changes occur. Ignores the output directory.\n20      --debug                    Enable more specific errors in the console\n21      --force-write              Force writing of the generated files to given directory even if it is a git repo with\n22                                 unstaged files or not empty dir (defaults to false)\n23      --map-base-url=<value>     Maps all schema references from base url to local folder\n24      --no-interactive           Disable interactive mode and run with the provided flags.\n25      --proxyHost=<value>        Name of the ProxyHost\n26      --proxyPort=<value>        Port number number for the proxyHost.\n27      --registry-auth=<value>    The registry username and password encoded with base64, formatted as username:password\n28      --registry-token=<value>   The npm registry authentication token, that can be passed instead of base64 encoded\n29                                 username and password\n30      --registry-url=<value>     [default: https://registry.npmjs.org] Specifies the URL of the private registry for\n31                                 fetching templates and dependencies\n32      --use-new-generator        Use v2 generator, for generating from newer templates\n33\n34DESCRIPTION\n35  Generates whatever you want using templates compatible with AsyncAPI Generator.\n36\n37EXAMPLES\n38  $ asyncapi generate fromTemplate - start creation of a template in interactive mode\n39  $ asyncapi generate fromTemplate asyncapi.yaml @asyncapi/html-template@3.0.0 --use-new-generator\n```\n See code: src/commands/generate/fromTemplate.ts asyncapi generate models LANGUAGE FILE Generates typed models \n```javascript\n1USAGE\n2  $ asyncapi generate models LANGUAGE FILE [-h] [-o <value>] [--packageName <value>] [--namespace <value>]\n3    [--tsModelType class|interface] [--tsEnumType enum|union] [--tsModuleSystem ESM|CJS] [--tsIncludeComments]\n4    [--tsExportType default|named] [--tsJsonBinPack] [--tsMarshalling] [--tsExampleInstance] [--tsRawPropertyNames]\n5    [--csharpAutoImplement] [--csharpNewtonsoft] [--csharpArrayType Array|List] [--csharpHashcode] [--csharpEqual]\n6    [--csharpSystemJson] [--javaIncludeComments] [--javaJackson] [--javaConstraints] [--javaArrayType Array|List]\n7    [--pyDantic] [--no-interactive] [--log-diagnostics] [--diagnostics-format\n8    json|stylish|junit|html|text|teamcity|pretty] [--fail-severity error|warn|info|hint] [--proxyHost <value>]\n9    [--proxyPort <value>]\n10\n11ARGUMENTS\n12  LANGUAGE  (typescript|csharp|golang|java|javascript|dart|python|rust|kotlin|php|cplusplus|scala) The language you want\n13            the typed models generated for.\n14  FILE      Path or URL to the AsyncAPI document, or context-name\n15\n16FLAGS\n17  -h, --help                         Show CLI help.\n18  -o, --output=<value>               The output file name. Omitting this flag the result will be printed in the console.\n19      --csharpArrayType=<option>     [default: Array] C# specific, define which type of array needs to be generated.\n20                                     <options: Array|List>\n21      --csharpAutoImplement          C# specific, define whether to generate auto-implemented properties or not.\n22      --csharpEqual                  C# specific, generate the models with the Equal method overwritten\n23      --csharpHashcode               C# specific, generate the models with the GetHashCode method overwritten\n24      --csharpNewtonsoft             C# specific, generate the models with newtonsoft serialization support\n25      --csharpSystemJson             C# specific, generate the models with System.Text.Json serialization support\n26      --diagnostics-format=<option>  [default: stylish] format to use for validation diagnostics\n27                                     <options: json|stylish|junit|html|text|teamcity|pretty>\n28      --fail-severity=<option>       [default: error] diagnostics of this level or above will trigger a failure exit\n29                                     code\n30                                     <options: error|warn|info|hint>\n31      --javaArrayType=<option>       [default: Array] Java specific, define which type of array needs to be generated.\n32                                     <options: Array|List>\n33      --javaConstraints              Java specific, generate the models with constraints\n34      --javaIncludeComments          Java specific, if enabled add comments while generating models.\n35      --javaJackson                  Java specific, generate the models with Jackson serialization support\n36      --[no-]log-diagnostics         log validation diagnostics or not\n37      --namespace=<value>            C#, C++ and PHP specific, define the namespace to use for the generated models.\n38                                     This is required when language is `csharp`,`c++` or `php`.\n39      --no-interactive               Disable interactive mode and run with the provided flags.\n40      --packageName=<value>          Go, Java and Kotlin specific, define the package to use for the generated models.\n41                                     This is required when language is `go`, `java` or `kotlin`.\n42      --proxyHost=<value>            Name of the ProxyHost\n43      --proxyPort=<value>            Port number number for the proxyHost.\n44      --pyDantic                     Python specific, generate the Pydantic models.\n45      --tsEnumType=<option>          [default: enum] TypeScript specific, define which type of enums needs to be\n46                                     generated.\n47                                     <options: enum|union>\n48      --tsExampleInstance            Typescript specific, generate example of the model.\n49      --tsExportType=<option>        [default: default] TypeScript specific, define which type of export needs to be\n50                                     generated.\n51                                     <options: default|named>\n52      --tsIncludeComments            TypeScript specific, if enabled add comments while generating models.\n53      --tsJsonBinPack                TypeScript specific, define basic support for serializing to and from binary with\n54                                     jsonbinpack.\n55      --tsMarshalling                TypeScript specific, generate the models with marshalling functions.\n56      --tsModelType=<option>         [default: class] TypeScript specific, define which type of model needs to be\n57                                     generated.\n58                                     <options: class|interface>\n59      --tsModuleSystem=<option>      [default: ESM] TypeScript specific, define the module system to be used.\n60                                     <options: ESM|CJS>\n61      --tsRawPropertyNames           Typescript specific, generate the models using raw property names.\n62\n63DESCRIPTION\n64  Generates typed models\n```\n See code: src/commands/generate/models.ts asyncapi new Create a new AsyncAPI project, specification files, or templates for clients and applications. \n```javascript\n1USAGE\n2  $ asyncapi new\n3\n4DESCRIPTION\n5  Create a new AsyncAPI project, specification files, or templates for clients and applications.\n```\n See code: src/commands/new/index.ts asyncapi new file Creates a new asyncapi file \n```javascript\n1USAGE\n2  $ asyncapi new file [-h] [-n <value>] [-e <value>] [-s] [-p <value>] [--no-tty]\n3\n4FLAGS\n5  -e, --example=<value>\n6      name of the example to use. Available examples are:\n7      - simple-asyncapi.yml\n8      - adeo-kafka-request-reply-asyncapi.yml\n9      - anyof-asyncapi.yml\n10      - application-headers-asyncapi.yml\n11      - correlation-id-asyncapi.yml\n12      - websocket-gemini-asyncapi.yml\n13      - gitter-streaming-asyncapi.yml\n14      - kraken-websocket-request-reply-message-filter-in-reply-asyncapi.yml\n15      - kraken-websocket-request-reply-multiple-channels-asyncapi.yml\n16      - mercure-asyncapi.yml\n17      - not-asyncapi.yml\n18      - operation-security-asyncapi.yml\n19      - oneof-asyncapi.yml\n20      - rpc-client-asyncapi.yml\n21      - rpc-server-asyncapi.yml\n22      - slack-rtm-asyncapi.yml\n23      - tutorial.yml\n24      - streetlights-kafka-asyncapi.yml\n25      - streetlights-operation-security-asyncapi.yml\n26      - streetlights-mqtt-asyncapi.yml\n27\n28  -h, --help\n29      Show CLI help.\n30\n31  -n, --file-name=<value>\n32      name of the file\n33\n34  -p, --port=<value>\n35      port in which to start Studio\n36\n37  -s, --studio\n38      open in Studio\n39\n40  --no-tty\n41      do not use an interactive terminal\n42\n43DESCRIPTION\n44  Creates a new asyncapi file\n45\n46EXAMPLES\n47  $ asyncapi new\t - start creation of a file in interactive mode\n48\n49  $ asyncapi new --file-name=my-asyncapi.yaml --example=default-example.yaml --no-tty\t - create a new file with a specific name, using one of the examples and without interactive mode\n```\n See code: src/commands/new/file.ts asyncapi new glee Creates a new Glee project \n```javascript\n1USAGE\n2  $ asyncapi new glee [-h] [-n <value>] [-t <value>] [-f <value>] [--force-write]\n3\n4FLAGS\n5  -f, --file=<value>      The path to the AsyncAPI file for generating a Glee project.\n6  -h, --help              Show CLI help.\n7  -n, --name=<value>      [default: project] Name of the Project\n8  -t, --template=<value>  [default: default] Name of the Template\n9      --force-write       Force writing of the generated files to given directory even if it is a git repo with unstaged\n10                          files or not empty dir (defaults to false)\n11\n12DESCRIPTION\n13  Creates a new Glee project\n```\n See code: src/commands/new/glee.ts asyncapi new template Creates a new template using React render engine \n```javascript\n1USAGE\n2  $ asyncapi new template [-h] [-n <value>] [-t <value>] [-f <value>] [--force-write]\n3\n4FLAGS\n5  -f, --file=<value>      The path to the AsyncAPI file for generating a template.\n6  -h, --help              Show CLI help.\n7  -n, --name=<value>      [default: project] Name of the Project\n8  -t, --template=<value>  [default: default] Name of the Template\n9      --force-write       Force writing of the generated files to given directory even if it is a git repo with unstaged\n10                          files or not empty dir (defaults to false)\n11\n12DESCRIPTION\n13  Creates a new template using React render engine\n```\n See code: src/commands/new/template.ts asyncapi optimize [SPEC-FILE] optimize asyncapi specification file \n```javascript\n1USAGE\n2  $ asyncapi optimize [SPEC-FILE] [-h] [-p\n3    remove-components|reuse-components|move-duplicates-to-components|move-all-to-components...] [-i schema...] [-o\n4    terminal|new-file|overwrite] [--no-tty] [--proxyHost <value>] [--proxyPort <value>]\n5\n6ARGUMENTS\n7  SPEC-FILE  spec path, url, or context-name\n8\n9FLAGS\n10  -h, --help                      Show CLI help.\n11  -i, --ignore=<option>...        [default: ] list of components to be ignored from the optimization process\n12                                  <options: schema>\n13  -o, --output=<option>           [default: terminal] select where you want the output.\n14                                  <options: terminal|new-file|overwrite>\n15  -p, --optimization=<option>...  [default: remove-components,reuse-components,move-duplicates-to-components,move-all-to\n16                                  -components] select the type of optimizations that you want to apply.\n17                                  <options: remove-components|reuse-components|move-duplicates-to-components|move-all-to\n18                                  -components>\n19      --no-tty                    do not use an interactive terminal\n20      --proxyHost=<value>         Name of the ProxyHost\n21      --proxyPort=<value>         Port number number for the proxyHost.\n22\n23DESCRIPTION\n24  optimize asyncapi specification file\n25\n26EXAMPLES\n27  $ asyncapi optimize ./asyncapi.yaml\n28\n29  $ asyncapi optimize ./asyncapi.yaml --no-tty\n30\n31  $ asyncapi optimize ./asyncapi.yaml --optimization=remove-components --optimization=reuse-components --optimization=move-all-to-components --no-tty\n32\n33  $ asyncapi optimize ./asyncapi.yaml --optimization=remove-components --output=terminal --no-tty\n34\n35  $ asyncapi optimize ./asyncapi.yaml --ignore=schema\n```\n See code: src/commands/optimize.ts asyncapi pretty SPEC-FILE Beautify the AsyncAPI spec file (indentation, styling) in place or output the formatted spec to a new file. \n```javascript\n1USAGE\n2  $ asyncapi pretty SPEC-FILE [-o <value>]\n3\n4ARGUMENTS\n5  SPEC-FILE  spec path, url, or context-name\n6\n7FLAGS\n8  -o, --output=<value>  Output file path\n9\n10DESCRIPTION\n11  Beautify the AsyncAPI spec file (indentation, styling) in place or output the formatted spec to a new file.\n12\n13EXAMPLES\n14  $ asyncapi pretty ./asyncapi.yaml\n15\n16  $ asyncapi pretty ./asyncapi.yaml --output formatted-asyncapi.yaml\n```\n See code: src/commands/pretty.ts asyncapi start Starts AsyncAPI-related services. Currently, it supports launching the AsyncAPI Studio \n```javascript\n1USAGE\n2  $ asyncapi start\n3\n4DESCRIPTION\n5  Starts AsyncAPI-related services. Currently, it supports launching the AsyncAPI Studio\n```\n See code: src/commands/start/index.ts asyncapi start studio [SPEC-FILE] starts a new local instance of Studio \n```javascript\n1USAGE\n2  $ asyncapi start studio [SPEC-FILE] [-h] [-f <value>] [-p <value>]\n3\n4ARGUMENTS\n5  SPEC-FILE  spec path, url, or context-name\n6\n7FLAGS\n8  -f, --file=<value>  path to the AsyncAPI file to link with Studio\n9  -h, --help          Show CLI help.\n10  -p, --port=<value>  port in which to start Studio\n11\n12DESCRIPTION\n13  starts a new local instance of Studio\n```\n See code: src/commands/start/studio.ts asyncapi validate [SPEC-FILE] validate asyncapi file \n```javascript\n1USAGE\n2  $ asyncapi validate [SPEC-FILE] [-h] [-w] [--log-diagnostics] [--diagnostics-format\n3    json|stylish|junit|html|text|teamcity|pretty] [--fail-severity error|warn|info|hint] [-o <value>] [--score]\n4    [--proxyHost <value>] [--proxyPort <value>]\n5\n6ARGUMENTS\n7  SPEC-FILE  spec path, url, or context-name\n8\n9FLAGS\n10  -h, --help                         Show CLI help.\n11  -o, --output=<value>               The output file name. Omitting this flag the result will be printed in the console.\n12  -w, --watch                        Enable watch mode\n13      --diagnostics-format=<option>  [default: stylish] format to use for validation diagnostics\n14                                     <options: json|stylish|junit|html|text|teamcity|pretty>\n15      --fail-severity=<option>       [default: error] diagnostics of this level or above will trigger a failure exit\n16                                     code\n17                                     <options: error|warn|info|hint>\n18      --[no-]log-diagnostics         log validation diagnostics or not\n19      --proxyHost=<value>            Name of the ProxyHost\n20      --proxyPort=<value>            Port number number for the proxyHost.\n21      --score                        Compute the score of the AsyncAPI document. Scoring is based on whether the\n22                                     document has description, license, server and/or channels.\n23\n24DESCRIPTION\n25  validate asyncapi file\n```\n See code: src/commands/validate.ts Go Back CLI Architecture Up Next GitHub Action for CLI Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1$ npm install -g @asyncapi/cli\n2$ asyncapi COMMAND\n3running command...\n4$ asyncapi (--version|--v)\n5@asyncapi/cli/2.16.4 linux-x64 node-v18.20.6\n6$ asyncapi --help [COMMAND]\n7USAGE\n8  $ asyncapi COMMAND\n9...",
      "1USAGE\n2  $ asyncapi bundle [-h] [-o <value>] [-b <value>] [-d <value>] [-x]\n3\n4FLAGS\n5  -b, --base=<value>     Path to the file which will act as a base. This is required when some properties need to be\n6                         overwritten.\n7  -d, --baseDir=<value>  One relative/absolute path to directory relative to which paths to AsyncAPI Documents that\n8                         should be bundled will be resolved.\n9  -h, --help             Show CLI help.\n10  -o, --output=<value>   The output file name. Omitting this flag the result will be printed in the console.\n11  -x, --xOrigin          Pass this switch to generate properties \"x-origin\" that will contain historical values of\n12                         dereferenced \"$ref\"s.\n13\n14DESCRIPTION\n15  Bundle one or multiple AsyncAPI Documents and their references together.\n16\n17EXAMPLES\n18  $ asyncapi bundle ./asyncapi.yaml > final-asyncapi.yaml\n19\n20  $ asyncapi bundle ./asyncapi.yaml --output final-asyncapi.yaml\n21\n22  $ asyncapi bundle ./asyncapi.yaml ./features.yaml\n23\n24  $ asyncapi bundle ./asyncapi.yaml ./features.yaml --base ./main.yaml\n25\n26  $ asyncapi bundle ./asyncapi.yaml ./features.yaml --base ./main.yaml --xOrigin\n27\n28  $ asyncapi bundle ./asyncapi.yaml -o final-asyncapi.yaml --base ../public-api/main.yaml --baseDir ./social-media/comments-service",
      "1USAGE\n2  $ asyncapi config\n3\n4DESCRIPTION\n5  CLI config settings",
      "1USAGE\n2  $ asyncapi config analytics [-h] [-d] [-e] [-s]\n3\n4FLAGS\n5  -d, --disable  disable analytics\n6  -e, --enable   enable analytics\n7  -h, --help     Show CLI help.\n8  -s, --status   show current status of analytics\n9\n10DESCRIPTION\n11  Enable or disable analytics for metrics collection",
      "1USAGE\n2  $ asyncapi config context\n3\n4DESCRIPTION\n5  Manage short aliases for full paths to AsyncAPI documents",
      "1USAGE\n2  $ asyncapi config context add CONTEXT-NAME SPEC-FILE-PATH [-h] [-s]\n3\n4ARGUMENTS\n5  CONTEXT-NAME    context name\n6  SPEC-FILE-PATH  file path of the spec file\n7\n8FLAGS\n9  -h, --help         Show CLI help.\n10  -s, --set-current  Set context being added as the current context\n11\n12DESCRIPTION\n13  Add a context to the store",
      "1USAGE\n2  $ asyncapi config context current [-h]\n3\n4FLAGS\n5  -h, --help  Show CLI help.\n6\n7DESCRIPTION\n8  Shows the current context that is being used",
      "1USAGE\n2  $ asyncapi config context edit CONTEXT-NAME NEW-SPEC-FILE-PATH [-h]\n3\n4ARGUMENTS\n5  CONTEXT-NAME        context name\n6  NEW-SPEC-FILE-PATH  file path of the spec file\n7\n8FLAGS\n9  -h, --help  Show CLI help.\n10\n11DESCRIPTION\n12  Edit a context in the store",
      "1USAGE\n2  $ asyncapi config context init [CONTEXT-FILE-PATH] [-h]\n3\n4ARGUMENTS\n5  CONTEXT-FILE-PATH  Specify directory in which context file should be created:\n6                     - current directory          : asyncapi config context init .(default)\n7                     - root of current repository : asyncapi config context init ./\n8                     - user's home directory      : asyncapi config context init ~`\n9\n10FLAGS\n11  -h, --help  Show CLI help.\n12\n13DESCRIPTION\n14  Initialize context",
      "1USAGE\n2  $ asyncapi config context list [-h]\n3\n4FLAGS\n5  -h, --help  Show CLI help.\n6\n7DESCRIPTION\n8  List all the stored contexts in the store",
      "1USAGE\n2  $ asyncapi config context remove CONTEXT-NAME [-h]\n3\n4ARGUMENTS\n5  CONTEXT-NAME  Name of the context to delete\n6\n7FLAGS\n8  -h, --help  Show CLI help.\n9\n10DESCRIPTION\n11  Delete a context from the store",
      "1USAGE\n2  $ asyncapi config context use CONTEXT-NAME [-h]\n3\n4ARGUMENTS\n5  CONTEXT-NAME  name of the saved context\n6\n7FLAGS\n8  -h, --help  Show CLI help.\n9\n10DESCRIPTION\n11  Set a context as current",
      "1USAGE\n2  $ asyncapi config versions [-h]\n3\n4FLAGS\n5  -h, --help  Show CLI help.\n6\n7DESCRIPTION\n8  Show versions of AsyncAPI tools used",
      "1USAGE\n2  $ asyncapi convert [SPEC-FILE] -f openapi|asyncapi|postman-collection [-h] [-o <value>] [-t <value>] [-p\n3    client|server] [--proxyHost <value>] [--proxyPort <value>]\n4\n5ARGUMENTS\n6  SPEC-FILE  spec path, url, or context-name\n7\n8FLAGS\n9  -f, --format=<option>         (required) [default: asyncapi] Specify the format to convert from (openapi or asyncapi)\n10                                <options: openapi|asyncapi|postman-collection>\n11  -h, --help                    Show CLI help.\n12  -o, --output=<value>          path to the file where the result is saved\n13  -p, --perspective=<option>    [default: server] Perspective to use when converting OpenAPI to AsyncAPI (client or\n14                                server). Note: This option is only applicable for OpenAPI to AsyncAPI conversions.\n15                                <options: client|server>\n16  -t, --target-version=<value>  [default: 3.0.0] asyncapi version to convert to\n17      --proxyHost=<value>       Name of the ProxyHost\n18      --proxyPort=<value>       Port number number for the proxyHost.\n19\n20DESCRIPTION\n21  Convert asyncapi documents older to newer versions or OpenAPI/postman-collection documents to AsyncAPI",
      "1USAGE\n2  $ asyncapi diff OLD NEW [-h] [-f json|yaml|yml|md] [-t breaking|non-breaking|unclassified|all]\n3    [--markdownSubtype json|yaml|yml] [-o <value>] [--no-error] [-w] [--log-diagnostics] [--diagnostics-format\n4    json|stylish|junit|html|text|teamcity|pretty] [--fail-severity error|warn|info|hint] [-o <value>]\n5\n6ARGUMENTS\n7  OLD  old spec path, URL or context-name\n8  NEW  new spec path, URL or context-name\n9\n10FLAGS\n11  -f, --format=<option>              [default: yaml] format of the output\n12                                     <options: json|yaml|yml|md>\n13  -h, --help                         Show CLI help.\n14  -o, --output=<value>               The output file name. Omitting this flag the result will be printed in the console.\n15  -o, --overrides=<value>            path to JSON file containing the override properties\n16  -t, --type=<option>                [default: all] type of the output\n17                                     <options: breaking|non-breaking|unclassified|all>\n18  -w, --watch                        Enable watch mode\n19      --diagnostics-format=<option>  [default: stylish] format to use for validation diagnostics\n20                                     <options: json|stylish|junit|html|text|teamcity|pretty>\n21      --fail-severity=<option>       [default: error] diagnostics of this level or above will trigger a failure exit\n22                                     code\n23                                     <options: error|warn|info|hint>\n24      --[no-]log-diagnostics         log validation diagnostics or not\n25      --markdownSubtype=<option>     the format of changes made to AsyncAPI document. It works only when diff is\n26                                     generated using md type. For example, when you specify subtype as json, then diff\n27                                     information in markdown is dumped as json structure.\n28                                     <options: json|yaml|yml>\n29      --no-error                     don't show error on breaking changes\n30\n31DESCRIPTION\n32  Find diff between two asyncapi files",
      "1USAGE\n2  $ asyncapi format [SPEC-FILE] -f yaml|yml|json [-h] [-o <value>]\n3\n4ARGUMENTS\n5  SPEC-FILE  spec path, url, or context-name\n6\n7FLAGS\n8  -f, --format=<option>  (required) [default: json] Specify the format to convert to\n9                         <options: yaml|yml|json>\n10  -h, --help             Show CLI help.\n11  -o, --output=<value>   path to the file where the result is saved\n12\n13DESCRIPTION\n14  Convert asyncapi documents from any format to yaml, yml or JSON",
      "1USAGE\n2  $ asyncapi generate\n3\n4DESCRIPTION\n5  Generate typed models or other things like clients, applications or docs using AsyncAPI Generator templates.",
      "1USAGE\n2  $ asyncapi generate fromTemplate ASYNCAPI TEMPLATE [-h] [-d <value>...] [--no-interactive] [-i] [--debug] [-n <value>...]\n3    [-o <value>] [--force-write] [-w] [-p <value>...] [--map-base-url <value>] [--registry-url <value>] [--registry-auth\n4    <value>] [--registry-token <value>] [--use-new-generator] [--proxyHost <value>] [--proxyPort <value>]\n5\n6ARGUMENTS\n7  ASYNCAPI  - Local path, url or context-name pointing to AsyncAPI file\n8  TEMPLATE  - Name of the generator template like for example @asyncapi/html-template or\n9            https://github.com/asyncapi/html-template\n10\n11FLAGS\n12  -d, --disable-hook=<value>...  Disable a specific hook type or hooks from a given hook type\n13  -h, --help                     Show CLI help.\n14  -i, --install                  Installs the template and its dependencies (defaults to false)\n15  -n, --no-overwrite=<value>...  Glob or path of the file(s) to skip when regenerating\n16  -o, --output=<value>           Directory where to put the generated files (defaults to current directory)\n17  -p, --param=<value>...         Additional param to pass to templates\n18  -w, --watch                    Watches the template directory and the AsyncAPI document, and re-generate the files\n19                                 when changes occur. Ignores the output directory.\n20      --debug                    Enable more specific errors in the console\n21      --force-write              Force writing of the generated files to given directory even if it is a git repo with\n22                                 unstaged files or not empty dir (defaults to false)\n23      --map-base-url=<value>     Maps all schema references from base url to local folder\n24      --no-interactive           Disable interactive mode and run with the provided flags.\n25      --proxyHost=<value>        Name of the ProxyHost\n26      --proxyPort=<value>        Port number number for the proxyHost.\n27      --registry-auth=<value>    The registry username and password encoded with base64, formatted as username:password\n28      --registry-token=<value>   The npm registry authentication token, that can be passed instead of base64 encoded\n29                                 username and password\n30      --registry-url=<value>     [default: https://registry.npmjs.org] Specifies the URL of the private registry for\n31                                 fetching templates and dependencies\n32      --use-new-generator        Use v2 generator, for generating from newer templates\n33\n34DESCRIPTION\n35  Generates whatever you want using templates compatible with AsyncAPI Generator.\n36\n37EXAMPLES\n38  $ asyncapi generate fromTemplate - start creation of a template in interactive mode\n39  $ asyncapi generate fromTemplate asyncapi.yaml @asyncapi/html-template@3.0.0 --use-new-generator",
      "1USAGE\n2  $ asyncapi generate models LANGUAGE FILE [-h] [-o <value>] [--packageName <value>] [--namespace <value>]\n3    [--tsModelType class|interface] [--tsEnumType enum|union] [--tsModuleSystem ESM|CJS] [--tsIncludeComments]\n4    [--tsExportType default|named] [--tsJsonBinPack] [--tsMarshalling] [--tsExampleInstance] [--tsRawPropertyNames]\n5    [--csharpAutoImplement] [--csharpNewtonsoft] [--csharpArrayType Array|List] [--csharpHashcode] [--csharpEqual]\n6    [--csharpSystemJson] [--javaIncludeComments] [--javaJackson] [--javaConstraints] [--javaArrayType Array|List]\n7    [--pyDantic] [--no-interactive] [--log-diagnostics] [--diagnostics-format\n8    json|stylish|junit|html|text|teamcity|pretty] [--fail-severity error|warn|info|hint] [--proxyHost <value>]\n9    [--proxyPort <value>]\n10\n11ARGUMENTS\n12  LANGUAGE  (typescript|csharp|golang|java|javascript|dart|python|rust|kotlin|php|cplusplus|scala) The language you want\n13            the typed models generated for.\n14  FILE      Path or URL to the AsyncAPI document, or context-name\n15\n16FLAGS\n17  -h, --help                         Show CLI help.\n18  -o, --output=<value>               The output file name. Omitting this flag the result will be printed in the console.\n19      --csharpArrayType=<option>     [default: Array] C# specific, define which type of array needs to be generated.\n20                                     <options: Array|List>\n21      --csharpAutoImplement          C# specific, define whether to generate auto-implemented properties or not.\n22      --csharpEqual                  C# specific, generate the models with the Equal method overwritten\n23      --csharpHashcode               C# specific, generate the models with the GetHashCode method overwritten\n24      --csharpNewtonsoft             C# specific, generate the models with newtonsoft serialization support\n25      --csharpSystemJson             C# specific, generate the models with System.Text.Json serialization support\n26      --diagnostics-format=<option>  [default: stylish] format to use for validation diagnostics\n27                                     <options: json|stylish|junit|html|text|teamcity|pretty>\n28      --fail-severity=<option>       [default: error] diagnostics of this level or above will trigger a failure exit\n29                                     code\n30                                     <options: error|warn|info|hint>\n31      --javaArrayType=<option>       [default: Array] Java specific, define which type of array needs to be generated.\n32                                     <options: Array|List>\n33      --javaConstraints              Java specific, generate the models with constraints\n34      --javaIncludeComments          Java specific, if enabled add comments while generating models.\n35      --javaJackson                  Java specific, generate the models with Jackson serialization support\n36      --[no-]log-diagnostics         log validation diagnostics or not\n37      --namespace=<value>            C#, C++ and PHP specific, define the namespace to use for the generated models.\n38                                     This is required when language is `csharp`,`c++` or `php`.\n39      --no-interactive               Disable interactive mode and run with the provided flags.\n40      --packageName=<value>          Go, Java and Kotlin specific, define the package to use for the generated models.\n41                                     This is required when language is `go`, `java` or `kotlin`.\n42      --proxyHost=<value>            Name of the ProxyHost\n43      --proxyPort=<value>            Port number number for the proxyHost.\n44      --pyDantic                     Python specific, generate the Pydantic models.\n45      --tsEnumType=<option>          [default: enum] TypeScript specific, define which type of enums needs to be\n46                                     generated.\n47                                     <options: enum|union>\n48      --tsExampleInstance            Typescript specific, generate example of the model.\n49      --tsExportType=<option>        [default: default] TypeScript specific, define which type of export needs to be\n50                                     generated.\n51                                     <options: default|named>\n52      --tsIncludeComments            TypeScript specific, if enabled add comments while generating models.\n53      --tsJsonBinPack                TypeScript specific, define basic support for serializing to and from binary with\n54                                     jsonbinpack.\n55      --tsMarshalling                TypeScript specific, generate the models with marshalling functions.\n56      --tsModelType=<option>         [default: class] TypeScript specific, define which type of model needs to be\n57                                     generated.\n58                                     <options: class|interface>\n59      --tsModuleSystem=<option>      [default: ESM] TypeScript specific, define the module system to be used.\n60                                     <options: ESM|CJS>\n61      --tsRawPropertyNames           Typescript specific, generate the models using raw property names.\n62\n63DESCRIPTION\n64  Generates typed models",
      "1USAGE\n2  $ asyncapi new\n3\n4DESCRIPTION\n5  Create a new AsyncAPI project, specification files, or templates for clients and applications.",
      "1USAGE\n2  $ asyncapi new file [-h] [-n <value>] [-e <value>] [-s] [-p <value>] [--no-tty]\n3\n4FLAGS\n5  -e, --example=<value>\n6      name of the example to use. Available examples are:\n7      - simple-asyncapi.yml\n8      - adeo-kafka-request-reply-asyncapi.yml\n9      - anyof-asyncapi.yml\n10      - application-headers-asyncapi.yml\n11      - correlation-id-asyncapi.yml\n12      - websocket-gemini-asyncapi.yml\n13      - gitter-streaming-asyncapi.yml\n14      - kraken-websocket-request-reply-message-filter-in-reply-asyncapi.yml\n15      - kraken-websocket-request-reply-multiple-channels-asyncapi.yml\n16      - mercure-asyncapi.yml\n17      - not-asyncapi.yml\n18      - operation-security-asyncapi.yml\n19      - oneof-asyncapi.yml\n20      - rpc-client-asyncapi.yml\n21      - rpc-server-asyncapi.yml\n22      - slack-rtm-asyncapi.yml\n23      - tutorial.yml\n24      - streetlights-kafka-asyncapi.yml\n25      - streetlights-operation-security-asyncapi.yml\n26      - streetlights-mqtt-asyncapi.yml\n27\n28  -h, --help\n29      Show CLI help.\n30\n31  -n, --file-name=<value>\n32      name of the file\n33\n34  -p, --port=<value>\n35      port in which to start Studio\n36\n37  -s, --studio\n38      open in Studio\n39\n40  --no-tty\n41      do not use an interactive terminal\n42\n43DESCRIPTION\n44  Creates a new asyncapi file\n45\n46EXAMPLES\n47  $ asyncapi new\t - start creation of a file in interactive mode\n48\n49  $ asyncapi new --file-name=my-asyncapi.yaml --example=default-example.yaml --no-tty\t - create a new file with a specific name, using one of the examples and without interactive mode",
      "1USAGE\n2  $ asyncapi new glee [-h] [-n <value>] [-t <value>] [-f <value>] [--force-write]\n3\n4FLAGS\n5  -f, --file=<value>      The path to the AsyncAPI file for generating a Glee project.\n6  -h, --help              Show CLI help.\n7  -n, --name=<value>      [default: project] Name of the Project\n8  -t, --template=<value>  [default: default] Name of the Template\n9      --force-write       Force writing of the generated files to given directory even if it is a git repo with unstaged\n10                          files or not empty dir (defaults to false)\n11\n12DESCRIPTION\n13  Creates a new Glee project",
      "1USAGE\n2  $ asyncapi new template [-h] [-n <value>] [-t <value>] [-f <value>] [--force-write]\n3\n4FLAGS\n5  -f, --file=<value>      The path to the AsyncAPI file for generating a template.\n6  -h, --help              Show CLI help.\n7  -n, --name=<value>      [default: project] Name of the Project\n8  -t, --template=<value>  [default: default] Name of the Template\n9      --force-write       Force writing of the generated files to given directory even if it is a git repo with unstaged\n10                          files or not empty dir (defaults to false)\n11\n12DESCRIPTION\n13  Creates a new template using React render engine",
      "1USAGE\n2  $ asyncapi optimize [SPEC-FILE] [-h] [-p\n3    remove-components|reuse-components|move-duplicates-to-components|move-all-to-components...] [-i schema...] [-o\n4    terminal|new-file|overwrite] [--no-tty] [--proxyHost <value>] [--proxyPort <value>]\n5\n6ARGUMENTS\n7  SPEC-FILE  spec path, url, or context-name\n8\n9FLAGS\n10  -h, --help                      Show CLI help.\n11  -i, --ignore=<option>...        [default: ] list of components to be ignored from the optimization process\n12                                  <options: schema>\n13  -o, --output=<option>           [default: terminal] select where you want the output.\n14                                  <options: terminal|new-file|overwrite>\n15  -p, --optimization=<option>...  [default: remove-components,reuse-components,move-duplicates-to-components,move-all-to\n16                                  -components] select the type of optimizations that you want to apply.\n17                                  <options: remove-components|reuse-components|move-duplicates-to-components|move-all-to\n18                                  -components>\n19      --no-tty                    do not use an interactive terminal\n20      --proxyHost=<value>         Name of the ProxyHost\n21      --proxyPort=<value>         Port number number for the proxyHost.\n22\n23DESCRIPTION\n24  optimize asyncapi specification file\n25\n26EXAMPLES\n27  $ asyncapi optimize ./asyncapi.yaml\n28\n29  $ asyncapi optimize ./asyncapi.yaml --no-tty\n30\n31  $ asyncapi optimize ./asyncapi.yaml --optimization=remove-components --optimization=reuse-components --optimization=move-all-to-components --no-tty\n32\n33  $ asyncapi optimize ./asyncapi.yaml --optimization=remove-components --output=terminal --no-tty\n34\n35  $ asyncapi optimize ./asyncapi.yaml --ignore=schema",
      "1USAGE\n2  $ asyncapi pretty SPEC-FILE [-o <value>]\n3\n4ARGUMENTS\n5  SPEC-FILE  spec path, url, or context-name\n6\n7FLAGS\n8  -o, --output=<value>  Output file path\n9\n10DESCRIPTION\n11  Beautify the AsyncAPI spec file (indentation, styling) in place or output the formatted spec to a new file.\n12\n13EXAMPLES\n14  $ asyncapi pretty ./asyncapi.yaml\n15\n16  $ asyncapi pretty ./asyncapi.yaml --output formatted-asyncapi.yaml",
      "1USAGE\n2  $ asyncapi start\n3\n4DESCRIPTION\n5  Starts AsyncAPI-related services. Currently, it supports launching the AsyncAPI Studio",
      "1USAGE\n2  $ asyncapi start studio [SPEC-FILE] [-h] [-f <value>] [-p <value>]\n3\n4ARGUMENTS\n5  SPEC-FILE  spec path, url, or context-name\n6\n7FLAGS\n8  -f, --file=<value>  path to the AsyncAPI file to link with Studio\n9  -h, --help          Show CLI help.\n10  -p, --port=<value>  port in which to start Studio\n11\n12DESCRIPTION\n13  starts a new local instance of Studio",
      "1USAGE\n2  $ asyncapi validate [SPEC-FILE] [-h] [-w] [--log-diagnostics] [--diagnostics-format\n3    json|stylish|junit|html|text|teamcity|pretty] [--fail-severity error|warn|info|hint] [-o <value>] [--score]\n4    [--proxyHost <value>] [--proxyPort <value>]\n5\n6ARGUMENTS\n7  SPEC-FILE  spec path, url, or context-name\n8\n9FLAGS\n10  -h, --help                         Show CLI help.\n11  -o, --output=<value>               The output file name. Omitting this flag the result will be printed in the console.\n12  -w, --watch                        Enable watch mode\n13      --diagnostics-format=<option>  [default: stylish] format to use for validation diagnostics\n14                                     <options: json|stylish|junit|html|text|teamcity|pretty>\n15      --fail-severity=<option>       [default: error] diagnostics of this level or above will trigger a failure exit\n16                                     code\n17                                     <options: error|warn|info|hint>\n18      --[no-]log-diagnostics         log validation diagnostics or not\n19      --proxyHost=<value>            Name of the ProxyHost\n20      --proxyPort=<value>            Port number number for the proxyHost.\n21      --score                        Compute the score of the AsyncAPI document. Scoring is based on whether the\n22                                     document has description, license, server and/or channels.\n23\n24DESCRIPTION\n25  validate asyncapi file"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "81dfa0f6",
    "title": "Library API | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/generator/api.html",
    "content": "Library API | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Generator new Generator generator.generate generator.validateAsyncAPIDocument generator.configureTemplateWorkflow ~~generator.generateFromString~~ generator.generateFromURL generator.generateFromFile generator.installTemplate Generator.getTemplateFile Library API Found an error? Have a suggestion? Edit this page on GitHub Reference API documentation for AsyncAPI Generator library. Generator Kind : global class Generator new Generator(templateName, targetDir, options) instance .compile : Boolean .registry : Object .templateName : String .targetDir : String .entrypoint : String .noOverwriteGlobs : Array.<String> .disabledHooks : Object.<String, (Boolean|String|Array.<String>)> .output : String .forceWrite : Boolean .debug : Boolean .install : Boolean .templateConfig : Object .hooks : Object .mapBaseUrlToFolder : Object .templateParams : Object .generate(asyncapiDocument, [parseOptions]) \u21d2 Promise.<void> .validateAsyncAPIDocument(asyncapiDocument) .setupOutput() .setupFSOutput() \u21d2 Promise.<void> .setLogLevel() \u21d2 void .installAndSetupTemplate() \u21d2 Promise.<{templatePkgName: string, templatePkgPath: string}> .configureTemplateWorkflow(parseOptions) \u21d2 Promise.<void> .handleEntrypoint() \u21d2 Promise.<void> .executeAfterHook() \u21d2 Promise.<void> .parseInput() .configureTemplate() .generateFromString(asyncapiString, [parseOptions]) \u21d2 Promise.<(TemplateRenderResult|undefined)> .generateFromURL(asyncapiURL) \u21d2 Promise.<(TemplateRenderResult|undefined)> .generateFromFile(asyncapiFile) \u21d2 Promise.<(TemplateRenderResult|undefined)> .installTemplate([force]) static .getTemplateFile(templateName, filePath, [templatesDir]) \u21d2 Promise new Generator Instantiates a new Generator object. Params templateName String - Name of the template to generate. targetDir String - Path to the directory where the files will be generated. options Object [.templateParams] Object.<string, string> - Optional parameters to pass to the template. Each template define their own params. [.entrypoint] String - Name of the file to use as the entry point for the rendering process. Use in case you want to use only a specific template file. Note: this potentially avoids rendering every file in the template. [.noOverwriteGlobs] Array.<String> - List of globs to skip when regenerating the template. [.disabledHooks] Object.<String, (Boolean|String|Array.<String>)> - Object with hooks to disable. The key is a hook type. If key has \"true\" value, then the generator skips all hooks from the given type. If the value associated with a key is a string with the name of a single hook, then the generator skips only this single hook name. If the value associated with a key is an array of strings, then the generator skips only hooks from the array. [.output] String = 'fs' - Type of output. Can be either 'fs' (default) or 'string'. Only available when entrypoint is set. [.forceWrite] Boolean = false - Force writing of the generated files to given directory even if it is a git repo with unstaged files or not empty dir. Default is set to false. [.install] Boolean = false - Install the template and its dependencies, even when the template has already been installed. [.debug] Boolean = false - Enable more specific errors in the console. At the moment it only shows specific errors about filters. Keep in mind that as a result errors about template are less descriptive. [.compile] Boolean = true - Whether to compile the template or use the cached transpiled version provided by template in '__transpiled' folder [.mapBaseUrlToFolder] Object.<String, String> - Optional parameter to map schema references from a base url to a local base folder e.g. url= https://schema.example.com/crm/ folder=./test/docs/ . [.registry] Object - Optional parameter with private registry configuration [.url] String - Parameter to pass npm registry url [.auth] String - Optional parameter to pass npm registry username and password encoded with base64, formatted like username:password value should be encoded [.token] String - Optional parameter to pass npm registry auth token that you can grab from .npmrc file Example \n```javascript\n1const path = require('path');\n2const generator = new Generator('@asyncapi/html-template', path.resolve(__dirname, 'example'));\n```\n Example (Passing custom params to the template) \n```javascript\n1const path = require('path');\n2const generator = new Generator('@asyncapi/html-template', path.resolve(__dirname, 'example'), {\n3  templateParams: {\n4    sidebarOrganization: 'byTags'\n5  }\n6});\n```\n generator.compile : Boolean ** : Whether to compile the template or use the cached transpiled version provided by template in '__transpiled' folder. Kind : instance property of Generator generator.registry : Object ** : Npm registry information. Kind : instance property of Generator generator.templateName : String ** : Name of the template to generate. Kind : instance property of Generator generator.targetDir : String ** : Path to the directory where the files will be generated. Kind : instance property of Generator generator.entrypoint : String ** : Name of the file to use as the entry point for the rendering process. Use in case you want to use only a specific template file. Note: this potentially avoids rendering every file in the template. Kind : instance property of Generator generator.noOverwriteGlobs : Array.<String> ** : List of globs to skip when regenerating the template. Kind : instance property of Generator generator.disabledHooks : Object.<String, (Boolean|String|Array.<String>)> ** : Object with hooks to disable. The key is a hook type. If key has \"true\" value, then the generator skips all hooks from the given type. If the value associated with a key is a string with the name of a single hook, then the generator skips only this single hook name. If the value associated with a key is an array of strings, then the generator skips only hooks from the array. Kind : instance property of Generator generator.output : String ** : Type of output. Can be either 'fs' (default) or 'string'. Only available when entrypoint is set. Kind : instance property of Generator generator.forceWrite : Boolean ** : Force writing of the generated files to given directory even if it is a git repo with unstaged files or not empty dir. Default is set to false. Kind : instance property of Generator generator.debug : Boolean ** : Enable more specific errors in the console. At the moment it only shows specific errors about filters. Keep in mind that as a result errors about template are less descriptive. Kind : instance property of Generator generator.install : Boolean ** : Install the template and its dependencies, even when the template has already been installed. Kind : instance property of Generator generator.templateConfig : Object ** : The template configuration. Kind : instance property of Generator generator.hooks : Object ** : Hooks object with hooks functions grouped by the hook type. Kind : instance property of Generator generator.mapBaseUrlToFolder : Object ** : Maps schema URL to folder. Kind : instance property of Generator generator.templateParams : Object ** : The template parameters. The structure for this object is based on each individual template. Kind : instance property of Generator generator.generate Generates files from a given template and an AsyncAPIDocument object. Kind : instance method of Generator Returns : Promise.<void> - A Promise that resolves when the generation is completed. Params asyncapiDocument AsyncAPIDocument | string - AsyncAPIDocument object to use as source. [parseOptions] Object = {} - AsyncAPI Parser parse options. Check out @asyncapi/parser for more information. Remember to use the right options for the right parser depending on the template you are using. Example \n```javascript\n1await generator.generate(myAsyncAPIdocument);\n2console.log('Done!');\n```\n Example \n```javascript\n1generator\n2  .generate(myAsyncAPIdocument)\n3  .then(() => {\n4    console.log('Done!');\n5  })\n6  .catch(console.error);\n```\n Example (Using async/await) \n```javascript\n1try {\n2  await generator.generate(myAsyncAPIdocument);\n3  console.log('Done!');\n4} catch (e) {\n5  console.error(e);\n6}\n```\n generator.validateAsyncAPIDocument Validates the provided AsyncAPI document. Kind : instance method of Generator Throws : Error Throws an error if the document is not valid. Since : 10/9/2023 - 4:26:33 PM Params asyncapiDocument * - The AsyncAPI document to be validated. generator.setupOutput()** : Sets up the output configuration based on the specified output type. Kind : instance method of Generator Throws : Error If 'output' is set to 'string' without providing 'entrypoint'. Example \n```javascript\n1const generator = new Generator();\n2await generator.setupOutput();\n```\n generator.setupFSOutput() \u21d2 Promise.<void> ** : Sets up the file system (FS) output configuration. This function creates the target directory if it does not exist and verifies the target directory if forceWrite is not enabled. Kind : instance method of Generator Returns : Promise.<void> - A promise that fulfills when the setup is complete. Throws : Error If verification of the target directory fails and forceWrite is not enabled. generator.setLogLevel() \u21d2 void ** : Sets the log level based on the debug option. If the debug option is enabled, the log level is set to 'debug'. Kind : instance method of Generator generator.installAndSetupTemplate() \u21d2 Promise.<{templatePkgName: string, templatePkgPath: string}> ** : Installs and sets up the template for code generation. This function installs the specified template using the provided installation option, sets up the necessary directory paths, loads the template configuration, and returns information about the installed template. Kind : instance method of Generator Returns : Promise.<{templatePkgName: string, templatePkgPath: string}> - A promise that resolves to an object containing the name and path of the installed template. generator.configureTemplateWorkflow Configures the template workflow based on provided parsing options. This function performs the following steps: Parses the input AsyncAPI document using the specified parse options. Validates the template configuration and parameters. Configures the template based on the parsed AsyncAPI document. Registers filters, hooks, and launches the 'generate:before' hook if applicable. Kind : instance method of Generator Returns : Promise.<void> - A promise that resolves when the configuration is completed. Params parseOptions * - Options for parsing the AsyncAPI document. generator.handleEntrypoint() \u21d2 Promise.<void> ** : Handles the logic for the template entrypoint. If an entrypoint is specified: Resolves the absolute path of the entrypoint file. Throws an error if the entrypoint file doesn't exist. Generates a file or renders content based on the output type. Launches the 'generate:after' hook if the output is 'fs'. If no entrypoint is specified, generates the directory structure. Kind : instance method of Generator Returns : Promise.<void> - A promise that resolves when the entrypoint logic is completed. generator.executeAfterHook() \u21d2 Promise.<void> ** : Executes the 'generate:after' hook. Launches the after-hook to perform additional actions after code generation. Kind : instance method of Generator Returns : Promise.<void> - A promise that resolves when the after-hook execution is completed. generator.parseInput()** : Parse the generator input based on the template templateConfig.apiVersion value. Kind : instance method of Generator generator.configureTemplate()** : Configure the templates based the desired renderer. Kind : instance method of Generator generator.generateFromString Deprecated Generates files from a given template and AsyncAPI string. Kind : instance method of Generator Params asyncapiString String - AsyncAPI string to use as source. [parseOptions] Object = {} - AsyncAPI Parser parse options. Check out @asyncapi/parser for more information. Example \n```javascript\n1const asyncapiString = `\n2asyncapi: '2.0.0'\n3info:\n4  title: Example\n5  version: 1.0.0\n6...\n7`;\n8generator\n9  .generateFromString(asyncapiString)\n10  .then(() => {\n11    console.log('Done!');\n12  })\n13  .catch(console.error);\n```\n Example (Using async/await) \n```javascript\n1const asyncapiString = `\n2asyncapi: '2.0.0'\n3info:\n4  title: Example\n5  version: 1.0.0\n6...\n7`;\n8\n9try {\n10  await generator.generateFromString(asyncapiString);\n11  console.log('Done!');\n12} catch (e) {\n13  console.error(e);\n14}\n```\n generator.generateFromURL Generates files from a given template and AsyncAPI file stored on external server. Kind : instance method of Generator Params asyncapiURL String - Link to AsyncAPI file Example \n```javascript\n1generator\n2  .generateFromURL('https://example.com/asyncapi.yaml')\n3  .then(() => {\n4    console.log('Done!');\n5  })\n6  .catch(console.error);\n```\n Example (Using async/await) \n```javascript\n1try {\n2  await generator.generateFromURL('https://example.com/asyncapi.yaml');\n3  console.log('Done!');\n4} catch (e) {\n5  console.error(e);\n6}\n```\n generator.generateFromFile Generates files from a given template and AsyncAPI file. Kind : instance method of Generator Params asyncapiFile String - AsyncAPI file to use as source. Example \n```javascript\n1generator\n2  .generateFromFile('asyncapi.yaml')\n3  .then(() => {\n4    console.log('Done!');\n5  })\n6  .catch(console.error);\n```\n Example (Using async/await) \n```javascript\n1try {\n2  await generator.generateFromFile('asyncapi.yaml');\n3  console.log('Done!');\n4} catch (e) {\n5  console.error(e);\n6}\n```\n generator.installTemplate Downloads and installs a template and its dependencies Kind : instance method of Generator Params [force] Boolean = false - Whether to force installation (and skip cache) or not. Generator.getTemplateFile Returns the content of a given template file. Kind : static method of Generator Params templateName String - Name of the template to generate. filePath String - Path to the file to render. Relative to the template directory. [templatesDir] String = DEFAULT_TEMPLATES_DIR - Path to the directory where the templates are installed. Example \n```javascript\n1const Generator = require('@asyncapi/generator');\n2const content = await Generator.getTemplateFile('@asyncapi/html-template', 'partials/content.html');\n```\n Example (Using a custom `templatesDir`) \n```javascript\n1const Generator = require('@asyncapi/generator');\n2const content = await Generator.getTemplateFile('@asyncapi/html-template', 'partials/content.html', '~/my-templates');\n```\n Go Back Generator version vs template version Up Next Template development Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1const path = require('path');\n2const generator = new Generator('@asyncapi/html-template', path.resolve(__dirname, 'example'));",
      "1const path = require('path');\n2const generator = new Generator('@asyncapi/html-template', path.resolve(__dirname, 'example'), {\n3  templateParams: {\n4    sidebarOrganization: 'byTags'\n5  }\n6});",
      "1await generator.generate(myAsyncAPIdocument);\n2console.log('Done!');",
      "1generator\n2  .generate(myAsyncAPIdocument)\n3  .then(() => {\n4    console.log('Done!');\n5  })\n6  .catch(console.error);",
      "1try {\n2  await generator.generate(myAsyncAPIdocument);\n3  console.log('Done!');\n4} catch (e) {\n5  console.error(e);\n6}",
      "1const generator = new Generator();\n2await generator.setupOutput();",
      "1const asyncapiString = `\n2asyncapi: '2.0.0'\n3info:\n4  title: Example\n5  version: 1.0.0\n6...\n7`;\n8generator\n9  .generateFromString(asyncapiString)\n10  .then(() => {\n11    console.log('Done!');\n12  })\n13  .catch(console.error);",
      "1const asyncapiString = `\n2asyncapi: '2.0.0'\n3info:\n4  title: Example\n5  version: 1.0.0\n6...\n7`;\n8\n9try {\n10  await generator.generateFromString(asyncapiString);\n11  console.log('Done!');\n12} catch (e) {\n13  console.error(e);\n14}",
      "1generator\n2  .generateFromURL('https://example.com/asyncapi.yaml')\n3  .then(() => {\n4    console.log('Done!');\n5  })\n6  .catch(console.error);",
      "1try {\n2  await generator.generateFromURL('https://example.com/asyncapi.yaml');\n3  console.log('Done!');\n4} catch (e) {\n5  console.error(e);\n6}",
      "1generator\n2  .generateFromFile('asyncapi.yaml')\n3  .then(() => {\n4    console.log('Done!');\n5  })\n6  .catch(console.error);",
      "1try {\n2  await generator.generateFromFile('asyncapi.yaml');\n3  console.log('Done!');\n4} catch (e) {\n5  console.error(e);\n6}",
      "1const Generator = require('@asyncapi/generator');\n2const content = await Generator.getTemplateFile('@asyncapi/html-template', 'partials/content.html');",
      "1const Generator = require('@asyncapi/generator');\n2const content = await Generator.getTemplateFile('@asyncapi/html-template', 'partials/content.html', '~/my-templates');"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "49bf3104",
    "title": "AsyncAPI document | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/generator/asyncapi-document.html",
    "content": "AsyncAPI document | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page AsyncAPI document generation process Method 1: originalAsyncAPI and template Method 2: asyncapi and template AsyncAPI document Found an error? Have a suggestion? Edit this page on GitHub The AsyncAPI document defines a standard, protocol-agnostic interface that describes message-based or event-driven APIs. The AsyncAPI document allows people or machines communicating with one another, to understand the capabilities of an event-driven API without requiring access to the source code, documentation, or inspecting the network traffic. This document allows you to define your API structures and formats, including channels the end user can subscribe to and the message formats they receive. The documents describing the message-driven API under the AsyncAPI specification are represented as JSON objects and conform to JSON standards. YAML, a superset of JSON, can also be used to represent an API. To learn how to create an AsyncAPI document or refresh your knowledge about the syntax and structure of the AsyncAPI document, check out our latest specification documentation . You can develop, validate, and convert the AsyncAPI document to the latest version or preview your AsyncAPI document in a more readable way using the AsyncAPI Studio . In the following sections, you'll learn about the inner working of the generator, what happens once the AsyncAPI document is fed to the generator, and how you can access the content of the document in your template. AsyncAPI document generation process The Generator receives the AsyncAPI Document as input. The Generator sends to the Parser the asyncapiString is a stringified version of the original AsyncAPI Document to validate and parse it. The Parser validates the AsyncAPI Document using additional schema-related plugins, either the OpenAPI schema, RAML data types, or Avro schema. If the Parser determines that the AsyncAPI Document is valid, it manipulates the original JSON/YAML document and provides a set of helper functions in return, bundling them together into an asyncapi variable that is an instance of AsyncAPIDocument . At this point, the Generator passes the originalAsyncAPI and the asyncapi which make up part of the Template Context to the Render Engine . The Template Context is accessible to the template files that are passed to either the react or nunjucks Render Engines . The AsyncAPI document's content is accessible to you while writing your template in two distinct ways: The originalAsyncAPI , which is a stringified version of the AsyncAPI document provided as input, without any modifications. The asyncapi ( AsyncAPIDocument ) which is an object with a set of helper functions, that comes as a result of the Parser manipulating the originalAyncAPI .The asyncapi functions make it easier to access the contents of AsyncAPI documents in your templates. In the following sections, you will learn how to use either the originalAsyncAPI or the asyncapi in your template. Method 1: originalAsyncAPI and template One way of using the contents of the AsyncAPI document inside your template files is by using its stringified version that reflects the same contents as the AsyncAPI document provided as input to the generator. You can access it directly in your templates using the originalAsyncAPI variable. You also access it via the hooks generator.originalAsyncAPI because originalAsyncAPI is also a part of the generator instance that is passed to hooks. \n```javascript\n1//example use case for using a stringified AsyncAPI document inside template hooks\n2\n3const fs = require('fs');\n4const path = require('path');\n5\n6function createAsyncapiFile(generator) {\n7  const asyncapi = generator.originalAsyncAPI;\n8  let extension;\n9\n10  try {\n11    JSON.parse(asyncapi);\n12    extension = 'json';\n13  } catch (e) {\n14    extension = 'yaml';\n15  }\n16\n17  const outputFileName = `asyncapi.${extension}`;\n18\n19  const asyncapiOutputLocation = path.resolve('./', outputFileName);\n20\n21  fs.writeFileSync(asyncapiOutputLocation, asyncapi);\n22}\n```\n Method 2: asyncapi and template A major advantage of using asyncapi (which is an instance of AsyncAPIDocument ) is that it enables the developer to easily access the AsyncAPI documents' content by simply invoking a function. Once the specification YAML or JSON document is passed as input to the generator, it is passed on to the Parser library, which then manipulates the asyncAPI document to a more structured document called the AsyncAPIDocument . Once the parser returns the document to the generator, the generator passes it to the render engine. The render engine makes the AsyncAPIDocument object accessible to your template through the asyncapi variable. For example, if you want to extract the version of your API from AsyncAPI document, you can do that by calling asyncapi.version() . You can say that this one is easy to access from JSON objects, but there are more complex scenarios. For example, to get access to all messages from all channels, you can call asyncapi.allMessages() instead of iterating through a complex JSON object on your own. In the sample code snippet below, notice how you can access the contents of the AsyncAPI document in your template using asyncapi variable from the context: \n```javascript\n1const apiName = asyncapi.info().title();\n2const channels = asyncapi.channels();\n```\n To learn about the various instances you can use to access the documents' content, look at the API of the AsyncAPI JavaScript Parser and the structure of AsyncAPIDocument Go Back Usage Up Next Template Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1//example use case for using a stringified AsyncAPI document inside template hooks\n2\n3const fs = require('fs');\n4const path = require('path');\n5\n6function createAsyncapiFile(generator) {\n7  const asyncapi = generator.originalAsyncAPI;\n8  let extension;\n9\n10  try {\n11    JSON.parse(asyncapi);\n12    extension = 'json';\n13  } catch (e) {\n14    extension = 'yaml';\n15  }\n16\n17  const outputFileName = `asyncapi.${extension}`;\n18\n19  const asyncapiOutputLocation = path.resolve('./', outputFileName);\n20\n21  fs.writeFileSync(asyncapiOutputLocation, asyncapi);\n22}",
      "1const apiName = asyncapi.info().title();\n2const channels = asyncapi.channels();"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "64b94e59",
    "title": "Configuration file | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/generator/configuration-file.html",
    "content": "Configuration file | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Example Special parameters Configuration file Found an error? Have a suggestion? Edit this page on GitHub The generator property from package.json file must contain a JSON object that may have the following information: Name Type Description renderer String Its value can be either react or nunjucks (default). apiVersion String Determines which major version of the Parser-API the template uses. For example, v2 for v2.x.x . If not specified, the Generator assumes the template is not compatible with the Parser-API so it will use the Parser-JS v1 API . For templates that need to support AsyncAPI specification v3 make sure to use v3 Parser-API . If the template uses a version of the Parser-API that is not supported by the Generator, the Generator will throw an error. supportedProtocols [String] A list with all the protocols this template supports. parameters Object[String, Object] An object with all the parameters that can be passed when generating the template. When using the command line, it's done by indicating --param name=value or -p name=value . parameters[param].description String A user-friendly description about the parameter. parameters[param].default Any Default value of the parameter if not specified. Shouldn't be used for mandatory required=true parameters. parameters[param].required Boolean Whether the parameter is required or not. conditionalFiles Object[String, Object] An object containing all the file paths that should be conditionally rendered. Each key represents a file path and each value must be an object with the keys subject and validation . The file path should be relative to the template directory inside the template. conditionalFiles[filePath].subject String The subject is a JMESPath query to grab the value you want to apply the condition to. It queries an object with the whole AsyncAPI document and, when specified, the given server. The object looks like this: { asyncapi: { ... }, server: { ... } } . If the template supports server parameter, you can access server details like for example protocol this way: server.protocol . During validation with conditionalFiles only the server that template user selected is available in the specification file. For more information about server parameter read about special parameters . conditionalFiles[filePath].validation Object The validation is a JSON Schema Draft 07 object. This JSON Schema definition will be applied to the JSON value resulting from the subject query. If validation doesn't have errors, the condition is met, and therefore the given file will be rendered. Otherwise, the file is ignored. Check JSON Schema Validation document for a list of all possible validation keywords. nonRenderableFiles [String] A list of file paths or globs that must be copied \"as-is\" to the target directory, i.e., without performing any rendering process. This is useful when you want to copy binary files. generator [String] A string representing the generator version-range the template is compatible with. This value must follow the semver syntax. E.g., >=1.0.0 , >=1.0.0 <=2.0.0 , ~1.0.0 , ^1.0.0 , 1.0.0 , etc. Read more about semver . filters [String] A list of modules containing functions that can be used as Nunjucks filters. In case of external modules, remember they need to be added as a dependency in package.json of your template. hooks Object[String, String] or Object[String, Array[String]] A list of modules containing hooks, except for the ones you keep locally in your template in the default location. For each module you must specify the exact name of the hook that should be used in the template. For a single hook, you can specify it as a string; for more hooks, you must pass an array of strings. In the case of external modules, remember they need to be added as a dependency in package.json of your template. There is also an official hooks library always included in the generator. As this is a library of multiple hooks, you still need to explicitly specify in the configuration which one you want to use. Use @asyncapi/generator-hooks as the library name. Example \n```javascript\n1\"generator\":\n2{\n3  \"renderer\": \"react\",\n4  \"apiVersion\": \"v3\",\n5  \"supportedProtocols\": [\"amqp\", \"mqtt\"],\n6  \"parameters\": {\n7    \"server\": {\n8      \"description\": \"The server you want to use in the code.\",\n9      \"required\": true\n10    },\n11    \"dummyParameter\": {\n12      \"description\": \"Example of parameter with default value.\",\n13      \"default\": \"just a string\",\n14      \"required\": false\n15    }\n16  },\n17  \"conditionalFiles\": {\n18    \"path/to/file/that/is/relative/to/template/dir/test-amqp.js\": {\n19      \"subject\": \"server.protocol\",\n20      \"validation\": {\n21        \"const\": \"amqp\"\n22      }\n23    },\n24    \"path/to/file/that/is/relative/to/template/dir/support.html\": {\n25      \"subject\": \"info.contact\",\n26        \"validation\": {\n27          \"required\": [\"url\"]\n28        }\n29    }\n30  },\n31  \"nonRenderableFiles\": [\n32    \"src/api/middlewares/*.*\",\n33    \"lib/lib/config.js\"\n34  ],\n35  \"generator\": \"<2.0.0\",\n36  \"filters\":[\n37    \"my-package-with-filters\"\n38  ],\n39  \"hooks\": {\n40    \"@asyncapi/generator-hooks\": \"hookFunctionName\",\n41    \"my-custom-hooks-package\": [\"myHook\", \"andAnotherOne\"]\n42  }\n43}\n```\n Special parameters There are some template parameters that have a special meaning: Name Description server It is used to let the template know which server from the AsyncAPI specification file you want to use. In some cases, this may be required. For instance, when generating code that connects to a specific server. Use this parameter in case your template relies on users' information about what server from the specification file they want to use during generation. You also need this parameter if you want to use server.protocol notation within conditionalFiles configuration option. Once you decide to specify this parameter for your template, it is recommended you make it a mandatory parameter otherwise a feature like conditionalFiles is not going to work if your users do not use this parameter obligatory. Go Back Template development Up Next Template context Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1\"generator\":\n2{\n3  \"renderer\": \"react\",\n4  \"apiVersion\": \"v3\",\n5  \"supportedProtocols\": [\"amqp\", \"mqtt\"],\n6  \"parameters\": {\n7    \"server\": {\n8      \"description\": \"The server you want to use in the code.\",\n9      \"required\": true\n10    },\n11    \"dummyParameter\": {\n12      \"description\": \"Example of parameter with default value.\",\n13      \"default\": \"just a string\",\n14      \"required\": false\n15    }\n16  },\n17  \"conditionalFiles\": {\n18    \"path/to/file/that/is/relative/to/template/dir/test-amqp.js\": {\n19      \"subject\": \"server.protocol\",\n20      \"validation\": {\n21        \"const\": \"amqp\"\n22      }\n23    },\n24    \"path/to/file/that/is/relative/to/template/dir/support.html\": {\n25      \"subject\": \"info.contact\",\n26        \"validation\": {\n27          \"required\": [\"url\"]\n28        }\n29    }\n30  },\n31  \"nonRenderableFiles\": [\n32    \"src/api/middlewares/*.*\",\n33    \"lib/lib/config.js\"\n34  ],\n35  \"generator\": \"<2.0.0\",\n36  \"filters\":[\n37    \"my-package-with-filters\"\n38  ],\n39  \"hooks\": {\n40    \"@asyncapi/generator-hooks\": \"hookFunctionName\",\n41    \"my-custom-hooks-package\": [\"myHook\", \"andAnotherOne\"]\n42  }\n43}"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "29e6e1ce",
    "title": "File templates | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/generator/file-templates.html",
    "content": "File templates | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Generating files with the Nunjucks render engine Example Generating files with the React render engine Example 1: Rendering hardcoded files Example 2: Rendering files based on the AsyncAPI Schema Example 3: Rendering files for each channel File templates Found an error? Have a suggestion? Edit this page on GitHub Generating files with the Nunjucks render engine Note : This section applies only to the Nunjucks render engine. For information on using the React render engine, refer to the Generating files with the React render engine section below. Note : Nunjucks renderer engine is deprecated and will be removed in the future. Use the React renderer engine instead. For more details read notes from release @asyncapi/generator@2.6.0 . It is possible to generate files for each specific object in your AsyncAPI documentation using the Nunjucks render engine. For example, you can specify a filename like $$channel$$.js to generate a file for each channel defined in your AsyncAPI. The following file-template names and extra variables are available: $$channel$$ , within the template-file you have access to two variables channel and channelName . Where the channel contains the current channel being rendered. $$message$$ , within the template-file you have access to two variables message and messageName . Where message contains the current message being rendered. $$schema$$ , within the template-file you have access to two variables schema and schemaName . Where schema contains the current schema being rendered. Only schemas from Components object are used. $$everySchema$$ , within the template-file you have access to two variables schema and schemaName . Where schema contains the current schema being rendered. Every Schema object from the entire AsyncAPI file is used. $$objectSchema$$ , within the template-file you have access to two variables schema and schemaName . Where schema contains the current schema being rendered. All the Schema objects with type object is used. $$parameter$$ , within the template-file you have access to two variables parameter and parameterName . Where the parameter contains the current parameter being rendered. $$securityScheme$$ , within the template-file you have access to two variables securityScheme and securitySchemeName . Where securityScheme contains the current security scheme being rendered. The file name will be equal to *Name variable. Example The file name is $$schema$$.txt , the content of this file is: \n```javascript\n1Schema name is '{{schemaName}}' and properties are:\n2{% for propName, prop in schema.properties() %}\n3- {{prop.uid()}}\n4{% endfor %}\n```\n With the following AsyncAPI: \n```javascript\n1components:\n2  schemas: \n3    peoplePayload:\n4      type: object\n5      properties:\n6        event:\n7          $ref: \"#/components/schemas/people\"\n8    people:\n9      type: object\n10      properties:\n11        id:\n12          type: integer\n```\n The generator creates two files peoplePayload.txt and people.txt with the following content: \n```javascript\n1Schema name is 'peoplePayload' and properties are:\n2- people\n```\n and \n```javascript\n1Schema name is 'people' and properties are:\n2- id\n```\n You can see an example of a file template that uses the Nunjucks render engine here . Generating files with the React render engine The above method of rendering file templates only works for the Nunjucks render engine. To use the React render engine, you need to follow a different approach. The React render engine allows for a more generic way to render multiple files by returning an array of File components in the rendering component. This can be particularly useful for complex templates or when you need to generate a large number of files with varying content. Example 1: Rendering hardcoded files The following is a simple hardcoded example of how to render multiple files using the React render engine: \n```javascript\n1import { File} from \"@asyncapi/generator-react-sdk\";\n2\n3export default function({ asyncapi }) {\n4  return [\n5    <File name={`file1.html`}>Content</File>,\n6    <File name={`file2.html`}>Content</File>\n7  ]\n8}\n```\n Example 2: Rendering files based on the AsyncAPI Schema In practice, to render the multiple files, that are generated from the data defined in your AsyncAPI, you'll iterate over the array of schemas and generate a file for each schema as shown in the example below: \n```javascript\n1import { File} from \"@asyncapi/generator-react-sdk\";\n2\n3/*\n4 * To render multiple files, it is enough to return an array of `File` components in the rendering component, like in following example.\n5 */\n6export default function({ asyncapi }) {\n7  const schemas = asyncapi.allSchemas();\n8  const files = [];\n9  // schemas is an instance of the Map\n10  schemas.forEach((schema) => {\n11    \n12    files.push(\n13      // We return a react file component and each time we do it, the name of the generated file will be a schema name\n14      // Content of the file will be a variable representing schema\n15      <File name={`${schema.id()}.js`}>\n16        const { schema.id() } = { JSON.stringify(schema._json, null, 2) }\n17      </File>\n18    );\n19  });\n20  return files;\n21}\n```\n Example 3: Rendering files for each channel Additionally, you can generate multiple files for each channel defined in your AsyncAPI specification using the React render engine as shown in the example below: \n```javascript\n1import { File, Text } from \"@asyncapi/generator-react-sdk\";\n2\n3\n4export default function ({ asyncapi }) {\n5  const files = [];\n6\n7  // Generate files for channels\n8  asyncapi.channels().forEach((channel) => {\n9    const channelName = channel.id();\n10\n11    files.push(\n12      <File name={`${channelName}.md`}>\n13        <Text newLines={2}># Channel: {channelName}</Text>\n14        <Text>\n15          {channel.hasDescription() && `${channel.description()}`}\n16        </Text>\n17      </File>\n18    );\n19  });\n20  return files;\n21}\n```\n The code snippet above uses the Text component to write file content to the .md markdown file. The newline property is used to ensure that the content isn't all rendered in one line in the markdown file. In summary, the code snippet above is a practical guide on generating properly formatted multiline Markdown files for each channel in an AsyncAPI document. You can see an example of a file template that uses the React render engine here . Go Back Hooks Up Next TypeScript support Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1Schema name is '{{schemaName}}' and properties are:\n2{% for propName, prop in schema.properties() %}\n3- {{prop.uid()}}\n4{% endfor %}",
      "1components:\n2  schemas: \n3    peoplePayload:\n4      type: object\n5      properties:\n6        event:\n7          $ref: \"#/components/schemas/people\"\n8    people:\n9      type: object\n10      properties:\n11        id:\n12          type: integer",
      "1Schema name is 'peoplePayload' and properties are:\n2- people",
      "1Schema name is 'people' and properties are:\n2- id",
      "1import { File} from \"@asyncapi/generator-react-sdk\";\n2\n3export default function({ asyncapi }) {\n4  return [\n5    <File name={`file1.html`}>Content</File>,\n6    <File name={`file2.html`}>Content</File>\n7  ]\n8}",
      "1import { File} from \"@asyncapi/generator-react-sdk\";\n2\n3/*\n4 * To render multiple files, it is enough to return an array of `File` components in the rendering component, like in following example.\n5 */\n6export default function({ asyncapi }) {\n7  const schemas = asyncapi.allSchemas();\n8  const files = [];\n9  // schemas is an instance of the Map\n10  schemas.forEach((schema) => {\n11    \n12    files.push(\n13      // We return a react file component and each time we do it, the name of the generated file will be a schema name\n14      // Content of the file will be a variable representing schema\n15      <File name={`${schema.id()}.js`}>\n16        const { schema.id() } = { JSON.stringify(schema._json, null, 2) }\n17      </File>\n18    );\n19  });\n20  return files;\n21}",
      "1import { File, Text } from \"@asyncapi/generator-react-sdk\";\n2\n3\n4export default function ({ asyncapi }) {\n5  const files = [];\n6\n7  // Generate files for channels\n8  asyncapi.channels().forEach((channel) => {\n9    const channelName = channel.id();\n10\n11    files.push(\n12      <File name={`${channelName}.md`}>\n13        <Text newLines={2}># Channel: {channelName}</Text>\n14        <Text>\n15          {channel.hasDescription() && `${channel.description()}`}\n16        </Text>\n17      </File>\n18    );\n19  });\n20  return files;\n21}"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "5655a518",
    "title": "Creating a template | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/generator/generator-template.html",
    "content": "Creating a template | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Prerequisites Background context Overview of steps package.json file index.js file Test using AsyncAPI CLI Creating a template 1. Create the client 2. Test the client 3. Update the template with client code 4. Write script to run the test code 5. Template your code 5a. Add parameters to the configuration file 5b. Templating index.js with React 5c. Creating a reusable component 5d. Update AsyncAPI document Where to go from here? Creating a template Found an error? Have a suggestion? Edit this page on GitHub This tutorial teaches you how to create a simple generator template using a Python MQTT client. You'll use the AsyncAPI document and the template you develop to generate Python code. Additionally, you'll create template code with a reusable component to reuse the custom functionality you create and test your code using an MQTT client. Suppose you can only sleep when the AC in your bedroom is set to 22 \u00b0C, and you can't sleep when the temperature drops or rises above that. You can install a smart monitor in your bedroom that keeps track of the temperature and notifies you to adjust it to your optimum temperature when it fluctuates. You will create a template to alert you when the bedroom's temperature fluctuates from 22 \u00b0C. In this tutorial: You'll use the Eclipse Mosquito MQTT broker , which you'll connect to subscribe and publish messages using an MQTT client. You'll use Python Paho-MQTT as the MQTT client in this project. You'll create a React template that will use the MQTT broker to allow you to monitor your bedroom's temperature and notify you when the temperature drops or rises above 22 \u00b0C. Lastly, create a reusable component for the output code's sendTemperatureDrop and sendTemperatureRise functions. Prerequisites Before you begin, make sure you have the following set up: Basic Programming Knowledge \u2013 Familiarity with JavaScript and Python. NPM & PIP \u2013 Required for installing dependencies. Install NPM from the official guide and PIP from the official guide . AsyncAPI CLI \u2013 Used for code generation, install using CLI installation guide . Docker - Required for running MQTT CLI. Install it from the official Docker website. Code Editor (VS Code recommended) \u2013 A good code editor is essential for development and debugging. Knowledge of Template Development \u2013 Review the Template Development Guide to understand the structure and minimum requirements for templates. Note: In this tutorial, we are using test.mosquitto.org as the public broker. However, sometimes it may not be reachable. If you experience any difficulty connecting to it, you can run a broker on your localhost instead. If you choose to run the broker on localhost, then in the further steps, replace all occurrences of test.mosquitto.org with localhost and run the following Docker command: \n```javascript\ndocker run -d --name mosquitto -p 1883:1883 eclipse-mosquitto\n```\n This starts an Eclipse Mosquitto broker locally on your machine, listening on port 1883. If you don\u2019t want to use Docker, you can install Mosquitto manually. Follow the official installation guide for your operating system. Background context There is a list of community maintained templates , but what if you do not find what you need? In that case, you'll create a user-defined template that generates custom output from the generator. Before you create the template, you'll need to have an AsyncAPI document that defines the properties you want to use in your template to test against. In this tutorial, you'll use the following template saved in the test/fixtures/asyncapi.yml file in your template project directory. \n```javascript\n1\n2asyncapi: 2.6.0\n3\n4info:\n5  title: Temperature Service\n6  version: 1.0.0\n7  description: This service is in charge of processing all the events related to temperature.\n8\n9servers:\n10  dev:\n11    url: test.mosquitto.org #in case you're using local mosquitto instance, change this value to localhost.\n12    protocol: mqtt\n13\n14channels:\n15  temperature/changed:\n16    description: Updates the bedroom temperature in the database when the temperatures drops or goes up.\n17    publish:\n18      operationId: temperatureChange\n19      message:\n20        description: Message that is being sent when the temperature in the bedroom changes.\n21        payload:\n22          type: object\n23          additionalProperties: false\n24          properties:\n25            temperatureId:\n26              type: string\n27components:\n28  schemas:\n29    temperatureId:\n30      type: object\n31      additionalProperties: false\n32      properties:\n33        temperatureId:\n34          type: string\n```\n Overview of steps Create a new directory for your template named python-mqtt-client-template . Install the AsyncAPI CLI using the command npm install -g @asyncapi/cli . Create a new folder test/fixtures with a file named asyncapi.yml in your fixtures directory. This file is used to define the structure of your template. You can copy the above example and paste it in your asyncapi.yml document. Create a new file named package.json in your python-mqtt-client-template directory. This file is used to define the dependencies for your template. Create a new folder python-mqtt-client-template/template . Create a new file named index.js in your template directory. This file is used to define the logic for your template. Create a test.py file to validate the logic of your application. Don't worry about this file for now. The tutorial will tell you how to create it later. Now your directory should look like this: \n```javascript\n1python-mqtt-client-template \n2\u251c\u2500\u2500 template\n3\u2502   \u2514\u2500\u2500 index.js\n4\u251c\u2500\u2500 test\n5\u2502   \u2514\u2500\u2500 fixtures\n6\u2502       \u2514\u2500\u2500 asyncapi.yml\n7\u2514\u2500\u2500 package.json\n```\n Lets break it down: package.json file The package.json file is used to define the dependencies for your template. Add the following code snippet to your package.json file: \n```javascript\n1{\n2  \"name\": \"python-mqtt-client-template\",\n3  \"version\": \"0.0.1\",\n4  \"description\": \"A template that generates a Python MQTT client using MQTT.\",\n5  \"generator\": {\n6    \"renderer\": \"react\",\n7    \"apiVersion\": \"v1\",\n8    \"generator\": \">=1.10.0 <2.0.0\",\n9    \"supportedProtocols\": [\"mqtt\"]\n10  },\n11  \"dependencies\": {\n12    \"@asyncapi/generator-react-sdk\": \"^0.2.25\"\n13  },\n14  \"devDependencies\": {\n15    \"rimraf\": \"^5.0.0\"\n16  }\n17}\n```\n Here's what is contained in the code snippet above: name -the name of your template. version - the current version of your template. description - a description of what your template does. generator - specify generator specific configuration . renderer - can either be react or nunjucks . In this case the generator will pass your template to the react render engine to generate the output. apiVersion - specifies which major version of the Parser-API your template will use. generator - a string representing the generator version-range your template is compatible with. supportedProtocols - A list that specifies which protocols are supported by your template. dependencies - specifies which version of @asyncapi/generator-react-sdk should be used. Navigate to the python-mqtt-client-template directory. Run the command npm install on your terminal to install the dependencies specified in package.json . index.js file The index.js file is used to define the logic for your template. Inside the template folder, create an index.js file and add the code snippet below: \n```javascript\n1//1\n2import { File } from '@asyncapi/generator-react-sdk'\n3//2\n4export default function ({ asyncapi }) {\n5//3\n6  return <File name=\"client.py\">{asyncapi.info().title()}</File>\n7}\n```\n The code snippet above does the following: Import the generator-react-sdk dependency. The asyncapi argument is an instance of the AsyncAPI Parser . It will allow you to access the content of the AsyncAPI document in your template using helper functions. The asyncapi.info().title() is using the info() helper function to return the info object from the AsyncAPI document illustrated in the code snippet below: \n```javascript\n1info:\n2  title: Temperature Service\n3  version: 1.0.0\n4  description: This service is in charge of processing all the events related to temperature.\n```\n The asyncapi.info().title() returns Temperature Service . Test using AsyncAPI CLI To see this in action, navigate to the python-mqtt-client-template directory. Then, run asyncapi generate fromTemplate test/fixtures/asyncapi.yml ./ -o test/project command on your terminal. If successful, you'll see the message below on your terminal: \n```javascript\n1Generation in progress. Keep calm and wait a bit... done\n2Check out your shiny new generated files at test/project.\n```\n Navigating to the test/project directory. You should see a client.py file; the only content is Temperature Service . Let's break down the previous command: asyncapi generate fromTemplate is how you use AsyncAPI generator via the AsyncAPI CLI. test/fixtures/asyncapi.yml points to your AsyncAPI document. ./ specifies the location of your template. -o specifies where to output the result. Creating a template You will create an MQTT-supported template that will generate a Python client from the template and the AsyncAPI document above. In this section, you'll: Write the MQTT client code. Write code to test the client works. Update the template to use the client code. Setup a script to help you run this code. Template your code. 1. Create the client Here is the sample code to be pasted in the client.py you generated above running the asyncapi generate fromTemplate test/fixtures/asyncapi.yml ./ -o test/project command. It uses the paho-mqtt package. \n```javascript\n1# 1\n2import paho.mqtt.client as mqtt\n3# 2\n4mqttBroker = \"test.mosquitto.org\"\n5\n6class TemperatureServiceClient:\n7    def __init__(self):\n8      # 3 \n9        self.client = mqtt.Client()\n10      # 4\n11        self.client.connect(mqttBroker)\n12\n13\n14    def sendTemperatureChange(self, id):\n15      # 5\n16        topic = \"temperature/changed\"\n17      # 6 \n18        self.client.publish(topic, id)\n```\n Make sure you have the Paho-MQTT library installed. You can install it using pip with the pip install paho-mqtt==1.6.1 command. Please note that this tutorial is based on Paho-MQTT version 1.6.1. The Paho-MQTT library has since been updated to version 2.0.0, which includes changes that are not covered in this tutorial. To ensure compatibility and to follow along without any issues, please install version 1.6.1 of the Paho-MQTT library. Let's break down the previous code snippet: Imports the MQTT module from the Paho package, which provides the MQTT client functionality. Assigns the MQTT broker address test.mosquitto.org to the variable MQTT broker. This specifies the location where the MQTT client will connect to. Defines an instance of the MQTT client object. This object will be used to establish a connection with the MQTT broker and perform MQTT operations. Defines that on client instance creation, it connects to the broker. The sendTemperatureChange is a function the client user invokes to publish a message to the broker, and its specific topic. In summary, this code sets up an MQTT client using the Paho-MQTT library. It connects to the test.mosquitto.org MQTT broker, and the sendTemperatureChange() method publishes temperature change information to the temperature/changed topic whenever called. 2. Test the client You'll interact with the Temperature Service using the client module you created above. You'll create an instance of the client using client = TemperatureServiceClient() and then use client.sendTemperatureChange function to publish messages that Temperature Service is subscribed to. Create a test/project/test.py file in your project and add the code snippet below: Now your directory should look like this: \n```javascript\n1python-mqtt-client-template\n2\u251c\u2500\u2500 template\n3\u2502   \u2514\u2500\u2500 index.js\n4\u2514\u2500\u2500 test\n5    \u251c\u2500\u2500 fixtures\n6    \u2502   \u2514\u2500\u2500 asyncapi.yml\n7    \u2514\u2500\u2500 project\n8        \u251c\u2500\u2500 client.py\n9        \u2514\u2500\u2500 test.py\n```\n \n```javascript\n1from client import TemperatureServiceClient\n2from random import randrange\n3import time\n4\n5client = TemperatureServiceClient()\n6\n7id_length = 8\n8min_value = 10**(id_length-1)  # Minimum value with 8 digits (e.g., 10000000)\n9max_value = 10**id_length - 1  # Maximum value with 8 digits (e.g., 99999999)\n10\n11while True:\n12    randomId = randrange(min_value, max_value + 1)\n13    client.sendTemperatureChange(randomId)\n14    print(\"New temperature detected \" + str(randomId) + \" sent to temperature/changed\")\n15    time.sleep(1)\n16\n```\n Navigate to the python-mqtt-client-template/test/project directory. Run the command python test.py on your terminal. You should see output similar to the snippet below logged on your terminal: \n```javascript\n1New temperature detected 64250266 sent to temperature/changed\n2New temperature detected 36947728 sent to temperature/changed\n3New temperature detected 72955029 sent to temperature/changed\n```\n To make sure your test.py and client code works check if the broker really receives temperature-related messages. You can do it using an MQTT CLI using docker. Run the command docker run hivemq/mqtt-cli sub -t temperature/changed -h test.mosquitto.org in your terminal. It will download the image if you don't have it locally, then the CLI will connect to the broker, subscribe to the temperature/changed topic and then output the temperature ids on the terminal. 3. Update the template with client code Open index.js and copy the content of client.py and replace {asyncapi.info().title()} with it. It should look like the code snippet below now: \n```javascript\n1import { File } from '@asyncapi/generator-react-sdk';\n2\n3export default function ({ asyncapi }) {\n4  return (\n5    <File name=\"client.py\">\n6      {`import paho.mqtt.client as mqtt\n7\n8mqttBroker = \"test.mosquitto.org\"\n9\n10class TemperatureServiceClient:\n11    def __init__(self):\n12        self.client = mqtt.Client()\n13        self.client.connect(mqttBroker)\n14\n15\n16    def sendTemperatureChange(self, id):\n17        topic = \"temperature/changed\"\n18        self.client.publish(topic, id)`}\n19    </File>\n20  )\n21}\n```\n 4. Write script to run the test code In package.json you can have the scripts property that you invoke by calling npm run <your_script> . After adding these scripts in package.json , it will look like the following code snippet: \n```javascript\n1    {\n2      \"name\": \"python-mqtt-client-template\",\n3      \"version\": \"0.0.1\",\n4      \"description\": \"A template that generates a Python MQTT client using MQTT.\",\n5      \"scripts\": {\n6        \"test:clean\": \"rimraf test/project/client.py\",\n7        \"test:generate\": \"asyncapi generate fromTemplate test/fixtures/asyncapi.yml ./ --output test/project --force-write\",\n8        \"test:start\": \"python test/project/test.py\",\n9        \"test\": \"npm run test:clean && npm run test:generate && npm run test:start\"\n10      },\n11      \"generator\": {\n12        \"renderer\": \"react\",\n13        \"apiVersion\": \"v1\",\n14        \"generator\": \">=1.10.0 <2.0.0\",\n15        \"supportedProtocols\": [\"mqtt\"]\n16      },\n17      \"dependencies\": {\n18        \"@asyncapi/generator-react-sdk\": \"^0.2.25\"\n19      },\n20      \"devDependencies\": {\n21        \"rimraf\": \"^5.0.0\"\n22      }\n23    }\n```\n The 4 scripts added in package.json do the following: test:clean : This script uses the rimraf package to remove the old version of the file test/project/client.py every time you run your test. test:generate : This script uses the AsyncAPI CLI to generate a new version of client.py . test:start : This script runs the python code using client.py . test : This script runs all the other scripts in proper order. Run npm test on your terminal to ensure everything works as expected. 5. Template your code 5a. Add parameters to the configuration file You often have different runtime environments in programming, e.g., development and production. You will use different servers to spin both of these instances. You'll have two broker versions, one for production and the other for development. You have defined a dev server in the AsyncAPI document: \n```javascript\n1servers:\n2  dev:\n3    url: test.mosquitto.org\n4    protocol: mqtt\n```\n This will allow you to also define the broker you will use in production in the servers section above. Therefore, we can template the code mqttBroker = 'test.mosquitto.org' in index.js so the value is populated dynamically at runtime depending on the specified server environment. The generator has a parameters object used to define parameters you use to dynamically modify your template code at runtime. It also supports the server parameter that defines the server configuration value. Navigate to package.json and add the snippet below: \n```javascript\n1    \"generator\": {\n2        # ...(redacted for brevity)\n3        \"parameters\": {\n4            \"server\": {\n5              \"description\": \"The server you want to use in the code.\",\n6              \"required\": true\n7            }\n8        }\n9    }\n```\n \"required\": true : makes the parameter mandatory and once user forgets to add it to the cli command, a proper error message is yielded. You'll pass the server to be used to generate your code using --param server=dev in the AsyncAPI CLI command. Failure to which you'll get an error: \n```javascript\nGenerator Error: This template requires the following missing params: server.\n```\n Update your test:generate script in package.json to include the server param \n```javascript\n\"test:generate\": \"asyncapi generate fromTemplate test/fixtures/asyncapi.yml ./ --output test/project --force-write --param server=dev\"\n```\n You can now replace the static broker from mqttBroker = 'test.mosquitto.org' to mqttBroker = \"${asyncapi.servers().get(params.server).url()}\" in index.js . Now the template code looks like this: \n```javascript\n1import { File } from '@asyncapi/generator-react-sdk';\n2\n3// notice that now the template not only gets the instance of parsed AsyncAPI document but also the parameters\n4export default function ({ asyncapi, params }) {\n5 \n6  return (\n7    <File name=\"client.py\">\n8      {`import paho.mqtt.client as mqtt\n9\n10mqttBroker = \"${asyncapi.servers().get(params.server).url()}\"\n11\n12class TemperatureServiceClient:\n13    def __init__(self):\n14        self.client = mqtt.Client()\n15        self.client.connect(mqttBroker)\n16\n17\n18    def sendTemperatureChange(self, id):\n19        topic = \"temperature/changed\"\n20        self.client.publish(topic, id)`}\n21    </File>\n22  )\n23}\n```\n Run npm test to validate that your code still works as expected. 5b. Templating index.js with React Python takes indentation very seriously, and our generated output will be Python code. We, therefore, need to make sure the indentation in index.js looks right so the generated code is indented correctly. After templating the code in index.js , it will look like the following code snippet: \n```javascript\n1// 1\n2import { File, Text } from '@asyncapi/generator-react-sdk'\n3export default function ({ asyncapi, params }) {\n4  return (\n5    <File name=\"client.py\">\n6    // 2\n7      <Text newLines={2}>import paho.mqtt.client as mqtt</Text>\n8    // 3\n9      <Text newLines={2}>mqttBroker = \"{asyncapi.servers().get(params.server).url()}\"</Text>\n10    // 4\n11      <Text newLines={2}>class {asyncapi.info().title().replaceAll(' ', '')}Client:</Text>\n12    // 5\n13      <Text indent={2} newLines={2}>\n14        {`def __init__(self):\n15            self.client = mqtt.Client()\n16            self.client.connect(mqttBroker)`}\n17      </Text>\n18      </File>\n19  )\n20}\n```\n Import the Text component that will wrap strings so they are indented properly in the output. Your import statement should now look like this: import { File, Text } from '@asyncapi/generator-react-sdk' . When the Paho module import is rendered in client.py file, it will add two extra new lines. The broker url is templated in a Text component removing the $ from the string template. Dynamically get the class name TemperatureServiceClient from the AsyncAPI document from the info object using the Parser API using the code: asyncapi.info().title() . It will return Temperature Service , then remove the spaces and add Client as a suffix. There is no templating needed in the __init__ function, there is only hardcoded information. If you're on the fence about which templating engine you should use in your template, check out the React render engine and nunjucks render engine documentation. In the next section, you'll refactor your template to use React. 5c. Creating a reusable component Suppose you have two channels , one to watch if the temperature drop below 22 \u00b0C and one to check if the temperature is above 22 \u00b0C, the generated output code would look like this: \n```javascript\n1import paho.mqtt.client as mqtt\n2\n3mqttBroker = \"test.mosquitto.org\"\n4\n5class TemperatureServiceClient:\n6\n7  def __init__(self):\n8              self.client = mqtt.Client()\n9              self.client.connect(mqttBroker)\n10\n11  def sendTemperatureDrop(self, id):\n12          topic = \"temperature/dropped\"\n13          self.client.publish(topic, id)\n14  def sendTemperatureRise(self, id):\n15          topic = \"temperature/risen\"\n16          self.client.publish(topic, id)\n17\n```\n You'll then need to template to dynamically generate sendTemperatureDrop and sendTemperatureRise functions in the generated code based off the AsyncAPI document content. The goal is to write template code that returns functions for channels that the Temperature Service application is subscribed to. The template code to generate these functions will look like this: \n```javascript\n1<Text indent={2} newLines={2}>\n2  <TopicFunction channels={asyncapi.channels().filterByReceive()} />\n3</Text>\n```\n It's recommended to put reusable components outside the template directory in a new directory called components. You'll create a component that will dynamically generate functions in the output for as many channels as there are in your AsyncAPI document that contains a publish operation. Add the following code in the python-mqtt-client-template/components/TopicFunction.js file, after creating the python-mqtt-client-template/components/ directory: \n```javascript\n1/*\n2 * This component returns a block of functions that user can use to send messages to specific topic.\n3 * As input it requires a list of Channel models from the parsed AsyncAPI document\n4 */\n5export function TopicFunction({ channels }) {\n6  const topicsDetails = getTopics(channels);\n7  let functions = '';\n8\n9  topicsDetails.forEach((t) => {\n10    functions += `def send${t.name}(self, id):\n11        topic = \"${t.topic}\"\n12        self.client.publish(topic, id)\\n`\n13  });\n14\n15  return functions;\n16}\n17\n18/*\n19 * This function returns a list of objects, one for each channel with two properties, name and topic\n20 * name - holds information about the operationId provided in the AsyncAPI document\n21 * topic - holds information about the address of the topic\n22 *\n23 * As input it requires a list of Channel models from the parsed AsyncAPI document\n24 */\n25function getTopics(channels) {\n26  const channelsCanSendTo = channels;\n27  let topicsDetails = [];\n28\n29  channelsCanSendTo.forEach((ch) => {\n30    const topic = {};\n31    const operationId = ch.operations().filterByReceive()[0].id();\n32    topic.name = operationId.charAt(0).toUpperCase() + operationId.slice(1);\n33    topic.topic = ch.address();\n34\n35    topicsDetails.push(topic);\n36  })\n37\n38  return topicsDetails;\n39}\n```\n { channels } : the TopicFunction component accepts a custom prop called channels and in your template code getTopics(channels) : Returns a list of objects, one for each channel with two properties; name and topic. The name holds information about the operationId provided in the AsyncAPI document while the topic holds information about the address of the topic. Import the TopicFunction component in your template code in index.js and add the template code to generate the functions to topics that the Temperature Service application is subscribed to. In your case, the final version of your template code should look like this: \n```javascript\n1import { File, Text } from '@asyncapi/generator-react-sdk'\n2import { TopicFunction } from '../components/TopicFunction'\n3\n4export default function ({ asyncapi, params }) {\n5  return (\n6    <File name=\"client.py\">\n7      <Text newLines={2}>import paho.mqtt.client as mqtt</Text>\n8\n9      <Text newLines={2}>mqttBroker = \"{asyncapi.servers().get(params.server).url()}\"</Text>\n10\n11      <Text newLines={2}>class {asyncapi.info().title().replaceAll(' ', '')}Client:</Text>\n12\n13      <Text indent={2} newLines={2}>\n14        {`def __init__(self):\n15            self.client = mqtt.Client()\n16            self.client.connect(mqttBroker)`}\n17      </Text>\n18\n19      <Text indent={2} newLines={2}>\n20        <TopicFunction channels={asyncapi.channels().filterByReceive()} />\n21      </Text>\n22    </File>\n23  )\n24}\n25\n```\n Now your directory should look like this: \n```javascript\n1python-mqtt-client-template\n2\u251c\u2500\u2500 components\n3\u2502   \u2514\u2500\u2500 TopicFunction.js\n4\u251c\u2500\u2500 template\n5\u2502   \u2514\u2500\u2500 index.js\n6\u2514\u2500\u2500 test\n7    \u251c\u2500\u2500 fixtures\n8    \u2502   \u2514\u2500\u2500 asyncapi.yml\n9    \u2514\u2500\u2500 project\n10        \u251c\u2500\u2500 client.py\n11        \u2514\u2500\u2500 test.py\n```\n Run npm test on your terminal to ensure everything works as expected. In the next section, you'll add another channel to asyncapi.yml file called temperature/dropped and temperature/risen then run the template again to make sure it still works as expected. 5d. Update AsyncAPI document Update the AsyncAPI document to use two channels: \n```javascript\n1channels:\n2  temperature/dropped:\n3    description:  Notifies the user when the temperature drops past a certain point.\n4    publish:\n5      operationId: temperatureDrop\n6      message:\n7        description: Message that is being sent when the temperature drops past a certain point.\n8        payload:\n9          type: object\n10          additionalProperties: false\n11          properties:\n12            temperatureId:\n13              type: string\n14\n15  temperature/risen:\n16    description: Notifies the user when the temperature rises past a certain point.\n17    publish:\n18      operationId: temperatureRise\n19      message:\n20        description: Message that is being sent when the temperature rises past a certain point.\n21        payload:\n22          type: object\n23          additionalProperties: false\n24          properties:\n25            temperatureId:\n26              type: string\n```\n And update your test script in test.py to test the two functions as below: \n```javascript\n1    client.sendTemperatureDrop(randomId)\n2    print(\"Temperature drop detected \" + str(randomId) + \" sent to temperature/dropped\")\n3    client.sendTemperatureRise(randomId)\n4    print(\"Temperature rise detected \" + str(randomId) + \" sent to temperature/risen\")\n```\n Run npm test to validate that everything works as expected. You should see logs similar to the snippet below in your terminal: \n```javascript\n1Temperature drop detected 49040460 sent to temperature/dropped\n2Temperature rise detected 49040460 sent to temperature/risen\n3Temperature drop detected 66943992 sent to temperature/dropped\n4Temperature rise detected 66943992 sent to temperature/risen\n```\n Where to go from here? Great job completing this tutorial! You have learnt how to use an AsyncAPI file to create a Python MQTT template and used it with the Paho-MQTT library in Python to connect to an MQTT broker and publish messages. \ud83d\ude03 If you want to tinker with a completed template and see what it would look like in production, check out the Paho-MQTT template . You can also check out the accompanying article about creating MQTT client code . You can also check out the MQTT beginners guide tutorial to learn more about asynchronous messaging using MQTT. Go Back Special file names Up Next Using private templates Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "docker run -d --name mosquitto -p 1883:1883 eclipse-mosquitto",
      "1\n2asyncapi: 2.6.0\n3\n4info:\n5  title: Temperature Service\n6  version: 1.0.0\n7  description: This service is in charge of processing all the events related to temperature.\n8\n9servers:\n10  dev:\n11    url: test.mosquitto.org #in case you're using local mosquitto instance, change this value to localhost.\n12    protocol: mqtt\n13\n14channels:\n15  temperature/changed:\n16    description: Updates the bedroom temperature in the database when the temperatures drops or goes up.\n17    publish:\n18      operationId: temperatureChange\n19      message:\n20        description: Message that is being sent when the temperature in the bedroom changes.\n21        payload:\n22          type: object\n23          additionalProperties: false\n24          properties:\n25            temperatureId:\n26              type: string\n27components:\n28  schemas:\n29    temperatureId:\n30      type: object\n31      additionalProperties: false\n32      properties:\n33        temperatureId:\n34          type: string",
      "1python-mqtt-client-template \n2\u251c\u2500\u2500 template\n3\u2502   \u2514\u2500\u2500 index.js\n4\u251c\u2500\u2500 test\n5\u2502   \u2514\u2500\u2500 fixtures\n6\u2502       \u2514\u2500\u2500 asyncapi.yml\n7\u2514\u2500\u2500 package.json",
      "1{\n2  \"name\": \"python-mqtt-client-template\",\n3  \"version\": \"0.0.1\",\n4  \"description\": \"A template that generates a Python MQTT client using MQTT.\",\n5  \"generator\": {\n6    \"renderer\": \"react\",\n7    \"apiVersion\": \"v1\",\n8    \"generator\": \">=1.10.0 <2.0.0\",\n9    \"supportedProtocols\": [\"mqtt\"]\n10  },\n11  \"dependencies\": {\n12    \"@asyncapi/generator-react-sdk\": \"^0.2.25\"\n13  },\n14  \"devDependencies\": {\n15    \"rimraf\": \"^5.0.0\"\n16  }\n17}",
      "1//1\n2import { File } from '@asyncapi/generator-react-sdk'\n3//2\n4export default function ({ asyncapi }) {\n5//3\n6  return <File name=\"client.py\">{asyncapi.info().title()}</File>\n7}",
      "1info:\n2  title: Temperature Service\n3  version: 1.0.0\n4  description: This service is in charge of processing all the events related to temperature.",
      "1Generation in progress. Keep calm and wait a bit... done\n2Check out your shiny new generated files at test/project.",
      "1# 1\n2import paho.mqtt.client as mqtt\n3# 2\n4mqttBroker = \"test.mosquitto.org\"\n5\n6class TemperatureServiceClient:\n7    def __init__(self):\n8      # 3 \n9        self.client = mqtt.Client()\n10      # 4\n11        self.client.connect(mqttBroker)\n12\n13\n14    def sendTemperatureChange(self, id):\n15      # 5\n16        topic = \"temperature/changed\"\n17      # 6 \n18        self.client.publish(topic, id)",
      "1python-mqtt-client-template\n2\u251c\u2500\u2500 template\n3\u2502   \u2514\u2500\u2500 index.js\n4\u2514\u2500\u2500 test\n5    \u251c\u2500\u2500 fixtures\n6    \u2502   \u2514\u2500\u2500 asyncapi.yml\n7    \u2514\u2500\u2500 project\n8        \u251c\u2500\u2500 client.py\n9        \u2514\u2500\u2500 test.py",
      "1from client import TemperatureServiceClient\n2from random import randrange\n3import time\n4\n5client = TemperatureServiceClient()\n6\n7id_length = 8\n8min_value = 10**(id_length-1)  # Minimum value with 8 digits (e.g., 10000000)\n9max_value = 10**id_length - 1  # Maximum value with 8 digits (e.g., 99999999)\n10\n11while True:\n12    randomId = randrange(min_value, max_value + 1)\n13    client.sendTemperatureChange(randomId)\n14    print(\"New temperature detected \" + str(randomId) + \" sent to temperature/changed\")\n15    time.sleep(1)\n16",
      "1New temperature detected 64250266 sent to temperature/changed\n2New temperature detected 36947728 sent to temperature/changed\n3New temperature detected 72955029 sent to temperature/changed",
      "1import { File } from '@asyncapi/generator-react-sdk';\n2\n3export default function ({ asyncapi }) {\n4  return (\n5    <File name=\"client.py\">\n6      {`import paho.mqtt.client as mqtt\n7\n8mqttBroker = \"test.mosquitto.org\"\n9\n10class TemperatureServiceClient:\n11    def __init__(self):\n12        self.client = mqtt.Client()\n13        self.client.connect(mqttBroker)\n14\n15\n16    def sendTemperatureChange(self, id):\n17        topic = \"temperature/changed\"\n18        self.client.publish(topic, id)`}\n19    </File>\n20  )\n21}",
      "1    {\n2      \"name\": \"python-mqtt-client-template\",\n3      \"version\": \"0.0.1\",\n4      \"description\": \"A template that generates a Python MQTT client using MQTT.\",\n5      \"scripts\": {\n6        \"test:clean\": \"rimraf test/project/client.py\",\n7        \"test:generate\": \"asyncapi generate fromTemplate test/fixtures/asyncapi.yml ./ --output test/project --force-write\",\n8        \"test:start\": \"python test/project/test.py\",\n9        \"test\": \"npm run test:clean && npm run test:generate && npm run test:start\"\n10      },\n11      \"generator\": {\n12        \"renderer\": \"react\",\n13        \"apiVersion\": \"v1\",\n14        \"generator\": \">=1.10.0 <2.0.0\",\n15        \"supportedProtocols\": [\"mqtt\"]\n16      },\n17      \"dependencies\": {\n18        \"@asyncapi/generator-react-sdk\": \"^0.2.25\"\n19      },\n20      \"devDependencies\": {\n21        \"rimraf\": \"^5.0.0\"\n22      }\n23    }",
      "1servers:\n2  dev:\n3    url: test.mosquitto.org\n4    protocol: mqtt",
      "1    \"generator\": {\n2        # ...(redacted for brevity)\n3        \"parameters\": {\n4            \"server\": {\n5              \"description\": \"The server you want to use in the code.\",\n6              \"required\": true\n7            }\n8        }\n9    }",
      "Generator Error: This template requires the following missing params: server.",
      "\"test:generate\": \"asyncapi generate fromTemplate test/fixtures/asyncapi.yml ./ --output test/project --force-write --param server=dev\"",
      "1import { File } from '@asyncapi/generator-react-sdk';\n2\n3// notice that now the template not only gets the instance of parsed AsyncAPI document but also the parameters\n4export default function ({ asyncapi, params }) {\n5 \n6  return (\n7    <File name=\"client.py\">\n8      {`import paho.mqtt.client as mqtt\n9\n10mqttBroker = \"${asyncapi.servers().get(params.server).url()}\"\n11\n12class TemperatureServiceClient:\n13    def __init__(self):\n14        self.client = mqtt.Client()\n15        self.client.connect(mqttBroker)\n16\n17\n18    def sendTemperatureChange(self, id):\n19        topic = \"temperature/changed\"\n20        self.client.publish(topic, id)`}\n21    </File>\n22  )\n23}",
      "1// 1\n2import { File, Text } from '@asyncapi/generator-react-sdk'\n3export default function ({ asyncapi, params }) {\n4  return (\n5    <File name=\"client.py\">\n6    // 2\n7      <Text newLines={2}>import paho.mqtt.client as mqtt</Text>\n8    // 3\n9      <Text newLines={2}>mqttBroker = \"{asyncapi.servers().get(params.server).url()}\"</Text>\n10    // 4\n11      <Text newLines={2}>class {asyncapi.info().title().replaceAll(' ', '')}Client:</Text>\n12    // 5\n13      <Text indent={2} newLines={2}>\n14        {`def __init__(self):\n15            self.client = mqtt.Client()\n16            self.client.connect(mqttBroker)`}\n17      </Text>\n18      </File>\n19  )\n20}",
      "1import paho.mqtt.client as mqtt\n2\n3mqttBroker = \"test.mosquitto.org\"\n4\n5class TemperatureServiceClient:\n6\n7  def __init__(self):\n8              self.client = mqtt.Client()\n9              self.client.connect(mqttBroker)\n10\n11  def sendTemperatureDrop(self, id):\n12          topic = \"temperature/dropped\"\n13          self.client.publish(topic, id)\n14  def sendTemperatureRise(self, id):\n15          topic = \"temperature/risen\"\n16          self.client.publish(topic, id)\n17",
      "1<Text indent={2} newLines={2}>\n2  <TopicFunction channels={asyncapi.channels().filterByReceive()} />\n3</Text>",
      "1/*\n2 * This component returns a block of functions that user can use to send messages to specific topic.\n3 * As input it requires a list of Channel models from the parsed AsyncAPI document\n4 */\n5export function TopicFunction({ channels }) {\n6  const topicsDetails = getTopics(channels);\n7  let functions = '';\n8\n9  topicsDetails.forEach((t) => {\n10    functions += `def send${t.name}(self, id):\n11        topic = \"${t.topic}\"\n12        self.client.publish(topic, id)\\n`\n13  });\n14\n15  return functions;\n16}\n17\n18/*\n19 * This function returns a list of objects, one for each channel with two properties, name and topic\n20 * name - holds information about the operationId provided in the AsyncAPI document\n21 * topic - holds information about the address of the topic\n22 *\n23 * As input it requires a list of Channel models from the parsed AsyncAPI document\n24 */\n25function getTopics(channels) {\n26  const channelsCanSendTo = channels;\n27  let topicsDetails = [];\n28\n29  channelsCanSendTo.forEach((ch) => {\n30    const topic = {};\n31    const operationId = ch.operations().filterByReceive()[0].id();\n32    topic.name = operationId.charAt(0).toUpperCase() + operationId.slice(1);\n33    topic.topic = ch.address();\n34\n35    topicsDetails.push(topic);\n36  })\n37\n38  return topicsDetails;\n39}",
      "1import { File, Text } from '@asyncapi/generator-react-sdk'\n2import { TopicFunction } from '../components/TopicFunction'\n3\n4export default function ({ asyncapi, params }) {\n5  return (\n6    <File name=\"client.py\">\n7      <Text newLines={2}>import paho.mqtt.client as mqtt</Text>\n8\n9      <Text newLines={2}>mqttBroker = \"{asyncapi.servers().get(params.server).url()}\"</Text>\n10\n11      <Text newLines={2}>class {asyncapi.info().title().replaceAll(' ', '')}Client:</Text>\n12\n13      <Text indent={2} newLines={2}>\n14        {`def __init__(self):\n15            self.client = mqtt.Client()\n16            self.client.connect(mqttBroker)`}\n17      </Text>\n18\n19      <Text indent={2} newLines={2}>\n20        <TopicFunction channels={asyncapi.channels().filterByReceive()} />\n21      </Text>\n22    </File>\n23  )\n24}\n25",
      "1python-mqtt-client-template\n2\u251c\u2500\u2500 components\n3\u2502   \u2514\u2500\u2500 TopicFunction.js\n4\u251c\u2500\u2500 template\n5\u2502   \u2514\u2500\u2500 index.js\n6\u2514\u2500\u2500 test\n7    \u251c\u2500\u2500 fixtures\n8    \u2502   \u2514\u2500\u2500 asyncapi.yml\n9    \u2514\u2500\u2500 project\n10        \u251c\u2500\u2500 client.py\n11        \u2514\u2500\u2500 test.py",
      "1channels:\n2  temperature/dropped:\n3    description:  Notifies the user when the temperature drops past a certain point.\n4    publish:\n5      operationId: temperatureDrop\n6      message:\n7        description: Message that is being sent when the temperature drops past a certain point.\n8        payload:\n9          type: object\n10          additionalProperties: false\n11          properties:\n12            temperatureId:\n13              type: string\n14\n15  temperature/risen:\n16    description: Notifies the user when the temperature rises past a certain point.\n17    publish:\n18      operationId: temperatureRise\n19      message:\n20        description: Message that is being sent when the temperature rises past a certain point.\n21        payload:\n22          type: object\n23          additionalProperties: false\n24          properties:\n25            temperatureId:\n26              type: string",
      "1    client.sendTemperatureDrop(randomId)\n2    print(\"Temperature drop detected \" + str(randomId) + \" sent to temperature/dropped\")\n3    client.sendTemperatureRise(randomId)\n4    print(\"Temperature rise detected \" + str(randomId) + \" sent to temperature/risen\")",
      "1Temperature drop detected 49040460 sent to temperature/dropped\n2Temperature rise detected 49040460 sent to temperature/risen\n3Temperature drop detected 66943992 sent to temperature/dropped\n4Temperature rise detected 66943992 sent to temperature/risen"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "3e8dc3ce",
    "title": "Hooks | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/generator/hooks.html",
    "content": "Hooks | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Types Location Examples Official library Hooks Found an error? Have a suggestion? Edit this page on GitHub Hooks are functions called by the generator on a specific moment in the generation process. Hooks can be anonymous functions but you can also add function names. These hooks can have arguments provided to them or being expected to return a value. Types The following types of hooks are currently supported: Hook type Description Return type Arguments generate:before Called after registration of all filters and before the generator starts processing of the template. void : Nothing is expected to be returned. The generator instance generate:after Called at the very end of the generation. void : Nothing is expected to be returned. The generator instance setFileTemplateName Called right before saving a new file generated by file template . string : a new filename for the generator to use for the file template. The generator instance and object in the form of { \"originalFilename\" : string } Location The generator parses: All the files in the .hooks directory inside the template. All modules listed in the template configuration and triggers only hooks whose names were added to the config. You can use an official hooks library that is bundled together with the generator. To learn how to add hooks to configuration read more about the configuration file . Examples Some of the examples have names of hook functions provided and some not. Keep in mind that hook functions kept in template in default location do not require a name. Name is required only if you keep hooks in non default location or in a separate library, because such hooks need to be explicitly configured in the configuration file. For more details on hooks configuration read more about the configuration file . Most basic modules with hooks look like this: \n```javascript\n1module.exports = {\n2  'generate:after': generator => console.log('This runs after generation is complete')\n3}\n```\n Below you have an example Hook that after generation creates an AsyncAPI file. \n```javascript\n1const fs = require('fs');\n2const path = require('path');\n3\n4module.exports = {\n5  'generate:after': generator => {\n6    const asyncapi = generator.originalAsyncAPI;\n7    let extension;\n8\n9    try {\n10      JSON.parse(asyncapi);\n11      extension = 'json';\n12    } catch (e) {\n13      extension = 'yaml';\n14    }\n15\n16    fs.writeFileSync(path.resolve(generator.targetDir, `asyncapi.${extension}`), asyncapi);\n17  }\n18};\n```\n And here an example Hook that before generation switches publish and subscribe operations for each channel. \n```javascript\n1module.exports = {\n2  'generate:before': function switchOperations(generator) {\n3    const asyncapi = generator.asyncapi;\n4    for (let [key, value] of Object.entries(asyncapi.channels())) {\n5      let publish = value._json.publish;\n6      value._json.publish = value._json.subscribe;\n7      value._json.subscribe = publish;\n8      if (!value._json.subscribe) {\n9        delete value._json.subscribe;\n10      }\n11      if (!value._json.publish) {\n12        delete value._json.publish;\n13      }\n14    }\n15  };\n16};\n```\n Example hook for changing the filename of a template file. Replaces all '-' characters with '_'. \n```javascript\n1module.exports = {\n2\t'setFileTemplateName': (generator, hookArguments) => {\n3\t\tconst currentFilename = hookArguments.originalFilename ;\n4\t\treturn currentFilename.replace('-', '_')\n5\t};\n6};\n```\n Official library It is a library of reusable hooks that you can use in your templates. You only have to add its name to the configuration: @asyncapi/generator-hooks and specify which hook you want to enable. This library consists of the following hooks: Hook name Hook type Description createAsyncapiFile generate:after It creates an AsyncAPI file with the content of the spec file passed to the generator. By default, it creates the file in the root of the generation output directory. This hook also supports custom parameters that the user can pass to template generation. The parameter called asyncapiFileDir allows the user to specify the location where the spec file should be created. To make your template users use this parameter, you need to add it to the configuration of your template like other parameters In your template configuration in package.json specify you want to use this library and what hook exactly: \n```javascript\n1{\n2  \"generator\": {\n3      \"hooks\": {\n4          \"@asyncapi/generator-hooks\": \"createAsyncapiFile\"\n5      }\n6  }\n7}\n```\n Some hooks support custom parameters that template's user can use to specify different behaviour of the hook. To enable these, you need to also add them to the list of your template's parameters: \n```javascript\n1{\n2  \"generator\": {\n3      \"parameters\": {\n4        \"asyncapiFileDir\": {\n5            \"description\": \"This template by default also outputs the AsyncAPI document that was passed as input. You can specify with this parameter what should be the location of this AsyncAPI document, relative to specified template output.\"\n6        }\n7    }\n8  }\n9}\n```\n Go Back Nunjucks render engine Up Next File templates Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1module.exports = {\n2  'generate:after': generator => console.log('This runs after generation is complete')\n3}",
      "1const fs = require('fs');\n2const path = require('path');\n3\n4module.exports = {\n5  'generate:after': generator => {\n6    const asyncapi = generator.originalAsyncAPI;\n7    let extension;\n8\n9    try {\n10      JSON.parse(asyncapi);\n11      extension = 'json';\n12    } catch (e) {\n13      extension = 'yaml';\n14    }\n15\n16    fs.writeFileSync(path.resolve(generator.targetDir, `asyncapi.${extension}`), asyncapi);\n17  }\n18};",
      "1module.exports = {\n2  'generate:before': function switchOperations(generator) {\n3    const asyncapi = generator.asyncapi;\n4    for (let [key, value] of Object.entries(asyncapi.channels())) {\n5      let publish = value._json.publish;\n6      value._json.publish = value._json.subscribe;\n7      value._json.subscribe = publish;\n8      if (!value._json.subscribe) {\n9        delete value._json.subscribe;\n10      }\n11      if (!value._json.publish) {\n12        delete value._json.publish;\n13      }\n14    }\n15  };\n16};",
      "1module.exports = {\n2\t'setFileTemplateName': (generator, hookArguments) => {\n3\t\tconst currentFilename = hookArguments.originalFilename ;\n4\t\treturn currentFilename.replace('-', '_')\n5\t};\n6};",
      "1{\n2  \"generator\": {\n3      \"hooks\": {\n4          \"@asyncapi/generator-hooks\": \"createAsyncapiFile\"\n5      }\n6  }\n7}",
      "1{\n2  \"generator\": {\n3      \"parameters\": {\n4        \"asyncapiFileDir\": {\n5            \"description\": \"This template by default also outputs the AsyncAPI document that was passed as input. You can specify with this parameter what should be the location of this AsyncAPI document, relative to specified template output.\"\n6        }\n7    }\n8  }\n9}"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "7de7bc6a",
    "title": "Installation guide | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/generator/installation-guide.html",
    "content": "Installation guide | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Prerequisites AsyncAPI CLI Generator library in Node.js apps Installation guide Found an error? Have a suggestion? Edit this page on GitHub You can use the generator library to generate whatever you want in your event-driven architecture apps. Find your preferred method below: AsyncAPI CLI Generator library in Node.js apps Prerequisites Before you install and use the AsyncAPI CLI and the generator library, ensure you meet the prerequisites below, then install the CLI . Node.js v18.12.0 or higher Npm v8.19.0 or higher To verify the versions of Node and Npm you have, run the following command on your terminal: npm -v node -v If you don't have either Node or Npm installed, use the official node.js installer . If you have the correct versions installed, proceed to the CLI installation guide below. Otherwise, upgrading the Npm or Node version is lower than the recommended versions specified above. AsyncAPI CLI The AsyncAPI CLI tool allows you to do many different things with the AsyncAPI document . You can generate message-based API boilerplate code, documentation, or anything else you need as long as you specify it in your template or the existing template already supports it. To use the generator via the AsyncAPI CLI, you need to install the AsyncAPI CLI tool. For the latest installation instructions, visit the official AsyncAPI CLI installation guide . \ud83d\udcdd Note: To use the generator in your CI/CD pipeline to automate whatever you generate for your event-driven architecture apps, install the AsyncAPI CLI in your pipeline. If you are using GitHub Actions, use Github Actions for Generator . Generator library in Node.js apps Use the generator library in your Node.js projects by installing it via the following command: npm install @asyncapi/generator . Don't include the -g flag in the installation command above since you're not installing the generator library globally but in your Node.js project. Go Back Introduction Up Next Usage Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "415262b3",
    "title": "Migrating from `ag` CLI to AsyncAPI CLI | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/generator/migration-cli.html",
    "content": "Migrating from `ag` CLI to AsyncAPI CLI | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Options Overview Migration Steps 1. Install AsyncAPI CLI 2. Update Your Commands 3. Verify and Test Additional Resources Migrating from `ag` CLI to AsyncAPI CLI Found an error? Have a suggestion? Edit this page on GitHub This guide provides detailed instructions on how to transition from the old ag Generator CLI to the new AsyncAPI CLI. Options Overview Here is a list of ag options and their equivalents in the AsyncAPI CLI: -d, --disable-hook [hooks...] AsyncAPI CLI equivalent: asyncapi generate fromTemplate <ASYNCAPI> <TEMPLATE> --disable-hook <hookType>=<hookName> --debug AsyncAPI CLI equivalent: asyncapi generate fromTemplate <ASYNCAPI> <TEMPLATE> --debug -i, --install AsyncAPI CLI equivalent: asyncapi generate fromTemplate <ASYNCAPI> <TEMPLATE> --install -n, --no-overwrite <glob> AsyncAPI CLI equivalent: asyncapi generate fromTemplate <ASYNCAPI> <TEMPLATE> --no-overwrite <glob> -o, --output <outputDir> AsyncAPI CLI equivalent: asyncapi generate fromTemplate <ASYNCAPI> <TEMPLATE> --output <outputDir> -p, --param <name=value> AsyncAPI CLI equivalent: asyncapi generate fromTemplate <ASYNCAPI> <TEMPLATE> --param <name=value> --force-write AsyncAPI CLI equivalent: asyncapi generate fromTemplate <ASYNCAPI> <TEMPLATE> --force-write --watch-template AsyncAPI CLI equivalent: asyncapi generate fromTemplate <ASYNCAPI> <TEMPLATE> --watch --map-base-url <url:folder> AsyncAPI CLI equivalent: asyncapi generate fromTemplate <ASYNCAPI> <TEMPLATE> --map-base-url <url:folder> Migration Steps 1. Install AsyncAPI CLI There are multiple different artifacts that AsyncAPI CLI is provided as. Get familiar with the official CLI installation guide . 2. Update Your Commands Replace the deprecated ag commands with the AsyncAPI CLI equivalents. Below are examples of how to update your commands: Using ag : \n```javascript\nag ./asyncapi.yaml ./template -o ./output -p param1=value1 --debug --install --disable-hook hookType=hookName\n```\n Using AsyncAPI CLI : \n```javascript\nasyncapi generate fromTemplate ./asyncapi.yaml ./template -o ./output -p param1=value1 --debug --install --disable-hook hookType=hookName\n```\n Notice that the change basically related to changing from ag to asyncapi generate fromTemplate . 3. Verify and Test Run the updated commands to ensure they work as expected and verify that the output files are generated correctly. Additional Resources CLI Documentation : AsyncAPI CLI Documentation Installation : AsyncAPI CLI Installation Usage : AsyncAPI CLI Usage Support : For any issues with CLI, create an issue in CLI repository . Go Back Migrating from Nunjucks to React render engine Up Next CLI - Introduction Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "ag ./asyncapi.yaml ./template -o ./output -p param1=value1 --debug --install --disable-hook hookType=hookName",
      "asyncapi generate fromTemplate ./asyncapi.yaml ./template -o ./output -p param1=value1 --debug --install --disable-hook hookType=hookName"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "1a3c6a18",
    "title": "Migrating from Nunjucks to React render engine | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/generator/migration-nunjucks-react.html",
    "content": "Migrating from Nunjucks to React render engine | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Step-by-step migration guide 1. Update package.json 2. Install dependencies 3. File naming 4. Basic template structure 5. Macros and Partials 6. File template 7. Models generation Additional Resources and Information Template Examples Filters to Helpers Hooks Remain Unchanged Testing your migration Conclusion Migrating from Nunjucks to React render engine Found an error? Have a suggestion? Edit this page on GitHub The AsyncAPI Generator is moving away from Nunjucks templates in favor of React templates. This guide will help you migrate your existing Nunjucks templates to React. For a comprehensive understanding of why we introduced React as an alternative in 2021 and why we're now removing Nunjucks entirely, please read our article React as a Generator Engine . The principles discussed in this article still apply to our current transition. Step-by-step migration guide 1. Update package.json Change your template configuration in package.json : \n```javascript\n1{\n2\"generator\": {\n3\"renderer\": \"react\"\n4}\n5}\n```\n Once the deprecation period has ended, and we remove the default Nunjucks, the React render engine will be used by default and this setting will no longer be needed to configure 2. Install dependencies Install the necessary React dependencies: npm install @asyncapi/generator-react-sdk 3. File naming In Nunjucks, the template's filename directly corresponds to the output file. For example, a template named index.html will generate an index.html file. In React, the filename of the generated file is not controlled by the file itself, but rather by the File component. The React component itself can be named anything with a .js extension because the output filename is controlled by the name attribute of the File component used inside the template file. Below you can see some examples of filenames: Nunjucks: index.html React: index.js or index.html.js or anything-you-want.js 4. Basic template structure Nunjucks: \n```javascript\n1<h1>{{ asyncapi.info().title() }}</h1>\n2<p>{{ asyncapi.info().description() }}</p>\n```\n React: \n```javascript\n1import { File } from '@asyncapi/generator-react-sdk';\n2\n3export default function({ asyncapi }) {\n4  return (\n5    <File name=\"index.html\">\n6      <h1>{asyncapi.info().title()}</h1>\n7      <p>{asyncapi.info().description()}</p>\n8    </File>\n9  );\n10}\n```\n 5. Macros and Partials Replace macros with React components: Nunjucks: \n```javascript\n1{% macro renderChannel(channel) %}\n2  <div class=\"channel\">\n3    <h3>{{ channel.address() }}</h3>\n4    <p>{{ channel.description() }}</p>\n5  </div>\n6{% endmacro %}\n7\n8{{ renderChannel(someChannel) }}\n```\n React: \n```javascript\n1// components/Channel.js\n2import { Text } from '@asyncapi/generator-react-sdk';\n3\n4export function Channel({ channel }) {\n5  return (\n6    <Text>\n7      <div className=\"channel\">\n8        <h3>{channel.address()}</h3>\n9        <p>{channel.description()}</p>\n10      </div>\n11    </Text>\n12  );\n13}\n14\n15// Main template\n16import { File, Text } from '@asyncapi/generator-react-sdk';\n17import { Channel } from './components/Channel';\n18\n19export default function({ asyncapi }) {\n20  return (\n21    <File name=\"channels.html\">\n22      <Text>\n23        <h2>Channels</h2>\n24      </Text>\n25      {asyncapi.channels().map(channel => (\n26        <Channel channel={channel} />\n27      ))}\n28    </File>\n29  );\n30}\n```\n 6. File template Check the detailed guide on file templates to learn what is the difference between templating multiple file outputs in Nunjucks and React. 7. Models generation If you have a template written with Nunjucks, it is almost certain that you have your own custom models, classes, or types templates in place. Instead of migrating them to React render engine we strongly advise you to delegate models generation to AsyncAPI Modelina project. Learn more about how to add models generation using Modelina . Additional Resources and Information Template Examples For a complete example of React features in use, please refer to the AsyncAPI Template for Generator Templates . The master branch demonstrates all React features, while the nunjucks branch shows the old Nunjucks implementation. This comparison can be particularly helpful in understanding the differences and migration process. Filters to Helpers If you've been using Nunjucks filters placed in the filters directory, you can still use this functionality in React. However, they should be treated as normal functions that you import into your components. We recommend renaming the filters directory to helpers to better reflect their new usage in React. Hooks Remain Unchanged It's important to note that hooks remain unchanged in this migration process. Hooks are not related to the render engine functionality, so you can continue to use them as you have been. Testing your migration After migrating, test your template thoroughly: Run the generator using your new React template Compare the output with the previous Nunjucks template output Check for any missing or incorrectly rendered content Consider implementing snapshot tests for your template before starting the migration. This will ease the review of changes in comparing the content rendered after render engine changes. Snapshot tests allow you to have tests that will persist expected output from Nunjucks template, and compare it with output generated after the migration. Check out an example of such snapshot integration test for our internal react template we use for development and testing . Conclusion Migrating from Nunjucks to React templates may require some initial effort, but it will result in more maintainable code. You can learn more about why we introduced the React render engine from article React as a Generator Engine . Go Back Adding models generation in template Up Next Migrating from `ag` CLI to AsyncAPI CLI Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1{\n2\"generator\": {\n3\"renderer\": \"react\"\n4}\n5}",
      "1<h1>{{ asyncapi.info().title() }}</h1>\n2<p>{{ asyncapi.info().description() }}</p>",
      "1import { File } from '@asyncapi/generator-react-sdk';\n2\n3export default function({ asyncapi }) {\n4  return (\n5    <File name=\"index.html\">\n6      <h1>{asyncapi.info().title()}</h1>\n7      <p>{asyncapi.info().description()}</p>\n8    </File>\n9  );\n10}",
      "1{% macro renderChannel(channel) %}\n2  <div class=\"channel\">\n3    <h3>{{ channel.address() }}</h3>\n4    <p>{{ channel.description() }}</p>\n5  </div>\n6{% endmacro %}\n7\n8{{ renderChannel(someChannel) }}",
      "1// components/Channel.js\n2import { Text } from '@asyncapi/generator-react-sdk';\n3\n4export function Channel({ channel }) {\n5  return (\n6    <Text>\n7      <div className=\"channel\">\n8        <h3>{channel.address()}</h3>\n9        <p>{channel.description()}</p>\n10      </div>\n11    </Text>\n12  );\n13}\n14\n15// Main template\n16import { File, Text } from '@asyncapi/generator-react-sdk';\n17import { Channel } from './components/Channel';\n18\n19export default function({ asyncapi }) {\n20  return (\n21    <File name=\"channels.html\">\n22      <Text>\n23        <h2>Channels</h2>\n24      </Text>\n25      {asyncapi.channels().map(channel => (\n26        <Channel channel={channel} />\n27      ))}\n28    </File>\n29  );\n30}"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "c477b43c",
    "title": "Adding models generation in template | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/generator/model-generation.html",
    "content": "Adding models generation in template | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Add Modelina dependency Create a models.js file Conclusion Adding models generation in template Found an error? Have a suggestion? Edit this page on GitHub This guide will walk you through the process of enabling models/types generation in a template by using Modelina . Modelina is an AsyncAPI library designed for generating data models using inputs such as AsyncAPI , OpenAPI, or JSON schema inputs. Its functionality revolves around creating data models from the provided AsyncAPI document and the model template, which defines message payloads. It is better to use Modelina in your template to handle model generation rather than providing custom templates. You can integrate the work shown in this guide into a template by following the tutorial about creating a template . In this guide, you'll learn how to use Modelina in a template code to enable support for Python data model generation. Add Modelina dependency Install Modelina in your project using npm: npm install --save @asyncapi/modelina . Ensure your template's package.json file now contains Modelina pointing to its latest version: \n```javascript\n1\"dependencies\": {\n2   // ...\n3   \"@asyncapi/modelina\": \"^2.0.5\"\n4   // ...\n5 }\n```\n Create a models.js file Create a new directory in the template directory named src/models and create a models.js file within it. In the models.js file, add the following code: \n```javascript\n1// 1\n2import { File } from '@asyncapi/generator-react-sdk';\n3// 2\n4import { PythonGenerator, FormatHelpers } from '@asyncapi/modelina';\n5\n6/**\n7 * @typedef RenderArgument\n8 * @type {object}\n9 * @property {AsyncAPIDocument} asyncapi document object received from the generator.\n10 */\n11\n12/**\n13 * Render all schema models\n14 * @param {RenderArgument} param0 \n15 * @returns \n16 */\n17// 3\n18export default async function schemaRender({ asyncapi }) {\n19  // 4 \n20  const pythonGenerator = new PythonGenerator();\n21  // 5\n22  const models = await pythonGenerator.generate(asyncapi);\n23  // 6\n24  const files = [];\n25  // 7\n26  for (const model of models) {\n27    // 8\n28    const modelFileName = `${FormatHelpers.toPascalCase(model.modelName)}.py`;\n29    // 9\n30    files.push(<File name={modelFileName}>{model.result}</File>);\n31  }\n32  return files;\n33}\n```\n Let's break it down. The code snippet above does the following: The File component from the generator react SDK is needed to handle the further rendering of generated models into files. The PythonGenerator generator is the core needed for model generation. Additionally, you can import FormatHelpers that provides a set of helpers making it easier to modify model names to match your required case. You can change the name schemaRender to anything else like modelRenderer . More importantly, this must be an async function and a default export. This function is invoked during generation process and should contain the logic behind models generation. First, create an instance of the PythonGenerator model generator. If you decide to use present functionality from Modelina, you need to pass your presets here during instance creation. The actual model generation is one line of code, and as a result you get an array of models that later you need to turn into files. You need to define an array that must be returned from schemaRender function. The array must contain React components, and in this case, the <File> component. Iterate over generated models and use their content to create proper definitions of <File> components. Notice how using Modelina helpers, in this case the toPascalCase function, let's you make sure that the filename of your model follows specific case pattern. Each component must be added into the files array that you later return from the default function. Notice the definition of the <File> component that enables you to provide the name of resulting file and the content of the model. Notice also model.result that shows that initially generated array with models did not contain raw models content but a set of output objects that contain not only result but also other info, like for example modelName . With such a model template that uses Modelina, as a result of generation process you would receive a set of model files in $OUTPUT_DIR/src/models directory. Conclusion Modelina provides a flexible and powerful way to generate data models from AsyncAPI, OpenAPI, or JSON Schema documents. By integrating Modelina you can much faster enable models generation in your template. Go Back Using private templates Up Next Migrating from Nunjucks to React render engine Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1\"dependencies\": {\n2   // ...\n3   \"@asyncapi/modelina\": \"^2.0.5\"\n4   // ...\n5 }",
      "1// 1\n2import { File } from '@asyncapi/generator-react-sdk';\n3// 2\n4import { PythonGenerator, FormatHelpers } from '@asyncapi/modelina';\n5\n6/**\n7 * @typedef RenderArgument\n8 * @type {object}\n9 * @property {AsyncAPIDocument} asyncapi document object received from the generator.\n10 */\n11\n12/**\n13 * Render all schema models\n14 * @param {RenderArgument} param0 \n15 * @returns \n16 */\n17// 3\n18export default async function schemaRender({ asyncapi }) {\n19  // 4 \n20  const pythonGenerator = new PythonGenerator();\n21  // 5\n22  const models = await pythonGenerator.generate(asyncapi);\n23  // 6\n24  const files = [];\n25  // 7\n26  for (const model of models) {\n27    // 8\n28    const modelFileName = `${FormatHelpers.toPascalCase(model.modelName)}.py`;\n29    // 9\n30    files.push(<File name={modelFileName}>{model.result}</File>);\n31  }\n32  return files;\n33}"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "246b2308",
    "title": "Nunjucks render engine | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/generator/nunjucks-render-engine.html",
    "content": "Nunjucks render engine | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Common assumptions Partials Filters Nunjucks render engine Found an error? Have a suggestion? Edit this page on GitHub Note : Nunjucks renderer engine is deprecated and will be removed in the future. Use the React renderer engine instead. For more details read notes from release @asyncapi/generator@2.6.0 . Nunjucks is the default render engine, however, we strongly recommend adopting the React engine. Common assumptions Templates may contain Nunjucks filters or helper functions . Read more about filters . Templates may contain partials (reusable chunks). They must be stored in the .partials directory under the template directory. Read more about partials . Templates may contain multiple files. Unless stated otherwise, all files will be rendered. The default variables you have access to in any the template file are the following: asyncapi that is a parsed spec file object. Read the API of the Parser to understand what structure you have access to in this parameter. originalAsyncAPI that is an original spec file before it is parsed. params that contain the parameters provided when generating. Partials Files from the .partials directory do not end up with other generated files in the target directory. In this directory you should keep reusable templates chunks that you can include in your templates. You can also put there macros to use them in templates, like in below example: \n```javascript\n1{# tags.html #}\n2{% macro tags(tagList) %}\n3<div class=\"mt-4\">\n4  {% for tag in tagList %}\n5    <span class=\"bg-grey-dark font-normal text-sm no-underline text-white rounded lowercase mr-2 px-2 py-1\" title=\"{{tag.description()}}\">{{tag.name()}}</span>\n6  {% endfor %}\n7</div>\n8{% endmacro %}\n9\n10{# operations.html #}\n11{% from \"./tags.html\" import tags %}\n12{{ tags(operation.tags()) }}\n```\n Filters A filter is a helper function that you can create to perform complex tasks. They are JavaScript files that register one or many Nunjuck filters . The generator parses all the files in the filters directory. Functions exported from these files are registered as filters. You can use the filter function in your template as in the following example: \n```javascript\nconst {{ channelName | camelCase }} = '{{ channelName }}';\n```\n The generator also supports asynchronous filters. Asynchronous filters receive as the last argument a callback to resume rendering. Asynchronous filters must be annotated with the async keyword. Make sure to call the callback with two arguments: callback(err, res) . err can be null . See the following example of how to use asynchronous filters: \n```javascript\n1const filter = module.exports;\n2\n3async function asyncCamelCase(str, callback) {\n4  try {\n5    const result = // logic for camel casing str\n6    callback(null, result);\n7  } catch (error) {\n8    callback(error);\n9  }\n10}\n11filter.renderAsyncContent = renderAsyncContent;\n12\n13// using in template\n14{{ channelName | asyncCamelCase }}\n```\n Unfortunately, if you need to use Promise, filter still must be annotated with the async keyword: \n```javascript\n1async function asyncCamelCase(str, callback) {\n2  return new Promise((resolve, reject) => {\n3    // logic with callback\n4  });\n5}\n```\n In case you have more than one template and want to reuse filters, you can put them in a single library. You can configure such a library in the template configuration under filters property. To learn how to add such filters to configuration read more about the configuration file . You can also use the official AsyncAPI nunjucks-filters that are by default included in the generator library. Go Back React render engine Up Next Hooks Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1{# tags.html #}\n2{% macro tags(tagList) %}\n3<div class=\"mt-4\">\n4  {% for tag in tagList %}\n5    <span class=\"bg-grey-dark font-normal text-sm no-underline text-white rounded lowercase mr-2 px-2 py-1\" title=\"{{tag.description()}}\">{{tag.name()}}</span>\n6  {% endfor %}\n7</div>\n8{% endmacro %}\n9\n10{# operations.html #}\n11{% from \"./tags.html\" import tags %}\n12{{ tags(operation.tags()) }}",
      "const {{ channelName | camelCase }} = '{{ channelName }}';",
      "1const filter = module.exports;\n2\n3async function asyncCamelCase(str, callback) {\n4  try {\n5    const result = // logic for camel casing str\n6    callback(null, result);\n7  } catch (error) {\n8    callback(error);\n9  }\n10}\n11filter.renderAsyncContent = renderAsyncContent;\n12\n13// using in template\n14{{ channelName | asyncCamelCase }}",
      "1async function asyncCamelCase(str, callback) {\n2  return new Promise((resolve, reject) => {\n3    // logic with callback\n4  });\n5}"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "05c36897",
    "title": "Parser | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/generator/parser.html",
    "content": "Parser | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Parser AsyncAPI document validation process Parser Found an error? Have a suggestion? Edit this page on GitHub Parser The AsyncAPI Parser is a package used to parse and validate the AsyncAPI documents in your Node.js or browser application. These documents can be either in YAML or JSON format. The Parser validates these documents using dedicated schema-supported plugins. Supported schemas: AsyncAPI schema (no plugin needed) OpenAPI schema JSON schema Avro schema RAML data-type schema The Parser allows the template developer to easily access schemas provided in the above supported formats. This is because the JavaScript parser converts all of them into JSON schema. If the document is valid, the Parser returns an AsyncAPIDocument instance with a set of helper functions that enable easier access to the contents of the AsyncAPI document. The parser provides dereferenced output. During the dereference process, the AsyncAPI parser substitutes a reference with a full definition. The dereferenced output is always in JSON format. The parser provides a message listing all errors if a document is invalid. The original AsyncAPI document is part of the Template Context as the generator also passes the original AsyncAPI document to the template context. The following AsyncAPI document example has two channels: channelOne and channelTwo . Each channel has one operation and a single message: \n```javascript\n1asyncapi: \"2.5.0\"\n2info:\n3  title: Demo API\n4  version: \"1.0.0\"\n5channels:\n6  channelOne:\n7    publish:\n8      summary: This is the first sample channel\n9      operationId: onMessage\n10      message:\n11        name: FirstMessage\n12        payload:\n13          id:\n14            type: integer\n15            minimum: 0\n16            description: Id of the channel\n17          sentAt:\n18            type: string\n19            format: date-time\n20            description: Date and time when the message was sent.\n21  channelTwo:\n22    publish:\n23      summary: This is the second sample channel\n24      operationId: messageRead\n25      message:\n26        name: SecondMessage\n27        payload:\n28          id:\n29            type: integer\n30            minimum: 0\n31            description: Id of the channel\n32          sentAt:\n33            type: string\n34            format: date-time\n35            description: Date and time when the message was sent.\n```\n We can use helper functions provided by the Parser to operate on the above JSON file. For example, we can use the helper method asyncAPIDocument.channelNames() , which returns an array of all channel names currently present in the AsyncAPI document. Another example where you can use a helper function is to list out messages present in your JSON file. Instead of fetching a single message one at a time, you can use the function asyncAPIDocument.allMessages() that returns the map of all messages in your AsyncAPI document. \n```javascript\n1const channelNames = asyncAPIDocument.channelNames();\n2const messages = asyncAPIDocument.allMessages();\n```\n The Parser gives you access to a number of these helper functions that you can implement to access the contents of your AsyncAPI document. AsyncAPI document validation process AsyncAPI document is fed as an input to the Generator. Generator sends the AsyncAPI document to the Parser as asyncapiString ; the stringified version of the original AsyncAPI document. The Parser uses additional plugins such as the OpenAPI, RAML, or Avro schemas to validate custom schemas of message payloads defined in the AsyncAPI document. If the AsyncAPI document is invalid, it throws an error based on the encountered failure type. For example, if the AsyncAPI document is not a string nor a JavaScript object, the Parser throws an invalid-document-type error. Similarly, you may encounter errors such as: invalid-json invalid-yaml impossible-to-convert-to-json If the document is valid, the Parser modifies the AsyncAPI document, returns a set of helper functions, and bundles them together into the asyncapi variable. These helper functions in the form of an asyncapi variable are passed to the Template Context . The Template Context passes all of these values to the Render Engine of your choice. Finally, the Render Engine generates whatever output you may have specified in your template. (i.e. code, documentation, diagrams, pdfs, applications, etc.) To learn more about the Parser and access all of its features, check out the AsyncAPI Parser\u2019s GitHub repository . Go Back Template Up Next Generator version vs template version Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1asyncapi: \"2.5.0\"\n2info:\n3  title: Demo API\n4  version: \"1.0.0\"\n5channels:\n6  channelOne:\n7    publish:\n8      summary: This is the first sample channel\n9      operationId: onMessage\n10      message:\n11        name: FirstMessage\n12        payload:\n13          id:\n14            type: integer\n15            minimum: 0\n16            description: Id of the channel\n17          sentAt:\n18            type: string\n19            format: date-time\n20            description: Date and time when the message was sent.\n21  channelTwo:\n22    publish:\n23      summary: This is the second sample channel\n24      operationId: messageRead\n25      message:\n26        name: SecondMessage\n27        payload:\n28          id:\n29            type: integer\n30            minimum: 0\n31            description: Id of the channel\n32          sentAt:\n33            type: string\n34            format: date-time\n35            description: Date and time when the message was sent.",
      "1const channelNames = asyncAPIDocument.channelNames();\n2const messages = asyncAPIDocument.allMessages();"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "5b3ac502",
    "title": "React render engine | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/generator/react-render-engine.html",
    "content": "React render engine | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Common assumptions Debugging React template in VSCode React render engine Found an error? Have a suggestion? Edit this page on GitHub React is the render engine that we strongly suggest you should use for any new templates. The only reason it is not the default render engine is to stay backward compatible. It enables the possibility of debugging your template (this is not possible with Nunjucks). It provides better error stack traces. Provides better support for separating code into more manageable chunks/components. The readability of the template is much better compared to Nunjucks syntax. Better tool support for development. Introduces testability of components which is not possible with Nunjucks. When writing React templates you decide whether to use CommonJS, ES5, or ES6 modules since everything is bundled together before the rendering process takes over. We use our own React renderer which can be found in the Generator React SDK . There you can find information about how the renderer works or how we transpile your template files. Your React template always requires @asyncapi/generator-react-sdk as a dependency. @asyncapi/generator-react-sdk is required to access the File component which is required as a root component for a file to be rendered. Furthermore, it provides some common components to make your development easier, like Text or Indent . Let's consider a basic React template as the one below called MyTemplate.js : \n```javascript\n1import { File, Text } from \"@asyncapi/generator-react-sdk\";\n2\n3export default function({ asyncapi, params, originalAsyncAPI }) {\n4  return (\n5    <File name=\"asyncapi.md\">\n6      <Text>Some text that should render as is</Text>\n7    </File>\n8  );\n9}\n```\n The exported default function returns a File component as a root component which the generator uses to determine what file should be generated. In our case, we overwrite the default functionality of saving the file as MyTemplate.js but instead use the filename asyncapi.md . It is then specified that we should render Some text that should render as is\\n within that file. Notice the \\n character at the end, which is automatically added after the Text component. For further information about components, props, etc, see the Generator React SDK Common assumptions Generator renders all files located in the template directory if they meet the following conditions: File is the root component The file is not in the list of nonRenderableFiles in the template configuration New lines are automatically added after each Text component. The props you have access to in the rendering function are: asyncapi which is a parsed spec file object. Read the API of the Parser to understand what structure you have access to in this parameter. originalAsyncAPI which is an original spec file before it is parsed. params that contain the parameters provided when generating. All the file templates are supported where the variables are provided after the default props as listed above. Debugging React template in VSCode With React, it enables you to debug your templates. For Visual Studio Code, we have created a boilerplate launch configuration to enable debugging in your template. Add the following launch configuration: \n```javascript\n1{\n2  \"version\": \"0.2.0\",\n3  \"configurations\": [\n4    {\n5      \"type\": \"node\",\n6      \"request\": \"launch\",\n7      \"name\": \"Debug template\",\n8      \"timeout\": 10000,\n9      \"sourceMaps\": true,\n10      \"args\": [\n11        \"./asyncapi.yml\",\n12        \"./template\",\n13        \"--output\",\n14        \"./output\",\n15        \"--install\",\n16        \"--force-write\"\n17      ],\n18      \"program\": \"ag\"\n19    }\n20  ]\n21}\n```\n Now replace ./asyncapi.yml with your document of choice. Replace ./template with the path to your React template. You can now debug your template by adding any breakpoints you want and inspecting your code. Go Back Template context Up Next Nunjucks render engine Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1import { File, Text } from \"@asyncapi/generator-react-sdk\";\n2\n3export default function({ asyncapi, params, originalAsyncAPI }) {\n4  return (\n5    <File name=\"asyncapi.md\">\n6      <Text>Some text that should render as is</Text>\n7    </File>\n8  );\n9}",
      "1{\n2  \"version\": \"0.2.0\",\n3  \"configurations\": [\n4    {\n5      \"type\": \"node\",\n6      \"request\": \"launch\",\n7      \"name\": \"Debug template\",\n8      \"timeout\": 10000,\n9      \"sourceMaps\": true,\n10      \"args\": [\n11        \"./asyncapi.yml\",\n12        \"./template\",\n13        \"--output\",\n14        \"./output\",\n15        \"--install\",\n16        \"--force-write\"\n17      ],\n18      \"program\": \"ag\"\n19    }\n20  ]\n21}"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "46b3eacd",
    "title": "Special file names | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/generator/special-file-names.html",
    "content": "Special file names | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets Special file names Found an error? Have a suggestion? Edit this page on GitHub We use NPM behind the scenes to download and install the templates. Since NPM will not fetch files like .gitignore , you should name them differently. Luckily, the Generator will take care of renaming them back for you. The following is a table of the special file names: Special file name Output file name {.gitignore} .gitignore {.npmignore} .npmignore Go Back TypeScript support Up Next Creating a template Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "43f727c9",
    "title": "Template context | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/generator/template-context.html",
    "content": "Template context | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Generation process Template context Template context Found an error? Have a suggestion? Edit this page on GitHub While using the generator tool, you may want dynamic values populated to your templates and rendered in the output. The generator can achieve that using the template context . The template context allows you to access the contents of the AsyncAPI document and inject dynamic values to the template files passed to the asyncAPI CLI during the generation process. The render engine then displays these dynamically assigned values in the output. Generation process The Generator receives Template and params as input. The Generator sends to the Parser the asyncapiString which is a stringified version of the original AsyncAPI document . The Parser validates the format of the asyncapiString using OpenAPI, RAML, or Avro schemas. If the asyncapiString is valid, the parser manipulates it, returns a set of helper functions and properties, and bundles them into an asyncapi variable. The asyncapi variable is an instance of the AsyncAPI document . The helper functions and properties make it easier to access the contents of the AsyncAPI document in the template. The Generator then passes the params , which are template-specific options used to customize the output, the Template files , and the asyncapi which collectively make up the Template Context . The Template Context is then passed to the Render Engine . The Render Engine then injects all the dynamic values from the Template Context into the Template files . Template context The extra context passed to the render engine during the generation process and made accessible in the templates includes: originalAsyncAPI is a stringified version of the original AsyncAPI document that the user passed to the Generator. asyncapi is a parsed AsyncAPI document with helper functions and properties. You should use it to access document contents e.g asyncapi.title . params is an object with all the parameters passed to the Generator by the user. Go Back Configuration file Up Next React render engine Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "b59009e9",
    "title": "Template development | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/generator/template-development.html",
    "content": "Template development | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Minimum template requirements template directory package.json file Additional configuration options package.json configuration options Accessing template parameters Hooks Template development Found an error? Have a suggestion? Edit this page on GitHub Note It is advised against attempting to manually template types and models from scratch using the AsyncAPI templating engines such as Nunjucks and React render engines. Instead, it is recommended to use AsyncAPI Modelina a dedicated library for model generation. Minimum template requirements Let's break down the minimum template requirements: the template directory and a package.json file. You can also check Template for Generator Templates project to see show-case template based on the AsyncAPI Generator. template directory The template directory holds all the files that will be used for generating the output. The generator will process all the files stored in this directory. The following code is an example of an index.js file inside the template folder. \n```javascript\n1import { File, Text } from \"@asyncapi/generator-react-sdk\";\n2\n3export default function ({ asyncapi, params, originalAsyncAPI }) {\n4  return (\n5    <File name=\"asyncapi.md\">\n6      <Text>My application's markdown file.</Text>\n7      <Text>App name: **{asyncapi.info().title()}**</Text>\n8    </File>\n9  );\n10}\n```\n The above example will produce an asyncapi.md file where usage of the AsyncAPI document information (i.e. the title ) is demonstrated. package.json file Before the generation process begins, the generator installs the template into its dependencies. A package.json file is necessary to identify the template name. The following block shows an example package.json file that points to the React Render Engine and necessary dependencies: \n```javascript\n1{\n2  \"name\": \"myTemplate\",\n3  \"generator\": {\n4    \"renderer\": \"react\"\n5  },\n6  \"dependencies\": {\n7    \"@asyncapi/generator-react-sdk\": \"^0.2.25\"\n8  }\n9}\n```\n Every template must depend on the @asyncapi/generator-react-sdk package , which contains a template file's basic components. Additional configuration options You must configure the generator's package.json file to contain JSON objects with the required parameters for template configuration, such as: Name Type Description renderer String Its value can be either react or nunjucks (default). supportedProtocols [String] A list with all the protocols this template supports. parameters Object[String, Object] An object with all the parameters that can be passed when generating the template. When using the command line, it's done by indicating --param name=value or -p name=value . parameters[param].description String A user-friendly description about the parameter. parameters[param].default Any Default value of the parameter if not specified. Shouldn't be used for mandatory required=true parameters. parameters[param].required Boolean Whether the parameter is required or not. The above table lists some configuration options that help the generator achieve a specific set of tasks throughout the generation process. The generator property from 'package.json' contains all the configuration information. To learn more about template configuration and various supported parameters, read the generator configuration file . Whenever you make a change to the package.json, make sure you perform an update by running npm install ; this command synchronizes with the package-lock.json and validates the file. package.json configuration options The following examples show some advanced configurations that we can use in our package.json file: \n```javascript\n1{\n2  \"name\": \"myTemplate\",\n3  \"generator\": {\n4    \"renderer\": \"react\",\n5    \"supportedProtocols\": [\n6      \"mqtt\"\n7    ]\n8  },\n9  \"dependencies\": {\n10    \"@asyncapi/generator-react-sdk\": \"^0.2.25\"\n11  }\n12}\n```\n The above package.json file has a newly added configuration called supportedProtocols which is set to a list containing only mqtt . This configuration displays all the protocols that this template supports. You can have multiple supported protocols in our template. For example, if you want to generate an output using the above template, you need to have an AsyncAPI document with servers that use mqtt to generate your desired output. If your AsyncAPI document has server connections with kafka , the generation process will be terminated since the only supported protocol mentioned is mqtt . Accessing template parameters Additionally, we can also have a configuration called parameters , which is an object with all the parameters that can be passed when generating the template: \n```javascript\n1{\n2  \"name\": \"myTemplate\",\n3  \"generator\": {\n4    \"renderer\": \"react\",\n5    \"supportedProtocols\": [\n6      \"mqtt\"\n7    ],\n8    \"parameters\": {\n9        \"version\": {\n10          \"description\": \"Overrides application version under `info.version` in the AsyncAPI document.\",\n11          \"required\": false\n12        }\n13    }\n14  },\n15  \"dependencies\": {\n16    \"@asyncapi/generator-react-sdk\": \"^0.2.25\"\n17  }\n18}\n```\n The default version of your application is always fetched from your AsyncAPI document. The above configuration helps the template user override the existing version with a new one on the command line. The changes done in the template will be as follows: Original: \n```javascript\n<Text>App name: **{ asyncapi.info().title() }**</Text>\n```\n Newer: \n```javascript\n1<Text>App name: **{ asyncapi.info().title() }**</Text>\n2<Text>Version is: **{params.version || asyncapi.info.version()}**</Text>\n```\n Now that you have added all the configuration options, you can start the generation process using the AsyncAPI CLI. You can pass these parameters via the CLI: --param name=value or -p name=value . The above configuration helps template users override the existing version with a new version on the command line. (Example: -p version=2.0.0 ) Hooks Hooks enable templates to perform multiple tasks. You can add Hooks to your template as fractions of code. In the template, you must store it in the hooks directory under the template directory. You can also store it in other modules and external libraries or configure it inside the template. The generation process can perform multiple actions. Templates can perform multiple actions before or after the generation process with the help of hooks . Hooks help you change the specification version with the new version that you can pass before the generation process even begins: \n```javascript\n1module.exports = {\n2  'generate:before': ({ asyncapi, templateParams = {} }) => {\n3    const version = templateParams.version || asyncapi.info().version();\n4    asyncapi._json.info.version = version;\n5  }\n6};\n```\n This can be an even better alternative to overriding the version parameter we discussed in the previous section. A markdown document will be generated, and the AsyncAPI document passed to the generator will be returned with the overwritten version. The updated template looks like the following: \n```javascript\n1<Text>App name: **{ asyncapi.info().title() }**</Text>\n2<Text>Version: **{asyncapi.info.version()}**</Text>\n```\n Go Back Library API Up Next Configuration file Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1import { File, Text } from \"@asyncapi/generator-react-sdk\";\n2\n3export default function ({ asyncapi, params, originalAsyncAPI }) {\n4  return (\n5    <File name=\"asyncapi.md\">\n6      <Text>My application's markdown file.</Text>\n7      <Text>App name: **{asyncapi.info().title()}**</Text>\n8    </File>\n9  );\n10}",
      "1{\n2  \"name\": \"myTemplate\",\n3  \"generator\": {\n4    \"renderer\": \"react\"\n5  },\n6  \"dependencies\": {\n7    \"@asyncapi/generator-react-sdk\": \"^0.2.25\"\n8  }\n9}",
      "1{\n2  \"name\": \"myTemplate\",\n3  \"generator\": {\n4    \"renderer\": \"react\",\n5    \"supportedProtocols\": [\n6      \"mqtt\"\n7    ]\n8  },\n9  \"dependencies\": {\n10    \"@asyncapi/generator-react-sdk\": \"^0.2.25\"\n11  }\n12}",
      "1{\n2  \"name\": \"myTemplate\",\n3  \"generator\": {\n4    \"renderer\": \"react\",\n5    \"supportedProtocols\": [\n6      \"mqtt\"\n7    ],\n8    \"parameters\": {\n9        \"version\": {\n10          \"description\": \"Overrides application version under `info.version` in the AsyncAPI document.\",\n11          \"required\": false\n12        }\n13    }\n14  },\n15  \"dependencies\": {\n16    \"@asyncapi/generator-react-sdk\": \"^0.2.25\"\n17  }\n18}",
      "<Text>App name: **{ asyncapi.info().title() }**</Text>",
      "1<Text>App name: **{ asyncapi.info().title() }**</Text>\n2<Text>Version is: **{params.version || asyncapi.info.version()}**</Text>",
      "1module.exports = {\n2  'generate:before': ({ asyncapi, templateParams = {} }) => {\n3    const version = templateParams.version || asyncapi.info().version();\n4    asyncapi._json.info.version = version;\n5  }\n6};",
      "1<Text>App name: **{ asyncapi.info().title() }**</Text>\n2<Text>Version: **{asyncapi.info.version()}**</Text>"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "2d1ef232",
    "title": "Template | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/generator/template.html",
    "content": "Template | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Template Template generation process Generator templates list Template Found an error? Have a suggestion? Edit this page on GitHub Template A template is a project that specifies the generation process output by using the AsyncAPI generator and an AsyncAPI document . These files describe the generation results depending on the AsyncAPI document's content. Examples outputs: Code Documentation Markdown diagrams Python and Java applications A template is an independent Node.js project unrelated to the generator repository. AsyncAPI templates are managed, released, and published separately. You can also create templates and manage templates on your own. The generator uses the official Arborist NPM library. (This means templates do not have to be published to package managers to use them.) Arborist helps the generator fetch the template's source code and use it for the generation process. By default, this library pulls data from the default NPM registry, which is https://registry.npmjs.org . You can also configure the generator to fetch templates that are private or hosted in different NPM registry You can store template projects on a local drive or as a git repository during the development process. Template generation process Template is provided as input to the Generator . asyncapi is the original AsyncAPI document injected into your template file by default. params are the parameters you pass to the AsyncAPI CLI. Later, you can also pass these params further to other components. The generator passes both the original asyncapi , the original AsyncAPI document, and the params to the Template Context . Concurrently, the generator passes Template files to the Render engine as well. AsyncAPI uses two render engines \u2014 react and nunjucks . Once the Render Engine receives both the Template Files and the Template Context, it injects all the dynamic values into your react or nunjucks engine, based on the Template Files using the Template Context. The render engine generates whatever output you may have specified in your template. (i.e. code, documentation, diagrams, pdfs, applications, etc.) Generator templates list AsyncAPI has a list of available templates to enhance your generation process. Templates are stored as repositories on AsyncAPI's official GitHub profile. Template Name Description Source code @asyncapi/nodejs-template Generates Node.js service that uses Hermes package Node.js template @asyncapi/nodejs-ws-template Generates Node.js service that supports WebSocket protocol only Node.js WebSocket template @asyncapi/java-template Generates Java JMS application Java template @asyncapi/java-spring-template Generates Java Spring service Java spring template @asyncapi/java-spring-cloud-stream-template Generates Java Spring Cloud Stream service Java spring cloud stream template @asyncapi/python-paho-template Generates Python service that uses Paho library Python paho template @asyncapi/html-template Generates HTML documentation site HTML template @asyncapi/markdown-template Generates documentation in Markdown file Markdown template @asyncapi/ts-nats-template Generates TypeScript NATS client TypeScript/Node.js NATS template @asyncapi/go-watermill-template Generates Go client using Watermill GO watermill template @asyncapi/dotnet-nats-template Generates .NET C# client using NATS .NET C# NATS template Some of these templates are maintained by various third-party organizations. The README file usually contains this information and more, such as configuration options the user can pass to the template, usage, technical requirements, etc. Check out all our community generator templates Go Back AsyncAPI document Up Next Parser Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "566b6b0f",
    "title": "TypeScript support | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/generator/typescript-support.html",
    "content": "TypeScript support | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets TypeScript support Found an error? Have a suggestion? Edit this page on GitHub The AsyncAPI generator has TypeScript support for hooks and Nunjucks's filters . Assumptions: Installing the typescript package and creating the tsconfig.json file isn't necessary. Source code of the hook/filter must have .ts extension. Each package related to the typings for TypeScript like @types/node must be installed in the template under dependencies array. This is because the Generator transpiles the TypeScript code on-the-fly while rendering the template, and cannot use packages under devDependencies . Each template should have @types/node package installed to enable support for typings for Node. Go Back File templates Up Next Special file names Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "c006f0fe",
    "title": "Usage | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/generator/usage.html",
    "content": "Usage | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page AsyncAPI CLI asyncapi generate fromTemplate ASYNCAPI TEMPLATE Global templates installed with yarn or npm CLI usage examples CLI usage with Docker CLI usage with npx instead of npm Using as a module/package Usage Found an error? Have a suggestion? Edit this page on GitHub There are two ways to use the generator: AsyncAPI CLI Generator library AsyncAPI CLI asyncapi generate fromTemplate ASYNCAPI TEMPLATE Generates whatever you want using templates compatible with AsyncAPI Generator. For complete command usage and options, refer to the official AsyncAPI CLI documentation . All templates are installable npm packages. Therefore, the value of template can be anything supported by npm install . Here's a summary of the possibilities: \n```javascript\n1npm install [<@scope>/]<name>\n2npm install [<@scope>/]<name>@<tag>\n3npm install [<@scope>/]<name>@<version>\n4npm install [<@scope>/]<name>@<version range>\n5npm install <git-host>:<git-user>/<repo-name>\n6npm install <git repo url>\n7npm install <tarball file>\n8npm install <tarball url>\n9npm install <folder>\n```\n Global templates installed with yarn or npm You can preinstall templates globally before installing the AsyncAPI CLI . The generator first tries to locate the template in local dependencies; if absent it checks where the global generator packages are installed. \n```javascript\n1npm install -g @asyncapi/html-template@0.16.0\n2asyncapi generate fromTemplate asyncapi.yaml @asyncapi/html-template\n3# The generator uses html-template version 0.16.0 and not the latest version.\n```\n CLI usage examples The shortest possible syntax: \n```javascript\nasyncapi generate fromTemplate asyncapi.yaml @asyncapi/html-template@3.0.0 --use-new-generator\n```\n Generating from a URL: \n```javascript\nasyncapi generate fromTemplate https://bit.ly/asyncapi @asyncapi/html-template@3.0.0 --use-new-generator\n```\n Specify where to put the result: \n```javascript\nasyncapi generate fromTemplate asyncapi.yaml @asyncapi/html-template@3.0.0 --use-new-generator -o ./docs\n```\n Passing parameters to templates: \n```javascript\nasyncapi generate fromTemplate asyncapi.yaml @asyncapi/html-template@3.0.0 --use-new-generator -o ./docs -p title='Hello from param'\n```\n In the template you can use it like this: {{ params.title }} Disabling the hooks: \n```javascript\nasyncapi generate fromTemplate asyncapi.yaml @asyncapi/html-template@3.0.0 --use-new-generator -o ./docs -d generate:before generate:after=foo,bar\n```\n The generator skips all hooks of the generate:before type and foo , bar hooks of the generate:after type. Installing the template from a folder: \n```javascript\nasyncapi generate fromTemplate asyncapi.yaml ~/my-template\n```\n It creates a symbolic link to the target directory ( ~/my-template in this case). Installing the template from a git URL: \n```javascript\nasyncapi generate fromTemplate asyncapi.yaml https://github.com/asyncapi/html-template.git\n```\n Map schema references from baseUrl to local folder: \n```javascript\nasyncapi generate fromTemplate test/docs/apiwithref.json @asyncapi/html-template@3.0.0 --use-new-generator -o ./build/ --force-write --map-base-url https://schema.example.com/crm/:./test/docs/\n```\n The parameter --map-base-url maps external schema references to local folders. CLI usage with Docker When using our docker image that we regularly update, you don't need to install Node.js or Npm, even though the generator is written with it since the Docker image has the generator installed. Install Docker first, then use docker to pull and run the image using the following command: \n```javascript\n1docker run --rm -it \\\n2--user=root \\\n3-v [ASYNCAPI SPEC FILE LOCATION]:/app/asyncapi.yml \\\n4-v [GENERATED FILES LOCATION]:/app/output \\\n5asyncapi/cli # docker image [COMMAND HERE]\n6\n7# Example that you can run inside the cli directory after cloning this repository. First, you specify the mount in the location of your AsyncAPI specification file and then you mount it in the directory where the generation result should be saved.\n8docker run --rm -it \\\n9   --user=root \\\n10   -v ${PWD}/test/fixtures/asyncapi_v1.yml:/app/asyncapi.yml \\\n11   -v ${PWD}/output:/app/output \\\n12   asyncapi/cli generate fromTemplate -o /app/output /app/asyncapi.yml @asyncapi/html-template@3.0.0 --use-new-generator --force-write\n```\n Note: Use ` instead of \\ for Windows. CLI usage with npx instead of npm npx is very useful when you want to run the generator in a CI/CD environment. In such a scenario, do not install the generator globally because most environments that provide Node.js and Npm, also provide npx out of the box. Use the following npx command on your terminal: \n```javascript\nnpx -p @asyncapi/cli asyncapi generate fromTemplate ./asyncapi.yaml @asyncapi/html-template@3.0.0 --use-new-generator\n```\n Using as a module/package Once you install the generator in your project, you can use it to generate whatever you want. The following code snippet is an example of HTML generation using the official @asyncapi/html-template template and fetching the spec document from the server using: \n```yaml\nhttps://raw.githubusercontent.com/asyncapi/asyncapi/2.0.0/examples/2.0.0/streetlights.yml\n```\n \n```javascript\n1const path = require('path');\n2const generator = new Generator('@asyncapi/html-template', path.resolve(__dirname, 'example'));\n3\n4try {\n5  await generator.generateFromURL('https://raw.githubusercontent.com/asyncapi/asyncapi/2.0.0/examples/2.0.0/streetlights.yml');\n6  console.log('Done!');\n7} catch (e) {\n8  console.error(e);\n9}\n```\n See the API documentation for more examples and full API reference information. Go Back Installation guide Up Next AsyncAPI document Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1npm install [<@scope>/]<name>\n2npm install [<@scope>/]<name>@<tag>\n3npm install [<@scope>/]<name>@<version>\n4npm install [<@scope>/]<name>@<version range>\n5npm install <git-host>:<git-user>/<repo-name>\n6npm install <git repo url>\n7npm install <tarball file>\n8npm install <tarball url>\n9npm install <folder>",
      "1npm install -g @asyncapi/html-template@0.16.0\n2asyncapi generate fromTemplate asyncapi.yaml @asyncapi/html-template\n3# The generator uses html-template version 0.16.0 and not the latest version.",
      "asyncapi generate fromTemplate asyncapi.yaml @asyncapi/html-template@3.0.0 --use-new-generator",
      "asyncapi generate fromTemplate https://bit.ly/asyncapi @asyncapi/html-template@3.0.0 --use-new-generator",
      "asyncapi generate fromTemplate asyncapi.yaml @asyncapi/html-template@3.0.0 --use-new-generator -o ./docs",
      "asyncapi generate fromTemplate asyncapi.yaml @asyncapi/html-template@3.0.0 --use-new-generator -o ./docs -p title='Hello from param'",
      "asyncapi generate fromTemplate asyncapi.yaml @asyncapi/html-template@3.0.0 --use-new-generator -o ./docs -d generate:before generate:after=foo,bar",
      "asyncapi generate fromTemplate asyncapi.yaml ~/my-template",
      "asyncapi generate fromTemplate asyncapi.yaml https://github.com/asyncapi/html-template.git",
      "asyncapi generate fromTemplate test/docs/apiwithref.json @asyncapi/html-template@3.0.0 --use-new-generator -o ./build/ --force-write --map-base-url https://schema.example.com/crm/:./test/docs/",
      "1docker run --rm -it \\\n2--user=root \\\n3-v [ASYNCAPI SPEC FILE LOCATION]:/app/asyncapi.yml \\\n4-v [GENERATED FILES LOCATION]:/app/output \\\n5asyncapi/cli # docker image [COMMAND HERE]\n6\n7# Example that you can run inside the cli directory after cloning this repository. First, you specify the mount in the location of your AsyncAPI specification file and then you mount it in the directory where the generation result should be saved.\n8docker run --rm -it \\\n9   --user=root \\\n10   -v ${PWD}/test/fixtures/asyncapi_v1.yml:/app/asyncapi.yml \\\n11   -v ${PWD}/output:/app/output \\\n12   asyncapi/cli generate fromTemplate -o /app/output /app/asyncapi.yml @asyncapi/html-template@3.0.0 --use-new-generator --force-write",
      "npx -p @asyncapi/cli asyncapi generate fromTemplate ./asyncapi.yaml @asyncapi/html-template@3.0.0 --use-new-generator",
      "1const path = require('path');\n2const generator = new Generator('@asyncapi/html-template', path.resolve(__dirname, 'example'));\n3\n4try {\n5  await generator.generateFromURL('https://raw.githubusercontent.com/asyncapi/asyncapi/2.0.0/examples/2.0.0/streetlights.yml');\n6  console.log('Done!');\n7} catch (e) {\n8  console.error(e);\n9}"
    ],
    "yaml_blocks": [
      "https://raw.githubusercontent.com/asyncapi/asyncapi/2.0.0/examples/2.0.0/streetlights.yml"
    ],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "0d19bbc9",
    "title": "Using private templates | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/generator/using-private-template.html",
    "content": "Using private templates | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Private registry using .npmrc: Private registry overriding arguments: Pulling private template using library: Using private templates Found an error? Have a suggestion? Edit this page on GitHub Generator allows fetching the template from private repositories like Verdaccio, Nexus, npm, etc. By default, the generator fetches the template from the public npm registry configured in the npm configuration. To fetch the template from a private registry, you need to provide the registry URL and authentication details in the .npmrc. For more information read the docs . However, you can override the default behavior by providing the registry URL and authentication details as arguments of the commandline. Private registry using .npmrc: \n```javascript\n1npm config set registry http://verdaccio:4873\n2npm config set //verdaccio:4873/:_auth=$(echo -n 'username:password' | base64)\n```\n npm config set registry : Provide the registry URL that points to the registry URL. npm config set _auth : Provide the base64 encoded value that represents the username and password for basic auth. npm config set _authToken : Provide the access token generated by the registry. Private registry overriding arguments: registry.url : The URL of the registry where the private template is located. Defaults to registry.npmjs.org . registry.auth : An optional parameter to pass the npm registry username and password encoded with base64, formatted as username:password . For example, if the username and password are admin and nimda , you need to encode them with the base64 value like admin:nimda which results in YWRtaW46bmltZGE= . registry.token : An optional parameter to pass to the npm registry authentication token. To get the token, you can first authenticate with the registry using npm login and then grab the generated token from the .npmrc file. Pulling private template using library: \n```javascript\n1const generator = new Generator('@asyncapi/html-template', 'output',\n2      { \n3        debug: true,\n4        registry: {\n5          url: 'http://verdaccio:4873',  \n6          auth: 'YWRtaW46bmltZGE=' \n7            // base64 encoded username and password \n8            // represented as admin:nimda\n9          \n10        }\n11      });\n```\n Assuming you host @asyncapi/html-template in a private package registry like Verdaccio. To pull this template, you need to provide registry.url option that points to the registry URL and registry.auth as a base64 encoded value that represents the username and password. Instead of username and password, you can also pass registry.token . Go Back Creating a template Up Next Adding models generation in template Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1npm config set registry http://verdaccio:4873\n2npm config set //verdaccio:4873/:_auth=$(echo -n 'username:password' | base64)",
      "1const generator = new Generator('@asyncapi/html-template', 'output',\n2      { \n3        debug: true,\n4        registry: {\n5          url: 'http://verdaccio:4873',  \n6          auth: 'YWRtaW46bmltZGE=' \n7            // base64 encoded username and password \n8            // represented as admin:nimda\n9          \n10        }\n11      });"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "3ae36359",
    "title": "Generator version vs template version | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/generator/versioning.html",
    "content": "Generator version vs template version | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets Generator version vs template version Found an error? Have a suggestion? Edit this page on GitHub The generator tool generates whatever you want, as long as it can be defined in a template based on the AsyncAPI document . On the other hand, a template is a file or group of files that specify the kind of output you expect from using the generator's features. For example, you may want to use the NodeJS template to generate boilerplate code for your message-based APIs. Templates are dependent on the generators' features. For example, the template you want to use may be compatible with the latest generator version but incompatible with the previous versions. Check the configuration file or ReadME of the template to see the version of the generator it supports. The generator has an isTemplateCompatible function that checks if the template is compatible with the version of the generator you want to use. If the template isn't compatible, you will see a terminal error output similar to the following: \n```javascript\n1Something went wrong:\n2Error: This template is not compatible with the current version of the generator (${generatorVersion}). This template is compatible with the following version range: ${generator}.`)\n```\n Use the following command to check the version of the AsyncAPI CLI you have installed with all its dependencies, like AsyncAPI Generator; asyncapi config versions It is better to lock a specific version of the template and the generator if you plan to use the AsyncAPI CLI and a particular template in production. The differences between using the version of the AsyncAPI CLI you have installed and locking a certain version on production are demonstrated in the following code snippets. Generate HTML with the latest AsyncAPI CLI using the html-template. \n```javascript\n1npm install -g @asyncapi/cli\n2asyncapi generate fromTemplate asyncapi.yaml @asyncapi/html-template@3.0.0 --use-new-generator\n```\n AsyncAPI CLI has multiple versions of the generator, and to use the latest version, you may need to pass the --use-new-generator flag. For more details you can also check asyncapi generate fromTemplate ASYNCAPI TEMPLATE Generate HTML using a particular version of the AsyncAPI CLI using the html-template. \n```javascript\n1npm install -g @asyncapi/cli@0.20.0\n2asyncapi generate fromTemplate asyncapi.yaml @asyncapi/html-template@0.7.0 -o ./docs\n```\n Before using newer versions of the template, always look at the changelog first. If the generator's features are not important to you, just make sure to use a version compatible with your template. Go Back Parser Up Next Library API Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1Something went wrong:\n2Error: This template is not compatible with the current version of the generator (${generatorVersion}). This template is compatible with the following version range: ${generator}.`)",
      "1npm install -g @asyncapi/cli\n2asyncapi generate fromTemplate asyncapi.yaml @asyncapi/html-template@3.0.0 --use-new-generator",
      "1npm install -g @asyncapi/cli@0.20.0\n2asyncapi generate fromTemplate asyncapi.yaml @asyncapi/html-template@0.7.0 -o ./docs"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "074e13f9",
    "title": "Authentication Functions | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/glee/authentication.html",
    "content": "Authentication Functions | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Getting Started with Authentication Functions Supported Authentication Values in the asyncapi.yaml File Server Authentication in Glee done() Function authProps Client Authentication in Glee Possible Authentication Parameters Authentication Functions Found an error? Have a suggestion? Edit this page on GitHub Getting Started with Authentication Functions Authentication in Glee can be implemented using authentication functions. These functions are files that export one or both of the following Node.js functions: clientAuth and serverAuth : \n```javascript\n1/* websocket.js */\n2\n3export async function serverAuth({ authProps, done }) {\n4  // Server authentication logic\n5}\n6\n7export async function clientAuth({ parsedAsyncAPI, serverName }) {\n8  // Client authentication logic\n9}\n```\n Glee searches for authentication files in the auth directory by default. However, this can be configured using the glee config file . The authentication file's name should match the targeted server for which the authentication logic is intended. Supported Authentication Values in the asyncapi.yaml File AsyncAPI supports a variety of authentication formats as specified in its documentation . Glee, however, supports the following authentication schemas: userPassword http (\"bearer\") httpApiKey Oauth2 Below is an example of a asyncapi.yaml file for a server with security requirements and a userPassword security scheme: \n```javascript\n1## Server AsyncAPI Schema\n2asyncapi: 3.0.0\n3info:\n4  title: AsyncAPI IMDB Server\n5  version: 1.0.0\n6  description: This app is a dummy server that streams trending/upcoming anime.\n7servers:\n8  trendingAnimeServer:\n9    host: 'localhost:8081'\n10    protocol: http\n11    security:\n12      - $ref: '#/components/securitySchemes/userPass'\n13\n14  ...\n15\n16components:\n17  securitySchemes:\n18    userPass:\n19      type: userPassword\n```\n Here's an example for a client that implements some requirements of the server mentioned above: \n```javascript\n1## Client AsyncAPI Schema\n2servers:\n3  trendingAnime:\n4    host: localhost:8081\n5    protocol: http\n6    security:\n7      - $ref: '#/components/securitySchemes/userPass'\n8  testwebhook:\n9    host: localhost:9000\n10    protocol: ws\n11x-remoteServers:\n12  - trendingAnime\n13\n14  ...\n15\n16components:\n17  securitySchemes:\n18    userPass:\n19      type: userPassword\n```\n Glee can function as both a server and a client. Hence, the need for both serverAuth and clientAuth functions arises. Glee acts as a client when the server name is included in the x-remoteServers property in the asyncapi.yaml file. When Glee operates as a client, it can connect to a Glee server. Conversely, as a server, it accepts connections from other Glee clients. Thus, a Glee application can accept connections from clients while also sending requests to other Glee servers. If a security requirement is specified in the asyncapi.yaml file, and Glee acts as a server, the serverAuth function should be implemented. If Glee acts as a client, then clientAuth should be implemented. If Glee is used as both client and server, both functions are necessary. Server Authentication in Glee The serverAuth function takes an argument that can be destructured as follows: Attribute Description done The function that signals the server to proceed. authProps The authentication parameters received from the client. serverName The name of the server/broker emitting the event. doc The parsed AsyncAPI schema. done() Function The done() parameter in the serverAuth function signals to the broker/server what action to take next, based on the boolean value passed. \n```javascript\n1/* websocket.js */\n2\n3export async function serverAuth({ authProps, done }) {\n4  if (isValidUser(authProps)) {\n5    done(true);\n6  } else {\n7    done(false);\n8  }\n9}\n```\n Parameters for done(): Authentication Result (Boolean): true for success, false for failure. Passing true to the done parameter indicates that authentication has succeeded, and the server/broker can proceed to allow the client to connect. Conversely, if false is passed, the server will reject the client, indicating failed authentication. The done() call should always be the last in the serverAuth function, as Glee will not execute any logic beyond this call. authProps The authProps parameter includes methods for the server to retrieve authentication parameters from the client. The current available methods are as follows: \n```javascript\n1export async function serverAuth({ authProps, done }) {\n2  // Some network request\n3  authProps.getOauthToken()\n4  authProps.getHttpAPIKeys('api_key')\n5  authProps.getToken()\n6  authProps.getUserPass()\n7\n8  done(false)\n9}\n```\n Method Description getOauthToken() Returns the OAuth authentication parameter. getHttpAPIKeys(name) Returns the HttpAPIKeys parameter with the specified name from either headers or query parameter getToken() Returns the HTTP bearer token parameter. getUserPass() Returns username and password parameters. Client Authentication in Glee The clientAuth function also takes an argument that can be destructured as follows: Attribute Description parsedAsyncAPI The parsed AsyncAPI schema. serverName The server/broker's name from which the authentication parameters are being sent. Possible Authentication Parameters The code snippet below illustrates the possible authentication parameters: \n```javascript\n1export async function clientAuth({ serverName }) {\n2  return {\n3    token: process.env.TOKEN,\n4    oauth: process.env.OAUTH2,\n5    apiKey: process.env.APIKEY,\n6    userPass: {\n7      user: process.env.USER,\n8      password: process.env.PASSWORD,\n9    },\n10  }\n11}\n```\n The names of the authentication parameters should match the names specified in the asyncapi.yaml file . Auth Type Values HTTP bearer (JWT) Value should be a JWT string. OAuth2 Value should be a string. httpApiKey in headers or query params Value should be a string. userPass Value should be an object with the user and password as properties. Go Back Introduction to Glee Authentication Up Next HTTP Authentication (Bearer Token) Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1/* websocket.js */\n2\n3export async function serverAuth({ authProps, done }) {\n4  // Server authentication logic\n5}\n6\n7export async function clientAuth({ parsedAsyncAPI, serverName }) {\n8  // Client authentication logic\n9}",
      "1## Server AsyncAPI Schema\n2asyncapi: 3.0.0\n3info:\n4  title: AsyncAPI IMDB Server\n5  version: 1.0.0\n6  description: This app is a dummy server that streams trending/upcoming anime.\n7servers:\n8  trendingAnimeServer:\n9    host: 'localhost:8081'\n10    protocol: http\n11    security:\n12      - $ref: '#/components/securitySchemes/userPass'\n13\n14  ...\n15\n16components:\n17  securitySchemes:\n18    userPass:\n19      type: userPassword",
      "1## Client AsyncAPI Schema\n2servers:\n3  trendingAnime:\n4    host: localhost:8081\n5    protocol: http\n6    security:\n7      - $ref: '#/components/securitySchemes/userPass'\n8  testwebhook:\n9    host: localhost:9000\n10    protocol: ws\n11x-remoteServers:\n12  - trendingAnime\n13\n14  ...\n15\n16components:\n17  securitySchemes:\n18    userPass:\n19      type: userPassword",
      "1/* websocket.js */\n2\n3export async function serverAuth({ authProps, done }) {\n4  if (isValidUser(authProps)) {\n5    done(true);\n6  } else {\n7    done(false);\n8  }\n9}",
      "1export async function serverAuth({ authProps, done }) {\n2  // Some network request\n3  authProps.getOauthToken()\n4  authProps.getHttpAPIKeys('api_key')\n5  authProps.getToken()\n6  authProps.getUserPass()\n7\n8  done(false)\n9}",
      "1export async function clientAuth({ serverName }) {\n2  return {\n3    token: process.env.TOKEN,\n4    oauth: process.env.OAUTH2,\n5    apiKey: process.env.APIKEY,\n6    userPass: {\n7      user: process.env.USER,\n8      password: process.env.PASSWORD,\n9    },\n10  }\n11}"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "4fd18580",
    "title": "HTTP Authentication (Bearer Token) | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/glee/bearerToken.html",
    "content": "HTTP Authentication (Bearer Token) | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Getting Started with Bearer Token Authentication Client Side Server Side HTTP Authentication (Bearer Token) Found an error? Have a suggestion? Edit this page on GitHub Getting Started with Bearer Token Authentication Bearer Token authentication is one of the most popular forms of authentication and is widely used due to its perceived security. This guide will walk you through how to implement bearer token authentication in Glee. Below is a sample asyncapi.yaml for a server with security requirements and a user password security scheme: \n```javascript\n1## Server AsyncAPI Schema\n2asyncapi: 3.0.0\n3info:\n4  title: AsyncAPI IMDB Server\n5  version: 1.0.0\n6  description: This app is a dummy server that streams trending/upcoming anime.\n7servers:\n8  trendingAnimeServer:\n9    host: 'localhost:8081'\n10    protocol: http\n11    security:\n12      - $ref: '#/components/securitySchemes/token'\n13\n14      ...\n15\n16components:\n17  securitySchemes:\n18    token:\n19      type: http\n20      scheme: bearer\n21      bearerFormat: JWT\n22\n```\n A sample asyncapi.yaml for a client that implements some of the requirements of the server above: \n```javascript\n1## Client AsyncAPI Schema\n2servers:\n3  trendingAnime:\n4    host: localhost:8081\n5    protocol: http\n6    security:\n7      - $ref: '#/components/securitySchemes/token'\n8  testwebhook:\n9    host: localhost:9000\n10    protocol: ws\n11x-remoteServers:\n12  - trendingAnime\n13\n14  ...\n15\n16components:\n17  securitySchemes:\n18    token:\n19      type: http\n20      scheme: bearer\n21      bearerFormat: JWT\n22\n```\n The Client asyncapi.yaml file doesn't need to implement all the security requirements of the server; it only needs to implement the ones it uses, like http (bearer token) here. Client Side Following the client asyncapi.yaml file above, create a file named trendingAnime.ts in the auth directory, since that is the server that has the security property. touch auth/trendingAnime.ts When using the bearer security scheme, pass the parameters as follows: \n```javascript\n1export async function clientAuth({ parsedAsyncAPI, serverName }) {\n2  return {\n3    token: process.env.TOKEN\n4  }\n5}\n```\n Glee will utilize the token for server authentication, employing it in the header with the format: Authorization: Bearer \\{token\\} . Server Side From the server asyncapi.yaml file above, create a file named trendingAnimeServer.ts in the auth directory, since that is the server that has the security property. touch auth/trendingAnimeServer.ts On the server side, you can retrieve the values as follows: \n```javascript\n1\n2export async function serverAuth({ authProps, done }) {\n3  authProps.getToken()\n4  // Your authentication logic here...\n5  done(true || false)\n6}\n7\n```\n So, getToken() returns a string containing the token sent from the client. Go Back Authentication Functions Up Next HttpApiKey Authentication Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1## Server AsyncAPI Schema\n2asyncapi: 3.0.0\n3info:\n4  title: AsyncAPI IMDB Server\n5  version: 1.0.0\n6  description: This app is a dummy server that streams trending/upcoming anime.\n7servers:\n8  trendingAnimeServer:\n9    host: 'localhost:8081'\n10    protocol: http\n11    security:\n12      - $ref: '#/components/securitySchemes/token'\n13\n14      ...\n15\n16components:\n17  securitySchemes:\n18    token:\n19      type: http\n20      scheme: bearer\n21      bearerFormat: JWT\n22",
      "1## Client AsyncAPI Schema\n2servers:\n3  trendingAnime:\n4    host: localhost:8081\n5    protocol: http\n6    security:\n7      - $ref: '#/components/securitySchemes/token'\n8  testwebhook:\n9    host: localhost:9000\n10    protocol: ws\n11x-remoteServers:\n12  - trendingAnime\n13\n14  ...\n15\n16components:\n17  securitySchemes:\n18    token:\n19      type: http\n20      scheme: bearer\n21      bearerFormat: JWT\n22",
      "1export async function clientAuth({ parsedAsyncAPI, serverName }) {\n2  return {\n3    token: process.env.TOKEN\n4  }\n5}",
      "1\n2export async function serverAuth({ authProps, done }) {\n3  authProps.getToken()\n4  // Your authentication logic here...\n5  done(true || false)\n6}\n7"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "7781dcfe",
    "title": "Crypto Websockets - Interactive (Alpha) | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/glee/crypto-websockets-interactive.html",
    "content": "Crypto Websockets - Interactive (Alpha) | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets Crypto Websockets - Interactive (Alpha) Found an error? Have a suggestion? Edit this page on GitHub tl;dr Please try out this interactive tutorial and let us know what you think, as we plan to have all the docs written this way. We created an interactive tutorial using KillerCoda . It is an interactive version of the Crypto Websockets tutorial that will always work for you no matter what operating system you have. Please become our alpha testers of the tutorial: Go through the tutorial here Let us know what you think using the channel that works for you the best: Slack Twitter GitHub Issue Go Back Username and Password Authentication Up Next Guides - Overview Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "c8d69ba4",
    "title": "Configuring Environment Variables and Configuration File | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/glee/env-vars-config.html",
    "content": "Configuring Environment Variables and Configuration File | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Environment Variables Handling Multiple .env Files Customizing Glee Settings The Glee Config File Core Glee Configurations Documentation Configuration WebSocket Server Configuration Cluster Configuration HTTP Server Configuration Configuring Environment Variables and Configuration File Found an error? Have a suggestion? Edit this page on GitHub Environment Variables Glee provides several environment variables that allow you to tailor your application's behavior to fit specific needs: Variable Purpose Example Usage GLEE_SERVER_NAMES Specifies a list of servers to initialize at startup, separated by commas. GLEE_SERVER_NAMES=websockets,mosquitto GLEE_SERVER_CERTS Indicates server-specific certificate files in a ${serverName}:${pathToCertificateFile} format, separated by commas. GLEE_SERVER_CERTS=mosquitto:mosquitto.org.crt GLEE_SERVER_VARIABLES Sets server variables in a ${serverName}:${serverVariable}:${value} format, separated by commas. GLEE_SERVER_VARIABLES=websockets:namespace:public Handling Multiple .env Files Glee supports loading variables from .env.local directly into process.env . This feature is handy for keeping secrets out of your repository during development. You can also set environment-specific defaults in .env.development or .env.production . .env.local takes precedence over other .env* files. Switch between development and production environments by setting the NODE_ENV variable accordingly. Customizing Glee Settings While Glee comes with defaults for ease of use, you may want to customize settings for specific needs. This is where glee.config.js comes into play. The Glee Config File glee.config.js is a JavaScript file exporting an asynchronous function, structured as follows: \n```javascript\n1export default async function () {\n2  // Configuration details go here...\n3}\n```\n This function should return an object with configurable properties: \n```javascript\n1export default async function () {\n2  return {\n3    glee: {},\n4    websocket: {},\n5    cluster: {},\n6    http: {}\n7  }\n8}\n```\n For example, a typical glee.config.js might look like this: \n```javascript\n1export default async function () {\n2  return {\n3    glee: { // Core Glee configurations\n4      lifecycleDir: './lifecycle',\n5      functionsDir: './functions',\n6      asyncapiFilePath: './asyncapi.json',\n7      logs: { // Adjust default logging behavior\n8        incoming: 'channel-only', // Logs only the channel, not the message payload\n9        outgoing: 'none', // Disables outgoing logs\n10      }\n11    },\n12    docs: {\n13      enabled: true, // Toggles documentation generation\n14      folder: 'docs', // Destination folder for docs\n15      template: '@asyncapi/markdown-template' // Specifies the documentation template\n16    },\n17    ws: {\n18      server: {\n19        httpServer: customServer, // Custom HTTP server\n20        adapter: \"native\", // Defaults to 'native', can be 'socket.io' or a custom adapter\n21        port: process.env.PORT, // Server port\n22      }\n23    },\n24    cluster: {\n25      adapter: \"redis\", // Cluster adapter, default is Redis\n26      name: \"cluster\", // Cluster name\n27      url: \"redis://localhost:6379\", // URL for the cluster server (Redis in this case)\n28    },\n29    http: {\n30      server: {\n31        httpServer: customServer, // Custom HTTP server\n32        adapter: 'native', \n33        port: process.env.PORT, // Server port\n34      },\n35    }\n36  };\n37}\n```\n In the return statement, configure the following options: Core Glee Configurations These settings are specific to Glee itself. Field Default Purpose glee.gleeDir .glee Determines the Glee directory for compiled sources. glee.lifecycleDir lifecycle Specifies the path to lifecycle events . glee.functionsDir functions Designates the path to functions . glee.asyncapiFilePath asyncapi.(yaml | yml | json) Path to your AsyncAPI file. glee.logs default Configures logging for incoming and outgoing messages. glee.logs.incoming \"all\" Options: channel-only , none . glee.logs.outgoing \"all\" Options: channel-only , none . Documentation Configuration Field Purpose docs.enabled Enables or disables documentation generation. docs.folder Specifies the output directory for documentation. docs.template Determines the AsyncAPI template for docs generation. WebSocket Server Configuration Field Purpose ws.server WebSocket server-specific settings. ws.server.adapter Selects the WebSocket server adapter: native , socket.io , or a custom one. ws.server.httpServer A custom HTTP server instance. ws.server.port |The port for the WebSocket server.| Cluster Configuration Field Purpose cluster.adapter Chooses the cluster communication adapter (default: Redis Pub/Sub). cluster.name The cluster's name. cluster.url URL of the server used by the cluster adapter. HTTP Server Configuration Field Purpose http.server HTTP server-specific settings. http.server.adapter Selects the HTTP server adapter. http.server.port The port for the HTTP server. Go Back Functions and Lifecycle Events Up Next Introduction to Glee Authentication Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1export default async function () {\n2  // Configuration details go here...\n3}",
      "1export default async function () {\n2  return {\n3    glee: {},\n4    websocket: {},\n5    cluster: {},\n6    http: {}\n7  }\n8}",
      "1export default async function () {\n2  return {\n3    glee: { // Core Glee configurations\n4      lifecycleDir: './lifecycle',\n5      functionsDir: './functions',\n6      asyncapiFilePath: './asyncapi.json',\n7      logs: { // Adjust default logging behavior\n8        incoming: 'channel-only', // Logs only the channel, not the message payload\n9        outgoing: 'none', // Disables outgoing logs\n10      }\n11    },\n12    docs: {\n13      enabled: true, // Toggles documentation generation\n14      folder: 'docs', // Destination folder for docs\n15      template: '@asyncapi/markdown-template' // Specifies the documentation template\n16    },\n17    ws: {\n18      server: {\n19        httpServer: customServer, // Custom HTTP server\n20        adapter: \"native\", // Defaults to 'native', can be 'socket.io' or a custom adapter\n21        port: process.env.PORT, // Server port\n22      }\n23    },\n24    cluster: {\n25      adapter: \"redis\", // Cluster adapter, default is Redis\n26      name: \"cluster\", // Cluster name\n27      url: \"redis://localhost:6379\", // URL for the cluster server (Redis in this case)\n28    },\n29    http: {\n30      server: {\n31        httpServer: customServer, // Custom HTTP server\n32        adapter: 'native', \n33        port: process.env.PORT, // Server port\n34      },\n35    }\n36  };\n37}"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "39300739",
    "title": "Functions and Lifecycle Events | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/glee/function-lifecycle-events.html",
    "content": "Functions and Lifecycle Events | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Functions How Does Glee Determine Which Function to Execute? Lifecycle Events List of Events Restricting the Lifecycle Event Functions and Lifecycle Events Found an error? Have a suggestion? Edit this page on GitHub Functions Glee relies on functions to execute your business logic. Functions are files that export a default async Node.js function: \n```javascript\n1/* onHello.js */\n2export default async function (event) {\n3  // Your business logic here...\n4}\n```\n Functions take a single argument, which is the event received from a broker or a client, depending on the type of API you're building. The event argument has the following structure: Attribute Description payload The payload/body of the received event. headers The headers/metadata of the received event. channel The name of the channel/topic from which the event was read. serverName The name of the server/broker from which the event was received. Functions may return an object to instruct Glee on what action to take next. For instance, the following example sends a greeting message to the development server: \n```javascript\n1/* onHello.js */\n2export default async function (event) {\n3  return {\n4    send: [{\n5      server: 'development',\n6      channel: 'greets',\n7      payload: 'Greetings! How is your day going?'\n8    }]\n9  };\n10}\n```\n Attribute Type Description send array< OutboundMessage > A list of outbound messages to send after processing the inbound event. All clients subscribed to the given channel/topic will receive the message. Anatomy of an Outbound Message Attribute Type Description payload string The payload/body of the message you want to send. headers object<string,string> The headers/metadata of the message you want to send. channel string The channel/topic to which you want to send the message. Defaults to event.channel , i.e., the same channel as the received event. server string The server/broker to which you want to send the message. Defaults to event.serverName , i.e., the same server as the received event. How Does Glee Determine Which Function to Execute? Glee reads your asyncapi.yaml file and looks for all the receive actions containing an operations attribute field. The operations field serves as a mechanism to bind a specific operation to a function file. For instance, given the following AsyncAPI definition: \n```javascript\n1...\n2operations:\n3  onHello: # operation ID\n4    action: receive\n5    channel:\n6      $ref: '#/channels/hello'\n7      ...\n```\n Glee maps the onHello operation to the functions/onHello.js file. Lifecycle Events Glee allows you to bind incoming messages to functions. However, sometimes it's necessary to initiate communication proactively, not merely as a reaction to another message. Use cases can vary widely: from sending a message to announce that our client is connected, to broadcasting messages at regular intervals. To subscribe to a lifecycle event, create a file under the lifecycle directory. It must be structured as follows: \n```javascript\n1export default async function ({\n2  glee,\n3  serverName,\n4  server,\n5  connection,\n6}) {\n7  // Your business logic here...\n8}\n9\n10export const lifecycleEvent = 'onConnect'\n```\n Each file in the lifecycle directory must export a default async function and the lifecycleEvent field, indicating the name of the event you wish to subscribe to. Optionally, your function can return an object following the same syntax as described above in the functions definition. List of Events Event Description onConnect A connection with a broker has been established. onReconnect Glee reconnected to a broker. onDisconnect A connection with a broker has been closed. onServerReady Your Glee server is now ready to accept connections. onServerConnectionOpen A client has opened a connection with your Glee server. onServerConnectionClose A client has closed the connection with your Glee server. All of them take a single argument containing information about the event: Attribute Description glee A reference to the Glee app. serverName The name of the server where the event occurred. server The AsyncAPI definition of the server where the event occurred. connection The connection where the event occurred. Restricting the Lifecycle Event In some cases, it's useful to restrict the lifecycle event to a specific server or set of servers. To do this, add a line like the following to your lifecycle file: export const servers = [ 'mosquitto' ] The above example ensures Glee fires the lifecycle event only if it originates from the mosquitto server. Similarly, you may want to restrict the lifecycle event to a specific channel/topic. Add a line like this to your lifecycle file: export const channels = [ 'user/signedup' ] The above example ensures Glee fires the lifecycle event only if the connection includes the channel user/signedup . Go Back Glee Installation Guide Up Next Configuring Environment Variables and Configuration File Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1/* onHello.js */\n2export default async function (event) {\n3  // Your business logic here...\n4}",
      "1/* onHello.js */\n2export default async function (event) {\n3  return {\n4    send: [{\n5      server: 'development',\n6      channel: 'greets',\n7      payload: 'Greetings! How is your day going?'\n8    }]\n9  };\n10}",
      "1...\n2operations:\n3  onHello: # operation ID\n4    action: receive\n5    channel:\n6      $ref: '#/channels/hello'\n7      ...",
      "1export default async function ({\n2  glee,\n3  serverName,\n4  server,\n5  connection,\n6}) {\n7  // Your business logic here...\n8}\n9\n10export const lifecycleEvent = 'onConnect'"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "5dd48904",
    "title": "Introduction to Glee Authentication | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/glee/glee-auth-intro.html",
    "content": "Introduction to Glee Authentication | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Authentication Using Authentication Functions: HTTP Bearer Token Authentication: HTTP API Key Authentication: Username and Password Authentication: Summary Introduction to Glee Authentication Found an error? Have a suggestion? Edit this page on GitHub Glee comes with authentication features that help you in verifying the identity of users or entities attempting to access a system or application. It ensures that only authorized individuals or systems are granted access, protecting against unauthorized intrusions and data breaches. Glee simplifies this vital process by offering multiple authentication methods, each tailored to different use cases. The following methods are different ways to shield your application access. Authentication Using Authentication Functions: Glee allows you to implement custom authentication logic by utilizing authentication functions. This flexible approach enables developers to craft tailored authentication mechanisms, ensuring that access to resources is controlled precisely as required. HTTP Bearer Token Authentication: In today's API-driven world, bearer token authentication is a widely adopted method. Glee supports this approach, allowing clients to present a token as proof of their identity, thus ensuring secure and efficient access to resources. HTTP API Key Authentication: Glee's authentication suite includes support for API key authentication, which is vital for protecting web APIs. By using API keys, you can regulate access to your services, making it an essential component of your application's security strategy. Username and Password Authentication: Traditional yet still crucial, username and password authentication remains a reliable option within Glee's toolkit. This method allows users to access systems or applications by providing their unique credentials, ensuring a familiar and straightforward login experience. Summary Glee's authentication features not only provide layers of security but also offer the flexibility needed to meet your unique requirements. Whether you're developing a web application, a mobile app, or any other type of application, Glee's authentication methods empower you to tailor your security measures to suit the demands of your project. With Glee, you can build and maintain a secure digital environment, ensuring that only authorized users and systems gain access, protecting your valuable data and resources. Go Back Configuring Environment Variables and Configuration File Up Next Authentication Functions Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "8b6f3601",
    "title": "HttpApiKey Authentication | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/glee/httpApiKey.html",
    "content": "HttpApiKey Authentication | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Getting Started with HttpAPIKey Authentication Client Side Server Side HttpApiKey Authentication Found an error? Have a suggestion? Edit this page on GitHub Getting Started with HttpAPIKey Authentication This guide will walk you through how to implement authentication using the httpApiKey security scheme in Glee. Below is a sample asyncapi.yaml for a server with security requirements and the HttpApiKey security scheme: \n```javascript\n1## Server AsyncAPI Schema\n2asyncapi: 3.0.0\n3info:\n4  title: AsyncAPI IMDB Server\n5  version: 1.0.0\n6  description: This app is a dummy server that streams the trending/upcoming anime.\n7servers:\n8  trendingAnimeServer:\n9    host: 'localhost:8081'\n10    protocol: http\n11    security:\n12      - $ref: '#/components/securitySchemes/apiKey'\n13\n14      ...\n15\n16components:\n17  securitySchemes:\n18    apiKey:\n19      type: httpApiKey\n20      name: api_key\n21      in: query\n22\n```\n A sample asyncapi.yaml for a client that implements some of the requirements of the server above: \n```javascript\n1## Client AsyncAPI Schema\n2servers:\n3  trendingAnime:\n4    host: localhost:8081\n5    protocol: http\n6    security:\n7      - $ref: '#/components/securitySchemes/apiKey'\n8  testwebhook:\n9    host: localhost:9000\n10    protocol: ws\n11x-remoteServers:\n12  - trendingAnime\n13\n14  ...\n15\n16components:\n17  securitySchemes:\n18    apiKey:\n19      type: httpApiKey\n20      name: api_key\n21      in: query\n22\n```\n The httpApiKey can be located in either the header or query parameter. The client asyncapi.yaml file does not need to implement all the security requirements of the server; it only needs to implement the ones it uses, like httpApiKey here. Client Side Following the client asyncapi.yaml file above, create a file named trendingAnime.ts in the auth directory, as this is the server that has the security property. touch auth/trendingAnime.ts When using the HttpApiKey security scheme, it is important to pass the parameters as follows: \n```javascript\n1export async function clientAuth({ parsedAsyncAPI, serverName }) {\n2  return {\n3    apiKey: process.env.APIKEY\n4  }\n5}\n```\n apiKey should be the name of the security requirement as specified in your asyncapi.yaml file, and its value should be a string. Server Side From the server asyncapi.yaml file above, create a file named trendingAnimeServer.ts in the auth directory, as this is the server that has the security property. touch auth/trendingAnimeServer.ts On the server side, you can retrieve the values as follows: \n```javascript\n1\n2export async function serverAuth({ authProps, done }) {\n3  authProps.getHttpAPIKeys('api_key')\n4  \n5  done(true)\n6}\n7\n```\n So, getHttpAPIKeys(name) takes a name parameter to specify the name of the httpApiKey that is desired. Then it returns an object containing the httpApiKey value that is sent from the client. Go Back HTTP Authentication (Bearer Token) Up Next Username and Password Authentication Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1## Server AsyncAPI Schema\n2asyncapi: 3.0.0\n3info:\n4  title: AsyncAPI IMDB Server\n5  version: 1.0.0\n6  description: This app is a dummy server that streams the trending/upcoming anime.\n7servers:\n8  trendingAnimeServer:\n9    host: 'localhost:8081'\n10    protocol: http\n11    security:\n12      - $ref: '#/components/securitySchemes/apiKey'\n13\n14      ...\n15\n16components:\n17  securitySchemes:\n18    apiKey:\n19      type: httpApiKey\n20      name: api_key\n21      in: query\n22",
      "1## Client AsyncAPI Schema\n2servers:\n3  trendingAnime:\n4    host: localhost:8081\n5    protocol: http\n6    security:\n7      - $ref: '#/components/securitySchemes/apiKey'\n8  testwebhook:\n9    host: localhost:9000\n10    protocol: ws\n11x-remoteServers:\n12  - trendingAnime\n13\n14  ...\n15\n16components:\n17  securitySchemes:\n18    apiKey:\n19      type: httpApiKey\n20      name: api_key\n21      in: query\n22",
      "1export async function clientAuth({ parsedAsyncAPI, serverName }) {\n2  return {\n3    apiKey: process.env.APIKEY\n4  }\n5}",
      "1\n2export async function serverAuth({ authProps, done }) {\n3  authProps.getHttpAPIKeys('api_key')\n4  \n5  done(true)\n6}\n7"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "e6cfe040",
    "title": "Glee Installation Guide | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/glee/installation.html",
    "content": "Glee Installation Guide | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Preparing for Installation Starting with Glee Initialize with an AsyncAPI Document Start with a Template Manual Installation Setting up asyncapi.yaml and Required Directories Launching the Development Server Glee Installation Guide Found an error? Have a suggestion? Edit this page on GitHub Preparing for Installation Before starting with Glee, ensure that NPM, Node.js, and the AsyncAPI CLI are already set up on your system. Need help installing AsyncAPI CLI? Check out the CLI Installation Guide . Starting with Glee Creating a new Glee application can be approached in three distinct ways: Begin with an existing AsyncAPI document . Use a predefined template . Opt for Manual Installation (recommended for advanced users keen on understanding Glee's inner workings). Initialize with an AsyncAPI Document If you already have an AsyncAPI specification file, you can jumpstart your project by using the -f or --file flag to specify the file path. The CLI will leverage this to set up your project. asyncapi new glee -f asyncapi.yaml This command generates all necessary files. Just open the project in your editor, and start integrating your authentication and business logic. Start with a Template For those without a custom AsyncAPI file and looking to experiment, starting with a template is an excellent choice. These are simple Glee projects that the AsyncAPI CLI can generate for you. Use the -t or --template flag to specify the template name. Currently, two templates are available: default : Responds with a string upon receiving a string. tutorial : Designed for this tutorial . To initiate a project with the default template: asyncapi new glee -t default After installation, follow these steps: \n```javascript\n1Next steps:\n2\n3  cd project\n4  npm install --ignore-scripts\n5  npm run dev\n6\n7Feel free to open the project in your preferred editor and start customizing it.\n```\n Refer to our Getting Started guide for further assistance during customization. Manual Installation For a hands-on setup, start by creating a new directory, e.g., myapp , and structure it as follows: \n```javascript\n1\u251c\u2500 functions          (required)\n2\u2502  \u251c\u2500 onHello.js\n3\u2502  \u2514\u2500 ...\n4\u251c\u2500 lifecycle          (optional)\n5\u2502  \u251c\u2500 onConnect.js\n6\u2502  \u2514\u2500 ...\n7\u251c\u2500 .env               (optional)\n8\u251c\u2500 asyncapi.(yaml | yml | json)      (required)\n9\u251c\u2500 glee.config.js     (optional)\n10\u251c\u2500 package.json       (required)\n```\n Inside this new folder, initialize and install Glee: \n```javascript\n1npm init -y\n2npm install @asyncapi/glee\n```\n Edit your package.json to include the following scripts: \n```javascript\n1{\n2  \"scripts\": {\n3    \"docs\": \"glee docs\",\n4    \"dev\": \"glee dev\",\n5    \"start\": \"glee start\",\n6  }\n7}\n```\n These scripts serve different development stages: glee docs : Generates your project documentation. glee dev : Starts a local development server, building your project in a development-friendly environment. glee start : Launches your project for production use. Setting up asyncapi.yaml and Required Directories Craft an asyncapi.yaml file capable of receiving a \"hello {name}\" message via WebSocket ( ws ) protocol on the hello channel. Define the operation ID as onHello , indicating the function to be called, and set the payload type to string for publishing on that channel. \n```javascript\n1# AsyncAPI Specification for Hello, Glee!\n2asyncapi: 3.0.0\n3info:\n4  title: 'Hello, Glee!'\n5  version: 1.0.0\n6servers:\n7  websockets:\n8    host: 0.0.0.0:3000\n9    protocol: ws\n10channels:\n11  hello:\n12    address: hello\n13    messages:\n14      hello:\n15        $ref: '#/components/messages/hello'\n16operations:\n17  onHello:\n18    action: receive\n19    channel:\n20      $ref: '#/channels/hello'\n21  SendHello:\n22    action: send\n23    channel: \n24      $ref: \"#/channels/hello\"\n25components:\n26  messages:\n27    hello:\n28      payload:\n29        type: string\n```\n Create a function onHello.js in myapp/functions : \n```javascript\n1export default async function (event) {  \n2  return {\n3    send: [{\n4      server: \"websockets\",\n5      channel: \"hello\",\n6      payload: `Hello from Glee! You said: \"${event.payload}\".`\n7    }]\n8  }\n9}\n```\n Launching the Development Server Execute npm run dev to start the server. Connect to ws://localhost:3000/hello and send a WebSocket request like {\"john\"} . Go Back Building Your First Glee Application Up Next Functions and Lifecycle Events Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1Next steps:\n2\n3  cd project\n4  npm install --ignore-scripts\n5  npm run dev\n6\n7Feel free to open the project in your preferred editor and start customizing it.",
      "1\u251c\u2500 functions          (required)\n2\u2502  \u251c\u2500 onHello.js\n3\u2502  \u2514\u2500 ...\n4\u251c\u2500 lifecycle          (optional)\n5\u2502  \u251c\u2500 onConnect.js\n6\u2502  \u2514\u2500 ...\n7\u251c\u2500 .env               (optional)\n8\u251c\u2500 asyncapi.(yaml | yml | json)      (required)\n9\u251c\u2500 glee.config.js     (optional)\n10\u251c\u2500 package.json       (required)",
      "1npm init -y\n2npm install @asyncapi/glee",
      "1{\n2  \"scripts\": {\n3    \"docs\": \"glee docs\",\n4    \"dev\": \"glee dev\",\n5    \"start\": \"glee start\",\n6  }\n7}",
      "1# AsyncAPI Specification for Hello, Glee!\n2asyncapi: 3.0.0\n3info:\n4  title: 'Hello, Glee!'\n5  version: 1.0.0\n6servers:\n7  websockets:\n8    host: 0.0.0.0:3000\n9    protocol: ws\n10channels:\n11  hello:\n12    address: hello\n13    messages:\n14      hello:\n15        $ref: '#/components/messages/hello'\n16operations:\n17  onHello:\n18    action: receive\n19    channel:\n20      $ref: '#/channels/hello'\n21  SendHello:\n22    action: send\n23    channel: \n24      $ref: \"#/channels/hello\"\n25components:\n26  messages:\n27    hello:\n28      payload:\n29        type: string",
      "1export default async function (event) {  \n2  return {\n3    send: [{\n4      server: \"websockets\",\n5      channel: \"hello\",\n6      payload: `Hello from Glee! You said: \"${event.payload}\".`\n7    }]\n8  }\n9}"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "725327ef",
    "title": "Username and Password Authentication | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/glee/userPassword.html",
    "content": "Username and Password Authentication | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Getting started with username and password authentication Client Side Server side Username and Password Authentication Found an error? Have a suggestion? Edit this page on GitHub Getting started with username and password authentication User and password authentication is one of the most basic forms of authentication. This guide will walk through how to implement username and password authentication in Glee. A sample asyncapi.yaml for a server with security requirements and user password security scheme is shown below: \n```javascript\n1##server asyncAPI schema\n2asyncapi: 3.0.0\n3info:\n4  title: AsyncAPI IMDB server\n5  version: 1.0.0\n6  description: This app is a dummy server that would stream the trending/upcoming anime.\n7servers:\n8  trendingAnimeServer:\n9    host: 'localhost:8081'\n10    protocol: http\n11    security:\n12      - $ref: '#/components/securitySchemes/userPass\n13\n14  ...\n15\n16components:\n17  securitySchemes:\n18    userPass:\n19      type: userPassword\n20\n```\n A sample asyncapi.yaml for a client that implements some of the requirements of the server above is as follows: \n```javascript\n1##client asyncAPI schema\n2servers:\n3  trendingAnime:\n4    host: localhost:8081\n5    protocol: http\n6    security:\n7      - $ref: '#/components/securitySchemes/userPass\n8  testwebhook:\n9    host: localhost:9000\n10    protocol: ws\n11x-remoteServers:\n12  - trendingAnime\n13\n14  ...\n15\n16components:\n17  securitySchemes:\n18    userPass:\n19      type: userPassword\n20\n```\n The Client asyncapi.yaml file does not need to implement all the security requirements in the server, it only needs to implement the ones that it uses like userPassword here. Client Side Following the client asyncapi.yaml file above, create a file named trendingAnime.ts in the auth directory, since that is the server that has the security Property. touch auth/trendingAnime.ts When using the userPassword security scheme, it is important that you pass the parameters as follows: \n```javascript\n1export async clientAuth({ parsedAsyncAPI, serverName }) {\n2  return {\n3    userPass: {\n4      user: process.env.user,\n5      password: process.env.password,\n6    },\n7  }\n8}\n```\n userPass should be the name of the security requirement as specified in your asyncapi.yaml file, then pass user and password as it's properties Server side From the server asyncapi.yaml file above, create a file named trendingAnimeServer.ts in the auth directory, since that is the server that has the security Property. touch auth/trendingAnimeServer.ts On the server side, you can retrieve the values as follows \n```javascript\n1\n2export async serverAuth({ authProps, done }) {\n3  authProps.getUserPass()\n4  \n5  done(true)\n6}\n7\n```\n So, getUserPass() returns an object containing the username and password that is sent from the client. Go Back HttpApiKey Authentication Up Next Crypto Websockets - Interactive (Alpha) Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1##server asyncAPI schema\n2asyncapi: 3.0.0\n3info:\n4  title: AsyncAPI IMDB server\n5  version: 1.0.0\n6  description: This app is a dummy server that would stream the trending/upcoming anime.\n7servers:\n8  trendingAnimeServer:\n9    host: 'localhost:8081'\n10    protocol: http\n11    security:\n12      - $ref: '#/components/securitySchemes/userPass\n13\n14  ...\n15\n16components:\n17  securitySchemes:\n18    userPass:\n19      type: userPassword\n20",
      "1##client asyncAPI schema\n2servers:\n3  trendingAnime:\n4    host: localhost:8081\n5    protocol: http\n6    security:\n7      - $ref: '#/components/securitySchemes/userPass\n8  testwebhook:\n9    host: localhost:9000\n10    protocol: ws\n11x-remoteServers:\n12  - trendingAnime\n13\n14  ...\n15\n16components:\n17  securitySchemes:\n18    userPass:\n19      type: userPassword\n20",
      "1export async clientAuth({ parsedAsyncAPI, serverName }) {\n2  return {\n3    userPass: {\n4      user: process.env.user,\n5      password: process.env.password,\n6    },\n7  }\n8}",
      "1\n2export async serverAuth({ authProps, done }) {\n3  authProps.getUserPass()\n4  \n5  done(true)\n6}\n7"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "d4623f78",
    "title": "Building Your First Glee Application | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tools/glee/your-first-glee-app.html",
    "content": "Building Your First Glee Application | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Crafting Your API Specification Initiating Your Glee Project Implementing the Operation Function Running and Evaluating Your App Building Your First Glee Application Found an error? Have a suggestion? Edit this page on GitHub Crafting Your API Specification Let's start with a straightforward WebSocket API using Glee. Imagine a WebSocket server that receives the current time from a client and responds with a greeting like \"good morning\", \"good evening\", or \"good night\" based on the time provided. In Glee, which is a spec-first framework, the journey begins with defining your API specification. If you're unfamiliar with what an API spec is or how to create one, we recommend going through the tutorials available here before proceeding. For this project, here's how we define our API: \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: Greet Bot\n4  version: 1.0.0\n5servers:\n6  websockets:\n7    host: localhost:3000\n8    protocol: ws\n9channels:\n10  greet:\n11    address: /greet\n12    messages:\n13      greet:\n14        payload:\n15          type: string\n16      time:\n17        payload:\n18          type: object\n19          properties:\n20            currentTime:\n21              type: number\n22            name:\n23              type: string\n24operations:\n25  receiveTime:\n26    action: receive\n27    channel:\n28      $ref: '#/channels/greet'\n29    messages:\n30      - $ref: \"#/channels/greet/messages/time\"\n31  sendGreet:\n32    action: send\n33    channel:\n34      $ref: '#/channels/greet'\n35    messages:\n36      - $ref: \"#/channels/greet/messages/greet\"\n```\n Store this in a file named asyncapi.yml . This spec shows that our app can perform two operations on a single channel: receiving time and sending a greeting. We've used JSON Schema to define what time and greet messages look like. Note the operations section. It's essential in Glee, linking your business logic to your spec. For instance, receiveTime is the function invoked when the /greet channel receives a message. Tip: Including a send operation isn't mandatory but is recommended for validating outgoing messages against your spec. Initiating Your Glee Project For ease and efficiency, start your Glee app with our CLI, which automates the setup. In your asyncapi.yml file's directory, execute: asyncapi new glee --name GreetBot --file asyncapi.yml It will prompt you with a list of server names and let you select which servers you want Glee to create a server for. select the websockets and continue. Then, navigate to your application's folder and install the dependencies: \n```javascript\n1cd GreetBot\n2npm install --ignore-scripts\n```\n You now have a Glee app scaffolded and ready for development. Implementing the Operation Function Navigate to functions/receiveTime.js and input the logic to analyze the time and generate the appropriate response. \n```javascript\n1import { GleeFunction } from '@asyncapi/glee';\n2\n3const receiveTime: GleeFunction = async (event) => {\n4  const { name, time } = event.payload;\n5  const t = new Date(time);\n6  const curHr = t.getHours();\n7  let response = '';\n8  if (curHr < 12) {\n9    response = `Good Morning, ${name}!`;\n10  } else if (curHr < 18) {\n11    response = `Good Afternoon, ${name}!`;\n12  } else {\n13    response = `Good Evening, ${name}!`;\n14  }\n15  return {\n16    send: [\n17      {\n18        server: 'websockets',\n19        channel: 'greet',\n20        payload: response,\n21      },\n22    ],\n23  };\n24};\n25\n26export default receiveTime;\n```\n Note: Want to know more about functions? Click Here! Each file in the functions directory is a handler where you can craft your business logic. Every handler should export an asynchronous function that takes an event parameter, giving you access to the payload and server details. Running and Evaluating Your App To launch and test the app's functionality, follow these steps: Run your Glee application using: \n```javascript\n1npm run dev\n2# or \n3npm run start\n```\n To test, open a WebSocket connection to ws://localhost:3000/greet in Postman and send {\"name\":\"John\",\"time\":\"1567906535\"} . Watch as your Glee app responds appropriately. Go Back Kickstarting Your Journey with Glee Up Next Glee Installation Guide Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1asyncapi: 3.0.0\n2info:\n3  title: Greet Bot\n4  version: 1.0.0\n5servers:\n6  websockets:\n7    host: localhost:3000\n8    protocol: ws\n9channels:\n10  greet:\n11    address: /greet\n12    messages:\n13      greet:\n14        payload:\n15          type: string\n16      time:\n17        payload:\n18          type: object\n19          properties:\n20            currentTime:\n21              type: number\n22            name:\n23              type: string\n24operations:\n25  receiveTime:\n26    action: receive\n27    channel:\n28      $ref: '#/channels/greet'\n29    messages:\n30      - $ref: \"#/channels/greet/messages/time\"\n31  sendGreet:\n32    action: send\n33    channel:\n34      $ref: '#/channels/greet'\n35    messages:\n36      - $ref: \"#/channels/greet/messages/greet\"",
      "1cd GreetBot\n2npm install --ignore-scripts",
      "1import { GleeFunction } from '@asyncapi/glee';\n2\n3const receiveTime: GleeFunction = async (event) => {\n4  const { name, time } = event.payload;\n5  const t = new Date(time);\n6  const curHr = t.getHours();\n7  let response = '';\n8  if (curHr < 12) {\n9    response = `Good Morning, ${name}!`;\n10  } else if (curHr < 18) {\n11    response = `Good Afternoon, ${name}!`;\n12  } else {\n13    response = `Good Evening, ${name}!`;\n14  }\n15  return {\n16    send: [\n17      {\n18        server: 'websockets',\n19        channel: 'greet',\n20        payload: response,\n21      },\n22    ],\n23  };\n24};\n25\n26export default receiveTime;",
      "1npm run dev\n2# or \n3npm run start"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "1b870abc",
    "title": "Create AsyncAPI document | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tutorials/create-asyncapi-document.html",
    "content": "Create AsyncAPI document | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Introduction Background context Create AsyncAPI document Summary Next steps Create AsyncAPI document Found an error? Have a suggestion? Edit this page on GitHub Introduction In this tutorial, you'll learn how to create an AsyncAPI document based on a sample real-world use case. Additionally, you will learn about event-driven architecture, message brokers, pub/sub pattern. Let's pretend you have a company called Smarty Lighting, and you install smart-city streetlight lighting systems. Such a smart lighting system is an Internet of Things (IoT) use case. You will create a Smarty Lighting Streetlights application using Node.js and Mosquitto (MQTT) as the message broker. Your application will allow you to manage city lights remotely. You want to build a system that can turn streetlights on and off based on their environmental conditions: You will implement an event-driven architecture (EDA) with a message broker in its \"center.\" The Streetlights application will receive information about environmental lighting conditions. The Streetlights application will connect to the broker and receive a stream of events from all the streetlights devices reporting their conditions. The Streetlights application is unaware of how many streetlights devices send measurement events to the broker; it just connects to the broker and receives all events. Background context Event-driven architecture (EDA) is a design pattern built around the production, detection, and reaction to events that take place in time. In this pattern, a message broker, event publishers, and subscribers are its main components for event exchange within microservices. Message brokers enables asynchronous communications between services so that the sending service need not wait for the receiving service\u2019s reply. That allows interdependent services to \u201ctalk\u201d with one another directly, even if they were written in different languages or implemented on different platforms. Furthermore, the Pub/sub is appealing for IoT use cases due to two key features: support for flexible coupling between publishers/subscribers and inherent support for point-to-multipoint transmission. MQTT , is a well-known protocol that is widely used in IoT applications because it was created particularly to address machine-to-machine (M2M) communication. Create AsyncAPI document In this step, you will create an AsyncAPI document to describe the Streelights application. It will help you generate the code and the documentation later on. To create one, you can either use the AsyncAPI Studio or the AsyncAPI CLI , depending on your project's needs. Remember You can create a new asyncapi.yaml document by running: asyncapi new --example=tutorial.yml --no-tty . Create the following specification document titled asyncapi with a .yaml extension. \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: Streetlights App\n4  version: '1.0.0'\n5  description: |\n6    The Smartylighting Streetlights application allows you\n7    to remotely manage the city lights.\n8  license:\n9    name: Apache 2.0\n10    url: 'https://www.apache.org/licenses/LICENSE-2.0'\n11servers:\n12  mosquitto:\n13    host: test.mosquitto.org\n14    protocol: mqtt\n15channels:\n16  lightMeasured:\n17    address: 'light/measured'\n18    messages:\n19      lightMeasuredMessage:\n20        name: LightMeasured\n21        payload:\n22          type: object\n23          properties:\n24            id:\n25              type: integer\n26              minimum: 0\n27              description: ID of the streetlight.\n28            lumens:\n29              type: integer\n30              minimum: 0\n31              description: Light intensity measured in lumens.\n32            sentAt:\n33              type: string\n34              format: date-time\n35              description: Date and time when the message was sent.\n36operations:\n37  onLightMeasured:\n38    action: 'receive'\n39    summary: Information about environmental lighting conditions for a particular streetlight.\n40    channel:\n41      $ref: '#/channels/lightMeasured'\n```\n Let's break the above code snippet down into pieces: \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: Streetlights App\n4  version: '1.0.0'\n5  description: |\n6    The Smartylighting Streetlights application allows you\n7    to remotely manage the city lights.\n8  license:\n9    name: Apache 2.0\n10    url: 'https://www.apache.org/licenses/LICENSE-2.0'\n```\n The asyncapi field indicates you use the AsyncAPI version 3.0.0. The info field holds information about the Streetlights application. Here, the title, version, description, and license were defined. Moving on, let's talk about the servers section: \n```javascript\n1servers:\n2  mosquitto:\n3    host: test.mosquitto.org\n4    protocol: mqtt\n```\n In this section, you point to the Eclipse Mosquitto message broker. The url points to a real broker instance hosted by the Mosquitto community , and the protocol is MQTT. If you do not want to use the test instance, you can spin up your own broker locally with docker run -it -p 1883:1883 eclipse-mosquitto:1.5 . Remember to change the url to mqtt://localhost . Now, let's move on to the channels section. In the servers section, you specified how to connect to the broker where the application sends messages to or receives messages from. In channels , you go into more details about the connection address inside the broker. (Example: A topic name that specifies what messages are available in the channel.) \n```javascript\n1channels:\n2  lightMeasured:\n3    address: 'light/measured'\n4    messages:\n5      lightMeasuredMessage:\n6        name: LightMeasured\n7        payload:\n8          redacted for brevity\n```\n In this example, light/measured is the channel address. From the Streetlight application example perspective, it means that light/measured is the topic's name in the MQTT broker. Next is the payload property. It is used to understand how the event should look like when publishing to that channel \n```javascript\n1      payload:\n2        type: object\n3        properties:\n4          id:\n5            type: integer\n6            minimum: 0\n7            description: Id of the streetlight.\n8          lumens:\n9            type: integer\n10            minimum: 0\n11            description: Light intensity measured in lumens.\n12          sentAt:\n13            type: string\n14            format: date-time\n15            description: Date and time when the message was sent.\n```\n The payload property defines the event's content using AsyncAPI schemas. It means that your event payload should contain an id and a lumens property \u2014which are integers bigger than zero\u2014and a sentAt property which should be a string containing a date and time. JSON Schema Draft 07 is 100% compatible with AsyncAPI schemas. You can also use other standards to describe payload schema, such as Avro . The last section is operations , where you describe what the application described in the AsyncAPI document is doing. \n```javascript\n1operations:\n2  onLightMeasured:\n3    action: 'receive'\n4    summary: Information about environmental lighting conditions for a particular streetlight.\n5    channel:\n6      $ref: '#/channels/lightMeasured'\n```\n You can see that the Streetlight application is a consumer that only receives events from the broker. Using the mandatory channel field, you specify with $ref what channel the events come from. The onLightMeasured key property describes the function or method name that takes care of this functionality in the generated code. It is a unique ID of the operation across the whole document. Summary In this tutorial, you learned how to create an AsyncAPI specification document via a real-life example with an IoT use case. Your finished document is just a starting point; you must add your business logic. Take some time to play with it. There are still lots of things to be covered, but the intent of this tutorial is to make it simple for you to get an idea of the potential. Next steps Now that you've completed this tutorial, you can proceed to learn how to validate your AsyncAPI document with AsyncAPI Studio . Go Back Adding security Up Next Generate code Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1asyncapi: 3.0.0\n2info:\n3  title: Streetlights App\n4  version: '1.0.0'\n5  description: |\n6    The Smartylighting Streetlights application allows you\n7    to remotely manage the city lights.\n8  license:\n9    name: Apache 2.0\n10    url: 'https://www.apache.org/licenses/LICENSE-2.0'\n11servers:\n12  mosquitto:\n13    host: test.mosquitto.org\n14    protocol: mqtt\n15channels:\n16  lightMeasured:\n17    address: 'light/measured'\n18    messages:\n19      lightMeasuredMessage:\n20        name: LightMeasured\n21        payload:\n22          type: object\n23          properties:\n24            id:\n25              type: integer\n26              minimum: 0\n27              description: ID of the streetlight.\n28            lumens:\n29              type: integer\n30              minimum: 0\n31              description: Light intensity measured in lumens.\n32            sentAt:\n33              type: string\n34              format: date-time\n35              description: Date and time when the message was sent.\n36operations:\n37  onLightMeasured:\n38    action: 'receive'\n39    summary: Information about environmental lighting conditions for a particular streetlight.\n40    channel:\n41      $ref: '#/channels/lightMeasured'",
      "1asyncapi: 3.0.0\n2info:\n3  title: Streetlights App\n4  version: '1.0.0'\n5  description: |\n6    The Smartylighting Streetlights application allows you\n7    to remotely manage the city lights.\n8  license:\n9    name: Apache 2.0\n10    url: 'https://www.apache.org/licenses/LICENSE-2.0'",
      "1servers:\n2  mosquitto:\n3    host: test.mosquitto.org\n4    protocol: mqtt",
      "1channels:\n2  lightMeasured:\n3    address: 'light/measured'\n4    messages:\n5      lightMeasuredMessage:\n6        name: LightMeasured\n7        payload:\n8          redacted for brevity",
      "1      payload:\n2        type: object\n3        properties:\n4          id:\n5            type: integer\n6            minimum: 0\n7            description: Id of the streetlight.\n8          lumens:\n9            type: integer\n10            minimum: 0\n11            description: Light intensity measured in lumens.\n12          sentAt:\n13            type: string\n14            format: date-time\n15            description: Date and time when the message was sent.",
      "1operations:\n2  onLightMeasured:\n3    action: 'receive'\n4    summary: Information about environmental lighting conditions for a particular streetlight.\n5    channel:\n6      $ref: '#/channels/lightMeasured'"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "450388cd",
    "title": "Generate code | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tutorials/generate-code.html",
    "content": "Generate code | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Introduction Background context Installation guide Create a Glee project Start generated application Send message to broker Summary Next steps Generate code Found an error? Have a suggestion? Edit this page on GitHub Introduction In this tutorial, you'll learn how to generate an application that uses the Glee framework. You'll do it with an AsyncAPI document and the AsyncAPI CLI . Background context Glee is a TypeScript/JavaScript framework that enables you to create APIs and messaging clients based on your AsyncAPI document. Instead of generating code, this framework tightly integrates with your AsyncAPI document and binds functions to specific AsyncAPI operations. You only have to provide the code for these functions and Glee handles the rest. Glee is often used with the AsyncAPI CLI for a better development experience. In the previous tutorial, you created an AsyncAPI document that is used in this tutorial. Remember If you did not follow the previous tutorial and do not have an asyncapi.yaml file for overview, then generate one by running the following command using the AsyncAPI CLI: asyncapi new --example=tutorial.yml --no-tty . Installation guide Remember It is important to have Node.js installed which will enable the installation of the required dependencies using npm . CLI Installation Follow the AsyncAPI CLI installation instructions below, based on your computer\u2019s operating system. brew You can install in MacOS via brew: brew install asyncapi . pkg Each release of CLI produces a MacOS dedicated pkg file that enables you to install this CLI as MacOS application. \n```javascript\n1# Download latest release. To download specific release, your link should look similar to https://github.com/asyncapi/cli/releases/download/v0.13.0/asyncapi.pkg. All releases are listed in https://github.com/asyncapi/cli/releases\n2curl -OL https://github.com/asyncapi/cli/releases/latest/download/asyncapi.pkg\n3# Install AsyncAPI CLI\n4sudo installer -pkg asyncapi.pkg -target /\n```\n You can install in Linux via dpkg , a debian package manager: curl -OL https://github.com/asyncapi/cli/releases/latest/download/asyncapi.deb sudo dpkg -i asyncapi.deb For Windows, install the appropriate installer and follow the default installation steps to complete the installation process. Download asyncapi.x64.exe for 64-bit Windows and asyncapi.x86.exe for 32-bit Windows. Read further AsyncAPI CLI installation instructions for different operating systems . Using NPM and Node.js Alternitavely, you can install the AsyncAPI CLI with Node.js >=v10 and NPM . Install AsyncAPI CLI globally with the following command: npm install -g @asyncapi/cli To install a specific version of the AsyncAPI CLI, pass the verion during installation: npm install -g @asyncapi/cli@{version} Create a Glee project Trigger the creation of the Glee project: \n```javascript\n1asyncapi new glee --name=tutorial --template=tutorial\n```\n Let's break down the previous command: asyncapi new glee is how you use Glee via the AsyncAPI CLI. --name=tutorial is how you tell the AsyncAPI CLI to name your new Glee project. --template=tutorial is how you tell the AsyncAPI CLI to use the template of a Glee project that was created specifically for this tutorial. List all files in the directory and confirm your Glee project creation: 1 cd tutorial && ls Upon execution of the command above, the following is an example of the expected result: \n```javascript\n1$ ls\n2 LICENSE\n3 README.md\n4 asyncapi.yaml\n5 functions\n6 package.json\n```\n Start generated application Install dependencies of the newly generated application: 1 npm install Start the application: 1 npm run dev Send message to broker In another terminal install the MQTT.js library: 1 npm install mqtt -g Send a message to the MQTT broker that's connected to your generated application. Run the following MQTT client command: \n```javascript\n1mqtt pub -t 'light/measured' -h 'test.mosquitto.org' -m '{\"id\": 1, \"lumens\": 3, \"sentAt\": \"2017-06-07T12:34:32.000Z\"}'\n```\n Go back to the previous terminal to check if your application logged the streetlight condition you just sent. You should see something like this displayed in the terminal: \n```javascript\n1lightMeasured was received from mosquitto:\n2 { id: 1, lumens: 3, sentAt: '2017-06-07T12:34:32.000Z' }\n3 Streetlight with id \"1\" updated its lighting information to 3 lumens at 2017-06-07T12:34:32.000Z.\n```\n Summary In this tutorial, you learned how to create a Glee project from the Streetlights API specification document created in a previous tutorial . Additionally, you've learned how to run your code by installing the project's dependencies and sending several test messages to the Streelights application using the MQTT client. Next steps Now that you've completed this tutorial, go ahead and learn how to validate your AsyncAPI messages (events) through the message validation techniques supported by AsyncAPI. Go Back Create AsyncAPI document Up Next Validate AsyncAPI document with Studio Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1# Download latest release. To download specific release, your link should look similar to https://github.com/asyncapi/cli/releases/download/v0.13.0/asyncapi.pkg. All releases are listed in https://github.com/asyncapi/cli/releases\n2curl -OL https://github.com/asyncapi/cli/releases/latest/download/asyncapi.pkg\n3# Install AsyncAPI CLI\n4sudo installer -pkg asyncapi.pkg -target /",
      "1asyncapi new glee --name=tutorial --template=tutorial",
      "1$ ls\n2 LICENSE\n3 README.md\n4 asyncapi.yaml\n5 functions\n6 package.json",
      "1mqtt pub -t 'light/measured' -h 'test.mosquitto.org' -m '{\"id\": 1, \"lumens\": 3, \"sentAt\": \"2017-06-07T12:34:32.000Z\"}'",
      "1lightMeasured was received from mosquitto:\n2 { id: 1, lumens: 3, sentAt: '2017-06-07T12:34:32.000Z' }\n3 Streetlight with id \"1\" updated its lighting information to 3 lumens at 2017-06-07T12:34:32.000Z."
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "0d2d8c80",
    "title": "Introduction | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tutorials/getting-started.html",
    "content": "Introduction | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets Introduction Found an error? Have a suggestion? Edit this page on GitHub AsyncAPI is an open source initiative that seeks to improve the current state of Event-Driven Architectures (EDA). Our long-term goal is to make working with EDAs as easy as working with REST APIs. That goes from documentation to code generation, and from discovery to event management. Most of the processes you apply to your REST APIs nowadays would be applicable to your event-driven/asynchronous APIs too. To make this happen, the first step is to create a specification that allows developers, architects, and product managers to define the interfaces of an async API. Much like OpenAPI (aka Swagger) does for REST APIs. The AsyncAPI specification lays the foundation for a greater and better tooling ecosystem for EDAs . If you are looking for a solution to automate and formalize the documentation or code generation of your event-driven (micro)services, you are in the right place. Likewise, if you are aiming to establish solid standards for your events and improve the governance of your asynchronous APIs, welcome to your new home. Go Back Tutorials - Overview Up Next Event-Driven Architectures Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "a051fbfa",
    "title": "Create AsyncAPI document for applications consuming from Kafka | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tutorials/kafka.html",
    "content": "Create AsyncAPI document for applications consuming from Kafka | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Introduction Background context Create AsyncAPI document for Kafka messages Define AsyncAPI version, API information, and server Define channels Define operations Define messages and schemas Summary Next steps Create AsyncAPI document for applications consuming from Kafka Found an error? Have a suggestion? Edit this page on GitHub Introduction In this tutorial, you will create a schema document for Kafka Messages using AsyncAPI. You will also learn about Event-Driven Architecture, the pub/sub model, and brokers concerning Kafka. Suppose you have a service publishing data to a Kafka topic whenever a new user signs up on your application. You want to build a system that tracks users who have signed up for your application. As such, your application will have the following flow: Background context Event-Driven Architecture (EDA) is a design pattern that revolves around the production, detection, and reaction to events over time. It consists of three main components: a message broker, event publishers, and subscribers, which together serve as the backbone for event exchange within different services. Message brokers facilitate asynchronous communications between services, meaning the sending service doesn't have to wait for the receiving service's response. Multiple services can talk to each other directly, even if they are written in different languages. A great example of such a message broker is Apache Kafka. Apache Kafka is a distributed event streaming platform thousands of companies use for their event-driven system. Here, a distributed event streaming platform is a system that operates on multiple nodes, providing high availability and fault tolerance. Publisher/Subscriber (Pub/Sub) is a typical model in EDAs, providing flexible coupling between publishers and subscribers. In this model, those who send event notifications act as publishers, while those who receive the notifications act as the corresponding subscribers. Create AsyncAPI document for Kafka messages In this section, you\u2019ll create an AsyncAPI document to describe the UserSignUp API. The same document can be later used to generate code and documentation as per requirement. Let's begin by analyzing the document. As you progress in the tutorial, we'll break down each segment, uncovering its purpose and functionality. \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: User Signup API\n4  version: 1.0.0\n5  description: The API notifies you whenever a new user signs up in the application.\n6\n7servers:\n8  centralKafkaServer:\n9    host: central.mykafkacluster.org:8092\n10    description: Kafka broker running in a central warehouse\n11    protocol: kafka\n12  westKafkaServer:\n13    host: west.mykafkacluster.org:8092\n14    description: Kafka broker running in the west warehouse\n15    protocol: kafka\n16  eastKafkaServer:\n17    host: east.mykafkacluster.org:8092\n18    description: Kafka broker running in the east warehouse\n19    protocol: kafka\n20\n21operations:\n22  onUserSignedUp:\n23    action: receive\n24    channel:\n25      $ref: '#/channels/userSignedUp'\n26\n27channels:\n28  userSignedUp:\n29    description: This channel contains a message per each user who signs up in our application.\n30    address: user_signedup\n31    messages:\n32      userSignedUp:\n33        $ref: '#/components/messages/userSignedUp'\n34\n35components:\n36  messages:\n37    userSignedUp:\n38      payload:\n39        type: object\n40        properties:\n41          userId:\n42            type: integer\n43            description: This property describes the id of the user\n44          userEmail:\n45            type: string\n46            description: This property describes the email of the user\n```\n Let's now break it down into pieces. Define AsyncAPI version, API information, and server First, you must describe your application, including the AsyncAPI version, the info about the document, and the server your application is based on. \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: User Signup API\n4  version: 1.0.0\n5  description: The API notifies you whenever a new user signs up in the application.\n6servers:\n7  centralKafkaServer:\n8    host: central.mykafkacluster.org:8092\n9    description: Kafka broker running in a central warehouse\n10    protocol: kafka\n11  westKafkaServer:\n12    host: west.mykafkacluster.org:8092\n13    description: Kafka broker running in the west warehouse\n14    protocol: kafka\n15  eastKafkaServer:\n16    host: east.mykafkacluster.org:8092\n17    description: Kafka broker running in the east warehouse\n18    protocol: kafka\n```\n In the above snippet: The asyncapi field indicates that you use AsyncAPI version 3.0.0. The info field provides information about the API. Here the the APIs title , version , and description are being defined. The server field specifies the details of the server, including the host , description , and the protocol that is being used (i.e., Kafka). This section allows you to define multiple clusters or servers, as shown in the provided code block. Remember If an application has multiple servers hidden from the user behind a load balancer, then only the address of the load balancer must be included in the AsyncAPI document. Define channels Next, let's move on to the channels section. The channel addresses are the topics in Kafka; they are the routes to which your API will send/receive messages. \n```javascript\n1channels:\n2  userSignedUp:\n3    description: This channel contains a message per each user who signs up in our application.\n4    address: user_signedup\n5    messages:\n6      userSignedUp:\n7        $ref: '#/components/messages/userSignedUp'\n```\n In the above code snippet: The userSignedUp object inside channels describes the Kafka topic where the application will receive the information and the associated message definition. The address field represents the actual name of the Kafka topic and the messages field describes the expected messages in that topic. Define operations Now, let's move on to the operations section. The operations property is used to describe how your application interacts with the defined channels. \n```javascript\n1operations:\n2  onUserSignedUp:\n3    action: receive\n4    channel:\n5      $ref: '#/channels/userSignedUp'\n```\n In the above code snippet: The onUserSignedUp object specifies the operation's nature, which occurs when the user signs up. The action property indicates that the application will receive the information. The channel property points to the channel where the operation occurs. Define messages and schemas Finally, you'll define the messages and their payload. The payload defines how the event would look like when it's sent from the channel. \n```javascript\n1components:\n2  messages:\n3    userSignedUp:\n4      payload:\n5        type: object\n6        properties:\n7          userId:\n8            type: integer\n9            description: This property describes the ID of the user\n10          userEmail:\n11            type: string\n12            description: This property describes the Email of the user\n```\n In the above code snippet: The userSignedUp message is defined which describes the payload (content) of the message. The payload property defines the message content. Your message payload should contain a userId , an integer, a userEmail property, and a string property. Summary The ability to generate an AsyncAPI document for Kafka is now in your toolkit. You generated an AsyncAPI document that defines the structure of the Kafka messages in a machine-readable format, which makes it easier to maintain event-driven architecture. Try adding your business logic and playing around with it. Next steps Now that you know how to write an AsyncAPI document for Kafka messages using the default schema, let's learn how to create an AsyncAPI document using Avro Schema instead . Go Back Tutorials - Implement Request/Reply in an AsyncAPI document for a Slack app Up Next Describe Kafka message payload using Avro Schema Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1asyncapi: 3.0.0\n2info:\n3  title: User Signup API\n4  version: 1.0.0\n5  description: The API notifies you whenever a new user signs up in the application.\n6\n7servers:\n8  centralKafkaServer:\n9    host: central.mykafkacluster.org:8092\n10    description: Kafka broker running in a central warehouse\n11    protocol: kafka\n12  westKafkaServer:\n13    host: west.mykafkacluster.org:8092\n14    description: Kafka broker running in the west warehouse\n15    protocol: kafka\n16  eastKafkaServer:\n17    host: east.mykafkacluster.org:8092\n18    description: Kafka broker running in the east warehouse\n19    protocol: kafka\n20\n21operations:\n22  onUserSignedUp:\n23    action: receive\n24    channel:\n25      $ref: '#/channels/userSignedUp'\n26\n27channels:\n28  userSignedUp:\n29    description: This channel contains a message per each user who signs up in our application.\n30    address: user_signedup\n31    messages:\n32      userSignedUp:\n33        $ref: '#/components/messages/userSignedUp'\n34\n35components:\n36  messages:\n37    userSignedUp:\n38      payload:\n39        type: object\n40        properties:\n41          userId:\n42            type: integer\n43            description: This property describes the id of the user\n44          userEmail:\n45            type: string\n46            description: This property describes the email of the user",
      "1asyncapi: 3.0.0\n2info:\n3  title: User Signup API\n4  version: 1.0.0\n5  description: The API notifies you whenever a new user signs up in the application.\n6servers:\n7  centralKafkaServer:\n8    host: central.mykafkacluster.org:8092\n9    description: Kafka broker running in a central warehouse\n10    protocol: kafka\n11  westKafkaServer:\n12    host: west.mykafkacluster.org:8092\n13    description: Kafka broker running in the west warehouse\n14    protocol: kafka\n15  eastKafkaServer:\n16    host: east.mykafkacluster.org:8092\n17    description: Kafka broker running in the east warehouse\n18    protocol: kafka",
      "1channels:\n2  userSignedUp:\n3    description: This channel contains a message per each user who signs up in our application.\n4    address: user_signedup\n5    messages:\n6      userSignedUp:\n7        $ref: '#/components/messages/userSignedUp'",
      "1operations:\n2  onUserSignedUp:\n3    action: receive\n4    channel:\n5      $ref: '#/channels/userSignedUp'",
      "1components:\n2  messages:\n3    userSignedUp:\n4      payload:\n5        type: object\n6        properties:\n7          userId:\n8            type: integer\n9            description: This property describes the ID of the user\n10          userEmail:\n11            type: string\n12            description: This property describes the Email of the user"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "b8b5cab6",
    "title": "Message validation in runtime | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tutorials/message-validation.html",
    "content": "Message validation in runtime | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Introduction Background context Validate messages Summary Next steps Message validation in runtime Found an error? Have a suggestion? Edit this page on GitHub Introduction In this tutorial, you'll learn how to validate messages (events) that are sent to your AsyncAPI application. Background context Message validation can be performed at both the producer and consumer levels. Message validation requires the participation of the producer, consumer, and broker. We will learn how to validate messages at the consumer level by discarding invalid messages based on the parameters provided. You will be using the Eclipse Mosquitto broker. The MQTT protocol provides a lightweight method of messaging using a publish/subscribe model. You will also use an MQTT client that runs an MQTT library and connects to an MQTT broker over a network. Here producers and consumers are MQTT clients. The producer and consumer labels refer to whether the client is sending or receiving messages. In the previous tutorial, you generated an application that uses Glee framework. Now you will be validating the messages that you will be sending to your application using a Mosquitto broker and an MQTT client. Remember If you did not follow the previous tutorial and do not have an application generated, then follow these instructions: asyncapi new glee --name=tutorial --template tutorial`. cd tutorial && npm install Validate messages In this step, you will send a message to your application using an MQTT broker and check the errors logged when you accidentally send an invalid message. Start your generated application: 1 npm run dev Send a message: \n```javascript\n1mqtt pub -t 'light/measured' -h 'test.mosquitto.org' -m '{\"id\": 1, \"lumens\": \"3\", \"sentAt\": \"2017-06-07T12:34:32.000Z\"}'\n```\n Go back to the previous terminal and check if your application logged the streetlight condition you just sent, with errors related to the invalid message. You should see something displayed in the terminal similar to the following: \n```javascript\n1lightMeasured was received from mosquitto:\n2{ id: 1, lumens: '3', sentAt: '2017-06-07T12:34:32.000Z' }\n3x You have received a malformed event or there has been error processing it. Please review the error below:\n4TYPE should be integer\n5 \n6  1 | {\n7  2 |   \"id\": 1,\n8> 3 |   \"lumens\": \"3\",\n9    |             ^^^ \ud83d\udc48\ud83c\udffd  type should be integer\n10  4 |   \"sentAt\": \"2017-06-07T12:34:32.000Z\"\n11  5 | }\n12 \n13ONEOF should match exactly one schema in oneOf\n14 \n15> 1 | {\n16    | ^\n17> 2 |   \"id\": 1,\n18    | ^^^^^^^^^^\n19> 3 |   \"lumens\": \"3\",\n20    | ^^^^^^^^^^\n21> 4 |   \"sentAt\": \"2017-06-07T12:34:32.000Z\"\n22    | ^^^^^^^^^^\n23> 5 | }\n24    | ^^ \ud83d\udc48\ud83c\udffd  oneOf should match exactly one schema in oneOf\n```\n Here, you can see that the property lumens has type integer , but you are sending a message with type string : \n```javascript\n1  message:\n2        name: lumensInfo\n3        payload:\n4          type: object\n5          properties:\n6            id:\n7              type: integer\n8              minimum: 0\n9              description: Id of the streetlight.\n10            lumens:\n11              type: integer\n12              minimum: 0\n13              description: Light intensity measured in lumens.\n```\n Send a correct message to your application: \n```javascript\n1mqtt pub -t 'light/measured' -h 'test.mosquitto.org' -m '{\"id\": 1, \"lumens\": 3, \"sentAt\": \"2017-06-07T12:34:32.000Z\"}'\n```\n You can see that your generated application received a message in the terminal: \n```javascript\n1lightMeasured was received from mosquitto:\n2{ id: 1, lumens: 3, sentAt: '2017-06-07T12:34:32.000Z' }\n3Streetlight with id \"1\" updated its lighting information to 3 lumens at 2017-06-07T12:34:32.000Z.\n```\n Such a terminal message indicates that your message is valid and the application received it correctly. Summary In this tutorial, you learned how to connect your generated application to an MQTT broker, send messages through it, identify when an invalid message is sent to your application, and how to correct an invalid message. Next steps Now that you've completed this tutorial, enjoy our AsyncAPI message validation guide . Go Back Validate AsyncAPI document with Studio Up Next Streetlights - Interactive Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1mqtt pub -t 'light/measured' -h 'test.mosquitto.org' -m '{\"id\": 1, \"lumens\": \"3\", \"sentAt\": \"2017-06-07T12:34:32.000Z\"}'",
      "1lightMeasured was received from mosquitto:\n2{ id: 1, lumens: '3', sentAt: '2017-06-07T12:34:32.000Z' }\n3x You have received a malformed event or there has been error processing it. Please review the error below:\n4TYPE should be integer\n5 \n6  1 | {\n7  2 |   \"id\": 1,\n8> 3 |   \"lumens\": \"3\",\n9    |             ^^^ \ud83d\udc48\ud83c\udffd  type should be integer\n10  4 |   \"sentAt\": \"2017-06-07T12:34:32.000Z\"\n11  5 | }\n12 \n13ONEOF should match exactly one schema in oneOf\n14 \n15> 1 | {\n16    | ^\n17> 2 |   \"id\": 1,\n18    | ^^^^^^^^^^\n19> 3 |   \"lumens\": \"3\",\n20    | ^^^^^^^^^^\n21> 4 |   \"sentAt\": \"2017-06-07T12:34:32.000Z\"\n22    | ^^^^^^^^^^\n23> 5 | }\n24    | ^^ \ud83d\udc48\ud83c\udffd  oneOf should match exactly one schema in oneOf",
      "1  message:\n2        name: lumensInfo\n3        payload:\n4          type: object\n5          properties:\n6            id:\n7              type: integer\n8              minimum: 0\n9              description: Id of the streetlight.\n10            lumens:\n11              type: integer\n12              minimum: 0\n13              description: Light intensity measured in lumens.",
      "1mqtt pub -t 'light/measured' -h 'test.mosquitto.org' -m '{\"id\": 1, \"lumens\": 3, \"sentAt\": \"2017-06-07T12:34:32.000Z\"}'",
      "1lightMeasured was received from mosquitto:\n2{ id: 1, lumens: 3, sentAt: '2017-06-07T12:34:32.000Z' }\n3Streetlight with id \"1\" updated its lighting information to 3 lumens at 2017-06-07T12:34:32.000Z."
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "1ec7a128",
    "title": "Streetlights - Interactive | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tutorials/streetlights-interactive.html",
    "content": "Streetlights - Interactive | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets Streetlights - Interactive Found an error? Have a suggestion? Edit this page on GitHub Check out the Streetlights interactive tutorial ; we plan to have more docs written this way! Our interactive tutorials on KillerCoda work for everyone, regardless of your operating system. Go through the Streetlights interactive tutorial . Share your opinion via your preferred channel: Slack Twitter GitHub Issue Go Back Message validation in runtime Up Next WebSocket - Create an AsyncAPI document for a Slackbot with WebSocket Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "854b7687",
    "title": "Validate AsyncAPI document with Studio | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tutorials/studio-document-validation.html",
    "content": "Validate AsyncAPI document with Studio | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Introduction Background context Copy invalid AsyncAPI document Troubleshoot Studio errors Summary Next steps Validate AsyncAPI document with Studio Found an error? Have a suggestion? Edit this page on GitHub Introduction In this tutorial, you'll learn how to validate AsyncAPI documents using the AsyncAPI Studio tool . You will start with a broken AsyncAPI document and troubleshoot via console errors step-by-step until you end up with a valid AsyncAPI document. This process will illustrate identifying REQUIRED properties in AsyncAPI documents . Background context An AsyncAPI document is a file that defines and annotates the different components of a specific Event-Driven API. The format of the file must be JSON or YAML. You can use this document to generate both documentation and code. The AsyncAPI Studio tool allows you to develop an AsyncAPI document, validate it, preview it, convert it to the latest version, and visualize event flows. Now let's experiment with an invalid file to see how errors are displayed and how to make that file valid again. Copy invalid AsyncAPI document Let's pretend you have an invalid AsyncAPI document. Open Studio . Remember You can also skip the step below by clicking on New File in Studio and opening the Invalid Example template in the tutorials section. Copy and paste the below invalid AsyncAPI document: \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: Streetlights API\n4  version: '1.0.0'\n5  description: |\n6    The Smartylighting Streetlights API allows you\n7    to remotely manage the city lights.\n8  license:\n9    name: Apache 2.0\n10    url: 'https://www.apache.org/licenses/LICENSE-2.0'\n11\n12servers:\n13  mosquitto:\n14    url: test.mosquitto.org\n15    protocol: mqtt\n16\n17channels:\n18  lightMeasured:\n19    address: 'light/measured'\n20    messages:\n21      lightMeasuredMessage:\n22        name: LightMeasured\n23        payload:\n24          type: object\n25          properties:\n26            id:\n27              type: integer\n28              minimum: true\n29              description: Id of the streetlight.\n30            lumens:\n31              type: integer\n32              minimum: 0\n33              description: Light intensity measured in lumens.\n34            sentAt:\n35              type: string\n36              format: date-time\n37              description: Date and time when the message was sent.\n38\n39operations:\n40  onLightMeasured:\n41    action: 'receive'\n42    summary: Inform about environmental lighting conditions for a particular streetlight.\n43    channel:\n44      $ref: '#/channels/lightMeasured'\n```\n Troubleshoot Studio errors Let's fix the errors one by one until you end up with a valid AsyncAPI document. You can see the error message on the screen: Empty or invalid document. Please fix errors/define AsyncAPI document. Open DIAGNOSTICS , you can see more information related to your errors. Fix the incorrect server information. Use host instead of url \n```javascript\n1servers:\n2  mosquitto:\n3    host: test.mosquitto.org\n4    protocol: mqtt\n```\n Remember Notice how description property is missing; that doesn't make the AsyncAPI document invalid, but it's always better to include. Read the next error: \"minimum\" property type must be number . Fix the minimum by changing it to: 0 . \n```javascript\n1          properties:\n2            id:\n3              type: integer\n4              minimum: 0\n```\n Congratulations! You identified and fixed all the errors, and now have a valid AsyncAPI document. Summary In this tutorial, you learned how to validate an AsyncAPI document using the AsyncAPI Studio tool. You also learned to troubleshoot an invalid AsyncAPI document by following the error message directions in diagnostics. In doing so, you learned how to identify REQUIRED properties in all AsyncAPI documents. Next steps Now that you have completed this tutorial, go ahead to learn generate AsyncAPI messages (events) which you will be sending to your application. You may also enjoy reading our AsyncAPI document validation guide . Go Back Generate code Up Next Message validation in runtime Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1asyncapi: 3.0.0\n2info:\n3  title: Streetlights API\n4  version: '1.0.0'\n5  description: |\n6    The Smartylighting Streetlights API allows you\n7    to remotely manage the city lights.\n8  license:\n9    name: Apache 2.0\n10    url: 'https://www.apache.org/licenses/LICENSE-2.0'\n11\n12servers:\n13  mosquitto:\n14    url: test.mosquitto.org\n15    protocol: mqtt\n16\n17channels:\n18  lightMeasured:\n19    address: 'light/measured'\n20    messages:\n21      lightMeasuredMessage:\n22        name: LightMeasured\n23        payload:\n24          type: object\n25          properties:\n26            id:\n27              type: integer\n28              minimum: true\n29              description: Id of the streetlight.\n30            lumens:\n31              type: integer\n32              minimum: 0\n33              description: Light intensity measured in lumens.\n34            sentAt:\n35              type: string\n36              format: date-time\n37              description: Date and time when the message was sent.\n38\n39operations:\n40  onLightMeasured:\n41    action: 'receive'\n42    summary: Inform about environmental lighting conditions for a particular streetlight.\n43    channel:\n44      $ref: '#/channels/lightMeasured'",
      "1servers:\n2  mosquitto:\n3    host: test.mosquitto.org\n4    protocol: mqtt",
      "1          properties:\n2            id:\n3              type: integer\n4              minimum: 0"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "34730db2",
    "title": "Create an AsyncAPI document for a Slackbot with WebSocket | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tutorials/websocket.html",
    "content": "Create an AsyncAPI document for a Slackbot with WebSocket | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Introduction Background context Define AsyncAPI version, API information, and server Define messages and schemas Define channels and bindings Define operations Summary Create an AsyncAPI document for a Slackbot with WebSocket Found an error? Have a suggestion? Edit this page on GitHub Introduction In this tutorial, you will learn how to write an AsyncAPI document designed for a Slack application that operates in Socket Mode. The aim is to help you grasp a real-world application of AsyncAPI with the WebSocket protocol. You will learn how to write an AsyncAPI document for a consumer-only application receiving a stream of messages from a WebSocket server. You will also learn why the AsyncAPI bindings feature exists and how to use it. Consider a scenario where you are in charge of maintaining a highly active Slack workspace. You want an easy way to keep track of the popular messages across all channels, but doing this manually would be difficult. To simplify this process, you will build a Slackbot called Heart-Counter that actively monitors reactions added to a message and determines its popularity by counting the reactions of the \u201cheart\u201d emoji. Here\u2019s a visual representation of how the Heart-Counter should work: Background context WebSocket is a communication protocol that enables simultaneous bidirectional data exchange between a client and a server over a single, long-lived connection. Unlike HTTP, which relies on the request-response model, WebSocket is ideal for scenarios where real-time, interactive, and low-latency communication is necessary. In Slack, WebSocket is employed as part of its Socket Mode feature to facilitate real-time notifications between Slack's servers and third-party applications or bots. The Slack Event API is a tool that lets you receive real-time notifications of specific events in a Slack workspace such as messages, reactions, and user presence changes. Define AsyncAPI version, API information, and server You start your AsyncAPI document by specifying the AsyncAPI version and essential information about your Slack application's API, which includes details such as the title, version, and description. The servers section allows you to define the protocol and specify information about the URLs your application will use, such as host , pathname , protocol , and description . Remember The WebSocket URL is generated by invoking the apps.connections.open method from Slack\u2019s API. You use the authentication tokens obtained during the configuration of your Slackbot to generate this URL. \n```javascript\n1asyncapi: '3.0.0'\n2info:\n3  title: Create an AsyncAPI document for a Slackbot with WebSocket\n4  version: '1.0.0'\n5  description:  |\n6    The Heart-Counter manages popular messages in a Slack workspace by monitoring message reaction data\n7servers:\n8  production:\n9    host: wss-primary.slack.com\n10    pathname: /link\n11    protocol: wss\n12    description: Slack's server in Socket Mode for real-time communication\n```\n Define messages and schemas Your AsyncAPI document needs to be very clear on the type of event it is expected to receive. Here's where the messages component steps in. Using the payload property, you can specify what these events should look like, their structure, and what content they carry. The payload attribute specifies the name, format, and description of all the expected properties. Heart-Counter starts the popularity count of a message by validating if the reaction property set in the reaction schema definition corresponds to \"heart\". \n```javascript\n1components:\n2  messages:\n3    reaction:\n4      summary: Action triggered when the channel receives a new reaction-added event\n5      payload:\n6        $ref: '#/components/schemas/reaction'\n7    hello:\n8      summary: Action triggered when a successful WebSocket connection is established\n9      payload:\n10        $ref: '#/components/schemas/hello'\n11  schemas:\n12    hello:\n13      type: object\n14      properties:\n15        type:\n16          type: string\n17          description: A hello string confirming WebSocket connection\n18        connection_info:\n19          type: object\n20          properties:\n21            app_id:\n22            type: string\n23        num_connections:\n24            type: integer\n25        debug_info:\n26          type: object\n27          properties:\n28            host:\n29              type: string\n30            started:\n31              type: string\n32            build_number:\n33              type: integer\n34            approximate_connection_time:\n35              type: integer\n36      reaction:\n37        type: object\n38        properties:\n39          user:\n40            type: string\n41            description: User ID who performed this event\n42          reaction:\n43            type: string\n44            description: The only reaction that we need is a heart emoji\n45          item_user:\n46            type: string\n47            description: User ID that created the original item that has been reacted to\n48          item:\n49            type: object\n50            properties:\n51              channel:\n52                type: string\n53                description: Channel information of original message\n54              ts:\n55                type: string\n56                description: Timestamp information of original message\n57          event_ts:\n58            type: string\n59            description: Reaction timestamp\n```\n Define channels and bindings The channels attribute defines a communication channel for the event. The address specifies where the channel is tuned in to receive messages while the messages property defines a key-value pair where each key corresponds to the event it's set up to handle. The WebSocket URL generated for Heart-Counter includes authentication tokens. This information is represented using query parameters. Query parameters are specific to HTTP protocol and partially to WebSocket, which uses HTTP to connect client and server. Since this is protocol-specific information, you must use an AsyncAPI feature called bindings that enables you to provide protocol-specific information inside the AsyncAPI document using the bindings attribute. By utilizing the query object from the WebSocket binding, you can outline the parameters needed for the connection and the conditions they must meet. \n```javascript\n1channels:\n2  root:\n3    address: /\n4    messages:\n5      hello:\n6        $ref: '#/components/messages/hello'\n7      reaction:\n8        $ref: '#/components/messages/reaction'\n9    bindings:\n10      ws:\n11        query:\n12          type: object\n13          description: Tokens are produced in the WebSocket URL generated from the [apps.connections.open](https://api.slack.com/methods/apps.connections.open) method from Slack\u2019s API\n14          properties:\n15            ticket:\n16              type: string\n17              description: Temporary token generated when connection is initiated\n18              const: '13748dac-b866-4ea7-b98e-4fb7895c0a7f'\n19            app_id:\n20              type: string\n21              description: Unique identifier assigned to the Slack app\n22              const: 'fe684dfa62159c6ac646beeac31c8f4ef415e4f39c626c2dbd1530e3a690892f'\n```\n Define operations The operation property is all about defining specific tasks your application can perform. Essentially, it's how the Heart-Counter interacts with Slack. In this example, the helloListener operation keeps an eye out for the message sent by the Slack server when a WebSocket connection is successfully established. On the other hand, the reactionListener is focused on the reaction_added event type. Your Slack application is designed to be notified of events within your workspace. It subscribes to a specific event type and uses Slack's Event API. In this case, both operations' action property is set to receive events. \n```javascript\n1operations:\n2  helloListener:\n3    action: receive\n4    channel:\n5      $ref: '#/channels/root'\n6    messages:\n7      - $ref: '#/channels/root/messages/hello'\n8  reactionListener:\n9    action: receive\n10    channel:\n11      $ref: '#/channels/root'\n12    messages:\n13      - $ref: '#/channels/root/messages/reaction'\n```\n Congratulations, you've completed the tutorial! Putting these blocks together gives you an AsyncAPI document all ready to go. \n```javascript\n1asyncapi: '3.0.0'\n2info:\n3  title: Create an AsyncAPI document for a Slackbot with WebSocket\n4  version: '1.0.0'\n5  description:  |\n6    The Heart-Counter manages popular messages in a Slack workspace by monitoring message reaction data.\n7servers:\n8  production:\n9    host: wss-primary.slack.com\n10    pathname: /link\n11    protocol: wss\n12    description: Slack's server in Socket Mode for real-time communication\n13channels:\n14  root:\n15    address: /\n16    messages:\n17      hello:\n18        $ref: '#/components/messages/hello'\n19      reaction:\n20        $ref: '#/components/messages/reaction'\n21    bindings:\n22      ws:\n23        query:\n24          type: object\n25          description: Tokens are produced in the WebSocket URL generated from the [apps.connections.open](https://api.slack.com/methods/apps.connections.open) method from Slack\u2019s API\n26          properties:\n27            ticket:\n28              type: string\n29              description: Temporary token generated when connection is initiated\n30              const: '13748dac-b866-4ea7-b98e-4fb7895c0a7f'\n31            app_id:\n32              type: string\n33              description: Unique identifier assigned to the Slack app\n34              const: 'fe684dfa62159c6ac646beeac31c8f4ef415e4f39c626c2dbd1530e3a690892f'\n35operations:\n36  helloListener:\n37    action: receive\n38    channel:\n39      $ref: '#/channels/root'\n40    messages:\n41      - $ref: '#/channels/root/messages/hello'\n42  reactionListener:\n43    action: receive\n44    channel:\n45      $ref: '#/channels/root'\n46    messages:\n47      - $ref: '#/channels/root/messages/reaction'\n48components:\n49  messages:\n50    reaction:\n51      summary: Action triggered when the channel receives a new reaction-added event\n52      payload:\n53        $ref: '#/components/schemas/reaction'\n54    hello:\n55      summary: Action triggered when a successful WebSocket connection is established\n56      payload:\n57        $ref: '#/components/schemas/hello'\n58  schemas:\n59    hello:\n60      type: object\n61      properties:\n62        type:\n63          type: string\n64          description: A hello string confirming WebSocket connection\n65        connection_info:\n66          type: object\n67          properties:\n68            app_id:\n69              type: string\n70            num_connections:\n71              type: integer\n72            debug_info:\n73              type: object\n74              properties:\n75                host:\n76                  type: string\n77                started:\n78                  type: string\n79                build_number:\n80                  type: integer\n81                approximate_connection_time:\n82                  type: integer\n83    reaction:\n84      type: object\n85      properties:\n86        user:\n87          type: string\n88          description: User ID who performed this event\n89        reaction:\n90          type: string\n91          description: The only reaction that we need is a heart emoji\n92        item_user:\n93          type: string\n94          description: User ID that created the original item that has been reacted to\n95        item:\n96          type: object\n97          properties:\n98            channel:\n99              type: string\n100              description: Channel information of original message\n101            ts:\n102              type: string\n103              description: Timestamp information of original message\n104        event_ts:\n105          type: string\n106          description: Reaction timestamp\n```\n Summary In this tutorial, you learned to create an AsyncAPI document for a Slackbot using WebSocket in Socket Mode. You gained practical insights into the functionality of operations, channels, messages, and schemas. Now you're equipped to handle real-world applications that facilitate bidirectional real-time data exchange, such as chatbots and live-streaming platforms. Go Back Tutorials - Streetlights - Interactive Up Next Implement Request/Reply in an AsyncAPI document for a Slack app Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1asyncapi: '3.0.0'\n2info:\n3  title: Create an AsyncAPI document for a Slackbot with WebSocket\n4  version: '1.0.0'\n5  description:  |\n6    The Heart-Counter manages popular messages in a Slack workspace by monitoring message reaction data\n7servers:\n8  production:\n9    host: wss-primary.slack.com\n10    pathname: /link\n11    protocol: wss\n12    description: Slack's server in Socket Mode for real-time communication",
      "1components:\n2  messages:\n3    reaction:\n4      summary: Action triggered when the channel receives a new reaction-added event\n5      payload:\n6        $ref: '#/components/schemas/reaction'\n7    hello:\n8      summary: Action triggered when a successful WebSocket connection is established\n9      payload:\n10        $ref: '#/components/schemas/hello'\n11  schemas:\n12    hello:\n13      type: object\n14      properties:\n15        type:\n16          type: string\n17          description: A hello string confirming WebSocket connection\n18        connection_info:\n19          type: object\n20          properties:\n21            app_id:\n22            type: string\n23        num_connections:\n24            type: integer\n25        debug_info:\n26          type: object\n27          properties:\n28            host:\n29              type: string\n30            started:\n31              type: string\n32            build_number:\n33              type: integer\n34            approximate_connection_time:\n35              type: integer\n36      reaction:\n37        type: object\n38        properties:\n39          user:\n40            type: string\n41            description: User ID who performed this event\n42          reaction:\n43            type: string\n44            description: The only reaction that we need is a heart emoji\n45          item_user:\n46            type: string\n47            description: User ID that created the original item that has been reacted to\n48          item:\n49            type: object\n50            properties:\n51              channel:\n52                type: string\n53                description: Channel information of original message\n54              ts:\n55                type: string\n56                description: Timestamp information of original message\n57          event_ts:\n58            type: string\n59            description: Reaction timestamp",
      "1channels:\n2  root:\n3    address: /\n4    messages:\n5      hello:\n6        $ref: '#/components/messages/hello'\n7      reaction:\n8        $ref: '#/components/messages/reaction'\n9    bindings:\n10      ws:\n11        query:\n12          type: object\n13          description: Tokens are produced in the WebSocket URL generated from the [apps.connections.open](https://api.slack.com/methods/apps.connections.open) method from Slack\u2019s API\n14          properties:\n15            ticket:\n16              type: string\n17              description: Temporary token generated when connection is initiated\n18              const: '13748dac-b866-4ea7-b98e-4fb7895c0a7f'\n19            app_id:\n20              type: string\n21              description: Unique identifier assigned to the Slack app\n22              const: 'fe684dfa62159c6ac646beeac31c8f4ef415e4f39c626c2dbd1530e3a690892f'",
      "1operations:\n2  helloListener:\n3    action: receive\n4    channel:\n5      $ref: '#/channels/root'\n6    messages:\n7      - $ref: '#/channels/root/messages/hello'\n8  reactionListener:\n9    action: receive\n10    channel:\n11      $ref: '#/channels/root'\n12    messages:\n13      - $ref: '#/channels/root/messages/reaction'",
      "1asyncapi: '3.0.0'\n2info:\n3  title: Create an AsyncAPI document for a Slackbot with WebSocket\n4  version: '1.0.0'\n5  description:  |\n6    The Heart-Counter manages popular messages in a Slack workspace by monitoring message reaction data.\n7servers:\n8  production:\n9    host: wss-primary.slack.com\n10    pathname: /link\n11    protocol: wss\n12    description: Slack's server in Socket Mode for real-time communication\n13channels:\n14  root:\n15    address: /\n16    messages:\n17      hello:\n18        $ref: '#/components/messages/hello'\n19      reaction:\n20        $ref: '#/components/messages/reaction'\n21    bindings:\n22      ws:\n23        query:\n24          type: object\n25          description: Tokens are produced in the WebSocket URL generated from the [apps.connections.open](https://api.slack.com/methods/apps.connections.open) method from Slack\u2019s API\n26          properties:\n27            ticket:\n28              type: string\n29              description: Temporary token generated when connection is initiated\n30              const: '13748dac-b866-4ea7-b98e-4fb7895c0a7f'\n31            app_id:\n32              type: string\n33              description: Unique identifier assigned to the Slack app\n34              const: 'fe684dfa62159c6ac646beeac31c8f4ef415e4f39c626c2dbd1530e3a690892f'\n35operations:\n36  helloListener:\n37    action: receive\n38    channel:\n39      $ref: '#/channels/root'\n40    messages:\n41      - $ref: '#/channels/root/messages/hello'\n42  reactionListener:\n43    action: receive\n44    channel:\n45      $ref: '#/channels/root'\n46    messages:\n47      - $ref: '#/channels/root/messages/reaction'\n48components:\n49  messages:\n50    reaction:\n51      summary: Action triggered when the channel receives a new reaction-added event\n52      payload:\n53        $ref: '#/components/schemas/reaction'\n54    hello:\n55      summary: Action triggered when a successful WebSocket connection is established\n56      payload:\n57        $ref: '#/components/schemas/hello'\n58  schemas:\n59    hello:\n60      type: object\n61      properties:\n62        type:\n63          type: string\n64          description: A hello string confirming WebSocket connection\n65        connection_info:\n66          type: object\n67          properties:\n68            app_id:\n69              type: string\n70            num_connections:\n71              type: integer\n72            debug_info:\n73              type: object\n74              properties:\n75                host:\n76                  type: string\n77                started:\n78                  type: string\n79                build_number:\n80                  type: integer\n81                approximate_connection_time:\n82                  type: integer\n83    reaction:\n84      type: object\n85      properties:\n86        user:\n87          type: string\n88          description: User ID who performed this event\n89        reaction:\n90          type: string\n91          description: The only reaction that we need is a heart emoji\n92        item_user:\n93          type: string\n94          description: User ID that created the original item that has been reacted to\n95        item:\n96          type: object\n97          properties:\n98            channel:\n99              type: string\n100              description: Channel information of original message\n101            ts:\n102              type: string\n103              description: Timestamp information of original message\n104        event_ts:\n105          type: string\n106          description: Reaction timestamp"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "4489001f",
    "title": "AsyncAPI documents | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tutorials/getting-started/asyncapi-documents.html",
    "content": "AsyncAPI documents | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets AsyncAPI documents Found an error? Have a suggestion? Edit this page on GitHub An AsyncAPI document is a file that defines and annotates the different components of a specific Event-Driven API . The file format must be JSON or YAML; however, only the subset of YAML that matches the JSON capabilities is allowed. \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: Example application\n4  version: '0.1.0'\n5channels:\n6  userSignup:\n7    address: 'user/signedup'\n8    messages:\n9      userSignedupMessage: \n10        description: A message describing that a user just signed up.\n11        payload:\n12          type: object\n13          additionalProperties: false\n14          properties:\n15            fullName:\n16              type: string\n17            email:\n18              type: string\n19              format: email\n20            age:\n21              type: integer\n22              minimum: 18\n23operations:\n24  publishUserSignedup:\n25    action: 'send'\n26    channel:\n27      $ref: '#/channels/userSignup'\n```\n The AsyncAPI document is a machine-readable definition of your Event-Driven API. That document can be used afterward to generate documentation and code, validate the messages that Example application sends, and even apply API management policies to your messages before they arrive at the broker. Your API documentation is now machine-readable (easily parseable by code) so the myriad of useful applications is endless. Go Back Request/reply pattern Up Next Servers Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1asyncapi: 3.0.0\n2info:\n3  title: Example application\n4  version: '0.1.0'\n5channels:\n6  userSignup:\n7    address: 'user/signedup'\n8    messages:\n9      userSignedupMessage: \n10        description: A message describing that a user just signed up.\n11        payload:\n12          type: object\n13          additionalProperties: false\n14          properties:\n15            fullName:\n16              type: string\n17            email:\n18              type: string\n19              format: email\n20            age:\n21              type: integer\n22              minimum: 18\n23operations:\n24  publishUserSignedup:\n25    action: 'send'\n26    channel:\n27      $ref: '#/channels/userSignup'"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "22d3d0e4",
    "title": "Coming from OpenAPI | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tutorials/getting-started/coming-from-openapi.html",
    "content": "Coming from OpenAPI | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Conclusion Coming from OpenAPI Found an error? Have a suggestion? Edit this page on GitHub If you're coming from OpenAPI, you must know that AsyncAPI started as an adaptation of the OpenAPI specification . AsyncAPI wanted to be as compatible as possible with OpenAPI so that the users could reuse parts in both. Before AsyncAPI 3.0.0 , you could find many similarities between OpenAPI and AsyncAPI. Remember that in the world of Event-Driven Architectures, you have more than one protocol; therefore, some things are different. Check out the following comparison chart, inspired by Darrel Miller's blog post : OpenAPI 3.0 Info Servers Security Paths Path Item Summary and description Operation (GET, PUT, POST, etc.) Request Responses Tags External Docs Components Schemas Responses Parameters Examples Request Bodies Headers Security Schemes Links Callbacks AsyncAPI 2.0 Info Servers (hosts + security) Channel Channel Item Operation (Publish and Subscribe) Summary, description, tags, etc. Message Headers Payload Id (application identifier) Tags External Docs Components Schemas Messages Security Schemes Parameters Correlation Ids Operation Traits Message Traits Server Bindings Channel Bindings Operation Bindings Message Bindings To enable more flexibility, the AsyncAPI 3.0.0 specification changes more and is less similar to OpenAPI starting with this version. The biggest change is in the channel structure, where operations are separated from it. It is like detaching operations from paths in OpenAPI. OpenAPI 3.0 Info Servers Security Paths Path Item Summary and description Operation GET, PUT, POST, etc. Request Responses Tags External Docs Components Definitions Responses Parameters Response Headers Security Definitions Callbacks Links AsyncAPI 3.0 Info Servers (hosts + security) Channels Channel Summary, description Messages Headers Payload Operations Operation action (send or receive) Channel reference Messages reference Id (application identifier) Tags External Docs Components Schemas Messages Security Schemes Parameters Correlation Ids Operation Traits Message Traits Server Bindings Channel Bindings Operation Bindings Message Bindings Aside from structural differences, you should know: AsyncAPI is compatible with OpenAPI schemas. The message payload in AsyncAPI can be any value, not just an AsyncAPI/OpenAPI schema. For instance, it could be an Avro schema. The AsyncAPI server object is almost identical to its OpenAPI counterpart, with the exception that scheme has been renamed to protocol and AsyncAPI introduces a new property called protocolVersion . AsyncAPI supports multiple protocols, not only HTTP, like in the case of OpenAPI. OpenAPI path parameters and AsyncAPI channel parameters are a bit different since AsyncAPI doesn't have the notion of \"query\" and \"cookie\", and header parameters can be defined in the message object . Therefore, AsyncAPI channel parameters are the equivalent of OpenAPI path parameters. Conclusion As you have seen above, OpenAPI and AsyncAPI are similar, but the specification's evolution will bring more differences in the future. In a real-world environment, systems don't have just REST APIs or events, but a mix of both. Most of the time, the information flowing in the events is very similar to the one the REST APIs have to handle in requests and responses; thus, being able to reuse schemas is a huge win. Let's learn how to create an AsyncAPI document that defines a \"Hello world\" application. Go Back Event-Driven Architectures Up Next Hello world Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "8a6b44d6",
    "title": "Event-Driven Architectures | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tutorials/getting-started/event-driven-architectures.html",
    "content": "Event-Driven Architectures | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Core concepts Message broker Publisher/Subscriber Message Channels Why \"event-driven\" and not \"message-driven\"? Conclusion Event-Driven Architectures Found an error? Have a suggestion? Edit this page on GitHub Many developers, architects, and product managers have used REST APIs and are familiar with the synchronous communication paradigm. You make a request and wait for the response. This is exactly how the world wide web works. You enter a URL (e.g., www.google.com ) in the browser's address bar and it sends a request to the server. The server then sends the response with the website content. The web is the greatest implementation of a REST API. However, there are certain situations where you don't need a response from the server. In most cases, it's only important to have some confirmation that the request was received. This is also called \"fire and forget\" , and it's very useful when you just want to communicate or inform that \"something happened.\" You're not requesting or asking for anything, thus you don't need a response. Some examples of this can be: A user just signed up. You have a new follower. Your fridge is almost empty. Along with the event, you may also want to send extra information . For instance: A user just signed up: here's the user information (e.g., name, email, age, etc.) You have a new follower: here are the follower details (e.g., username, name, picture, etc.) Your fridge is almost empty: here's the percentage of \"emptiness\" or available volume (e.g. 23%) This extra information is often referred to as the event payload or message payload . An Event-Driven Architecture (EDA) uses events to trigger and communicate between services and is common in modern applications built with microservices. An event is a state change, or an update, like adding a shopping item to a cart on an e-commerce website. Core concepts \n![](/img/diagrams/simple-event-driven.png)\n In most cases, EDAs are broker-centric, as seen in the diagram above. There are some new concepts in that diagram, so let's go through them now. Message broker A message broker (or \"broker\" ) is a piece of infrastructure in charge of receiving messages and delivering them to those who have shown interest. They often store messages until they are delivered, which makes EDAs very resilient to failures. Examples of brokers are RabbitMQ , Apache Kafka , Solace , etc. Publisher/Subscriber A publisher (a.k.a. producer ) is an application that sends messages to the broker . A subscriber (a.k.a. consumer ) is an application that connects to the broker , manifests an interest in a certain type of message, and leaves the connection open so the broker can push messages to them. Message A message is a piece of information that is sent by publishers to the broker, and received by all interested subscribers. Messages can contain anything and are frequently cataloged as events and commands . As you saw above, events communicate a fact that occurred. On the other hand, commands are very similar to requests in REST APIs. They instruct the subscribers to \"do this.\" To be precise, events and commands share the same structure but differ conceptually. Channels One detail that might pass unnoticed from the diagram above is the existence of channels . All brokers support communication through multiple channels. The industry doesn't have a common term for them, so you may see them referred to as topics , routing keys , event types , etc. A channel is usually assigned a name or identifier (e.g., user_signed_up ) and it is often good practice to send a single type of message through a particular channel. Think about TV or radio channels; the BBC only broadcasts its information through an assigned channel. If the broadcasters (publishers) didn't respect that rule, you (the subscriber) would only see and hear interference. Why \"event-driven\" and not \"message-driven\"? You will find both used interchangeably, although they are not the same. You will even find \"message-based\" and \"event-based\" . In practice, chances are they all refer to the same thing. Theoretically, \"message-driven\" is the most generic term -meaning you may use events and commands- while event-driven means that it's purely about events. However, that's not always the case, as Martin Fowler explains in his talk \"the many meanings of Event-Driven Architecture\" . Conclusion We've seen what an Event-Driven Architecture is, how it works, and explained its components. AsyncAPI defines and documents each of these components. We'll cover each of the components during the rest of this guide. To continue, choose your next step: Go Back Introduction Up Next Coming from OpenAPI Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/diagrams/simple-event-driven.png",
        "alt": ""
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "dd5479c0",
    "title": "Hello world | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tutorials/getting-started/hello-world.html",
    "content": "Hello world | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets Hello world Found an error? Have a suggestion? Edit this page on GitHub Let's define an application that's capable of receiving a \"hello {name}\" message: \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: Hello world application\n4  version: '0.1.0'\n5channels:\n6  hello:\n7    address: 'hello'\n8    messages:\n9      sayHelloMessage:\n10        payload:\n11          type: string\n12          pattern: '^hello .+$'\n13operations:\n14  receiveHello:\n15    action: 'receive'\n16    channel:\n17      $ref: '#/channels/hello'\n```\n Let's get into the details of this sample AsyncAPI document: \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: Hello world application\n4  version: '0.1.0'\n5channels:\n6  hello:\n7    address: 'hello'\n8    messages:\n9      sayHelloMessage:\n10        payload:\n11          type: string\n12          pattern: '^hello .+$'\n13operations:\n14  receiveHello:\n15    action: 'receive'\n16    channel:\n17      $ref: '#/channels/hello'\n```\n The first line of the specification starts with the document type asyncapi and the version (3.0.0). That line doesn't have to be the first one, but it's a best practice. \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: Hello world application\n4  version: '0.1.0'\n5channels:\n6  hello:\n7    address: 'hello'\n8    messages:\n9      sayHelloMessage:\n10        payload:\n11          type: string\n12          pattern: '^hello .+$'\n13operations:\n14  receiveHello:\n15    action: 'receive'\n16    channel:\n17      $ref: '#/channels/hello'\n```\n The info object contains the minimum required information about the application. It contains the title , which is a memorable name for the API, and the version . While it's not mandatory, it's strongly recommended to change the version whenever you make changes to the API. \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: Hello world application\n4  version: '0.1.0'\n5channels:\n6  hello:\n7    address: 'hello'\n8    messages:\n9      sayHelloMessage:\n10        payload:\n11          type: string\n12          pattern: '^hello .+$'\n13operations:\n14  receiveHello:\n15    action: 'receive'\n16    channel:\n17      $ref: '#/channels/hello'\n```\n The channels section of the specification houses all of the mediums where messages flow through. For example, some systems use topic , event name or routing key . Different kinds of information flow through each channel similar to the analogy of TV channels. You only have one channel called hello , and you see what message is available in this channel and how it must be structured. The payload object defines that the message must be a string and match the given regular expression in a string format such as hello {name} . \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: Hello world application\n4  version: '0.1.0'\n5channels:\n6  hello:\n7    address: 'hello'\n8    messages:\n9      sayHelloMessage:\n10        payload:\n11          type: string\n12          pattern: '^hello .+$'\n13operations:\n14  receiveHello:\n15    action: 'receive'\n16    channel:\n17      $ref: '#/channels/hello'\n```\n The operations section is where you describe what the application is doing. Each operation has a unique identifier for example, receiveHello . In the above example, you see that the Hello world application is a consumer listening to the sayHelloMessage message from the hello channel. In other words, you can say that the Hello world application subscribes to the hello topic to receive the sayHelloMessage message. That AsyncAPI document describes what the Hello world application is doing, not what others can do with it. Go Back Coming from OpenAPI Up Next Request/reply pattern Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1asyncapi: 3.0.0\n2info:\n3  title: Hello world application\n4  version: '0.1.0'\n5channels:\n6  hello:\n7    address: 'hello'\n8    messages:\n9      sayHelloMessage:\n10        payload:\n11          type: string\n12          pattern: '^hello .+$'\n13operations:\n14  receiveHello:\n15    action: 'receive'\n16    channel:\n17      $ref: '#/channels/hello'",
      "1asyncapi: 3.0.0\n2info:\n3  title: Hello world application\n4  version: '0.1.0'\n5channels:\n6  hello:\n7    address: 'hello'\n8    messages:\n9      sayHelloMessage:\n10        payload:\n11          type: string\n12          pattern: '^hello .+$'\n13operations:\n14  receiveHello:\n15    action: 'receive'\n16    channel:\n17      $ref: '#/channels/hello'",
      "1asyncapi: 3.0.0\n2info:\n3  title: Hello world application\n4  version: '0.1.0'\n5channels:\n6  hello:\n7    address: 'hello'\n8    messages:\n9      sayHelloMessage:\n10        payload:\n11          type: string\n12          pattern: '^hello .+$'\n13operations:\n14  receiveHello:\n15    action: 'receive'\n16    channel:\n17      $ref: '#/channels/hello'",
      "1asyncapi: 3.0.0\n2info:\n3  title: Hello world application\n4  version: '0.1.0'\n5channels:\n6  hello:\n7    address: 'hello'\n8    messages:\n9      sayHelloMessage:\n10        payload:\n11          type: string\n12          pattern: '^hello .+$'\n13operations:\n14  receiveHello:\n15    action: 'receive'\n16    channel:\n17      $ref: '#/channels/hello'",
      "1asyncapi: 3.0.0\n2info:\n3  title: Hello world application\n4  version: '0.1.0'\n5channels:\n6  hello:\n7    address: 'hello'\n8    messages:\n9      sayHelloMessage:\n10        payload:\n11          type: string\n12          pattern: '^hello .+$'\n13operations:\n14  receiveHello:\n15    action: 'receive'\n16    channel:\n17      $ref: '#/channels/hello'"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "e9193203",
    "title": "Request/reply pattern | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tutorials/getting-started/request-reply.html",
    "content": "Request/reply pattern | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Static reply address Dynamic reply address Request/reply pattern Found an error? Have a suggestion? Edit this page on GitHub In this tutorial, you'll learn how to implement the request/reply pattern in an AsyncAPI document using a straightforward ping-pong example. Before we begin, it would be beneficial for you to have a basic understanding of AsyncAPI and Event-Driven Architectures (EDA). If you need a refresher, refer to our Event-Driven Architecture document. Request/reply is a messaging pattern involving two key components: the requester , which sends a request message, and the replier , responsible for receiving this request and responding with a reply. This pattern fundamentally revolves around these two roles, requester and replier. Static reply address Here's how you can implement the request/reply pattern when the response address is known at the compile or design time. A requester can be configured with the send operation, where it dispatches a message to the ping channel and anticipates receiving a response through the pong channel. In the below example, the Operation Reply object within the pingRequest operation provides essential details, like the destination for the reply, which is the pong channel. Since the pong channel is configured with only one message, there's no need to explicitly define the reply message. Similarly, the ping channel has just one message, eliminating the need to specify the message sent in the request. \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: Ping/pong example with static reply channel\n4  version: 1.0.0\n5  description: Requester example that initiates the request/reply pattern on a different channel than the reply is using\n6channels:\n7  ping:\n8    address: /ping\n9    messages:\n10      ping:\n11        $ref: '#/components/messages/ping'\n12  pong:\n13    address: /pong\n14    messages:\n15      pong:\n16        $ref: '#/components/messages/pong'\n17operations:\n18  pingRequest:\n19    action: send\n20    channel: \n21      $ref: '#/channels/ping'\n22    reply:\n23      channel: \n24        $ref: '#/channels/pong'\n25components: \n26  messages: \n27    ping:\n28      payload:\n29        type: object\n30        properties:\n31          event:\n32            type: string\n33            const: ping\n34    pong:\n35      payload:\n36        type: object\n37        properties:\n38          event:\n39            type: string\n40            const: pong\n```\n Dynamic reply address Occasionally, the destination for a reply cannot be predetermined during the design or compile phase. In such cases, the address for the reply is dynamically determined at runtime, allowing for more flexible and adaptive communication. In scenarios where the address or reply channel is unknown at design time, the address property can either be set to null or omitted entirely. To define the reply address dynamically, the Operation Reply Address object can be used, allowing for runtime expressions. That enables the requester to specify where the replier should send the reply, detailing the address's location and its specific position within the request. In this situation, the location property is assigned the runtime expression $message.header#/replyTo . Such an expression indicates that the address for the reply is located within the header of the request, specifically in the replyTo field. This method dynamically determines the reply address based on the content of the request header. \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: Ping/pong example with reply specified as dynamic information provided in the runtime\n4  version: 1.0.0\n5  description: Example document for an application that processes ping requests and replies to the address dynamically specified by the requestor in the message header\n6channels:\n7  ping:\n8    address: /ping\n9    messages:\n10      ping:\n11        $ref: '#/components/messages/ping'\n12  pong:\n13    address: null\n14    messages:\n15      pong:\n16        $ref: '#/components/messages/pong'\n17operations:\n18  pingRequest:\n19    action: receive\n20    channel: \n21      $ref: '#/channels/ping'\n22    reply:\n23      address:\n24        description: Reply is sent to topic specified in 'replyTo' property in the message header\n25        location: \"$message.header#/replyTo\"\n26      channel: \n27        $ref: '#/channels/pong'\n28components:\n29  messages:\n30    ping:\n31      headers:\n32        type: object\n33        properties:\n34          replyTo:\n35            type: string\n36            description: Provide path to which reply must be provided\n37          requestId:\n38            type: string\n39            format: uuid\n40            description: Provide request id that you will use to identify the reply match\n41      payload:\n42        type: object\n43        properties:\n44          event:\n45            type: string\n46            const: ping\n47      correlationId:\n48        $ref: \"#/components/correlationIds/pingCorrelationId\"\n49    pong:\n50      headers:\n51        type: object\n52        properties:\n53          requestId:\n54            type: string\n55            format: uuid\n56            description: Reply message must contain id of the request message\n57      payload:\n58        type: object\n59        properties:\n60          event:\n61            type: string\n62            const: pong\n63      correlationId:\n64        $ref: \"#/components/correlationIds/pingCorrelationId\"\n65  correlationIds:\n66    pingCorrelationId:\n67      location: '$message.header#/requestId'\n```\n While the above examples are a simple implementation of the request/reply pattern, in a protocol-agnostic world there are many different ways to represent the request/reply pattern. All of which are supported by AsyncAPI. Go Back Hello world Up Next AsyncAPI documents Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1asyncapi: 3.0.0\n2info:\n3  title: Ping/pong example with static reply channel\n4  version: 1.0.0\n5  description: Requester example that initiates the request/reply pattern on a different channel than the reply is using\n6channels:\n7  ping:\n8    address: /ping\n9    messages:\n10      ping:\n11        $ref: '#/components/messages/ping'\n12  pong:\n13    address: /pong\n14    messages:\n15      pong:\n16        $ref: '#/components/messages/pong'\n17operations:\n18  pingRequest:\n19    action: send\n20    channel: \n21      $ref: '#/channels/ping'\n22    reply:\n23      channel: \n24        $ref: '#/channels/pong'\n25components: \n26  messages: \n27    ping:\n28      payload:\n29        type: object\n30        properties:\n31          event:\n32            type: string\n33            const: ping\n34    pong:\n35      payload:\n36        type: object\n37        properties:\n38          event:\n39            type: string\n40            const: pong",
      "1asyncapi: 3.0.0\n2info:\n3  title: Ping/pong example with reply specified as dynamic information provided in the runtime\n4  version: 1.0.0\n5  description: Example document for an application that processes ping requests and replies to the address dynamically specified by the requestor in the message header\n6channels:\n7  ping:\n8    address: /ping\n9    messages:\n10      ping:\n11        $ref: '#/components/messages/ping'\n12  pong:\n13    address: null\n14    messages:\n15      pong:\n16        $ref: '#/components/messages/pong'\n17operations:\n18  pingRequest:\n19    action: receive\n20    channel: \n21      $ref: '#/channels/ping'\n22    reply:\n23      address:\n24        description: Reply is sent to topic specified in 'replyTo' property in the message header\n25        location: \"$message.header#/replyTo\"\n26      channel: \n27        $ref: '#/channels/pong'\n28components:\n29  messages:\n30    ping:\n31      headers:\n32        type: object\n33        properties:\n34          replyTo:\n35            type: string\n36            description: Provide path to which reply must be provided\n37          requestId:\n38            type: string\n39            format: uuid\n40            description: Provide request id that you will use to identify the reply match\n41      payload:\n42        type: object\n43        properties:\n44          event:\n45            type: string\n46            const: ping\n47      correlationId:\n48        $ref: \"#/components/correlationIds/pingCorrelationId\"\n49    pong:\n50      headers:\n51        type: object\n52        properties:\n53          requestId:\n54            type: string\n55            format: uuid\n56            description: Reply message must contain id of the request message\n57      payload:\n58        type: object\n59        properties:\n60          event:\n61            type: string\n62            const: pong\n63      correlationId:\n64        $ref: \"#/components/correlationIds/pingCorrelationId\"\n65  correlationIds:\n66    pingCorrelationId:\n67      location: '$message.header#/requestId'"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "3f39a081",
    "title": "Adding security | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tutorials/getting-started/security.html",
    "content": "Adding security | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Conclusion Adding security Found an error? Have a suggestion? Edit this page on GitHub In production environments, your API may have to access a message broker that's protected by some auth mechanisms. Auth mechanism examples: User & password Certificates API keys OAuth 2 If you're using AsyncAPI to define an API that connects to a message broker, you'll probably use user/password or certificates. Traditionally, message brokers are infrastructure pieces that serve an internal purpose, and they're not exposed to the public. That's why their security mechanisms are also simpler than what we're used to with REST APIs. However, AsyncAPI also helps you define your HTTP streaming APIs, and therefore, it supports more sophisticated mechanisms like OAuth2 or OpenID. Continuing with the hello world application example, let's learn how to define a simple security scheme (mechanism) for it. \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: Hello world application\n4  version: '0.1.0'\n5servers:\n6  production:\n7    host: broker.mycompany.com\n8    protocol: amqp\n9    description: This is \"My Company\" broker.\n10    security:\n11      - type: userPassword\n12channels:\n13  hello:\n14    address: 'hello'\n15    messages:\n16      sayHelloMessage:\n17        $ref: '#/components/messages/hello-msg'\n18  goodbye:\n19    address: 'goodbye'\n20    messages:\n21      sayGoodbyeMessage:\n22        $ref: '#/components/messages/goodbye-msg'\n23operations:\n24  receiveHello:\n25    action: 'receive'\n26    channel:\n27      $ref: '#/channels/hello'\n28  receiveGoodbye:\n29    action: 'receive'\n30    channel:\n31      $ref: '#/channels/goodbye'\n32components:\n33  messages:\n34    hello-msg:\n35      payload:\n36        type: object\n37        properties:\n38          name:\n39            type: string\n40          sentAt:\n41            $ref: '#/components/schemas/sent-at'\n42    goodbye-msg:\n43      payload:\n44        type: object\n45        properties:\n46          sentAt:\n47            $ref: '#/components/schemas/sent-at'\n48  schemas:\n49    sent-at:\n50      type: string\n51      description: The date and time a message was sent.\n52      format: datetime\n```\n The example above shows how to specify that your server (a Kafka broker) requires a user and a password to establish a connection. Let's break this down. There's a property in the server object called security . It's an array and can contain multiple security mechanisms. You chose to specify only one mechanism which is userPassword . A best practice is to put security details inside the components.securitySchemes section as it enables reusability across multiple servers. Below, you can see the same example, but this time, under server security, you see that $ref links to more security details located under the user-password object in securitySchemes . \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: Hello world application\n4  version: '0.1.0'\n5servers:\n6  production:\n7    host: broker.mycompany.com\n8    protocol: amqp\n9    description: This is \"My Company\" broker.\n10    security:\n11      - $ref: \"#/components/securitySchemes/user-password\"\n12channels:\n13  hello:\n14    address: 'hello'\n15    messages:\n16      sayHelloMessage:\n17        $ref: '#/components/messages/hello-msg'\n18  goodbye:\n19    address: 'goodbye'\n20    messages:\n21      sayGoodbyeMessage:\n22        $ref: '#/components/messages/goodbye-msg'\n23operations:\n24  receiveHello:\n25    action: 'receive'\n26    channel:\n27      $ref: '#/channels/hello'\n28  receiveGoodbye:\n29    action: 'receive'\n30    channel:\n31      $ref: '#/channels/goodbye'\n32components:\n33  messages:\n34    hello-msg:\n35      payload:\n36        type: object\n37        properties:\n38          name:\n39            type: string\n40          sentAt:\n41            $ref: '#/components/schemas/sent-at'\n42    goodbye-msg:\n43      payload:\n44        type: object\n45        properties:\n46          sentAt:\n47            $ref: '#/components/schemas/sent-at'\n48  schemas:\n49    sent-at:\n50      type: string\n51      description: The date and time a message was sent.\n52      format: datetime\n53  securitySchemes:\n54    user-password:\n55      type: userPassword\n```\n Hint Learn more about the several kinds of security schemes . Conclusion You can now define what security mechanisms your application needs to connect to the server. You've also seen how to require a user and a password, which is the most common use case. At this point, you know AsyncAPI well enough to create a simple Hello world application . However, real use cases are more complicated than that. The following tutorials can teach you how to create real-world use cases from zero to production. Go Back Servers Up Next Create AsyncAPI document Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1asyncapi: 3.0.0\n2info:\n3  title: Hello world application\n4  version: '0.1.0'\n5servers:\n6  production:\n7    host: broker.mycompany.com\n8    protocol: amqp\n9    description: This is \"My Company\" broker.\n10    security:\n11      - type: userPassword\n12channels:\n13  hello:\n14    address: 'hello'\n15    messages:\n16      sayHelloMessage:\n17        $ref: '#/components/messages/hello-msg'\n18  goodbye:\n19    address: 'goodbye'\n20    messages:\n21      sayGoodbyeMessage:\n22        $ref: '#/components/messages/goodbye-msg'\n23operations:\n24  receiveHello:\n25    action: 'receive'\n26    channel:\n27      $ref: '#/channels/hello'\n28  receiveGoodbye:\n29    action: 'receive'\n30    channel:\n31      $ref: '#/channels/goodbye'\n32components:\n33  messages:\n34    hello-msg:\n35      payload:\n36        type: object\n37        properties:\n38          name:\n39            type: string\n40          sentAt:\n41            $ref: '#/components/schemas/sent-at'\n42    goodbye-msg:\n43      payload:\n44        type: object\n45        properties:\n46          sentAt:\n47            $ref: '#/components/schemas/sent-at'\n48  schemas:\n49    sent-at:\n50      type: string\n51      description: The date and time a message was sent.\n52      format: datetime",
      "1asyncapi: 3.0.0\n2info:\n3  title: Hello world application\n4  version: '0.1.0'\n5servers:\n6  production:\n7    host: broker.mycompany.com\n8    protocol: amqp\n9    description: This is \"My Company\" broker.\n10    security:\n11      - $ref: \"#/components/securitySchemes/user-password\"\n12channels:\n13  hello:\n14    address: 'hello'\n15    messages:\n16      sayHelloMessage:\n17        $ref: '#/components/messages/hello-msg'\n18  goodbye:\n19    address: 'goodbye'\n20    messages:\n21      sayGoodbyeMessage:\n22        $ref: '#/components/messages/goodbye-msg'\n23operations:\n24  receiveHello:\n25    action: 'receive'\n26    channel:\n27      $ref: '#/channels/hello'\n28  receiveGoodbye:\n29    action: 'receive'\n30    channel:\n31      $ref: '#/channels/goodbye'\n32components:\n33  messages:\n34    hello-msg:\n35      payload:\n36        type: object\n37        properties:\n38          name:\n39            type: string\n40          sentAt:\n41            $ref: '#/components/schemas/sent-at'\n42    goodbye-msg:\n43      payload:\n44        type: object\n45        properties:\n46          sentAt:\n47            $ref: '#/components/schemas/sent-at'\n48  schemas:\n49    sent-at:\n50      type: string\n51      description: The date and time a message was sent.\n52      format: datetime\n53  securitySchemes:\n54    user-password:\n55      type: userPassword"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "1b50e13c",
    "title": "Servers | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tutorials/getting-started/servers.html",
    "content": "Servers | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Conclusion Servers Found an error? Have a suggestion? Edit this page on GitHub In the previous lesson, you learned how to create the definition of a simple Hello World application . Let's take it from there. In this tutorial, you'll learn how to add servers to your AsyncAPI document. Adding and defining servers is useful because it specifies where and how to connect. The connection facilitates where to send and receive messages. \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: Hello world application\n4  version: '0.1.0'\n5servers:\n6  production:\n7    host: broker.mycompany.com\n8    protocol: amqp\n9    description: This is \"My Company\" broker.\n10channels:\n11  hello:\n12    address: 'hello'\n13    messages:\n14      sayHelloMessage:\n15        payload:\n16          type: string\n17          pattern: '^hello .+$'\n18operations:\n19  receiveHello:\n20    action: 'receive'\n21    channel:\n22      $ref: '#/channels/hello'\n```\n You've now added a new section called servers in your AsyncAPI document. You might have noticed that our example mentions amqp , a very common protocol that was popularized by RabbitMQ (among others). While our example uses amqp , you can use any protocol. The most common protocols used are mqtt (widely adopted by the Internet of Things and mobile apps), kafka (popular for its streaming solution), ws (WebSockets are frequently used in browsers), and http (used in HTTP streaming APIs). Remember The servers section defines where your application should connect to start sending and receiving messages. If you are using a broker-centric architecture such as Kafka or RabbitMQ, specify the broker URL. If you have the classic client-server model such as for REST APIs, then your server should be the URL of the server. Conclusion Now you know where the Hello world application connects to, and you can start receiving hello {name} messages. In the next section, you'll learn how to add security requirements to your server. Go Back AsyncAPI documents Up Next Adding security Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1asyncapi: 3.0.0\n2info:\n3  title: Hello world application\n4  version: '0.1.0'\n5servers:\n6  production:\n7    host: broker.mycompany.com\n8    protocol: amqp\n9    description: This is \"My Company\" broker.\n10channels:\n11  hello:\n12    address: 'hello'\n13    messages:\n14      sayHelloMessage:\n15        payload:\n16          type: string\n17          pattern: '^hello .+$'\n18operations:\n19  receiveHello:\n20    action: 'receive'\n21    channel:\n22      $ref: '#/channels/hello'"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "61a4e4b1",
    "title": "Event-Driven Architectures | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tutorials/getting-started/event-driven-architectures/index.html",
    "content": "Event-Driven Architectures | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Core concepts Message broker Publisher/Subscriber Message Channels Why \"event-driven\" and not \"message-driven\"? Conclusion Event-Driven Architectures Found an error? Have a suggestion? Edit this page on GitHub Many developers, architects, and product managers have used REST APIs and are familiar with the synchronous communication paradigm. You make a request and wait for the response. This is exactly how the world wide web works. You enter a URL (e.g., www.google.com ) in the browser's address bar and it sends a request to the server. The server then sends the response with the website content. The web is the greatest implementation of a REST API. However, there are certain situations where you don't need a response from the server. In most cases, it's only important to have some confirmation that the request was received. This is also called \"fire and forget\" , and it's very useful when you just want to communicate or inform that \"something happened.\" You're not requesting or asking for anything, thus you don't need a response. Some examples of this can be: A user just signed up. You have a new follower. Your fridge is almost empty. Along with the event, you may also want to send extra information . For instance: A user just signed up: here's the user information (e.g., name, email, age, etc.) You have a new follower: here are the follower details (e.g., username, name, picture, etc.) Your fridge is almost empty: here's the percentage of \"emptiness\" or available volume (e.g. 23%) This extra information is often referred to as the event payload or message payload . An Event-Driven Architecture (EDA) uses events to trigger and communicate between services and is common in modern applications built with microservices. An event is a state change, or an update, like adding a shopping item to a cart on an e-commerce website. Core concepts \n![](/img/diagrams/simple-event-driven.png)\n In most cases, EDAs are broker-centric, as seen in the diagram above. There are some new concepts in that diagram, so let's go through them now. Message broker A message broker (or \"broker\" ) is a piece of infrastructure in charge of receiving messages and delivering them to those who have shown interest. They often store messages until they are delivered, which makes EDAs very resilient to failures. Examples of brokers are RabbitMQ , Apache Kafka , Solace , etc. Publisher/Subscriber A publisher (a.k.a. producer ) is an application that sends messages to the broker . A subscriber (a.k.a. consumer ) is an application that connects to the broker , manifests an interest in a certain type of message, and leaves the connection open so the broker can push messages to them. Message A message is a piece of information that is sent by publishers to the broker, and received by all interested subscribers. Messages can contain anything and are frequently cataloged as events and commands . As you saw above, events communicate a fact that occurred. On the other hand, commands are very similar to requests in REST APIs. They instruct the subscribers to \"do this.\" To be precise, events and commands share the same structure but differ conceptually. Channels One detail that might pass unnoticed from the diagram above is the existence of channels . All brokers support communication through multiple channels. The industry doesn't have a common term for them, so you may see them referred to as topics , routing keys , event types , etc. A channel is usually assigned a name or identifier (e.g., user_signed_up ) and it is often good practice to send a single type of message through a particular channel. Think about TV or radio channels; the BBC only broadcasts its information through an assigned channel. If the broadcasters (publishers) didn't respect that rule, you (the subscriber) would only see and hear interference. Why \"event-driven\" and not \"message-driven\"? You will find both used interchangeably, although they are not the same. You will even find \"message-based\" and \"event-based\" . In practice, chances are they all refer to the same thing. Theoretically, \"message-driven\" is the most generic term -meaning you may use events and commands- while event-driven means that it's purely about events. However, that's not always the case, as Martin Fowler explains in his talk \"the many meanings of Event-Driven Architecture\" . Conclusion We've seen what an Event-Driven Architecture is, how it works, and explained its components. AsyncAPI defines and documents each of these components. We'll cover each of the components during the rest of this guide. To continue, choose your next step: Go Back Introduction Up Next Coming from OpenAPI Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "/img/diagrams/simple-event-driven.png",
        "alt": ""
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "fae96b8b",
    "title": "Kafka bindings | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tutorials/kafka/bindings-with-kafka.html",
    "content": "Kafka bindings | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Introduction Background context Add server bindings Add operation bindings Add channel bindings Add message bindings Summary Next steps Kafka bindings Found an error? Have a suggestion? Edit this page on GitHub Introduction You learned how to manage schemas with a schema registry in the previous tutorial . This tutorial teaches you how Kafka bindings function by defining Kafka messages and expanding your AsyncAPI document with protocol-specific details. Background context Bindings are essential for event-driven applications because they provide protocol-specific details, abstracting the complexities of message handling from your application's core logic. They enhance the API's clarity and usability by offering setup options and context for different protocols. Bindings include the topics your application reads from or writes to, message formatting, and rules for interacting with multiple data or messages. In an AsyncAPI document, bindings can be added to various sections like servers, channels, or messages. They contain protocol-specific details unique to each protocol. Binding definitions let you specify functionalities specific to the protocol, which are not covered by AsyncAPI's core features. You can configure several objects using Kafka bindings . However, for the scope of this tutorial, you will focus on four levels of bindings: server bindings, operations binding, channel bindings, and message bindings. Using the code snippets from the previous tutorial, where you learned how to manage Avro schemas using a centralized schema registry that enables you to share schemas across multiple applications , you will add configurations for server, operations, channel, and message bindings. Below, you can find the updated schema reference file you'll use for this tutorial. \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: User Signup API\n4  version: 1.0.0\n5  description: The API notifies you whenever a new user signs up in the application.\n6servers:\n7  kafkaServer:\n8    host: test.mykafkacluster.org:8092\n9    description: Kafka Server\n10    protocol: kafka\n11operations:\n12  onUserSignedUp:\n13    action: receive\n14    channel:\n15      $ref: '#/channels/userSignedUp'\n16channels:\n17  userSignedUp:\n18    description: This channel contains a message per each user who signs up in our application.\n19    address: user_signedup\n20    messages:\n21      userSignedUp:\n22        $ref: '#/components/messages/userSignedUp'\n23components:\n24  messages:\n25    userSignedUp:\n26      payload:\n27        schemaFormat: 'application/vnd.apache.avro+json;version=1.9.0'\n28        schema:\n29          $ref: http://localhost:8080/apis/registry/v2/groups/my-group/artifacts/UserSignedUp\n```\n Add server bindings Server bindings provide protocol-specific configuration details for connecting and interacting with a server. Server bindings allow you to specify a schemaRegistryUrl , which provides an API URL for a given server where a schema registry was used. A schema registry is a repository for managing and validating messages' schemas. To learn more about schema registry, read the message validation guide for schema registry . schemaRegistryVendor is used optionally to refer to vendors or platforms that provide the schema registry service, in this case, Apicurio Registry. Learn about other fields you can configure under server bindings . \n```javascript\n1servers:\n2  kafkaServer:\n3    host: test.mykafkacluster.org:8092\n4    description: Kafka Server\n5    protocol: kafka\n6    bindings:\n7      kafka:\n8        schemaRegistryUrl: 'http://localhost:8080/apis/registry/'\n9        schemaRegistryVendor: 'apicurio'\n10        bindingVersion: '0.5.0'\n```\n Important: bindingVersion is the field version of a binding. It specifies the version of the binding specification that is used to describe how an API interacts with Kafka. The bindingVersion field is an optional field that is available for all bindings. Add operation bindings Operation bindings object contains information about the operation representation in Kafka (eg. the way to consume messages). The operation binding object provides a structured way to describe how a particular operation (publish, subscribe) should behave on a Kafka topic. The groupid , for example, is the Id of the consumer group, while the cliendID is the Id of the consumer within a consumer group. These configurations are vital for distributed message consumption and load balancing among consumers. Learn more about other fields you can configure under operations binding . \n```javascript\n1operations:\n2  onUserSignedUp:\n3    action: receive\n4    channel:\n5      $ref: '#/channels/userSignedUp'\n6    bindings:\n7      kafka:\n8        bindingVersion: '0.5.0'\n9        groupId:\n10          type: string\n11          enum: ['myGroupId']\n12        clientId:\n13          type: string\n14          enum: ['myClientId']\n```\n Add channel bindings Channel bindings provide protocol-specific information for a particular channel. These configurations may include information how the Kafka topic has been configured. The Channel Binding Object is part of AsyncAPI's wider bindings architecture, which specifies how the API interacts with the messaging system \u2014 in this case, Kafka. In Kafka, you can specify a given topic's number of partitions or replicas therefore, enabling parallel processing of data or consumers. Learn more about other fields that you can configure under channel bindings . \n```javascript\n1channels:\n2  userSignedUp:\n3    description: This channel contains a message per each user who signs up in our application.\n4    address: user_signedup\n5    messages:\n6      userSignedUp:\n7        $ref: '#/components/messages/userSignedUp'\n8    bindings:\n9      kafka:\n10        bindingVersion: '0.5.0'\n11        partitions: 10\n12        replicas: 2\n13        topicConfiguration:\n14          cleanup.policy: [\"delete\", \"compact\"]\n15          retention.ms: 604800000\n16          retention.bytes: 1000000000\n17          delete.retention.ms: 86400000\n18          max.message.bytes: 1048588\n```\n Add message bindings Message bindings provide protocol-specific information for a specific message. For Kafka topics, this can include how message keys are used, and details about how serialized message data has been encoded. For example, the schemaIdLocation field, if specified is used to indicate where the schema identifier (ID) for the message payload's schema is located. It is useful for message serialization and deserialization, enabling consumers to understand how to interpret the message payload. Learn more about other fields that you can configure under message bindings \n```javascript\n1components:\n2  messages:\n3    userSignedUp:\n4      bindings:\n5        kafka:\n6            key:\n7              type: string\n8              enum: ['myKey']\n9            schemaIdLocation: 'payload'\n10            schemaIdPayloadEncoding: 'apicurio-new'\n11            schemaLookupStrategy: 'TopicIdStrategy'\n12            bindingVersion: '0.5.0'\n13      payload:\n14        schemaFormat: 'application/vnd.apache.avro+json;version=1.9.0'\n15        schema:\n16          $ref: http://localhost:8080/apis/registry/v2/groups/my-group/artifacts/UserSignedUp\n```\n Congratulations, you've completed the tutorial! Putting these blocks together gives you an AsyncAPI document all ready to go. \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: User Signup API\n4  version: 1.0.0\n5  description: The API notifies you whenever a new user signs up in the application.\n6servers:\n7  kafkaServer:\n8    host: test.mykafkacluster.org:8092\n9    description: Kafka Server\n10    protocol: kafka\n11    bindings:\n12      kafka:\n13        schemaRegistryUrl: 'http://localhost:8080/apis/registry/'\n14        schemaRegistryVendor: 'apicurio'\n15        bindingVersion: '0.5.0'\n16operations:\n17  onUserSignedUp:\n18    action: receive\n19    channel:\n20      $ref: '#/channels/userSignedUp'\n21    bindings:\n22      kafka:\n23        bindingVersion: '0.5.0'\n24        groupId:\n25          type: string\n26          enum: ['myGroupId']\n27        clientId:\n28          type: string\n29          enum: ['myClientId']\n30channels:\n31  userSignedUp:\n32    description: This channel contains a message per each user who signs up in our application.\n33    address: user_signedup\n34    messages:\n35      userSignedUp:\n36        $ref: '#/components/messages/userSignedUp'\n37    bindings:\n38      kafka:\n39        bindingVersion: '0.5.0'\n40        partitions: 10\n41        replicas: 2\n42        topicConfiguration:\n43          cleanup.policy: [\"delete\", \"compact\"]\n44          retention.ms: 604800000\n45          retention.bytes: 1000000000\n46          delete.retention.ms: 86400000\n47          max.message.bytes: 1048588\n48components:\n49  messages:\n50    userSignedUp:\n51      bindings:\n52        kafka:\n53          bindingVersion: '0.5.0'\n54          key:\n55            type: string\n56            enum: ['myKey']\n57          schemaIdLocation: 'payload'\n58          schemaIdPayloadEncoding: 'apicurio-new'\n59          schemaLookupStrategy: 'TopicIdStrategy'\n60      payload:\n61        schemaFormat: 'application/vnd.apache.avro+json;version=1.9.0'\n62        schema:\n63          $ref: http://localhost:8080/apis/registry/v2/groups/my-group/artifacts/UserSignedUp\n```\n Summary In this tutorial, you learned how to configure server, operation, message, and channel bindings. You also learned that bindings are essential when integrating Kafka with different systems, platforms, or protocols \u2014 especially in API specifications like AsyncAPI. Next steps Now that you have completed this tutorial, you can learn more about other Kakfa bindings or protocol-specific bindings . Go Back Managing schemas using Schema Registry Up Next Tools - Overview Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1asyncapi: 3.0.0\n2info:\n3  title: User Signup API\n4  version: 1.0.0\n5  description: The API notifies you whenever a new user signs up in the application.\n6servers:\n7  kafkaServer:\n8    host: test.mykafkacluster.org:8092\n9    description: Kafka Server\n10    protocol: kafka\n11operations:\n12  onUserSignedUp:\n13    action: receive\n14    channel:\n15      $ref: '#/channels/userSignedUp'\n16channels:\n17  userSignedUp:\n18    description: This channel contains a message per each user who signs up in our application.\n19    address: user_signedup\n20    messages:\n21      userSignedUp:\n22        $ref: '#/components/messages/userSignedUp'\n23components:\n24  messages:\n25    userSignedUp:\n26      payload:\n27        schemaFormat: 'application/vnd.apache.avro+json;version=1.9.0'\n28        schema:\n29          $ref: http://localhost:8080/apis/registry/v2/groups/my-group/artifacts/UserSignedUp",
      "1servers:\n2  kafkaServer:\n3    host: test.mykafkacluster.org:8092\n4    description: Kafka Server\n5    protocol: kafka\n6    bindings:\n7      kafka:\n8        schemaRegistryUrl: 'http://localhost:8080/apis/registry/'\n9        schemaRegistryVendor: 'apicurio'\n10        bindingVersion: '0.5.0'",
      "1operations:\n2  onUserSignedUp:\n3    action: receive\n4    channel:\n5      $ref: '#/channels/userSignedUp'\n6    bindings:\n7      kafka:\n8        bindingVersion: '0.5.0'\n9        groupId:\n10          type: string\n11          enum: ['myGroupId']\n12        clientId:\n13          type: string\n14          enum: ['myClientId']",
      "1channels:\n2  userSignedUp:\n3    description: This channel contains a message per each user who signs up in our application.\n4    address: user_signedup\n5    messages:\n6      userSignedUp:\n7        $ref: '#/components/messages/userSignedUp'\n8    bindings:\n9      kafka:\n10        bindingVersion: '0.5.0'\n11        partitions: 10\n12        replicas: 2\n13        topicConfiguration:\n14          cleanup.policy: [\"delete\", \"compact\"]\n15          retention.ms: 604800000\n16          retention.bytes: 1000000000\n17          delete.retention.ms: 86400000\n18          max.message.bytes: 1048588",
      "1components:\n2  messages:\n3    userSignedUp:\n4      bindings:\n5        kafka:\n6            key:\n7              type: string\n8              enum: ['myKey']\n9            schemaIdLocation: 'payload'\n10            schemaIdPayloadEncoding: 'apicurio-new'\n11            schemaLookupStrategy: 'TopicIdStrategy'\n12            bindingVersion: '0.5.0'\n13      payload:\n14        schemaFormat: 'application/vnd.apache.avro+json;version=1.9.0'\n15        schema:\n16          $ref: http://localhost:8080/apis/registry/v2/groups/my-group/artifacts/UserSignedUp",
      "1asyncapi: 3.0.0\n2info:\n3  title: User Signup API\n4  version: 1.0.0\n5  description: The API notifies you whenever a new user signs up in the application.\n6servers:\n7  kafkaServer:\n8    host: test.mykafkacluster.org:8092\n9    description: Kafka Server\n10    protocol: kafka\n11    bindings:\n12      kafka:\n13        schemaRegistryUrl: 'http://localhost:8080/apis/registry/'\n14        schemaRegistryVendor: 'apicurio'\n15        bindingVersion: '0.5.0'\n16operations:\n17  onUserSignedUp:\n18    action: receive\n19    channel:\n20      $ref: '#/channels/userSignedUp'\n21    bindings:\n22      kafka:\n23        bindingVersion: '0.5.0'\n24        groupId:\n25          type: string\n26          enum: ['myGroupId']\n27        clientId:\n28          type: string\n29          enum: ['myClientId']\n30channels:\n31  userSignedUp:\n32    description: This channel contains a message per each user who signs up in our application.\n33    address: user_signedup\n34    messages:\n35      userSignedUp:\n36        $ref: '#/components/messages/userSignedUp'\n37    bindings:\n38      kafka:\n39        bindingVersion: '0.5.0'\n40        partitions: 10\n41        replicas: 2\n42        topicConfiguration:\n43          cleanup.policy: [\"delete\", \"compact\"]\n44          retention.ms: 604800000\n45          retention.bytes: 1000000000\n46          delete.retention.ms: 86400000\n47          max.message.bytes: 1048588\n48components:\n49  messages:\n50    userSignedUp:\n51      bindings:\n52        kafka:\n53          bindingVersion: '0.5.0'\n54          key:\n55            type: string\n56            enum: ['myKey']\n57          schemaIdLocation: 'payload'\n58          schemaIdPayloadEncoding: 'apicurio-new'\n59          schemaLookupStrategy: 'TopicIdStrategy'\n60      payload:\n61        schemaFormat: 'application/vnd.apache.avro+json;version=1.9.0'\n62        schema:\n63          $ref: http://localhost:8080/apis/registry/v2/groups/my-group/artifacts/UserSignedUp"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "c04acfb7",
    "title": "Describe Kafka message payload using Avro Schema | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tutorials/kafka/configure-kafka-avro.html",
    "content": "Describe Kafka message payload using Avro Schema | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Introduction Background context Define message payload with Avro Schema directly in AsyncAPI document Reusing existing Avro Schemas Summary Next Steps Describe Kafka message payload using Avro Schema Found an error? Have a suggestion? Edit this page on GitHub Introduction The previous tutorial on creating an AsyncAPI document for applications consuming from Kafka taught you about writing an AsyncAPI document for Kafka messages using the default schema. This tutorial will teach you to write the same document using Avro Schema. While AsyncAPI schema can be the default choice for describing payloads, many prefer using Avro Schemas to define messages in Kafka. This tutorial teaches you to modify your existing AsyncAPI schema to add Avro schema into your document in both YAML and JSON formats. Background context AsyncAPI is a specification for describing Event-Driven Architectures (EDAs) in a machine-readable format. AsyncAPI schema outlines the format and content specifications that enable a consistent representation of agreements for communication between services in an Event-Driven Architecture. Avro is a sophisticated tool in Apache Kafka that handles data communication efficiently. It provides a standardized method for organizing and transmitting data, ensuring that different parts of the system can understand each other effectively. With Avro, there's a common language for messages, promoting compatibility and smooth operation between various components. It's like having a shared rulebook that helps different system parts communicate and exchange information seamlessly. Define message payload with Avro Schema directly in AsyncAPI document Defining message schema with the default schema is already covered in the previous Kafka tutorial . The default choice was the AsyncAPI schema, a JSON Schema superset. Here's an example of what the AsyncAPI schema looks like: \n```javascript\n1messages:\n2  userSignedUp:\n3    payload:\n4      type: object\n5      properties:\n6        userId:\n7          type: integer\n8          description: This property describes the ID of the user\n9        userEmail:\n10          type: string\n11          description: This property describes the email of the user\n```\n Now it's time to shift your focus to defining messages using Avro Schemas directly within your document. \n```javascript\n1messages:\n2  userSignedUp:\n3    payload:\n4      schemaFormat: 'application/vnd.apache.avro;version=1.9.0'\n5      schema:\n6        type: record\n7        name: UserSignedUp\n8        namespace: com.company\n9        doc: User sign-up information\n10        fields:\n11          - name: userId\n12            type: int\n13          - name: userEmail\n14            type: string\n```\n In the above code snippet: The userSignedUp message is defined with Avro Schema, using the specified schemaFormat and the schema . Use the schemaFormat to indicate that you're using Avro and specify the version of Avro Schema by using a MIME type. The schema includes a record named UserSignedUp within the com.company namespace. It also describes two fields, userId and userEmail, defining their data types as int and string , respectively. Now let's combine the above Avro Schema with the AsyncAPI document that you created in the previous tutorial. Check out below what an AsyncAPI document fully equipped with Avro Schema looks like! \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: User Signup API\n4  version: 1.0.0\n5  description: The API notifies you whenever a new user signs up in the application.\n6servers:\n7  kafkaServer:\n8    host: test.mykafkacluster.org:8092\n9    description: Kafka Server\n10    protocol: kafka\n11operations:\n12  onUserSignedUp:\n13    action: receive\n14    channel:\n15      $ref: '#/channels/userSignedUp'\n16channels:\n17  userSignedUp:\n18    description: This channel contains a message per each user who signs up in our application.\n19    address: user_signedup\n20    messages:\n21      userSignedUp:\n22        $ref: '#/components/messages/userSignedUp'\n23components:\n24  messages:\n25    userSignedUp:\n26      payload:\n27        schemaFormat: 'application/vnd.apache.avro;version=1.9.0'\n28        schema:\n29          type: record\n30          name: UserSignedUp\n31          namespace: com.company\n32          doc: User sign-up information\n33          fields:\n34            - name: userId\n35              type: int\n36            - name: userEmail\n37              type: string\n```\n Reusing existing Avro Schemas Occasionally, you might find yourself with an existing set of Avro Schemas. In such cases, instead of repeatedly defining these schemas in your AsyncAPI document, integrate them seamlessly by calling out existing files. Assume you have a file named userSchema.json that encapsulates the Avro Schema that resembles the following: \n```javascript\n1// userSchema.json\n2{\n3  \"type\": \"record\",\n4  \"name\": \"UserSignedUp\",\n5  \"namespace\": \"com.company\",\n6  \"doc\": \"User sign-up information\",\n7  \"fields\": [\n8    { \"name\": \"userId\", \"type\": \"int\" },\n9    { \"name\": \"userEmail\", \"type\": \"string\" }\n10  ]\n11}\n```\n To seamlessly incorporate this existing Avro schema into your AsyncAPI document, you can use the $ref property to reference the path to the JSON file. This way, your AsyncAPI document will incorporate the Avro Schema from the external JSON file, ensuring consistency and interoperability in your Kafka ecosystem. \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: User Signup API\n4  version: 1.0.0\n5  description: The API notifies you whenever a new user signs up in the application.\n6servers:\n7  kafkaServer:\n8    host: test.mykafkacluster.org:8092\n9    description: Kafka Server\n10    protocol: kafka\n11operations:\n12  onUserSignedUp:\n13    action: receive\n14    channel:\n15      $ref: '#/channels/userSignedUp'\n16channels:\n17  userSignedUp:\n18    description: This channel contains a message per each user who signs up in our application.\n19    address: user_signedup\n20    messages:\n21      userSignedUp:\n22        $ref: '#/components/messages/userSignedUp'\n23components:\n24  messages:\n25    userSignedUp:\n26      payload:\n27        schemaFormat: 'application/vnd.apache.avro;version=1.9.0'\n28        schema:\n29          $ref: './userSchema.json'\n```\n Summary In this tutorial, you smoothly updated from the default schema to utilize the capabilities of Avro Schema. The use of Avro Schema with AsyncAPI ensures improved communication in event-driven systems. Now, you can further experiment by incorporating your business logic and experimenting with more advanced capabilities. Next Steps Now that you know how to write an AsyncAPI document using Avro Schemas, let's learn how to use Schema Registry with AsyncAPI . Go Back Create AsyncAPI document for applications consuming from Kafka Up Next Managing schemas using Schema Registry Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1messages:\n2  userSignedUp:\n3    payload:\n4      type: object\n5      properties:\n6        userId:\n7          type: integer\n8          description: This property describes the ID of the user\n9        userEmail:\n10          type: string\n11          description: This property describes the email of the user",
      "1messages:\n2  userSignedUp:\n3    payload:\n4      schemaFormat: 'application/vnd.apache.avro;version=1.9.0'\n5      schema:\n6        type: record\n7        name: UserSignedUp\n8        namespace: com.company\n9        doc: User sign-up information\n10        fields:\n11          - name: userId\n12            type: int\n13          - name: userEmail\n14            type: string",
      "1asyncapi: 3.0.0\n2info:\n3  title: User Signup API\n4  version: 1.0.0\n5  description: The API notifies you whenever a new user signs up in the application.\n6servers:\n7  kafkaServer:\n8    host: test.mykafkacluster.org:8092\n9    description: Kafka Server\n10    protocol: kafka\n11operations:\n12  onUserSignedUp:\n13    action: receive\n14    channel:\n15      $ref: '#/channels/userSignedUp'\n16channels:\n17  userSignedUp:\n18    description: This channel contains a message per each user who signs up in our application.\n19    address: user_signedup\n20    messages:\n21      userSignedUp:\n22        $ref: '#/components/messages/userSignedUp'\n23components:\n24  messages:\n25    userSignedUp:\n26      payload:\n27        schemaFormat: 'application/vnd.apache.avro;version=1.9.0'\n28        schema:\n29          type: record\n30          name: UserSignedUp\n31          namespace: com.company\n32          doc: User sign-up information\n33          fields:\n34            - name: userId\n35              type: int\n36            - name: userEmail\n37              type: string",
      "1// userSchema.json\n2{\n3  \"type\": \"record\",\n4  \"name\": \"UserSignedUp\",\n5  \"namespace\": \"com.company\",\n6  \"doc\": \"User sign-up information\",\n7  \"fields\": [\n8    { \"name\": \"userId\", \"type\": \"int\" },\n9    { \"name\": \"userEmail\", \"type\": \"string\" }\n10  ]\n11}",
      "1asyncapi: 3.0.0\n2info:\n3  title: User Signup API\n4  version: 1.0.0\n5  description: The API notifies you whenever a new user signs up in the application.\n6servers:\n7  kafkaServer:\n8    host: test.mykafkacluster.org:8092\n9    description: Kafka Server\n10    protocol: kafka\n11operations:\n12  onUserSignedUp:\n13    action: receive\n14    channel:\n15      $ref: '#/channels/userSignedUp'\n16channels:\n17  userSignedUp:\n18    description: This channel contains a message per each user who signs up in our application.\n19    address: user_signedup\n20    messages:\n21      userSignedUp:\n22        $ref: '#/components/messages/userSignedUp'\n23components:\n24  messages:\n25    userSignedUp:\n26      payload:\n27        schemaFormat: 'application/vnd.apache.avro;version=1.9.0'\n28        schema:\n29          $ref: './userSchema.json'"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "87b704cb",
    "title": "Managing schemas using Schema Registry | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tutorials/kafka/managing-schemas-using-schema-registry.html",
    "content": "Managing schemas using Schema Registry | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Introduction Background context Prerequisites AsyncAPI document with Avro Schema Start Apicurio Registry Upload Avro schema Update schema reference Summary Next steps Managing schemas using Schema Registry Found an error? Have a suggestion? Edit this page on GitHub Introduction In the previous Kafka and Avro configuration tutorial , you learned how to add Apache Avro schemas to your AsyncAPI document. Now, you will learn how to save your schema in a central Schema Registry and reuse it. Background context The need for schema management has become increasingly prevalent to handle the evolving complexity of modern Event-Driven Architecture. A Schema Registry is a centralized service that stores and maintains schemas for data exchanged between various components of a modern distributed system. Validating exchanged data maintains data consistency and compatibility. While several Schema Registry implementations exist, you will use the Apicurio Registry for this tutorial. Apicurio Registry is a popular open-source Schema Registry implementation that supports multiple serialization formats and facilitates schema management for diverse data in distributed systems. You will use Apicurio Registry combined with Avro, a language-neutral data serialization system. Prerequisites Install Docker from the official website. AsyncAPI document with Avro Schema The previous tutorial taught you how to write an AsyncAPI document for Kafka messages using the Avro schema. Here's an example of what an AsyncAPI document fully equipped with Avro schema looks like: \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: User Signup API\n4  version: 1.0.0\n5  description: The API notifies you whenever a new user signs up in the application.\n6servers:\n7  kafkaServer:\n8    host: test.mykafkacluster.org:8092\n9    description: Kafka Server\n10    protocol: kafka\n11operations:\n12  onUserSignedUp:\n13    action: receive\n14    channel:\n15      $ref: '#/channels/userSignedUp'\n16channels:\n17  userSignedUp:\n18    description: This channel contains a message per each user who signs up in our application.\n19    address: user_signedup\n20    messages:\n21      userSignedUp:\n22        $ref: '#/components/messages/userSignedUp'\n23components:\n24  messages:\n25    userSignedUp:\n26      payload:\n27        schemaFormat: 'application/vnd.apache.avro;version=1.9.0'\n28        schema:\n29          type: record\n30          name: UserSignedUp\n31          namespace: com.company\n32          doc: User sign-up information\n33          fields:\n34            - name: userId\n35              type: int\n36            - name: userEmail\n37              type: string\n```\n Start Apicurio Registry Start the Apicurio Registry locally with the following docker command: \n```javascript\ndocker run --env CORS_ALLOWED_ORIGINS='*' -it -p 8080:8080 apicurio/apicurio-registry-mem:2.5.8.Final\n```\n Upload Avro schema Once your local instance of Apicurio Registry is running, upload your Avro schema. Open a new terminal window and create an Avro schema artifact with the following command: \n```javascript\n1curl \\\n2http://localhost:8080/apis/registry/v2/groups/my-group/artifacts \\\n3-X POST  \\\n4-H \"Content-Type: application/json; artifactType=AVRO\" \\\n5-H \"X-Registry-ArtifactId: UserSignedUp\" \\\n6--data @- << EOF\n7{\n8  \"type\": \"record\",\n9  \"name\": \"UserSignedUp\",\n10  \"namespace\": \"com.company\",\n11  \"doc\": \"User sign-up information\",\n12  \"fields\": [\n13    {\n14      \"name\": \"userId\",\n15      \"type\": \"int\"\n16    },\n17    {\n18      \"name\": \"userEmail\",\n19      \"type\": \"string\"\n20    }\n21  ]\n22}\n23EOF\n```\n Remember Download your Avro schema by visiting the following URL: http://localhost:8080/apis/registry/v2/groups/my-group/artifacts/UserSignedUp . Update schema reference One alternative is to keep your schema in a separate file, as you learned in the previous tutorial, describe Kafka message payload using Avro schema . After uploading your Avro schema, remove the schema from your AsyncAPI document and add a $ref pointing to the previous step's URL. \n```javascript\n$ref: http://localhost:8080/apis/registry/v2/groups/my-group/artifacts/UserSignedUp\n```\n \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: User Signup API\n4  version: 1.0.0\n5  description: The API notifies you whenever a new user signs up in the application.\n6servers:\n7  kafkaServer:\n8    host: test.mykafkacluster.org:8092\n9    description: Kafka Server\n10    protocol: kafka\n11operations:\n12  onUserSignedUp:\n13    action: receive\n14    channel:\n15      $ref: '#/channels/userSignedUp'\n16channels:\n17  userSignedUp:\n18    description: This channel contains a message per each user who signs up in our application.\n19    address: user_signedup\n20    messages:\n21      userSignedUp:\n22        $ref: '#/components/messages/userSignedUp'\n23components:\n24  messages:\n25    userSignedUp:\n26      payload:\n27        schemaFormat: 'application/vnd.apache.avro+json;version=1.9.0'\n28        schema:\n29          $ref: http://localhost:8080/apis/registry/v2/groups/my-group/artifacts/UserSignedUp\n```\n Summary In this tutorial, you managed Avro schemas using a centralized schema registry that enables you to share schemas across multiple applications. The good news is that this approach is valid for various other schema types! Next steps Now that you have learned how to manage schemas, check out the bindings with Kafka tutorial to start sending messages between your services. Go Back Describe Kafka message payload using Avro Schema Up Next Kafka bindings Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1asyncapi: 3.0.0\n2info:\n3  title: User Signup API\n4  version: 1.0.0\n5  description: The API notifies you whenever a new user signs up in the application.\n6servers:\n7  kafkaServer:\n8    host: test.mykafkacluster.org:8092\n9    description: Kafka Server\n10    protocol: kafka\n11operations:\n12  onUserSignedUp:\n13    action: receive\n14    channel:\n15      $ref: '#/channels/userSignedUp'\n16channels:\n17  userSignedUp:\n18    description: This channel contains a message per each user who signs up in our application.\n19    address: user_signedup\n20    messages:\n21      userSignedUp:\n22        $ref: '#/components/messages/userSignedUp'\n23components:\n24  messages:\n25    userSignedUp:\n26      payload:\n27        schemaFormat: 'application/vnd.apache.avro;version=1.9.0'\n28        schema:\n29          type: record\n30          name: UserSignedUp\n31          namespace: com.company\n32          doc: User sign-up information\n33          fields:\n34            - name: userId\n35              type: int\n36            - name: userEmail\n37              type: string",
      "docker run --env CORS_ALLOWED_ORIGINS='*' -it -p 8080:8080 apicurio/apicurio-registry-mem:2.5.8.Final",
      "1curl \\\n2http://localhost:8080/apis/registry/v2/groups/my-group/artifacts \\\n3-X POST  \\\n4-H \"Content-Type: application/json; artifactType=AVRO\" \\\n5-H \"X-Registry-ArtifactId: UserSignedUp\" \\\n6--data @- << EOF\n7{\n8  \"type\": \"record\",\n9  \"name\": \"UserSignedUp\",\n10  \"namespace\": \"com.company\",\n11  \"doc\": \"User sign-up information\",\n12  \"fields\": [\n13    {\n14      \"name\": \"userId\",\n15      \"type\": \"int\"\n16    },\n17    {\n18      \"name\": \"userEmail\",\n19      \"type\": \"string\"\n20    }\n21  ]\n22}\n23EOF",
      "$ref: http://localhost:8080/apis/registry/v2/groups/my-group/artifacts/UserSignedUp",
      "1asyncapi: 3.0.0\n2info:\n3  title: User Signup API\n4  version: 1.0.0\n5  description: The API notifies you whenever a new user signs up in the application.\n6servers:\n7  kafkaServer:\n8    host: test.mykafkacluster.org:8092\n9    description: Kafka Server\n10    protocol: kafka\n11operations:\n12  onUserSignedUp:\n13    action: receive\n14    channel:\n15      $ref: '#/channels/userSignedUp'\n16channels:\n17  userSignedUp:\n18    description: This channel contains a message per each user who signs up in our application.\n19    address: user_signedup\n20    messages:\n21      userSignedUp:\n22        $ref: '#/components/messages/userSignedUp'\n23components:\n24  messages:\n25    userSignedUp:\n26      payload:\n27        schemaFormat: 'application/vnd.apache.avro+json;version=1.9.0'\n28        schema:\n29          $ref: http://localhost:8080/apis/registry/v2/groups/my-group/artifacts/UserSignedUp"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "62a99d04",
    "title": "Implement Request/Reply in an AsyncAPI document for a Slack app | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/docs/tutorials/websocket/websocket-request-reply.html",
    "content": "Implement Request/Reply in an AsyncAPI document for a Slack app | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets On this page Introduction Background context Define messages Define schemas Define acknowledge message to channel Define operations Summary Implement Request/Reply in an AsyncAPI document for a Slack app Found an error? Have a suggestion? Edit this page on GitHub Introduction In the Create an AsyncAPI Document for a Slackbot with WebSockets tutorial, you learned how to write an AsyncAPI document for a Slackbot Heart-Counter that actively monitored reactions associated with a message. In this lesson, let's go a step further. After receiving a reaction, Heart-Counter responds via a message back to the Slack server through WebSocket to confirm the event reception. The interaction where the Slackbot acknowledges the event and replies with a specific response sets the stage for the Request/Reply messaging pattern discussed in this context. Refer to the Request/Reply pattern tutorial for an introduction to its implementation. Background context The Request-Reply Messaging Pattern in AsyncAPI is an exciting and highly anticipated feature. The messaging pattern mirrors a traditional conversation, where one \"requester\" entity initiates a query or request, and the \"responder\" entity provides a specific and expected response. The messaging pattern can work in both synchronous and asynchronous environments and is very beneficial to decouple components by allowing them to operate independently in a distributed system. Define messages In the Heart-Counter tutorial, you dealt with the hello event triggered when the WebSocket connection was established and the reaction event expected when a new reaction-added event was triggered. In this tutorial, you'll add the acknowledge message to your AsyncAPI document to represent the acknowledgment sent by the Slack application back to the server to indicate that it has successfully received the message. \n```javascript\n1components:\n2  messages:\n3    reaction:\n4      summary: Action triggered when the channel receives a new reaction-added event\n5      payload:\n6        $ref: '#/components/schemas/reaction'\n7    hello:\n8      summary: Action triggered when a successful WebSocket connection is established\n9      payload:\n10        $ref: '#/components/schemas/hello'\n11    acknowledge:\n12      summary: Acknowledgement response sent to Server\n13      payload:\n14        $ref: '#/components/schemas/acknowledge'\n```\n Define schemas Previously, the reaction schema was simplified to include the event payload. However, in this instance, you will be able to elaborate on the schema for the complete request it is expected to receive. Remember The sample request and response payloads are extracted from Slack's official documentation . \n```javascript\n1  schemas:\n2    hello:\n3      type: object\n4      properties:\n5        type:\n6          type: string\n7          description: A hello string confirming WebSocket connection\n8        connection_info:\n9          type: object\n10          properties:\n11            app_id:\n12              type: string\n13        num_connections:\n14          type: integer\n15        debug_info:\n16          type: object\n17          properties:\n18            host:\n19              type: string\n20            started:\n21              type: string\n22            build_number:\n23              type: integer\n24            approximate_connection_time:\n25              type: integer\n26    reaction:\n27      type: object\n28      properties:\n29        envelope_id:\n30          type: string\n31          description: 'Unique ID assigned to payload'\n32        payload:\n33          type: object\n34          description: 'Payload of the reaction added event'\n35          properties:\n36            token:\n37              type: string\n38            team_id:\n39              type: string\n40            event:\n41              type: object\n42              properties:\n43                user:\n44                  type: string\n45                  description: User ID who performed this event\n46                reaction:\n47                  type: string\n48                  description: The only reaction that you need is a heart emoji\n49                item_user:\n50                  type: string\n51                  description: |\n52                    User ID that created the original item that has been reacted\n53                    to\n54                item:\n55                  type: object\n56                  properties:\n57                    channel:\n58                      type: string\n59                      description: Channel information of original message\n60                    ts:\n61                      type: string\n62                      description: Timestamp information of original message\n63                event_ts:\n64                  type: string\n65                  description: Reaction timestamp\n66        type:\n67          type: string\n68        accepts_response_payload:\n69          type: boolean\n```\n Additionally, you will also be adding the acknowledge schema that makes use of the envelope_id attribute to send a reply back to Slack acknowledging that event has been received. \n```javascript\n1    acknowledge:\n2      type: object\n3      properties:\n4        envelope_id:\n5          type: string\n6          description: 'Unique ID of acknowledged payload'\n7        payload:\n8          type: object\n9          description: 'Optional payload of event'\n```\n Define acknowledge message to channel Extend the channel the Heart-Counter used to include the acknowledge message. \n```javascript\n1channels:\n2  root:\n3    address: /\n4    messages:\n5      hello:\n6        $ref: '#/components/messages/hello'\n7      reaction:\n8        $ref: '#/components/messages/reaction'\n9      acknowledge:\n10        $ref: '#/components/messages/acknowledge'\n```\n Define operations Now you've reached the most important part of the tutorial; it's time to represent the Request/Reply pattern. Both helloListener and reactionListener operations are set to receive events. However, in the case of reactionListener , you also want to represent the message sent back to the server. This is where the reply attribute comes into play. Since both the request and reply function happens over the same WebSocket URL, both channel values stay the same. However, you can differentiate each operation's message by specifying the messages sent or received. Thus, you can say that for a reaction message received over the root channel, the reactionListener operation will reply with the acknowledge message over the same channel. \n```javascript\n1operations:\n2  helloListener:\n3    action: receive\n4    channel:\n5      $ref: '#/channels/root'\n6    messages:\n7      - $ref: '#/channels/root/messages/hello'\n8  reactionListener:\n9    action: receive\n10    channel: \n11      $ref: '#/channels/root'\n12    messages:\n13      - $ref: '#/channels/root/messages/reaction'\n14    reply:\n15      messages:\n16        - $ref: '#/channels/root/messages/acknowledge'      \n17      channel: \n18        $ref: '#/channels/root'\n```\n Putting all this together, you have your AsyncAPI document ready to go! \n```javascript\n1asyncapi: 3.0.0\n2info:\n3  title: Implement Request/Reply in an AsyncAPI document for a Slack app\n4  version: 1.0.0\n5  description: >\n6    The Heart-Counter manages popular messages in a Slack workspace by\n7    monitoring message reaction data. It also sends an acknowledgment message\n8    back to the Slack Server to indicate it has received the message.\n9servers:\n10  production:\n11    host: wss-primary.slack.com\n12    pathname: /link\n13    protocol: wss\n14    description: Slack's server in Socket Mode for real-time communication\n15channels:\n16  root:\n17    address: /\n18    messages:\n19      hello:\n20        $ref: '#/components/messages/hello'\n21      reaction:\n22        $ref: '#/components/messages/reaction'\n23      acknowledge:\n24        $ref: '#/components/messages/acknowledge'\n25    bindings:\n26      ws:\n27        query:\n28          type: object\n29          description: >-\n30            Tokens are produced in the WebSocket URL generated from the\n31            [apps.connections.open](https://api.slack.com/methods/apps.connections.open)\n32            method from Slack's API\n33          properties:\n34            ticket:\n35              type: string\n36              description: Temporary token generated when connection is initiated\n37              const: 13748dac-b866-4ea7-b98e-4fb7895c0a7f\n38            app_id:\n39              type: string\n40              description: Unique identifier assigned to the Slack app\n41              const: fe684dfa62159c6ac646beeac31c8f4ef415e4f39c626c2dbd1530e3a690892f\n42operations:\n43  helloListener:\n44    action: receive\n45    channel:\n46      $ref: '#/channels/root'\n47    messages:\n48      - $ref: '#/channels/root/messages/hello'\n49  reactionListener:\n50    action: receive\n51    channel:\n52      $ref: '#/channels/root'\n53    messages:\n54      - $ref: '#/channels/root/messages/reaction'\n55    reply:\n56      messages:\n57        - $ref: '#/channels/root/messages/acknowledge'\n58      channel:\n59        $ref: '#/channels/root'\n60components:\n61  messages:\n62    reaction:\n63      summary: Action triggered when the channel receives a new reaction-added event\n64      payload:\n65        $ref: '#/components/schemas/reaction'\n66    hello:\n67      summary: Action triggered when a successful WebSocket connection is established\n68      payload:\n69        $ref: '#/components/schemas/hello'\n70    acknowledge:\n71      summary: Acknowledgement response sent to Server\n72      payload:\n73        $ref: '#/components/schemas/acknowledge'\n74  schemas:\n75    hello:\n76      type: object\n77      properties:\n78        type:\n79          type: string\n80          description: A hello string confirming WebSocket connection\n81        connection_info:\n82          type: object\n83          properties:\n84            app_id:\n85              type: string\n86        num_connections:\n87          type: integer\n88        debug_info:\n89          type: object\n90          properties:\n91            host:\n92              type: string\n93            started:\n94              type: string\n95            build_number:\n96              type: integer\n97            approximate_connection_time:\n98              type: integer\n99    reaction:\n100      type: object\n101      properties:\n102        envelope_id:\n103          type: string\n104          description: 'Unique ID assigned to payload'\n105        payload:\n106          type: object\n107          description: 'Payload of the reaction added event'\n108          properties:\n109            token:\n110              type: string\n111            team_id:\n112              type: string\n113            event:\n114              type: object\n115              properties:\n116                user:\n117                  type: string\n118                  description: User ID who performed this event\n119                reaction:\n120                  type: string\n121                  description: The only reaction that you need is a heart emoji\n122                item_user:\n123                  type: string\n124                  description: |\n125                    User ID that created the original item that has been reacted\n126                    to\n127                item:\n128                  type: object\n129                  properties:\n130                    channel:\n131                      type: string\n132                      description: Channel information of original message\n133                    ts:\n134                      type: string\n135                      description: Timestamp information of original message\n136                event_ts:\n137                  type: string\n138                  description: Reaction timestamp\n139        type:\n140          type: string\n141        accepts_response_payload:\n142          type: boolean\n143    acknowledge:\n144      type: object\n145      properties:\n146        envelope_id:\n147          type: string\n148          description: 'Unique ID of acknowledged payload'\n149        payload:\n150          type: object\n151          description: 'Optional payload of event'\n```\n Summary Great job getting to the end! In this tutorial, you learned how to create an AsyncAPI document for a use case that implemented the Request-Reply messaging pattern. Now, you can explore this pattern with sub-patterns to see how it works with real-life use cases. Go Back Create an AsyncAPI document for a Slackbot with WebSocket Up Next Kafka - Create AsyncAPI document for applications consuming from Kafka Was this helpful? Help us improve the docs by adding your contribution.",
    "code_blocks": [
      "1components:\n2  messages:\n3    reaction:\n4      summary: Action triggered when the channel receives a new reaction-added event\n5      payload:\n6        $ref: '#/components/schemas/reaction'\n7    hello:\n8      summary: Action triggered when a successful WebSocket connection is established\n9      payload:\n10        $ref: '#/components/schemas/hello'\n11    acknowledge:\n12      summary: Acknowledgement response sent to Server\n13      payload:\n14        $ref: '#/components/schemas/acknowledge'",
      "1  schemas:\n2    hello:\n3      type: object\n4      properties:\n5        type:\n6          type: string\n7          description: A hello string confirming WebSocket connection\n8        connection_info:\n9          type: object\n10          properties:\n11            app_id:\n12              type: string\n13        num_connections:\n14          type: integer\n15        debug_info:\n16          type: object\n17          properties:\n18            host:\n19              type: string\n20            started:\n21              type: string\n22            build_number:\n23              type: integer\n24            approximate_connection_time:\n25              type: integer\n26    reaction:\n27      type: object\n28      properties:\n29        envelope_id:\n30          type: string\n31          description: 'Unique ID assigned to payload'\n32        payload:\n33          type: object\n34          description: 'Payload of the reaction added event'\n35          properties:\n36            token:\n37              type: string\n38            team_id:\n39              type: string\n40            event:\n41              type: object\n42              properties:\n43                user:\n44                  type: string\n45                  description: User ID who performed this event\n46                reaction:\n47                  type: string\n48                  description: The only reaction that you need is a heart emoji\n49                item_user:\n50                  type: string\n51                  description: |\n52                    User ID that created the original item that has been reacted\n53                    to\n54                item:\n55                  type: object\n56                  properties:\n57                    channel:\n58                      type: string\n59                      description: Channel information of original message\n60                    ts:\n61                      type: string\n62                      description: Timestamp information of original message\n63                event_ts:\n64                  type: string\n65                  description: Reaction timestamp\n66        type:\n67          type: string\n68        accepts_response_payload:\n69          type: boolean",
      "1    acknowledge:\n2      type: object\n3      properties:\n4        envelope_id:\n5          type: string\n6          description: 'Unique ID of acknowledged payload'\n7        payload:\n8          type: object\n9          description: 'Optional payload of event'",
      "1channels:\n2  root:\n3    address: /\n4    messages:\n5      hello:\n6        $ref: '#/components/messages/hello'\n7      reaction:\n8        $ref: '#/components/messages/reaction'\n9      acknowledge:\n10        $ref: '#/components/messages/acknowledge'",
      "1operations:\n2  helloListener:\n3    action: receive\n4    channel:\n5      $ref: '#/channels/root'\n6    messages:\n7      - $ref: '#/channels/root/messages/hello'\n8  reactionListener:\n9    action: receive\n10    channel: \n11      $ref: '#/channels/root'\n12    messages:\n13      - $ref: '#/channels/root/messages/reaction'\n14    reply:\n15      messages:\n16        - $ref: '#/channels/root/messages/acknowledge'      \n17      channel: \n18        $ref: '#/channels/root'",
      "1asyncapi: 3.0.0\n2info:\n3  title: Implement Request/Reply in an AsyncAPI document for a Slack app\n4  version: 1.0.0\n5  description: >\n6    The Heart-Counter manages popular messages in a Slack workspace by\n7    monitoring message reaction data. It also sends an acknowledgment message\n8    back to the Slack Server to indicate it has received the message.\n9servers:\n10  production:\n11    host: wss-primary.slack.com\n12    pathname: /link\n13    protocol: wss\n14    description: Slack's server in Socket Mode for real-time communication\n15channels:\n16  root:\n17    address: /\n18    messages:\n19      hello:\n20        $ref: '#/components/messages/hello'\n21      reaction:\n22        $ref: '#/components/messages/reaction'\n23      acknowledge:\n24        $ref: '#/components/messages/acknowledge'\n25    bindings:\n26      ws:\n27        query:\n28          type: object\n29          description: >-\n30            Tokens are produced in the WebSocket URL generated from the\n31            [apps.connections.open](https://api.slack.com/methods/apps.connections.open)\n32            method from Slack's API\n33          properties:\n34            ticket:\n35              type: string\n36              description: Temporary token generated when connection is initiated\n37              const: 13748dac-b866-4ea7-b98e-4fb7895c0a7f\n38            app_id:\n39              type: string\n40              description: Unique identifier assigned to the Slack app\n41              const: fe684dfa62159c6ac646beeac31c8f4ef415e4f39c626c2dbd1530e3a690892f\n42operations:\n43  helloListener:\n44    action: receive\n45    channel:\n46      $ref: '#/channels/root'\n47    messages:\n48      - $ref: '#/channels/root/messages/hello'\n49  reactionListener:\n50    action: receive\n51    channel:\n52      $ref: '#/channels/root'\n53    messages:\n54      - $ref: '#/channels/root/messages/reaction'\n55    reply:\n56      messages:\n57        - $ref: '#/channels/root/messages/acknowledge'\n58      channel:\n59        $ref: '#/channels/root'\n60components:\n61  messages:\n62    reaction:\n63      summary: Action triggered when the channel receives a new reaction-added event\n64      payload:\n65        $ref: '#/components/schemas/reaction'\n66    hello:\n67      summary: Action triggered when a successful WebSocket connection is established\n68      payload:\n69        $ref: '#/components/schemas/hello'\n70    acknowledge:\n71      summary: Acknowledgement response sent to Server\n72      payload:\n73        $ref: '#/components/schemas/acknowledge'\n74  schemas:\n75    hello:\n76      type: object\n77      properties:\n78        type:\n79          type: string\n80          description: A hello string confirming WebSocket connection\n81        connection_info:\n82          type: object\n83          properties:\n84            app_id:\n85              type: string\n86        num_connections:\n87          type: integer\n88        debug_info:\n89          type: object\n90          properties:\n91            host:\n92              type: string\n93            started:\n94              type: string\n95            build_number:\n96              type: integer\n97            approximate_connection_time:\n98              type: integer\n99    reaction:\n100      type: object\n101      properties:\n102        envelope_id:\n103          type: string\n104          description: 'Unique ID assigned to payload'\n105        payload:\n106          type: object\n107          description: 'Payload of the reaction added event'\n108          properties:\n109            token:\n110              type: string\n111            team_id:\n112              type: string\n113            event:\n114              type: object\n115              properties:\n116                user:\n117                  type: string\n118                  description: User ID who performed this event\n119                reaction:\n120                  type: string\n121                  description: The only reaction that you need is a heart emoji\n122                item_user:\n123                  type: string\n124                  description: |\n125                    User ID that created the original item that has been reacted\n126                    to\n127                item:\n128                  type: object\n129                  properties:\n130                    channel:\n131                      type: string\n132                      description: Channel information of original message\n133                    ts:\n134                      type: string\n135                      description: Timestamp information of original message\n136                event_ts:\n137                  type: string\n138                  description: Reaction timestamp\n139        type:\n140          type: string\n141        accepts_response_payload:\n142          type: boolean\n143    acknowledge:\n144      type: object\n145      properties:\n146        envelope_id:\n147          type: string\n148          description: 'Unique ID of acknowledged payload'\n149        payload:\n150          type: object\n151          description: 'Optional payload of event'"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "26335067",
    "title": "Newsletter | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/en/newsletter.html",
    "content": "Newsletter | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo Subscribe to our newsletter to receive news about AsyncAPI. We respect your inbox. No spam, promise \u270c\ufe0f",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "88057ba6",
    "title": "Slack",
    "path": "asyncapi-docs/www.asyncapi.com/slack-invite/index.html",
    "content": "Slack We're very sorry, but your browser is not supported! Please upgrade to a supported browser , or try one of our apps. Desktop Apps Mac See system requirements \n![Download on the Mac App Store](https://a.slack-edge.com/80588/marketing/img/downloads/app_stores/ios_mac_app_store_badge.IN.png)\n v4.43.51 Windows See system requirements \n![Download on the Microsoft Store](https://a.slack-edge.com/80588/marketing/img/downloads/app_stores/windows_store_btn.IN.png)\n v4.43.51 Linux See system requirements \n![Download from the Snap Store](https://a.slack-edge.com/80588/marketing/img/downloads/app_stores/snap_store_btn.IN.png)\n v4.41.105 Mobile Apps iOS \n![Download on the App Store](https://a.slack-edge.com/80588/marketing/img/downloads/app_stores/ios_app_store_btn.IN.png)\n Android \n![Get it on Google Play](https://a.slack-edge.com/80588/marketing/img/downloads/app_stores/google_play_store_btn.IN.png)\n Don't see the platform you're looking for? Let us know.",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [
      {
        "src": "https://a.slack-edge.com/80588/marketing/img/downloads/app_stores/ios_mac_app_store_badge.IN.png",
        "alt": "Download on the Mac App Store"
      },
      {
        "src": "https://a.slack-edge.com/80588/marketing/img/downloads/app_stores/windows_store_btn.IN.png",
        "alt": "Download on the Microsoft Store"
      },
      {
        "src": "https://a.slack-edge.com/80588/marketing/img/downloads/app_stores/snap_store_btn.IN.png",
        "alt": "Download from the Snap Store"
      },
      {
        "src": "https://a.slack-edge.com/80588/marketing/img/downloads/app_stores/ios_app_store_btn.IN.png",
        "alt": "Download on the App Store"
      },
      {
        "src": "https://a.slack-edge.com/80588/marketing/img/downloads/app_stores/google_play_store_btn.IN.png",
        "alt": "Get it on Google Play"
      }
    ],
    "source": "asyncapi-docs"
  },
  {
    "id": "fea0bb94",
    "title": "CLI | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/tools/cli.html",
    "content": "CLI | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets Interact with AsyncAPI from the comfort of your CLI AsyncAPI CLI Create, validate, and explore your AsyncAPI files with our CLI tool. Installation & Usage Start using AsyncAPI CLI within seconds by selecting one of our commands to get started. View on Github View Docs Installing 1 npm install -g @asyncapi/cli Example Create a new AsyncAPI file 1 asyncapi new Features Use the AsyncAPI CLI tool to help you create, develop, and maintain your AsyncAPI files. New files Use the CLI tool to quickly create new AsyncAPI files. Select from a range of templates (MQTT, WebSockets, Kafka, and more.) Validate Validate your AsyncAPI documents with the CLI. Quickly get feedback to verify your AsyncAPI document is within the correct format. Open Studio Got an AsyncAPI file locally? Run asyncapi start studio to open our studio in seconds. Open Source All our tools are open source, feel free to contribute new commands or help evolve our existing ones. View on Github View Docs",
    "code_blocks": [],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  },
  {
    "id": "6e77f671",
    "title": "Modelina | AsyncAPI Initiative for event-driven APIs",
    "path": "asyncapi-docs/www.asyncapi.com/tools/modelina.html",
    "content": "Modelina | AsyncAPI Initiative for event-driven APIs AsyncAPI Logo AsyncAPI Conference Singapore Edition 15th - 16th of April, 2025 | Singapore, Singapore 9 days until you get a Free Ticket Get Free Tickets Modelina Sometimes you just want to generate data models for your payload. Modelina is a library for generating data models based on inputs such as AsyncAPI, OpenAPI, or JSON Schema documents. Installation & Usage Start using Modelina really quickly. Select one of the available languages we offer and start generating models from your AsyncAPI document in a few seconds. npm install @asyncapi/modelina View on Github Try it now \n```javascript\n1import { JavaGenerator, JAVA_COMMON_PRESET } from '@asyncapi/modelina'\n2  \n3const generator = new JavaGenerator({\n4  collectionType: \"List\",\n5  presets: [\n6    {\n7      preset: JAVA_COMMON_PRESET,\n8      options: {\n9        classToString: true\n10      }\n11    }\n12  ]\n13});\n14\n15// const input = ...AsyncAPI document\n16const models = await generator.generate(input)\n```\n",
    "code_blocks": [
      "1import { JavaGenerator, JAVA_COMMON_PRESET } from '@asyncapi/modelina'\n2  \n3const generator = new JavaGenerator({\n4  collectionType: \"List\",\n5  presets: [\n6    {\n7      preset: JAVA_COMMON_PRESET,\n8      options: {\n9        classToString: true\n10      }\n11    }\n12  ]\n13});\n14\n15// const input = ...AsyncAPI document\n16const models = await generator.generate(input)"
    ],
    "yaml_blocks": [],
    "images": [],
    "source": "asyncapi-docs"
  }
]